<!DOCTYPE html>
<html>
    <head>
        <title>Part2</title>
        <style>
                body{
                    margin: 0;
                    padding: 0;
                }
                h1{
                    padding: 20px;
                    color: white;
                    background-color: black;
                    margin: 0;
                }
                #menu{
                    display: table;
                    width: 100%;
                    /* border: 1px solid green; */
                    background-color: red;
                    color: white;

                 }
                 #menu div{
                    display: table-cell;
                    padding: 10px;
                 }
                 .button-container{
                    width: 70%;
                    text-align: right;
                 }
                 .button{
                    border: 1px solid blue;
                    display: inline-block;
                    padding: 10px 40px;
                    background-color: blue;
                    color: white;
                 }
                 #content{
                    display: table;
                    width: 100%;
                 }
                 #content div{
                        display: table-cell;
                        padding: 10px 20px;
                        border: 1px solid black;

                 }
                 #contents{
                        width: 100%;
                        padding-left: 0;
                 }
            </style>
    </head>
    <body>
        <!-- <div id="test-image">
                testability testability testability testability testability testability testability
                testability testability testability testability testability testability testability
                testability testability testability testability testability testability testability
                testability testability testability testability testability testability testability
                <img src="file:///C:/study/homework/img/figure_1.png" alt="no image"/>
        </div> -->
        <h1>PART 2</h1>
        <div id="menu">
            <div>
                MAIN
            </div>
            <div class="button-container">
                <a href="file:///C:/study/homework/index.html" target="_blank" class="button">Preface</a>
                <a href="file:///C:/study/homework/part1.html" target="_blank" class="button">Part1</a>
                <a href="file:///C:/study/homework/part2.html" class="button">Part2</a>
            </div>
        </div>
        <div id="content">
                <div id="contents">
                        <ol>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html" target="_blank">PART2</a>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#Domain_Logic_Patterns" target="_blank">Chapter 9: Domain Logic Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#Transaction_Script" target="_blank">Transaction Script</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#110" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#111" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#112" target="_blank">The Revenue Recognition Problem</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#113" target="_blank">Example: Revenue Recognition (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#116" target="_blank">Domain Model</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#116(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#119" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#119(2)" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#120" target="_blank">Example: Revenue Recognition (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#125" target="_blank">Table Module</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#126" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#128" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#129" target="_blank">Example: Revenue Recognition with a Table Module (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#133" target="_blank">Service Layer <i>(by Randy Stafford)</i></a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#134" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#137" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#137(2)" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#138" target="_blank">Example: Revenue Recognition (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#143" target="_blank">Chapter 10: Data Source Architectural Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#144" target="_blank">Table Data Gateway</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#144(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#145" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#146" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#146(2)" target="_blank">Example: Person Gateway (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#148" target="_blank">Example: Using ADO.NET Data Sets (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#152" target="_blank">Row Data Gateway</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#152(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#153" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#155" target="_blank">Example: A Person Record (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#158" target="_blank">Example: A Data Holder for a Domain Object (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#160" target="_blank">Active Record</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#160(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#161" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#162" target="_blank">Example: A Simple Person (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#165" target="_blank">Data Mapper</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#165(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#170" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#171" target="_blank">Example: A Simple Database Mapper (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#176" target="_blank">Example: Separating the Finders (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#179" target="_blank">Example: Creating an Empty Object (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#183" target="_blank">Chapter 11: Object-Relational Behavioral Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#184" target="_blank">Unit of Work</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#184(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#189" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#190" target="_blank">Example: <i>Unit of Work with Object Registration (Java) (by David Rice)</i> </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#195" target="_blank">Identity Map</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#195(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#198" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#198(2)" target="_blank">Example: Methods for an Identity Map (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#200" target="_blank">Lazy Load</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#200(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#203" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#203(2)" target="_blank">Example: Lazy Initialization (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#203(3)" target="_blank">Example: Virtual Proxy (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#205" target="_blank">Example: Using a Value Holder (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#206" target="_blank">Example: Using Ghosts (C#)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#215" target="_blank">Chapter 12: Object-Relational Structural Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#216" target="_blank">Identity Field</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#216(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#220" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#221" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#221(2)" target="_blank">Example: Integral Key (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#222" target="_blank">Example: Using a Key Table (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#224" target="_blank">Example: Using a Compound Key (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#236" target="_blank">Foreign Key Mapping</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#236(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#239" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#240" target="_blank">Example: Single-Valued Reference (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#243" target="_blank">Example: Multitable Find (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#244" target="_blank">Example: Collection of References (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#248" target="_blank">Association Table Mapping</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#248(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#249" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#250" target="_blank">Example: Employees and Skills (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#253" target="_blank">Example: Using Direct SQL (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#256" target="_blank">Example: Using a Single Query for Multiple Employees (Java) <i>(by Matt Foemmel and Martin Fowler)</i></a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#262" target="_blank">Dependent Mapping</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#262(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#263" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#264" target="_blank">Example: Albums and Tracks (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#268" target="_blank">Embedded Value</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#268(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#268(3)" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#270" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#270(2)" target="_blank">Example: Simple Value Object (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#272" target="_blank">Serialized LOB</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#272(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#274" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#274(2)" target="_blank">Example: Serializing a Department Hierarchy in XML (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#278" target="_blank">Single Table Inheritance</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#278(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#279" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#280" target="_blank">Example: A Single Table for Players (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#281" target="_blank">Loading an Object from the Database</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#285" target="_blank">Class Table Inheritance</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#285(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#286" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#287" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#287(2)" target="_blank">Example: Players and Their Kin (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#293" target="_blank">Concrete Table Inheritance</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#293(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#295" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#296" target="_blank">Example: Concrete Players (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#302" target="_blank">Inheritance Mappers</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#303" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#304" target="_blank">When to Use It</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#305" target="_blank">Chapter 13: Object-Relational Metadata Mapping Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#306" target="_blank">Metadata Mapping</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#306(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#308" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#309" target="_blank">Example: Using Metadata and Reflection (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#316" target="_blank">Query Object</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#316" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#317" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#318" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#318(2)" target="_blank">Example: A Simple Query Object (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#322" target="_blank">Repository (by Edward Hieatt and Rob Mee)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#323" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#324" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#325" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#325(2)" target="_blank">Example: Finding a Personâ€™s Dependents (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#326" target="_blank">Example: Swapping Repository Strategies (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#329" target="_blank">Chapter 14: Web Presentation Patterns.</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#330" target="_blank">Model View Controller</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#330(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#332" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#333" target="_blank">Page Controller</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#333(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#334" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#335" target="_blank">Example: Simple Display with a Servlet Controller and a JSP View (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#337" target="_blank">Example: Using a JSP as a Handler (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#340" target="_blank">Example: Page Handler with a Code Behind (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#344" target="_blank">Front Controller</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#344(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#346" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#347" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#347(2)" target="_blank">Example: Simple Display (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#350" target="_blank">Template View</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#351" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#354" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#355" target="_blank">Example: Using a JSP as a View with a Separate Controller (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#357" target="_blank">Example: ASP.NET Server Page (C#) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#361" target="_blank">Transform View</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#361(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#362" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#363" target="_blank">Example: Simple Transform (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#365" target="_blank">Two Step View</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#365(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#367" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#371" target="_blank">Example: Two Stage XSLT (XSLT)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#374" target="_blank">Example: JSP and Custom Tags (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#379" target="_blank">Application Controller</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#380" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#381" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#382" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#382(2)" target="_blank">Example: State Model Application Controller (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#387" target="_blank">Chapter 15: Distribution Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#388" target="_blank">Remote Facade</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#389" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#392" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#392(2)" target="_blank">Example: Using a Java Session Bean as a Remote Facade (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#395" target="_blank">Example: Web Service (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#401" target="_blank">Data Transfer Object</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#401(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#406" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#407" target="_blank">Further Reading </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#407(2)" target="_blank">Example: Transferring Information About Albums (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#411" target="_blank">Example: Serializing Using XML (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#415" target="_blank">Chapter 16: Offline Concurrency Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#416" target="_blank">Optimistic Offline Lock (by David Rice)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#417" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#420" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#421" target="_blank">Example: Domain Layer with Data Mappers (165) (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#426" target="_blank">Pessimistic Offline Lock (by David Rice)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#427" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#431" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#431(2)" target="_blank">Example: Simple Lock Manager (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#438" target="_blank">Coarse-Grained Lock (by David Rice and Matt Foemmel)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#438(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#441" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#441(2)" target="_blank">Example: Shared Optimistic Offline Lock (416) (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#446" target="_blank">Example: Shared Pessimistic Offline Lock (426) (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#447" target="_blank">Example: Root Optimistic Offline Lock (416) (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#449" target="_blank">Implicit Lock (by David Rice)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#450" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#451" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#451(2)" target="_blank">Example: Implicit Pessimistic Offline Lock (426) (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#455" target="_blank">Chapter 17: Session State Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#456" target="_blank">Client Session State</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#456(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#457" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#458" target="_blank">Server Session State</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#458(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#460" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#462" target="_blank">Database Session State</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#462(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#464" target="_blank">When to Use It</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#465" target="_blank">Chapter 18: Base Patterns.</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#466" target="_blank">Gateway</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#466(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#467" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#468" target="_blank">Example: A Gateway to a Proprietary Messaging Service (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#473" target="_blank">Mapper</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#473(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#474" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#475" target="_blank">Layer Supertype</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#475(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#475(3)" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#475(4)" target="_blank">Example: Domain Object (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#476" target="_blank">Separated Interface</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#477" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#478" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#480" target="_blank">Registry</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#480(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#482" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#483" target="_blank">Example: A Singleton Registry (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#484" target="_blank">Example: Thread-Safe Registry (Java) (by Matt Foemmel and Martin Fowler)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#486" target="_blank">Value Object</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#486(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#487" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#488" target="_blank">Money</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#488(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#490" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#491" target="_blank">Example: A Money Class (Java) (by Matt Foemmel and Martin Fowler)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#496" target="_blank">Special Case</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#497" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#497(2)" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#497(3)" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#498" target="_blank">Example: A Simple Null Object (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#499" target="_blank">Plugin (by David Rice and Matt Foemmel)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#499(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#500" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#501" target="_blank">Example: An Id Generator (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#504" target="_blank">Service Stub (by David Rice).</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#504(2)" target="_blank">How It Works </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#505" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#505(2)" target="_blank">Example: Sales Tax Service (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#508" target="_blank">Record Set</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#508(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#510" target="_blank">When to Use It</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#511" target="_blank">References</a>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#517" target="_blank">Index</a>
                                </li>
                        </ol>
                </div>
                <div>
                        <h2>The Patterns</h2>
                <p><i>This page intentionally left blank</i></p>
                <h3 id="Domain_Logic_Patterns">Chapter 9</h3>
                <h2>Domain Logic Patterns</h2>
                <h3 id="Transaction_Script">Transaction Script</h3>
                <p><img src="img/part2.1.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Most business applications can be thought of as a series of transactions. A
                        transaction may view some information as organized in a particular way,
                        another will make changes to it. Each interaction between a client system and a
                        server system contains a certain amount of logic. In some cases this can be as
                        simple as displaying information in the database. In others it may involve many
                        steps of validations and calculations.
                        A Transaction Script organizes all this logic primarily as a single procedure,
                        making calls directly to the database or through a thin database wrapper. Each
                        transaction will have its own Transaction Script, although common subtasks
                        can be broken into subprocedures.</p>
                <h3 id="110">How It Works</h3>
                <p>With Transaction Script the domain logic is primarily organized by the transactions that you carry out with the system. If your need is to book a hotel room,
                        the logic to check room availability, calculate rates, and update the database is
                        found inside the Book Hotel Room procedure.
                        For simple cases there isnâ€™t much to say about how you organize this. Of
                        course, as with any other program you should structure the code into modules in
                        a way that makes sense. Unless the transaction is particularly complicated, that
                        wonâ€™t be much of a challenge. One of the benefits of this approach is that you
                        donâ€™t need to worry about what other transactions are doing. Your task is to get
                        the input, interrogate the database, munge, and save your results to the database.
                        Where you put the Transaction Script will depend on how you organize your
                        layers. It may be in a server page, a CGI script, or a distributed session object.
                        My preference is to separate Transaction Scripts as much as you can. At the
                        very least put them in distinct subroutines; better still, put them in classes separate from those that handle presentation and data source. In addition, donâ€™t
                        have any calls from the Transaction Scripts to any presentation logic; that will
                        make it easier to modify the code and test the Transaction Scripts.
                        You can organize your Transaction Scripts into classes in two ways. The most
                        common is to have several Transaction Scripts in a single class, where each class
                        defines a subject area of related Transaction Scripts. This is straightforward and
                        the best bet for most cases. The other way is to have each Transaction Script in its
                        own class (Figure 9.1), using the Command pattern [Gang of Four]. In this case
                        you define a supertype for your commands that specifies some execute method in
                        which Transaction Script logic fits. The advantage of this is that it allows you to
                        manipulate instances of scripts as objects at runtime, although Iâ€™ve rarely seen a
                        need to do this with the kinds of systems that use Transaction Scripts to organize
                        domain logic. Of course, you can ignore classes completely in many languages
                        and just use global functions. However, youâ€™ll often find that instantiating a new
                        object helps with threading issues as it makes it easier to isolate data.
                        I use the term Transaction Script because most of the time youâ€™ll have one
                        Transaction Script for each database transaction. This isnâ€™t a 100 percent rule,
                        but itâ€™s true to the first approximation.</p>
                <h3 id="111">When to Use It</h3>
                <p>The glory of Transaction Script is its simplicity. Organizing logic this way is
                        natural for applications with only a small amount of logic, and it involves very
                        little overhead either in performance or in understanding.
                        As the business logic gets more complicated, however, it gets progressively
                        harder to keep it in a well-designed state
                <p><img src="img/figure 9.1.png" alt="no img" style="margin-left: 200px;"></p>
                        is its duplication between transactions. Since the whole point is to handle one
                        transaction, any common code tends to be duplicated.
                        Careful factoring can alleviate many of these problems, but more complex
                        business domains need to build a Domain Model (116). A Domain Model (116)
                        will give you many more options in structuring the code, increasing readability
                        and decreasing duplication.</p>
                <p>Itâ€™s hard to quantify the cutover level, especially when youâ€™re more familiar
                        with one pattern than the other. You can refactor a Transaction Script design to
                        a Domain Model (116) design, but itâ€™s a harder change than it otherwise needs
                        to be. Therefore, an early shot is often the best way to move forward.
                        However much of an object bigot you become, donâ€™t rule out Transaction
                        Script. There are a lot of simple problems out there, and a simple solution will
                        get you up and running much faster.</p>
                <h3 id="112">The Revenue Recognition Problem</h3>
                <p>For this pattern, and others that talk about domain logic, Iâ€™m going to use the
                        same problem as an illustration. To avoid typing the problem statement several
                        times, Iâ€™m just putting it in here.
                        Revenue recognition is a common problem in business systems. Itâ€™s all about
                        when you can actually count the money you receive on your books. If I sell you
                        a cup of coffee, itâ€™s a simple matter: I give you the coffee, I take your money,
                        and I count the money to the books that nanosecond. For many things it gets
                        complicated, however. Say you pay me a retainer to be available that year. Even
                        if you pay me some ridiculous fee today, I may not be able to put it on my
                        books right away because the service is to be performed over the course of a
                        year. One approach might be to count only one-twelfth of that fee for each
                        month in the year, since you might pull out of the contract after a month when
                        you realize that writing has atrophied my programming skills.</p>
                <p>The rules for revenue recognition are many, various, and volatile. Some are
                        set by regulation, some by professional standards, and some by company policy. Revenue tracking ends up being quite a complex problem.
                        I donâ€™t fancy delving into the complexity right now, so instead weâ€™ll imagine
                        a company that sells three kinds of products: word processors, databases, and
                        spreadsheets. According to the rules, when you sign a contract for a word processor you can book all the revenue right away. If itâ€™s a spreadsheet, you can
                        book one-third today, one-third in sixty days, and one-third in ninety days. If
                        itâ€™s a database, you can book one-third today, one-third in thirty days, and onethird in sixty days. Thereâ€™s no basis for these rules other than my own fevered
                        imagination. Iâ€™m told that the real rules are equally rational.</p>
                <p><img src="img/figure 9.2.png" alt="no img" style="margin-left: 200px;"></p>
                <h3 id="113">Example: Revenue Recognition (Java)</h3>
                <p>This example uses two transaction scripts: one to calculate the revenue recognitions for a contract and one to tell how much revenue on a contract has been
                        recognized by a certain date. The database structure has three tables: one for
                        the products, one for the contracts, and one for the revenue recognitions.
                        <pre >CREATE TABLE products (ID int primary key, name varchar, type varchar)
                        CREATE TABLE contracts (ID int primary key, product int, revenue decimal, dateSigned date)
                        CREATE TABLE revenueRecognitions (contract int, amount decimal, recognizedOn date,
                        PRIMARY KEY (contract, recognizedOn))</pre>
                        The first script calculates the amount of recognition due by a particular day. I
                        can do this in two stages: In the first I select the appropriate rows in the revenue
                        recognitions table; in the second I sum up the amounts.
                        Many Transaction Script designs have scripts that operate directly on the
                        database, putting SQL code in the procedure. Here Iâ€™m using a simple Table
                        Data Gateway (144) to wrap the SQL queries. Since this example is so simple,
                        Iâ€™m using a single gateway rather than one for each table. I can define an appropriate find method on the gateway.
                        <pre>class Gateway...
                        public ResultSet findRecognitionsFor(long contractID, MfDate asof) throws SQLException{
                                PreparedStatement stmt = db.prepareStatement(findRecognitionsStatement);
                                stmt.setLong(1, contractID);
                                stmt.setDate(2, asof.toSqlDate());
                                ResultSet result = stmt.executeQuery();
                                return result;
                        }
                        </pre>
                        I then use the script to sum up based on the result set passed back from the
                        gateway.
                        <pre>class RecognitionService...
                        public Money recognizedRevenue(long contractNumber, MfDate asOf) {
                        Money result = Money.dollars(0);
                        try {
                        ResultSet rs = db.findRecognitionsFor(contractNumber, asOf);
                        while (rs.next()) {
                        result = result.add(Money.dollars(rs.getBigDecimal("amount")));
                        }
                        return result;
                        } catch (SQLException e) {throw new ApplicationException (e);
                        }
                        }</pre>
                        When the calculation is as simple as this, you can replace the in-memory script
                        with a call to a SQL statement that uses an aggregate function to sum the
                        amounts.
                        For calculating the revenue recognitions on an existing contract, I use a similar split. The script on the service carries out the business logic.
                        <pre>class RecognitionService...
                        public void calculateRevenueRecognitions(long contractNumber) {
                        try {
                        ResultSet contracts = db.findContract(contractNumber);
                        contracts.next();
                        Money totalRevenue = Money.dollars(contracts.getBigDecimal("revenue"));
                        MfDate recognitionDate = new MfDate(contracts.getDate("dateSigned"));
                        String type = contracts.getString("type");
                        if (type.equals("S")){
                        Money[] allocation = totalRevenue.allocate(3);
                        db.insertRecognition
                        (contractNumber, allocation[0], recognitionDate);
                        db.insertRecognition
                        (contractNumber, allocation[1], recognitionDate.addDays(60));
                        db.insertRecognition
                        (contractNumber, allocation[2], recognitionDate.addDays(90));
                        } else if (type.equals("W")){
                        db.insertRecognition(contractNumber, totalRevenue, recognitionDate);
                        } else if (type.equals("D")) {
                        Money[] allocation = totalRevenue.allocate(3);
                        db.insertRecognition
                        (contractNumber, allocation[0], recognitionDate);
                        db.insertRecognition
                        (contractNumber, allocation[1], recognitionDate.addDays(30));
                        db.insertRecognition
                        (contractNumber, allocation[2], recognitionDate.addDays(60));
                        }
                        } catch (SQLException e) {throw new ApplicationException (e);
                        }
                        }
                        Notice that Iâ€™m using Money (488) to carry out the allocation. When splitting
                        an amount three ways itâ€™s very easy to lose a penny.
                        The Table Data Gateway (144) provides support on the SQL. First thereâ€™s a
                        finder for a contract.
                        class Gateway...
                        public ResultSet findContract (long contractID) throws SQLException{
                        PreparedStatement stmt = db.prepareStatement(findContractStatement);
                        stmt.setLong(1, contractID);
                        ResultSet result = stmt.executeQuery();
                        return result;
                        }
                        private static final String findContractStatement =
                        "SELECT * " +
                        " FROM contracts c, products p " +
                        " WHERE ID = ? AND c.product = p.ID";
                        And secondly thereâ€™s a wrapper for the insert.
                        class Gateway...
                        public void insertRecognition (long contractID, Money amount, MfDate asof) throws SQLException {
                        PreparedStatement stmt = db.prepareStatement(insertRecognitionStatement);
                        stmt.setLong(1, contractID);
                        stmt.setBigDecimal(2, amount.amount());
                        stmt.setDate(3, asof.toSqlDate());
                        stmt.executeUpdate();
                        }
                        private static final String insertRecognitionStatement =
                        "INSERT INTO revenueRecognitions VALUES (?, ?, ?)";</pre>
                        In a Java system the recognition service might be a regular class or a session bean.
                        As you compare this to the example in Domain Model (116), unless your mind
                        is as twisted as mine, youâ€™ll probably be thinking that this is much simpler. The
                        harder thing to imagine is what happens as the rules get more complicated. Typical revenue recognition rules get very involved, varying not just by product but
                        also by date (if the contract was signed before April 15 this rule applies . . .). Itâ€™s
                        difficult to keep a coherent design with Transaction Script once things get that
                        complicated, which is why object bigots like me prefer using a Domain Model
                        (116) in these circumstances.</p>
                <h3 id="116">Domain Model</h3>
                <p><img src="img/part2.2.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object model of the domain that incorporates
                        both behavior and data.
                        At its worst business logic can be very complex. Rules and logic describe many
                        different cases and slants of behavior, and itâ€™s this complexity that objects were
                        designed to work with. A Domain Model creates a web of interconnected
                        objects, where each object represents some meaningful individual, whether as
                        large as a corporation or as small as a single line on an order form.</p>
                <h3 id="116(2)">How It Works</h3>
                <p>Putting a Domain Model in an application involves inserting a whole layer of
                        objects that model the business area youâ€™re working in. Youâ€™ll find objects that
                        mimic the data in the business and objects that capture the rules the business
                        uses. Mostly the data and process are combined to cluster the processes close to
                        the data they work with.
                        An OO domain model will often look similar to a database model, yet it will
                        still have a lot of differences. A Domain Model mingles data and process, has
                        multivalued attributes and a complex web of associations, and uses inheritance.
                        As a result I see two styles of Domain Model in the field. A simple Domain
                        Model looks very much like the database design with mostly one domain object
                        for each database table. A rich Domain Model can look different from the database design, with inheritance, strategies, and other [Gang of Four] patterns, and
                        complex webs of small interconnected objects. A rich Domain Model is better
                        for more complex logic, but is harder to map to the database. A simple Domain
                        Model can use Active Record (160), whereas a rich Domain Model requires
                        Data Mapper (165).</p>
                <p>Since the behavior of the business is subject to a lot of change, itâ€™s important to be able to modify, build, and test this layer easily. As a result youâ€™ll
                        want the minimum of coupling from the Domain Model to other layers in the
                        system. Youâ€™ll notice that a guiding force of many layering patterns is to keep
                        as few dependencies as possible between the domain model and other parts of
                        the system.
                        With a Domain Model there are a number of different scopes you might use.
                        The simplest case is a single-user application where the whole object graph is
                        read from a file and put into memory. A desktop application may work this
                        way, but itâ€™s less common for a multitiered IS application simply because there
                        are too many objects. Putting every object into memory consumes too much
                        memory and takes too long. The beauty of object-oriented databases is that
                        they give the impression of doing this while moving objects between memory
                        and disk.</p>
                <p>Without an OO database you have to do this yourself. Usually a session will
                        involve pulling in an object graph of all the objects involved in it. This will certainly not be all objects and usually not all the classes. Thus, if youâ€™re looking at
                        a set of contracts you might pull in only the products referenced by contracts
                        within your working set. If youâ€™re just performing calculations on contracts and
                        revenue recognition objects, you may not pull in any product objects at all.
                        Exactly what you pull into memory is governed by your database mapping
                        objects.
                        If you need the same object graph between calls to the server, you have to
                        save the server state somewhere, which is the subject of the section on saving
                        server state (page 81).</p>
                <p>A common concern with domain logic is bloated domain objects. As you
                        build a screen to manipulate orders youâ€™ll notice that some of the order behavior is only needed for it. If you put these responsibilities on the order, the risk is
                        that the Order class will become too big because itâ€™s full of responsibilities that
                        are only used in a single use case. This concern leads people to consider whether
                        some responsibility is general, in which case it should sit in the order class, or
                        specific, in which case it should sit in some usage-specific class, which might be
                        a Transaction Script (110) or perhaps the presentation itself.
                        The problem with separating usage-specific behavior is that it can lead to
                        duplication. Behavior thatâ€™s separated from the order is harder to find, so people
                        tend to not see it and duplicate it instead. Duplication can quickly lead to more
                        complexity and inconsistency, but Iâ€™ve found that bloating occurs much less frequently than predicted. If it does occur, itâ€™s relatively easy to see and not difficult
                        to fix. My advice is not to separate usage-specific behavior. Put it all in the object
                        thatâ€™s the natural fit. Fix the bloating when, and if, it becomes a problem.</p>
                <h5>Java Implementation</h5>
                <p>Thereâ€™s always a lot of heat generated when people talk about developing a
                        Domain Model in J2EE. Many of the teaching materials and introductory
                        J2EE books suggest that you use entity beans to develop a domain model,
                        but there are some serious problems with this approach, at least with the
                        current (2.0) specification.
                        Entity beans are most useful when you use Container Managed Persistence
                        (CMP). Indeed, I would say thereâ€™s little point in using entity beans without
                        CMP. However, CMP is a limited form of object-relational mapping, and it
                        canâ€™t support many of the patterns that you need in a rich Domain Model.
                        Entity beans canâ€™t be re-entrant. That is, if you call out from one entity
                        bean into another object, that other object (or any object it calls) canâ€™t call
                        back into the first entity bean. A rich Domain Model often uses re-entrancy,
                        so this is a handicap. Itâ€™s made worse by the fact that itâ€™s hard to spot reentrant behavior. As a result, some people say that one entity bean should
                        never call another. While this avoids re-entrancy, it very much cripples the
                        advantages using a Domain Model.</p>
                <p>A Domain Model should use fine-grained objects with fine-grained interfaces. Entity beans may be remotable (prior to version 2.0 they had to be). If
                        you have remote objects with fine-grained interfaces you get terrible performance. You can avoid this problem quite easily by only using local interfaces for your entity beans in a Domain Model.
                        To run with entity beans you need a container and a database connected.
                        This will increase build times and also increase the time to do test runs since
                        the tests have to execute against a database. Entity beans are also tricky to
                        debug.
                        The alternative is to use normal Java objects, although this often causes a
                        surprised reactionâ€”itâ€™s amazing how many people think that you canâ€™t run
                        regular Java objects in an EJB container. Iâ€™ve come to the conclusion that
                        people forget about regular Java objects because they havenâ€™t got a fancy
                        name. Thatâ€™s why, while preparing for a talk in 2000, Rebecca Parsons, Josh
                        Mackenzie, and I gave them one: POJOs (plain old Java objects). A POJO
                        domain model is easy to put together, is quick to build, can run and test outside an EJB container, and is independent of EJB (maybe thatâ€™s why EJB vendors donâ€™t encourage you to use them).</p>
                <p>My view on the whole is that using entity beans as a Domain Model
                        works if you have pretty modest domain logic. If so, you can build a
                        Domain Model that has a simple relationship with the database: where
                        thereâ€™s mostly one entity bean class per database table. If you have a richer
                        domain logic with inheritance, strategies, and other more sophisticated patterns, youâ€™re better off with a POJO domain model and Data Mapper (165),
                        using a commercial tool or with a homegrown layer.
                        The biggest frustration for me with the use of EJB is that I find a rich
                        Domain Model complicated enough to deal with, and I want to keep as independent as possible from the details of the implementation environment. EJB
                        forces itself into your thinking about the Domain Model, which means that I
                        have to worry about both the domain and the EJB environment.</p>
                <h4 id="119">When to Use It</h4>
                <p>If the how for a Domain Model is difficult because itâ€™s such a big subject, the
                        when is hard because of both the vagueness and the simplicity of the advice. It
                        all comes down to the complexity of the behavior in your system. If you have
                        complicated and everchanging business rules involving validation, calculations,
                        and derivations, chances are that youâ€™ll want an object model to handle them.
                        On the other hand, if you have simple not-null checks and a couple of sums to
                        calculate, a Transaction Script (110) is a better bet.
                        One factor that comes into this is comfortable used the development team is
                        with domain objects. Learning how to design and use a Domain Model is a significant exerciseâ€”one that has led to many articles on the â€œparadigm shiftâ€ of
                        objects use. It certainly takes practice and coaching to get used to a Domain
                        Model, but once used to it Iâ€™ve found that few people want to go back to a
                        Transaction Script (110) for any but the simplest problems.
                        If youâ€™re using Domain Model, my first choice for database interaction is
                        Data Mapper (165). This will help keep your Domain Model independent from
                        the database and is the best approach to handle cases where the Domain Model
                        and database schema diverge.
                        When you use Domain Model you may want to consider Service Layer (133)
                        to give your Domain Model a more distinct API.</p>
                <h4 id="119(2)">Further Reading</h4>
                <p>Almost any book on OO design will talk about Domain Models, since most of
                        what people refer to as OO development is centered around their use.
                        If youâ€™re looking for an introductory book on OO design, my current favorite is [Larman]. For examples of Domain Model take a look at [Fowler AP].
                        [Hay] also gives good examples in a relational context. To build a good
                        Domain Model you should have an understanding of conceptual thinking
                        about objects. For this Iâ€™ve always liked [Martin and Odell]. For an understanding of the patterns youâ€™ll see in a rich Domain Model, or any other OO system,
                        you must read [Gang of Four].
                        Eric Evans is currently writing a book [Evans] on building Domain Models.
                        As I write this Iâ€™ve seen only an early manuscript, but it looks very promising.</p>
                <h4 id="120">Example: Revenue Recognition (Java)</h4>
                <p>One of the biggest frustrations of describing a Domain Model is the fact that
                        any example I show is necessarily simple so you can understand it; yet that simplicity hides the Domain Modelâ€™s strength. You only appreciate these strengths
                        when you have a really complicated domain.
                        But even if the example canâ€™t do justice to why you would want a Domain
                        Model, at least it will give you a sense of what one can look like. Therefore, Iâ€™m
                        using the same example (page 112) that I used for Transaction Script (110), a
                        little matter of revenue recognition.
                        An immediate thing to notice is that every class, in this small example (Figure 9.3) contains both behavior and data. Even the humble Revenue Recognition class contains a simple method to find out if that objectâ€™s value is
                        recognizable on a certain date.
                        <pre>class RevenueRecognition...
                        private Money amount;
                        private MfDate date;
                        public RevenueRecognition(Money amount, MfDate date) {
                        this.amount = amount;
                        this.date = date;
                        }
                        public Money getAmount() {
                        return amount;
                        }
                        boolean isRecognizableBy(MfDate asOf) {
                        return asOf.after(date) || asOf.equals(date);
                        }</pre>
                        Calculating how much revenue is recognized on a particular date involves
                        both the contract and revenue recognition classes.
                        <pre>class Contract...
                        private List revenueRecognitions = new ArrayList();
                        public Money recognizedRevenue(MfDate asOf) {
                        Money result = Money.dollars(0);
                        Iterator it = revenueRecognitions.iterator();</pre>
                <p><img src="img/figure 9.3.png" alt="no img" style="margin-left: 200px;"></p>
                        <pre>while (it.hasNext()) {
                        RevenueRecognition r = (RevenueRecognition) it.next();
                        if (r.isRecognizableBy(asOf))
                        result = result.add(r.getAmount());
                        }
                        return result;
                        }</pre>
                        A common thing you find in domain models is how multiple classes interact
                        to do even the simplest tasks. This is what often leads to the complaint that
                        with OO programs you spend a lot of time hunting around from class to class
                        trying to find them. Thereâ€™s a lot of merit to this complaint. The value comes as
                        the decision on whether something is recognizable by a certain date gets more
                        complex and as other objects need to know. Containing the behavior on the
                        object that needs to know avoids duplication and reduces coupling between the
                        different objects.
                        Figure 9.3 Class diagram of the example classes for a Domain Model.
                        recognizedRevenue (date) : Money
                        calculateRecognitions
                        revenue
                        whenSigned
                        Contract
                        calculateRecognitions (Contract)
                        Product
                        isRecognizableBy (date)
                        amount: Money
                        date
                        Revenue Recognition
                        1
                        calculateRevenueRecognitions (Contract)
                        Recognition Strategy
                        calculateRevenueRecognitions (Contract)
                        Complete Recognition Strategy
                        calculateRevenueRecognitions (Contract)
                        firstRecognitionOffset
                        secondRecognitionOffset
                        Three-Way Recognition Strategy
                        * 1
                        *
                        1
                        *
                        122 DOMAIN LOGIC PATTERNS
                        Domain
                        Model</p>
                <p>Looking at calculating and creating these revenue recognition objects further
                        demonstrates the notion of lots of little objects. In this case the calculation and
                        creation begin with the customer and are handed off via the product to a strategy hierarchy. The strategy pattern [Gang of Four] is a well-known OO pattern
                        that allows you to combine a group of operations in a small class hierarchy.
                        Each instance of product is connected to a single instance of recognition strategy, which determines which algorithm is used to calculate revenue recognition.
                        In this case we have two subclasses of recognition strategy for the two different
                        cases. The structure of the code looks like this:
                        <pre>class Contract...
                        private Product product;
                        private Money revenue;
                        private MfDate whenSigned;
                        private Long id;
                        public Contract(Product product, Money revenue, MfDate whenSigned) {
                        this.product = product;
                        this.revenue = revenue;
                        this.whenSigned = whenSigned;
                        }
                        class Product...
                        private String name;
                        private RecognitionStrategy recognitionStrategy;
                        public Product(String name, RecognitionStrategy recognitionStrategy) {
                        this.name = name;
                        this.recognitionStrategy = recognitionStrategy;
                        }
                        public static Product newWordProcessor(String name) {
                        return new Product(name, new CompleteRecognitionStrategy());
                        }
                        public static Product newSpreadsheet(String name) {
                        return new Product(name, new ThreeWayRecognitionStrategy(60, 90));
                        }
                        public static Product newDatabase(String name) {
                        return new Product(name, new ThreeWayRecognitionStrategy(30, 60));
                        }
                        class RecognitionStrategy...
                        abstract void calculateRevenueRecognitions(Contract contract);
                        class CompleteRecognitionStrategy...
                        void calculateRevenueRecognitions(Contract contract) {
                        contract.addRevenueRecognition(new RevenueRecognition(contract.getRevenue(),
                        contract.getWhenSigned()));
                        }
                        DOMAIN MODEL 123
                        Domain
                        Model
                        class ThreeWayRecognitionStrategy...
                        private int firstRecognitionOffset;
                        private int secondRecognitionOffset;
                        public ThreeWayRecognitionStrategy(int firstRecognitionOffset,
                        int secondRecognitionOffset)
                        {
                        this.firstRecognitionOffset = firstRecognitionOffset;
                        this.secondRecognitionOffset = secondRecognitionOffset;
                        }
                        void calculateRevenueRecognitions(Contract contract) {
                        Money[] allocation = contract.getRevenue().allocate(3);
                        contract.addRevenueRecognition(new RevenueRecognition
                        (allocation[0], contract.getWhenSigned()));
                        contract.addRevenueRecognition(new RevenueRecognition
                        (allocation[1], contract.getWhenSigned().addDays(firstRecognitionOffset)));
                        contract.addRevenueRecognition(new RevenueRecognition
                        (allocation[2], contract.getWhenSigned().addDays(secondRecognitionOffset)));
                        }</pre>
                        The great value of the strategies is that they provide well-contained plug points
                        to extend the application. Adding a new revenue recognition algorithm involves
                        creating a new subclass and overriding the calculateRevenueRecognitions method.
                        This makes it easy to extend the algorithmic behavior of the application.
                        When you create products, you hook them up with the appropriate strategy
                        objects. Iâ€™m doing this in my test code.
                        <pre>class Tester...
                        private Product word = Product.newWordProcessor("Thinking Word");
                        private Product calc = Product.newSpreadsheet("Thinking Calc");
                        private Product db = Product.newDatabase("Thinking DB");</pre>
                        Once everything is set up, calculating the recognitions requires no knowledge of
                        the strategy subclasses.
                        <pre>class Contract...
                        public void calculateRecognitions() {
                        product.calculateRevenueRecognitions(this);
                        }
                        class Product...
                        void calculateRevenueRecognitions(Contract contract) {
                        recognitionStrategy.calculateRevenueRecognitions(contract);
                        }</pre>
                        The OO habit of successive forwarding from object to object moves the
                        behavior to the object most qualified to handle it, but it also resolves much of
                        124 DOMAIN LOGIC PATTERNS
                        Domain
                        Model
                        the conditional behavior. Youâ€™ll notice that there are no conditionals in this calculation. You set up the decision path when you create the products with the
                        appropriate strategy. Once everything is wired together like this, the algorithms
                        just follow the path. Domain models work very well when you have similar
                        conditionals because the similar conditionals can be factored out into the object
                        structure itself. This moves complexity out of the algorithms and into the relationships between objects. The more similar the logic, the more you find the
                        same network of relationships used by different parts of the system. Any algorithm thatâ€™s dependent on the type of recognition calculation can follow this
                        particular network of objects.</p>
                <p>Notice in this example that Iâ€™ve shown nothing about how the objects are
                        retrieved from, and written to, the database. This is for a couple of reasons.
                        First, mapping a Domain Model to a database is always somewhat hard, so Iâ€™m
                        chickening out and not providing an example. Second, in many ways the whole
                        point of a Domain Model is to hide the database, both from upper layers and
                        from people working the Domain Model itself. Thus, hiding it here reflects
                        what itâ€™s like to actually program in this environment.</p>
                <h3 id="125">Table Module</h3>
                <p><img src="img/part2.3.png" alt="no img" style="margin-left: 200px;"></p>
                <p>A single instance that handles the business logic for
                        all rows in a database table or view.
                        One of the key messages of object orientation is bundling the data with the
                        behavior that uses it. The traditional object-oriented approach is based on
                        objects with identity, along the lines of Domain Model (116). Thus, if we have
                        an Employee class, any instance of it corresponds to a particular employee. This
                        scheme works well because once we have a reference to an employee, we can
                        execute operations, follow relationships, and gather data on him.
                        One of the problems with Domain Model (116) is the interface with relational
                        databases. In many ways this approach treats the relational database like a crazy
                        aunt whoâ€™s shut up in an attic and whom nobody wants to talk about. As a result
                        you often need considerable programmatic gymnastics to pull data in and out of
                        the database, transforming between two different representations of the data.
                        A Table Module organizes domain logic with one class per table in the database, and a single instance of a class contains the various procedures that will
                        act on the data. The primary distinction with Domain Model (116) is that, if
                        you have many orders, a Domain Model (116) will have one order object per
                        order while a Table Module will have one object to handle all orders.</p>
                <h4 id="126">How It Works</h4>
                <p>The strength of Table Module is that it allows you to package the data and
                        behavior together and at the same time play to the strengths of a relational
                        database. On the surface Table Module looks much like a regular object. The
                        key difference is that it has no notion of an identity for the objects itâ€™s working
                        with. Thus, if you want to obtain the address of an employee, you use a method
                        like anEmployeeModule.getAddress(long employeeID). Every time you want to do something to a particular employee you have to pass in some kind of identity reference. Often this will be the primary key used in the database.
                        Usually you use Table Module with a backing data structure thatâ€™s table oriented. The tabular data is normally the result of a SQL call and is held in a
                        Record Set (508) that mimics a SQL table. The Table Module gives you an
                        explicit method-based interface that acts on that data. Grouping the behavior
                        with the table gives you many of the benefits of encapsulation in that the behavior is close to the data it will work on.
                        Often youâ€™ll need behavior from multiple Table Modules in order to do some
                        useful work. Many times you see multiple Table Modules operating on the same
                        Record Set (508) (Figure 9.4).</p>
                <p>The most obvious example of Table Module is the use of one for each table
                        in the database. However, if you have interesting queries and views in the database you can have Table Modules
                <p><img src="img/figure 9.4.png" alt="no img" style="margin-left: 200px;"></p>
                        Table Module The Table Module may be an instance or it may be a collection of static
                        methods. The advantage of an instance is that it allows you to initialize the
                        Table Module with an existing record set, perhaps the result of a query. You can
                        then use the instance to manipulate the rows in the record set. Instances also
                        make it possible to use inheritance, so we can write a rush contract module that
                        contains additional behavior to the regular contract.</p>
                <p>The Table Module may include queries as factory methods. The alternative is
                        a Table Data Gateway (144), but the disadvantage of this is having an extra
                        Table Data Gateway (144) class and mechanism in the design. The advantage is
                        that you can use a single Table Module on data from different data sources,
                        since you use a different Table Data Gateway (144) for each data source.
                        When you use a Table Data Gateway (144) the application first uses the
                        Table Data Gateway (144) to assemble data in a Record Set (508). You then
                        create a Table Module with the Record Set (508) as an argument. If you need
                        behavior from multiple Table Modules, you can create them with the same
                        Record Set (508). The Table Module can then do business logic on the Record
                        Set (508) and pass the modified Record Set (508) to the presentation for display
                        and editing using the table-aware widgets. The widgets canâ€™t tell if the record
                <p><img src="img/figure 9.5.png" alt="no img" style="margin-left: 200px;"></p>
                        Table Module sets came directly from the relational database or if a Table Module manipulated the data on the way out. After modification in the GUI, the data set goes
                        back to the Table Module for validation before itâ€™s saved to the database. One
                        of the benefits of this style is that you can test the Table Module by creating a
                        Record Set (508) in memory without going to the database.</p>
                <p>The word â€œtableâ€ in the pattern name suggests that you have one Table
                        Module per table in the database. While this is true to the first approximation,
                        it isnâ€™t completely true. Itâ€™s also useful to have a Table Module for commonly
                        used views or other queries. Indeed, the structure of the Table Module doesnâ€™t
                        really depend on the structure of tables in the database but more on the virtual
                        tables perceived by the application, including views and queries.</p>
                <h4 id="128">When to Use It</h4>
                <p>Table Module is very much based on table-oriented data, so obviously using it
                        makes sense when youâ€™re accessing tabular data using Record Set (508). It also
                        puts that data structure very much in the center of the code, so you also want
                        the way you access the data structure to be fairly straightforward.
                        However, Table Module doesnâ€™t give you the full power of objects in organizing complex logic. You canâ€™t have direct instance-to-instance relationships, and
                        polymorphism doesnâ€™t work well. So, for handling complicated domain logic, a
                        Domain Model (116) is a better choice. Essentially you have to trade off
                        Domain Model (116)â€™s ability to handle complex logic against Table Moduleâ€™s
                        easier integration with the underlying table-oriented data structures.
                        If the objects in a Domain Model (116) and the database tables are relatively
                        similar, it may be better to use a Domain Model (116) that uses Active Record
                        (160). Table Module works better than a combination of Domain Model (116)
                        and Active Record (160) when other parts of the application are based on a
                        common table-oriented data structure. Thatâ€™s why you donâ€™t see Table Module
                        very much in the Java environment, although that may change as row sets
                        become more widely used.
                        The most well-known situation in which Iâ€™ve come across this pattern is in
                        Microsoft COM designs. In COM (and .NET) the Record Set (508) is the primary repository of data in an application. Record sets can be passed to the UI,
                        where data-aware widgets display information. Microsoftâ€™s ADO libraries give
                        you a good mechanism to access the relational data as record sets. In this situation Table Module allows you to fit business logic into the application in a wellorganized manner, without losing the way the various elements work on the
                        tabular data.</p>
                <h4 id="129">Example: Revenue Recognition with a Table Module (C#)</h4>
                <p>Time to revisit the revenue recognition example (page 112) I used in the other
                        domain modeling patterns, this time with a Table Module. To recap, our mission is to recognize revenue on orders when the rules vary depending on the
                        product type. In this example we have different rules for word processors,
                        spreadsheets, and databases.</p>
                <p>Table Module is based on a data schema of some kind, usually a relational
                        data model (although in the future we may well see an XML model used in a
                        similar way). In this case Iâ€™ll use the relational schema from Figure 9.6.
                        The classes that manipulate this data are in pretty much the same form;
                        thereâ€™s one Table Module class for each table. In the .NET architecture a data
                        set object provides an in-memory representation of a database structure. It thus
                        makes sense to create classes that operate on this data set. Each Table Module
                        class has a data member of a data table, which is the .NET system class corresponding to a table within the data set. This ability to read a table is common
                        to all Table Modules and so can appear in a Layer Supertype (475).
                        <pre>class TableModule...
                        protected DataTable table;
                        protected TableModule(DataSet ds, String tableName) {
                        table = ds.Tables[tableName];
                        }</pre>
                        The subclass constructor calls the superclass constructor with the correct
                        table name.
                        <pre>class Contract...
                        public Contract (DataSet ds) : base (ds, "Contracts") {}</pre>
                <p><img src="img/figure 9.5.png" alt="no img" style="margin-left: 200px;"></p>
                        This allows you to create a new Table Module just by passing in a data set to
                        Table Moduleâ€™s constructor
                        <pre>contract = new Contract(dataset);</pre>
                        which keeps the code that creates the data set away from the Table Modules,
                        following the guidelines of ADO.NET. </p>
                <p>A useful feature is the C# indexer, which gets to a particular row in the data
                        table given the primary key.</p>
                        <pre>class Contract...
                        public DataRow this [long key] {
                        get {
                        String filter = String.Format("ID = {0}", key);
                        return table.Select(filter)[0];
                        }
                        }</pre>
                <p>The first piece of functionality calculates the revenue recognition for a contract, updating the revenue recognition table accordingly. The amount recognized depends on the kind of product we have. Since this behavior mainly uses
                        data from the contract table, I decided to add the method to the contract class.
                        <pre>class Contract...
                        public void CalculateRecognitions (long contractID) {
                        DataRow contractRow = this[contractID];
                        Decimal amount = (Decimal)contractRow["amount"];
                        RevenueRecognition rr = new RevenueRecognition (table.DataSet);
                        Product prod = new Product(table.DataSet);
                        long prodID = GetProductId(contractID);
                        if (prod.GetProductType(prodID) == ProductType.WP) {
                        rr.Insert(contractID, amount, (DateTime) GetWhenSigned(contractID));
                        } else if (prod.GetProductType(prodID) == ProductType.SS) {
                        Decimal[] allocation = allocate(amount,3);
                        rr.Insert(contractID, allocation[0], (DateTime) GetWhenSigned(contractID));
                        rr.Insert(contractID, allocation[1], (DateTime)
                        GetWhenSigned(contractID).AddDays(60));
                        rr.Insert(contractID, allocation[2], (DateTime)
                        GetWhenSigned(contractID).AddDays(90));
                        } else if (prod.GetProductType(prodID) == ProductType.DB) {
                        Decimal[] allocation = allocate(amount,3);
                        rr.Insert(contractID, allocation[0], (DateTime) GetWhenSigned(contractID));
                        rr.Insert(contractID, allocation[1], (DateTime)
                        GetWhenSigned(contractID).AddDays(30));
                        rr.Insert(contractID, allocation[2], (DateTime)
                        GetWhenSigned(contractID).AddDays(60));
                        } else throw new Exception("invalid product id");
                        }
                        private Decimal[] allocate(Decimal amount, int by) {
                        Decimal lowResult = amount / by;
                        TABLE MODULE 131
                        Table Module lowResult = Decimal.Round(lowResult,2);
                        Decimal highResult = lowResult + 0.01m;
                        Decimal[] results = new Decimal[by];
                        int remainder = (int) amount % by;
                        for (int i = 0; i &lt; remainder; i++) results[i] = highResult;
                        for (int i = remainder; i &lt; by; i++) results[i] = lowResult;
                        return results;
                        }</pre>
                        Usually I would use Money (488) here, but for varietyâ€™s sake Iâ€™ll show this using
                        a decimal. I use an allocation method similar to the one I use for Money (488).
                        To carry this out, we need some behavior thatâ€™s defined on the other classes.
                        The product needs to be able to tell us which type it is. We can do this with an
                        enum for the product type and a lookup method.
                        <pre>public enum ProductType {WP, SS, DB};
                        class Product...
                        public ProductType GetProductType (long id) {
                        String typeCode = (String) this[id]["type"];
                        return (ProductType) Enum.Parse(typeof(ProductType), typeCode);
                        }
                        GetProductType</pre> encapsulates the data in the data table. Thereâ€™s an argument for
                        doing this for all columns of data, as opposed to accessing them directly as I did
                        with the amount on the contract. While encapsulation is generally a Good
                        Thing, I donâ€™t use it here because it doesnâ€™t fit with the assumption of the environment that different parts of the system access the data set directly. Thereâ€™s no
                        encapsulation when the data set moves over to the UI, so column access functions only make sense when thereâ€™s some additional functionality to be done,
                        such as converting a string to a product type.
                        This is also a good time to mention that, although Iâ€™m using an untyped data
                        set here because these are more common on different platforms, thereâ€™s a strong
                        argument (page 509) for using .NETâ€™s strongly typed data set.
                        The other additional behavior is inserting a new revenue recognition record.
                        <pre>class RevenueRecognition...
                        public long Insert (long contractID, Decimal amount, DateTime date) {
                        DataRow newRow = table.NewRow();
                        long id = GetNextID();
                        newRow["ID"] = id;
                        newRow["contractID"] = contractID;
                        newRow["amount"] = amount;
                        newRow["date"]= String.Format("{0:s}", date);
                        table.Rows.Add(newRow);
                        return id;
                        }</pre>
                        132 DOMAIN LOGIC PATTERNS
                        Table Module Again, the point of this method is less to encapsulate the data row and more to
                        have a method instead of several lines of code that are repeated.
                        The second piece of functionality is to sum up all the revenue recognized on
                        a contract by a given date. Since this uses the revenue recognition table it makes
                        sense to define the method there.
                        <pre>class RevenueRecognition...
                        public Decimal RecognizedRevenue (long contractID, DateTime asOf) {
                        String filter = String.Format("ContractID = {0} AND date &lt;= #{1:d}#", contractID,asOf);
                        DataRow[] rows = table.Select(filter);
                        Decimal result = 0m;
                        foreach (DataRow row in rows) {
                        result += (Decimal)row["amount"];
                        }
                        return result;
                        }</pre>
                        This fragment takes advantage of the really nice feature of ADO.NET that
                        allows you to define a where clause and then select a subset of the data table to
                        manipulate. Indeed, you can go further and use an aggregate function.
                        <pre>class RevenueRecognition...
                        public Decimal RecognizedRevenue2 (long contractID, DateTime asOf) {
                        String filter = String.Format("ContractID = {0} AND date &lt;= #{1:d}#", contractID,asOf);
                        String computeExpression = "sum(amount)";
                        Object sum = table.Compute(computeExpression, filter);
                        return (sum is System.DBNull) ? 0 : (Decimal) sum;
                        }</pre></p>
                <h3 id="133">Service Layer</h3>
                <p><img src="img/part2.4.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Defines an applicationâ€™s boundary with a layer of services that
                        establishes a set of available operations and coordinates the
                        applicationâ€™s response in each operation.
                        Enterprise applications typically require different kinds of interfaces to the data
                        they store and the logic they implement: data loaders, user interfaces, integration gateways, and others. Despite their different purposes, these interfaces
                        often need common interactions with the application to access and manipulate
                        its data and invoke its business logic. The interactions may be complex, involving transactions across multiple resources and the coordination of several
                        responses to an action. Encoding the logic of the interactions separately in each
                        interface causes a lot of duplication.
                        A Service Layer defines an applicationâ€™s boundary [Cockburn PloP] and its
                        set of available operations from the perspective of interfacing client layers. It
                        encapsulates the applicationâ€™s business logic, controlling transactions and coordinating responses in the implementation of its operations.</p>
                <h4 id="134">How It Works</h4>
                <p>A Service Layer can be implemented in a couple of different ways, without violating the defining characteristics stated above. The differences appear in the
                        allocation of responsibility behind the Service Layer interface. Before I delve
                        into the various implementation possibilities, let me lay a bit of groundwork.</p>
                <p><b>Kinds of â€œBusiness Logicâ€</b> Like Transaction Script (110) and Domain Model
                        (116), Service Layer is a pattern for organizing business logic. Many designers,
                        including me, like to divide â€œbusiness logicâ€ into two kinds: â€œdomain logic,â€
                        having to do purely with the problem domain (such as strategies for calculating
                        revenue recognition on a contract), and â€œapplication logic,â€ having to do with
                        application responsibilities [Cockburn UC] (such as notifying contract administrators, and integrated applications, of revenue recognition calculations). Application logic is sometimes referred to as â€œworkflow logic,â€ although different
                        people have different interpretations of â€œworkflow.â€</p>
                <p>Domain Models (116) are preferable to Transaction Scripts (110) for avoiding domain logic duplication and for managing complexity using classical
                        design patterns. But putting application logic into pure domain object classes
                        has a couple of undesirable consequences. First, domain object classes are less
                        reusable across applications if they implement application-specific logic and
                        depend on application-specific packages. Second, commingling both kinds of
                        logic in the same classes makes it harder to reimplement the application logic
                        in, say, a workflow tool if that should ever become desirable. For these reasons
                        Service Layer factors each kind of business logic into a separate layer, yielding
                        the usual benefits of layering and rendering the pure domain object classes more
                        reusable from application to application.</p>
                <p><b>Implementation Variations</b> The two basic implementation variations are the
                        domain facade approach and the operation script approach. In the domain
                        facade approach a Service Layer is implemented as a set of thin facades over a
                        Domain Model (116). The classes implementing the facades donâ€™t implement
                        any business logic. Rather, the Domain Model (116) implements all of the business logic. The thin facades establish a boundary and set of operations through
                        which client layers interact with the application, exhibiting the defining characteristics of Service Layer. sIn the operation script approach a Service Layer is implemented as a set of
                        thicker classes that directly implement application logic but delegate to encapsulated domain object classes for domain logic. The operations available to clients
                        of a Service Layer are implemented as scripts, organized several to a class defining a subject area of related logic. Each such class forms an application â€œservice,â€ and itâ€™s common for service type names to end with â€œService.â€ A Service
                        Layer is comprised of these application service classes, which should extend a
                        Layer Supertype (475), abstracting their responsibilities and common behaviors.</p>
                <p><i>To Remote or Not to Remote</i> The interface of a Service Layer class is coarse
                        grained almost by definition, since it declares a set of application operations
                        available to interfacing client layers. Therefore, Service Layer classes are well
                        suited to remote invocation from an interface granularity perspective.
                        However, remote invocation comes at the cost of dealing with object distribution. It likely entails a lot of extra work to make your Service Layer method
                        signatures deal in Data Transfer Objects (401). Donâ€™t underestimate the cost of
                        this work, especially if you have a complex Domain Model (116) and rich editing UIs for complex update use cases! Itâ€™s significant, and itâ€™s painfulâ€”perhaps
                        second only to the cost and pain of object-relational mapping. Remember the
                        First Law of Distributed Object Design (page 89).</p>
                <p>My advice is to start with a locally invocable Service Layer whose method
                        signatures deal in domain objects. Add remotability when you need it (if ever)
                        by putting Remote Facades (388) on your Service Layer or having your Service
                        Layer objects implement remote interfaces. If your application has a Web-based
                        UI or a Web-services-based integration gateway, thereâ€™s no law that says your
                        business logic has to run in a separate process from your server pages and Web
                        services. In fact, you can save yourself some development effort and runtime
                        response time, without sacrificing scalability, by starting out with a colocated
                        approach.</p>
                <p><i>Identifying Services and Operations</i> Identifying the operations needed on a Service Layer boundary is pretty straightforward. Theyâ€™re determined by the needs
                        of Service Layer clients, the most significant (and first) of which is typically a
                        user interface. Since a user interface is designed to support the use cases that
                        actors want to perform with an application, the starting point for identifying
                        Service Layer operations is the use case model and the user interface design for
                        the application.
                        Disappointing as it is, many of the use cases in an enterprise application
                        are fairly boring â€œCRUDâ€ (create, read, update, delete) use cases on domain
                        objectsâ€”create one of these, read a collection of those, update this other
                        thing. My experience is that thereâ€™s almost always a one-to-one correspondence between CRUD use cases and Service Layer operations.
                        The applicationâ€™s responsibilities in carrying out these use cases, however,
                        may be anything but boring. Validation aside, the creation, update, or deletion
                        of a domain object in an application increasingly requires notification of other
                        people and other integrated applications. These responses must be coordinated,
                        and transacted atomically, by Service Layer operations.</p>
                <p>If only it were as straightforward to identify Service Layer abstractions to
                        group related operations. There are no hard-and-fast prescriptions in this area;
                        only vague heuristics. For a sufficiently small application, it may suffice to have
                        but one abstraction, named after the application itself. In my experience larger
                        applications are partitioned into several â€œsubsystems,â€ each of which includes a
                        complete vertical slice through the stack of architecture layers. In this case I prefer
                        one abstraction per subsystem, named after the subsystem. Other possibilities
                        include abstractions reflecting major partitions in a domain model, if these are
                        different from the subsystem partitions (e.g., ContractsService, ProductsService), and
                        abstractions named after thematic application behaviors (e.g., RecognitionService).</p>
                <h5>Java Implementation</h5>
                <p>In both the domain facade approach and the operation script approach, a
                        Service Layer class can be implemented as either a POJO (plain old Java
                        object) or a stateless session bean. The trade-off pits ease of testing against
                        ease of transaction control. POJOs might be easier to test, since they donâ€™t
                        have to be deployed in an EJB container to run, but itâ€™s harder for a POJO
                        Service Layer to hook into distributed container-managed transaction services, especially in interservice invocations. EJBs, on the other hand, come
                        with the potential for container-managed distributed transactions but have
                        to be deployed in a container before they can be tested and run. Choose
                        your poison.</p>
                <p>My preferred way of applying a Service Layer in J2EE is with EJB 2.0
                        stateless session beans, using local interfaces, and the operation script
                        approach, delegating to POJO domain object classes. Itâ€™s just so darned convenient to implement a Service Layer using stateless session bean, because of
                        the distributed container-managed transactions provided by EJB. Also, with
                        the local interfaces introduced in EJB 2.0, a Service Layer can exploit the
                        valuable transaction services while avoiding the thorny object distribution
                        issues.
                        On a related Java-specific note, let me differentiate Service Layer from
                        the Session Facade pattern documented in the J2EE patterns literature
                        [Alur et al.] and [Marinescu]. Session Facade was motivated by the desire
                        to avoid the performance penalty of too many remote invocations on entity
                        beans; it therefore prescribes facading entity beans with session beans. Service Layer is motivated instead by factoring responsibility to avoid duplication and promote reusability; itâ€™s an architecture pattern that transcends
                        technology. In fact, the application boundary pattern [Cockburn PloP] that
                        inspired Service Layer predates EJB by three years. Session Facade may be
                        in the spirit of Service Layer but, as currently named, scoped, and presented,
                        is not the same.</p>
                <h4 id="137">When to Use It</h4>
                <p>The benefit of Service Layer is that it defines a common set of application operations available to many kinds of clients and it coordinates an applicationâ€™s
                        response in each operation. The response may involve application logic that
                        needs to be transacted atomically across multiple transactional resources. Thus,
                        in an application with more than one kind of client of its business logic, and
                        complex responses in its use cases involving multiple transactional resources, it
                        makes a lot of sense to include a Service Layer with container-managed transactions, even in an undistributed architecture.
                        The easier question to answer is probably when not to use it. You probably
                        donâ€™t need a Service Layer if your applicationâ€™s business logic will only have one
                        kind of clientâ€”say, a user interfaceâ€”and its use case responses donâ€™t involve
                        multiple transactional resources. In this case your Page Controllers can manually control transactions and coordinate whatever response is required, perhaps
                        delegating directly to the Data Source layer.
                        But as soon as you envision a second kind of client, or a second transactional
                        resource in use case responses, it pays to design in a Service Layer from the
                        beginning.</p>
                <h4 id="137(2)">Further Reading</h4>
                <p>Thereâ€™s not a great deal of prior art on Service Layer, whose inspiration is
                        Alistair Cockburnâ€™s application boundary pattern [Cockburn PloP]. In the
                        remotable services vein [Alpert, et al.] discuss the role of facades in distributed
                        systems. Compare and contrast this with the various presentations of Session
                        Facade [Alur et al.] and [Marinescu]. On the topic of application responsibilities that must be coordinated within Service Layer operations, Cockburnâ€™s
                        description of use cases as a contract for behavior [Cockburn UC] is very helpful. An earlier background reference is the Fusion methodologyâ€™s recognition of
                        â€œsystem operationsâ€ [Coleman et al.].</p>
                <h4 id="138">Example: Revenue Recognition (Java)</h4>
                        This example continues the revenue recognition example of the Transaction
                        Script (110) and Domain Model (116) patterns, demonstrating how Service
                        Layer is used to script application logic and delegate for domain logic in a Service Layer operation. It uses the operation script approach to implement a Service Layer, first with POJOs and then with EJBs.
                        To make the demonstration we expand the scenario to include some application logic. Suppose the use cases for the application require that, when the revenue recognitions for a contract are calculated, the application must respond by
                        sending an e-mail notification of that event to a designated contract administrator and by publishing a message using message-oriented middleware to notify
                        other integrated applications.
                        We start by changing the RecognitionService class from the Transaction
                        Script (110) example to extend a Layer Supertype (475) and to use a couple of
                        Gateways (466) in carrying out application logic. This yields the class diagram
                        of Figure 9.7. RecognitionService becomes a POJO implementation of a Service
                        Layer application service, and its methods represent two of the operations
                        available at the applicationâ€™s boundary.</p>
                <p>The methods of the RecognitionService class script the application logic of
                        the operations, delegating to domain object classes (of the example from
                        Domain Model (116)) for domain logic.
                        <pre>public class ApplicationService {
                        protected EmailGateway getEmailGateway() {
                        //return an instance of EmailGateway
                        }
                        protected IntegrationGateway getIntegrationGateway() {
                        //return an instance of IntegrationGateway
                        }
                        }
                        public interface EmailGateway {
                        void sendEmailMessage(String toAddress, String subject, String body);
                        }
                        public interface IntegrationGateway {
                        void publishRevenueRecognitionCalculation(Contract contract);
                        }
                        public class RecognitionService
                        extends ApplicationService {
                        public void calculateRevenueRecognitions(long contractNumber) {
                        Contract contract = Contract.readForUpdate(contractNumber);
                        contract.calculateRecognitions();
                        getEmailGateway().sendEmailMessage(
                        contract.getAdministratorEmailAddress(),
                        "RE: Contract #" + contractNumber,
                        contract + " has had revenue recognitions calculated.");
                        getIntegrationGateway().publishRevenueRecognitionCalculation(contract);
                        }</pre>
                <p><img src="img/figure 9.7.png" alt="no img" style="margin-left: 200px;"></p>
                        <pre>public Money recognizedRevenue(long contractNumber, Date asOf) {
                        return Contract.read(contractNumber).recognizedRevenue(asOf);
                        }</pre>
                        Persistence details are again left out of the example. Suffice it to say that the
                        Contract class implements static methods to read contracts from the Data Source
                        layer by their numbers. One of these methods has a name revealing an intention
                        to update the contract thatâ€™s read, which allows an underlying Data Mapper
                        (165) to register the read object(s) with for example, a Unit of Work (184).</p>
                <p>Transaction control details are also left out of the example. The calculateRevenueRecognitions() method is inherently transactional because, during its execution,
                        persistent contract objects are modified via addition of revenue recognitions;
                        messages are enqueued in message-oriented middleware; and e-mail messages
                        are sent. All of these responses must be transacted atomically because we donâ€™t
                        want to send e-mail and publish messages to other applications if the contract
                        changes fail to persist.
                        In the J2EE platform we can let the EJB container manage distributed transactions by implementing application services (and Gateways (466)) as stateless
                        session beans that use transactional resources. Figure 9.8 shows the class diagram of a RecognitionService implementation that uses EJB 2.0 local interfaces
                        and the â€œbusiness interfaceâ€ idiom. In this implementation a Layer Supertype
                        (475) is still used, providing default implementations of the bean implementation class methods required by EJB, in addition to the application-specific methods. If we assume that the EmailGateway and IntegrationGateway interfaces are also
                        â€œbusiness interfacesâ€ for their respective stateless session beans, then control of
                        the distributed transaction is achieved by declaring the calculateRevenueRecognitions, sendEmailMessage, and publishRevenueRecognitionCalculation methods to be
                        transactional. The RecognitionService methods from the POJO example move
                        unchanged to RecognitionServiceBeanImpl.</p>
                <p>The important point about the example is that the Service Layer uses both
                        operation scripting and domain object classes in coordinating the transactional
                        response of the operation. The calculateRevenueRecognitions method scripts the
                        application logic of the response required by the applicationâ€™s use cases, but it
                        delegates to the domain object classes for domain logic. It also presents a couple
                        of techniques for combating duplicated logic within operation scripts of a Service Layer. Responsibilities are factored into different objects (e.g., Gateways
                        (466)) that can be reused via delegation. A Layer Supertype (475) provides convenient access to these other objects.
                        Some might argue that a more elegant implementation of the operation
                        script would use the Observer pattern [Gang of Four], but Observer is difficult
                <p><img src="img/figure 9.8.png" alt="no img" style="margin-left: 200px;"></p>
                        to implement in a stateless, multithreaded Service Layer. In my opinion the
                        open code of the operation script is clearer and simpler.
                        Some might also argue that the application logic responsibilities could be
                        implemented in domain object methods, such as Contract.calculateRevenueRecognitions(), or even in the data source layer, thereby eliminating the need for a separate Service Layer. However, I find those allocations of responsibility
                        undesirable for a number of reasons. First, domain object classes are less reusable across applications if they implement application-specific logic (and
                        depend on application-specific Gateways (466), and the like). They should
                        model the parts of the problem domain that are of interest to the application,
                        which doesnâ€™t mean all of the applicationâ€™s use case responsibilities. Second,
                        encapsulating application logic in a â€œhigherâ€ layer dedicated to that purpose
                        (which the data source layer isnâ€™t) facilitates changing the implementation of
                        that layerâ€”perhaps to use a workflow engine.
                        As an organization pattern for the logic layer of an enterprise application,
                        Service Layer combines scripting and domain object classes, leveraging the best
                        aspects of both. Several variations are possible in a Service Layer implementationâ€”for example, domain facades or operation scripts, POJOs or session
                        beans, or a combination of both. Service Layer can be designed for local invocation, remote invocation, or both. Most important, regardless of these variations, this pattern lays the foundation for encapsulated implementation of an
                        applicationâ€™s business logic and consistent invocation of that logic by its various
                        clients.</p>
                <h3 id="143">Chapter 10</h3>
                <h1>Data Source Architectural Patterns</h1>
                <h3 id="144">Table Data Gateway</h3>
                <p><img src="img/part2.5.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that acts as a Gateway (466) to a database table.
                        One instance handles all the rows in the table.
                        Mixing SQL in application logic can cause several problems. Many developers
                        arenâ€™t comfortable with SQL, and many who are comfortable may not write it
                        well. Database administrators need to be able to find SQL easily so they can figure out how to tune and evolve the database.
                        A Table Data Gateway holds all the SQL for accessing a single table or
                        view: selects, inserts, updates, and deletes. Other code calls its methods for all
                        interaction with the database.</p>
                <h3 id="144(2)">How It Works</h3>
                <p>A Table Data Gateway has a simple interface, usually consisting of several find
                        methods to get data from the database and update, insert, and delete methods.
                        Each method maps the input parameters into a SQL call and executes the SQL
                        against a database connection.The Table Data Gateway is usually stateless, as
                        its role is to push data back and forth.
                        The trickiest thing about a Table Data Gateway is how it returns information from a query. Even a simple find-by-ID query will return multiple data
                        items. In environments where you can return multiple items you can use that
                        for a single row, but many languages give you only a single return value and
                        many queries return multiple rows.
                        One alternative is to return some simple data structure, such as a map. A
                        map works, but it forces data to be copied out of the record set that comes from
                        the database into the map. I think that using maps to pass data around is bad
                        form because it defeats compile time checking and isnâ€™t a very explicit interface,
                        find (id) : RecordSet
                        findWithLastName(String) : RecordSet
                        update (id, lastname, firstname, numberOfDependents)
                        insert (lastname, firstname, numberOfDependents)
                        delete (id)
                        Person Gateway
                        leading to bugs as people misspell whatâ€™s in the map. A better alternative is to
                        use a Data Transfer Object (401). Itâ€™s another object to create but one that may
                        well be used elsewhere.
                        To save all this you can return the Record Set (508) that comes from the SQL
                        query. This is conceptually messy, as ideally the in-memory object doesnâ€™t have to
                        know anything about the SQL interface. It may also make it difficult to substitute
                        the database for a file if you canâ€™t easily create record sets in your own code. Nevertheless, in many environments that use Record Set (508) widely, such as .NET,
                        itâ€™s a very effective approach. A Table Data Gateway thus goes very well with
                        Table Module (125). If all of your updates are done through the Table Data Gateway, the returned data can be based on views rather than on the actual tables,
                        which reduces the coupling between your code and the database.
                        If youâ€™re using a Domain Model (116), you can have the Table Data Gateway return the appropriate domain object. The problem with this is that you
                        then have bidirectional dependencies between the domain objects and the gateway. The two are closely connected, so that isnâ€™t necessarily a terrible thing, but
                        itâ€™s something Iâ€™m always reluctant to do.</p>
                <p>Most times when you use Table Data Gateway, youâ€™ll have one for each
                        table in the database. For very simple cases, however, you can have a single
                        Table Data Gateway that handles all methods for all tables. You can also have
                        one for views or even for interesting queries that arenâ€™t kept in the database as
                        views. Obviously, view-based Table Data Gateways often canâ€™t update and so
                        wonâ€™t have update behavior. However, if you can make updates to the underlying tables, then encapsulating the updates behind update operations on the
                        Table Data Gateway is a very good technique. </p>
                <h3 id="145">When to Use It</h3>
                <p>As with Row Data Gateway (152) the decision regarding Table Data Gateway
                        is first whether to use a Gateway (466) approach at all and then which one.
                        I find that Table Data Gateway is probably the simplest database interface
                        pattern to use, as it maps so nicely onto a database table or record type. It also
                        makes a natural point to encapsulate the precise access logic of the data source.
                        I use it least with Domain Model (116) because I find that Data Mapper (165)
                        gives a better isolation between the Domain Model (116) and the database.
                        Table Data Gateway works particularly well with Table Module (125),
                        where it produces a record set data structure for the Table Module (125) to
                        work on. Indeed, I canâ€™t really imagine any other database-mapping approach
                        for Table Module (125).
                        Just like Row Data Gateway (152), Table Data Gateway is very suitable for
                        Transaction Scripts (110). The choice between the two really boils down to
                        how they deal with multiple rows of data. Many people like using a Data
                        Transfer Object (401), but that seems to me like more work than is worthwhile,
                        unless the same Data Transfer Object (401) is used elsewhere. I prefer Table
                        Data Gateway when the result set representation is convenient for the Transaction Script (110) to work with.
                        Interestingly, it often makes sense to have the Data Mappers (165) talk to the
                        database via Table Data Gateways. Although this isnâ€™t useful when everything
                        is handcoded, it can be very effective if you want to use metadata for the Table
                        Data Gateways but prefer handcoding for the actual mapping to the domain
                        objects.</p>
                <p>One of the benefits of using a Table Data Gateway to encapsulate database
                        access is that the same interface can work both for using SQL to manipulate the
                        database and for using stored procedures. Indeed, stored procedures themselves
                        are often organized as Table Data Gateways. That way the insert and update
                        stored procedures encapsulate the actual table structure. The find procedures in
                        this case can return views, which helps to hide the underlying table structure.</p>
                <h3 id="146">Further Reading</h3>
                <p>[Alur et al.] discusses the Data Access Object pattern, which is a Table Data
                        Gateway. They show returning a collection of Data Transfer Objects (401) on
                        the query methods. Itâ€™s not clear whether they see this pattern as always being
                        table based; the intent and discussion seems to imply either Table Data Gateway or Row Data Gateway (152).
                        Iâ€™ve used a different name, partly because I see this pattern as a particular
                        usage of the more general Gateway (466) concept and I want the pattern name
                        to reflect that. Also, the term Data Access Object and its abbreviation DAO has
                        its own particular meaning within the Microsoft world.</p>
                <h3 id="146(2)">Example: Person Gateway (C#)</h3>
                <p>Table Data Gateway is the usual form of database access in the windows
                        world, so it makes sense to illustrate one with C#. I have to stress, however, that
                        this classic form of Table Data Gateway doesnâ€™t quite fit in the .NET environment since it doesnâ€™t take advantage of the ADO.NET data set; instead, it uses
                        the data reader, which is a cursor-like interface to database records. The data
                        TABLE DATA GATEWAY 147
                        Data Source
                        Architectural
                        Patterns
                        reader is the right choice for manipulating larger amounts of information when
                        you donâ€™t want to bring everything into memory in one go.</p>
                <p>For the example Iâ€™m using a Person Gateway class that connects to a person
                        table in a database. The Person Gateway contains the finder code, returning
                        ADO.NETâ€™s data reader to access the returned data.
                        <pre>class PersonGateway...
                        public IDataReader FindAll() {
                        String sql = "select * from person";
                        return new OleDbCommand(sql, DB.Connection).ExecuteReader();
                        }
                        public IDataReader FindWithLastName(String lastName) {
                        String sql = "SELECT * FROM person WHERE lastname = ?";
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter("lastname", lastName));
                        return comm.ExecuteReader();
                        }
                        public IDataReader FindWhere(String whereClause) {
                        String sql = String.Format("select * from person where {0}", whereClause);
                        return new OleDbCommand(sql, DB.Connection).ExecuteReader();
                        }</pre>
                        Almost always youâ€™ll want to pull back a bunch of rows with a reader. On a
                        rare occasion you might want to get hold of an individual row of data with a
                        method along these lines:
                        <pre>class PersonGateway...
                        public Object[] FindRow (long key) {
                        String sql = "SELECT * FROM person WHERE id = ?";
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter("key",key));
                        IDataReader reader = comm.ExecuteReader();
                        reader.Read();
                        Object [] result = new Object[reader.FieldCount];
                        reader.GetValues(result);
                        reader.Close();
                        return result;
                        }</pre>
                        The update and insert methods receive the necessary data in arguments and
                        invoke the appropriate SQL routines.
                        <pre>class PersonGateway...
                        public void Update (long key, String lastname, String firstname, long numberOfDependents){
                        String sql = @"
                        UPDATE person
                        SET lastname = ?, firstname = ?, numberOfDependents = ?
                        WHERE id = ?";
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter ("last", lastname));
                        comm.Parameters.Add(new OleDbParameter ("first", firstname));
                        comm.Parameters.Add(new OleDbParameter ("numDep", numberOfDependents));
                        comm.Parameters.Add(new OleDbParameter ("key", key));
                        comm.ExecuteNonQuery();
                        }
                        class PersonGateway...
                        public long Insert(String lastName, String firstName, long numberOfDependents) {
                        String sql = "INSERT INTO person VALUES (?,?,?,?)";
                        long key = GetNextID();
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter ("key", key));
                        comm.Parameters.Add(new OleDbParameter ("last", lastName));
                        comm.Parameters.Add(new OleDbParameter ("first", firstName));
                        comm.Parameters.Add(new OleDbParameter ("numDep", numberOfDependents));
                        comm.ExecuteNonQuery();
                        return key;
                        }</pre>
                        The deletion method just needs a key.
                        <pre>class PersonGateway...
                        public void Delete (long key) {
                        String sql = "DELETE FROM person WHERE id = ?";
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter ("key", key));
                        comm.ExecuteNonQuery();
                        }</pre></p>
                <h3 id="148">Example: Using ADO.NET Data Sets (C#)</h3>
                <p>The generic Table Data Gateway works with pretty much any kind of platform
                        since itâ€™s nothing but a wrapper for SQL statements. With .NET you use data
                        sets more often, but Table Data Gateway is still useful although it comes in a
                        different form.
                        A data set needs data adapters to load the data into it and update the data. In
                        find it useful to define a holder for the data set and the adapters. A gateway
                        then uses the holder to store them. Much of this behavior is generic and can be
                        done in a superclass.</p>
                <p>The holder indexes the data sets and adapters by the name of the table.
                        <pre>class DataSetHolder...
                        public DataSet Data = new DataSet();
                        private Hashtable DataAdapters = new Hashtable();</pre>
                <p><img src="img/figure 10.1.png" alt="no img" style="margin-left: 200px;"></p>
                        The gateway stores the holder and exposes the data set for its clients.
                        <pre>class DataGateway...
                        public DataSetHolder Holder;
                        public DataSet Data {
                        get {return Holder.Data;}
                        }</pre>
                        The gateway can act on an existing holder, or it can create a new one.
                        <pre>class DataGateway...
                        protected DataGateway() {
                        Holder = new DataSetHolder();
                        }
                        protected DataGateway(DataSetHolder holder) {
                        this.Holder = holder;
                        }</pre>
                        The find behavior can work a bit differently here. A data set is a container
                        for table-oriented data and can hold data from several tables. For that reason
                        itâ€™s better to load data into a data set.
                        <pre>class DataGateway...
                        public void LoadAll() {
                        String commandString = String.Format("select * from {0}", TableName);
                        Holder.FillData(commandString, TableName);
                        }
                        Figure 10.1 Class diagram of data-set-oriented gateway and the supporting data holder.
                        Data Gateway Data Set Holder
                        Person Gateway
                        1
                        Data Set
                        1
                        Data Adapter
                        tablename
                        1
                        *
                        150 DATA SOURCE ARCHITECTURAL PATTERNS
                        Table Data
                        Gateway
                        public void LoadWhere(String whereClause) {
                        String commandString =
                        String.Format("select * from {0} where {1}", TableName,whereClause);
                        Holder.FillData(commandString, TableName);
                        }
                        abstract public String TableName {get;}
                        class PersonGateway...
                        public override String TableName {
                        get {return "Person";}
                        }
                        class DataSetHolder...
                        public void FillData(String query, String tableName) {
                        if (DataAdapters.Contains(tableName)) throw new MutlipleLoadException();
                        OleDbDataAdapter da = new OleDbDataAdapter(query, DB.Connection);
                        OleDbCommandBuilder builder = new OleDbCommandBuilder(da);
                        da.Fill(Data, tableName);
                        DataAdapters.Add(tableName, da);
                        }</pre>
                        To update data you manipulate the data set directly in some client code.
                        <pre>person.LoadAll();
                        person[key]["lastname"] = "Odell";
                        person.Holder.Update();</pre>
                        The gateway can have an indexer to make it easier to get to specific rows.
                        <pre>class DataGateway...
                        public DataRow this[long key] {
                        get {
                        String filter = String.Format("id = {0}", key);
                        return Table.Select(filter)[0];
                        }
                        }
                        public override DataTable Table {
                        get { return Data.Tables[TableName];}
                        }
                        The update triggers update behavior on the holder.
                        class DataSetHolder...
                        public void Update() {
                        foreach (String table in DataAdapters.Keys)
                        ((OleDbDataAdapter)DataAdapters[table]).Update(Data, table);
                        }
                        public DataTable this[String tableName] {
                        get {return Data.Tables[tableName];}
                        }</pre>
                        Insertion can be done much the same way: Get a data set, insert a new row in
                        the data table, and fill in each column. However, an update method can do the
                        insertion in one call.
                        <pre>class DataGateway...
                        public long Insert(String lastName, String firstname, int numberOfDependents) {
                        long key = new PersonGatewayDS().GetNextID();
                        DataRow newRow = Table.NewRow();
                        newRow["id"] = key;
                        newRow["lastName"] = lastName;
                        newRow["firstName"] = firstname;
                        newRow["numberOfDependents"] = numberOfDependents;
                        Table.Rows.Add(newRow);
                        return key;
                        }</pre></p>
                <h3 id="152">Row Data Gateway</h3>
                <p><img src="img/part2.6.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that acts as a Gateway (466) to a single record in a data
                        source. There is one instance per row.
                        Embedding database access code in in-memory objects can leave you with a few
                        disadvantages. For a start, if your in-memory objects have business logic of
                        their own, adding the database manipulation code increases complexity. Testing
                        is awkward too since, if your in-memory objects are tied to a database, tests are
                        slower to run because of all the database access. You may have to access multiple databases with all those annoying little variations on their SQL.
                        A Row Data Gateway gives you objects that look exactly like the record in
                        your record structure but can be accessed with the regular mechanisms of your
                        programming language. All details of data source access are hidden behind this
                        interface.</p>
                <h3 id="152(2)">How It Works</h3>
                <p>A Row Data Gateway acts as an object that exactly mimics a single record,
                        such as one database row. In it each column in the database becomes one field.
                        The Row Data Gateway will usually do any type conversion from the data
                        source types to the in-memory types, but this conversion is pretty simple. This
                        pattern holds the data about a row so that a client can then access the Row
                        Data Gateway directly. The gateway acts as a good interface for each row of
                        data. This approach works particularly well for Transaction Scripts (110).
                        With a Row Data Gateway youâ€™re faced with the questions of where to put
                        the find operations that generate this pattern. You can use static find methods,
                        but they preclude polymorphism should you want to substitute different finder
                        methods for different data sources. In this case it often makes sense to have separate finder objects so that each table in a relational database will have one
                        finder class and one gateway class for the results (Figure 10.2).
                        Itâ€™s often hard to tell the difference between a Row Data Gateway and an
                        Active Record (160). The crux of the matter is whether thereâ€™s any domain logic
                        present; if there is, you have an Active Record (160). A Row Data Gateway
                        should contain only database access logic and no domain logic.</p>
                <p>As with any other form of tabular encapsulation, you can use a Row Data
                        Gateway with a view or query as well as a table. Updates often turn out to be
                        more complicated this way, as you have to update the underlying tables. Also, if
                        you have two Row Data Gateways that operate on the same underlying tables,
                        you may find that the second Row Data Gateway you update undoes the
                        changes on the first. Thereâ€™s no general way to prevent this; developers just have
                        to be aware of how virtual Row Data Gateways are formed. After all, the same
                        thing can happen with updatable views. Of course, you can choose not to provide update operations.
                        Row Data Gateways tend to be somewhat tedious to write, but theyâ€™re a
                        very good candidate for code generation based on a Metadata Mapping (306).
                        This way all your database access code can be automatically built for you during your automated build process.</p>
                <h3 id="153">When to Use It</h3>
                <p>The choice of Row Data Gateway often takes two steps: first whether to use a
                        gateway at all and second whether to use Row Data Gateway or Table Data
                        Gateway (144).
                        I use Row Data Gateway most often when Iâ€™m using a Transaction Script
                        (110). In this case it nicely factors out the database access code and allows it to
                        be reused easily by different Transaction Scripts (110).
                        I donâ€™t use a Row Data Gateway when Iâ€™m using a Domain Model (116). If
                        the mapping is simple, Active Record (160) does the same job without an additional layer of code. If the mapping is complex, Data Mapper (165) works better, as itâ€™s better at decoupling the data structure from the domain objects
                        because the domain objects donâ€™t need to know the layout of the database. Of
                        course, you can use the Row Data Gateway to shield the domain objects from
                <p><img src="img/figure 10.2.png" alt="no img" style="margin-left: 200px;"></p>
                        the database structure. Thatâ€™s a good thing if youâ€™re changing the database
                        structure when using Row Data Gateway and you donâ€™t want to change the
                        domain logic. However, doing this on a large scale leads you to three data representations: one in the business logic, one in the Row Data Gateway, and one
                        in the databaseâ€”and thatâ€™s one too many. For that reason I usually have Row
                        Data Gateways that mirror the database structure.</p>
                <p>Interestingly, Iâ€™ve seen Row Data Gateway used very nicely with Data Mapper (165). Although this seems like extra work, it can be effective iff the Row
                        Data Gateways are automatically generated from metadata while the Data
                        Mappers (165) are done by hand.
                        If you use Transaction Script (110) with Row Data Gateway, you may notice
                        that you have business logic thatâ€™s repeated across multiple scripts; logic that
                        would make sense in the Row Data Gateway. Moving that logic will gradually
                        turn your Row Data Gateway into an Active Record (160), which is often good
                        as it reduces duplication in the business logic.</p>
                <h3 id="155">Example: A Person Record (Java)</h3>
                <p>Hereâ€™s an example for Row Data Gateway. Itâ€™s a simple person table.
                        <pre>create table people (ID int primary key, lastname varchar,
                        firstname varchar, number_of_dependents int)</pre>
                        PersonGateway is a gateway for the table. It starts with data fields and accessors.
                        <pre>class PersonGateway...
                        private String lastName;
                        private String firstName;
                        private int numberOfDependents;
                        public String getLastName() {
                        return lastName;
                        }
                        public void setLastName(String lastName) {
                        this.lastName = lastName;
                        }
                        public String getFirstName() {
                        return firstName;
                        }
                        public void setFirstName(String firstName) {
                        this.firstName = firstName;
                        }
                        public int getNumberOfDependents() {
                        return numberOfDependents;
                        }
                        public void setNumberOfDependents(int numberOfDependents) {
                        this.numberOfDependents = numberOfDependents;
                        }</pre>
                        The gateway class itself can handle updates and inserts.
                        <pre>class PersonGateway...
                        private static final String updateStatementString =
                        "UPDATE people " +
                        " set lastname = ?, firstname = ?, number_of_dependents = ? " +
                        " where id = ?";
                        public void update() {
                        PreparedStatement updateStatement = null;
                        try {
                        updateStatement = DB.prepare(updateStatementString);
                        updateStatement.setString(1, lastName);
                        updateStatement.setString(2, firstName);
                        updateStatement.setInt(3, numberOfDependents);
                        updateStatement.setInt(4, getID().intValue());
                        updateStatement.execute();
                        } catch (Exception e) {
                        throw new ApplicationException(e);
                        } finally {DB.cleanUp(updateStatement);
                        }
                        }
                        private static final String insertStatementString =
                        "INSERT INTO people VALUES (?, ?, ?, ?)";
                        public Long insert() {
                        PreparedStatement insertStatement = null;
                        try {
                        insertStatement = DB.prepare(insertStatementString);
                        setID(findNextDatabaseId());
                        insertStatement.setInt(1, getID().intValue());
                        insertStatement.setString(2, lastName);
                        insertStatement.setString(3, firstName);
                        insertStatement.setInt(4, numberOfDependents);
                        insertStatement.execute();
                        Registry.addPerson(this);
                        return getID();
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally { DB.cleanUp(insertStatement);
                        }
                        }</pre>
                        To pull people out of the database, we have a separate PersonFinder. This
                        works with the gateway to create new gateway objects.
                        <pre>class PersonFinder...
                        private final static String findStatementString =
                        "SELECT id, lastname, firstname, number_of_dependents " +
                        " from people " +
                        " WHERE id = ?";
                        ROW DATA GATEWAY 157
                        Row Data
                        Gateway
                        public PersonGateway find(Long id) {
                        PersonGateway result = (PersonGateway) Registry.getPerson(id);
                        if (result != null) return result;
                        PreparedStatement findStatement = null;
                        ResultSet rs = null;
                        try {
                        findStatement = DB.prepare(findStatementString);
                        findStatement.setLong(1, id.longValue());
                        rs = findStatement.executeQuery();
                        rs.next();
                        result = PersonGateway.load(rs);
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {DB.cleanUp(findStatement, rs);
                        }
                        }
                        public PersonGateway find(long id) {
                        return find(new Long(id));
                        }
                        class PersonGateway...
                        public static PersonGateway load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        PersonGateway result = (PersonGateway) Registry.getPerson(id);
                        if (result != null) return result;
                        String lastNameArg = rs.getString(2);
                        String firstNameArg = rs.getString(3);
                        int numDependentsArg = rs.getInt(4);
                        result = new PersonGateway(id, lastNameArg, firstNameArg, numDependentsArg);
                        Registry.addPerson(result);
                        return result;
                        }</pre>
                        To find more than one person according to some criteria we can provide a suitable finder method.
                        <pre>class PersonFinder...
                        private static final String findResponsibleStatement =
                        "SELECT id, lastname, firstname, number_of_dependents " +
                        " from people " +
                        " WHERE number_of_dependents > 0";
                        public List findResponsibles() {
                        List result = new ArrayList();
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        stmt = DB.prepare(findResponsibleStatement);
                        rs = stmt.executeQuery();
                        158 DATA SOURCE ARCHITECTURAL PATTERNS
                        Row Data
                        Gateway
                        while (rs.next()) {
                        result.add(PersonGateway.load(rs));
                        }
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {DB.cleanUp(stmt, rs);
                        }
                        }</pre>
                        The finder uses a Registry (480) to hold Identity Maps (195).
                        We can now use the gateways from a Transaction Script (110)
                        <pre>PersonFinder finder = new PersonFinder();
                        Iterator people = finder.findResponsibles().iterator();
                        StringBuffer result = new StringBuffer();
                        while (people.hasNext()) {
                        PersonGateway each = (PersonGateway) people.next();
                        result.append(each.getLastName());
                        result.append("");
                        result.append(each.getFirstName());
                        result.append("");
                        result.append(String.valueOf(each.getNumberOfDependents()));
                        result.append("\n");
                        }
                        return result.toString();</pre></p>
                <h3 id="158">Example: A Data Holder for a Domain Object (Java)</h3>
                <p>I use Row Data Gateway mostly with Transaction Script (110). If we want to
                        use the Row Data Gateway from a Domain Model (116), the domain objects
                        need to get at the data from the gateway. Instead of copying the data to the
                        domain object we can use the Row Data Gateway as a data holder for the
                        domain object.
                        <pre>class Person...
                        private PersonGateway data;
                        public Person(PersonGateway data) {
                        this.data = data;
                        }</pre>
                        Accessors on the domain logic can then delegate to the gateway for the data.
                        <pre>class Person...
                        public int getNumberOfDependents() {
                        return data.getNumberOfDependents();
                        }</pre>
                        The domain logic uses the getters to pull the data from the gateway.
                        <pre>class Person...
                        public Money getExemption() {
                        Money baseExemption = Money.dollars(1500);
                        Money dependentExemption = Money.dollars(750);
                        return baseExemption.add(dependentExemption.multiply(this.getNumberOfDependents()));
                        }</pre></p>
                <h3 id="160">Active Record</h3>
                <p><img src="img/part2.7.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that wraps a row in a database table or view, encapsulates
                        the database access, and adds domain logic on that data.
                        An object carries both data and behavior. Much of this data is persistent and
                        needs to be stored in a database. Active Record uses the most obvious
                        approach, putting data access logic in the domain object. This way all people
                        know how to read and write their data to and from the database.</p>
                <h3 id="160(2)">How It Works</h3>
                <p>The essence of an Active Record is a Domain Model (116) in which the classes
                        match very closely the record structure of an underlying database. Each Active
                        Record is responsible for saving and loading to the database and also for any
                        domain logic that acts on the data. This may be all the domain logic in the
                        application, or you may find that some domain logic is held in Transaction
                        Scripts (110) with common and data-oriented code in the Active Record.
                        The data structure of the Active Record should exactly match that of the
                        database: one field in the class for each column in the table. Type the fields the
                        way the SQL interface gives you the dataâ€”donâ€™t do any conversion at this
                        stage. You may consider Foreign Key Mapping (236), but you may also leave
                        the foreign keys as they are. You can use views or tables with Active Record,
                        although updates through views are obviously harder. Views are particularly
                        useful for reporting purposes.</p>
                <p>The Active Record class typically has methods that do the following:
                <ul>
                        <li>Construct an instance of the Active Record from a SQL result set row</li>
                        <li>Construct a new instance for later insertion into the table</li>
                        <li>Static finder methods to wrap commonly used SQL queries and return
                        <i>Active Record objects</i></li>
                        <li>Update the database and insert into it the data in the Active Record</li>
                        <li>Get and set the fields</li>
                        <li>Implement some pieces of business logic</li>
                </ul>
                </p>
                <p>The getting and setting methods can do some other intelligent things, such as
                        convert from SQL-oriented types to better in-memory types. Also, if you ask for
                        a related table, the getting method can return the appropriate Active Record,
                        even if you arenâ€™t using Identity Field (216) on the data structure (by doing a
                        lookup).
                        In this pattern the classes are convenient, but they donâ€™t hide the fact that a
                        relational database is present. As a result you usually see fewer of the other
                        object-relational mapping patterns present when youâ€™re using Active Record.
                        Active Record is very similar to Row Data Gateway (152). The principal difference is that a Row Data Gateway (152) contains only database access while
                        an Active Record contains both data source and domain logic. Like most boundaries in software, the line between the two isnâ€™t terribly sharp, but itâ€™s useful.
                        Because of the close coupling between the Active Record and the database, I
                        more often see static find methods in this pattern. However, thereâ€™s no reason
                        that you canâ€™t separate out the find methods into a separate class, as I discussed
                        with Row Data Gateway (152), and that is better for testing.
                        As with the other tabular patterns, you can use Active Record with a view or
                        query as well as a table.</p>
                <h3 id="161">When to Use It</h3>
                <p>Active Record is a good choice for domain logic that isnâ€™t too complex, such as
                        creates, reads, updates, and deletes. Derivations and validations based on a single record work well in this structure.
                        In an initial design for a Domain Model (116) the main choice is between
                        Active Record and Data Mapper (165). Active Record has the primary advantage of simplicity. Itâ€™s easy to build Active Records, and they are easy to understand. Their primary problem is that they work well only if the Active Record
                        objects correspond directly to the database tables: an isomorphic schema. If
                        your business logic is complex, youâ€™ll soon want to use your objectâ€™s direct relationships, collections, inheritance, and so forth. These donâ€™t map easily onto
                        Active Record, and adding them piecemeal gets very messy. Thatâ€™s what will
                        lead you to use Data Mapper (165) instead.
                        Another argument against Active Record is the fact that it couples the object
                        design to the database design. This makes it more difficult to refactor either
                        design as a project goes forward.
                        Active Record is a good pattern to consider if youâ€™re using Transaction Script
                        (110) and are beginning to feel the pain of code duplication and the difficulty in
                        updating scripts and tables that Transaction Script (110) often brings. In this
                        case you can gradually start creating Active Records and then slowly refactor
                        behavior into them. It often helps to wrap the tables as a Gateway (466) first,
                        and then start moving behavior so that the tables evolve to a Active Record.</p>
                <h3 id="162">Example: A Simple Person (Java)</h3>
                <p>This is a simple, even simplistic, example to show how the bones of Active
                        Record work. We begin with a basic Person class.
                        <pre>class Person...
                        private String lastName;
                        private String firstName;
                        private int numberOfDependents;</pre>
                        Thereâ€™s also an ID field in the superclass.
                        The database is set up with the same structure.
                        <pre>create table people (ID int primary key, lastname varchar,
                        firstname varchar, number_of_dependents int)</pre>
                        To load an object, the person class acts as the finder and also performs the
                        load. It uses static methods on the person class.
                        <pre>class Person...
                        private final static String findStatementString =
                        "SELECT id, lastname, firstname, number_of_dependents" +
                        " FROM people" +
                        " WHERE id = ?";
                        public static Person find(Long id) {
                        Person result = (Person) Registry.getPerson(id);
                        if (result != null) return result;
                        PreparedStatement findStatement = null;
                        ResultSet rs = null;
                        ACTIVE RECORD 163
                        Active
                        Record
                        try {
                        findStatement = DB.prepare(findStatementString);
                        findStatement.setLong(1, id.longValue());
                        rs = findStatement.executeQuery();
                        rs.next();
                        result = load(rs);
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(findStatement, rs);
                        }
                        }
                        public static Person find(long id) {
                        return find(new Long(id));
                        }
                        public static Person load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        Person result = (Person) Registry.getPerson(id);
                        if (result != null) return result;
                        String lastNameArg = rs.getString(2);
                        String firstNameArg = rs.getString(3);
                        int numDependentsArg = rs.getInt(4);
                        result = new Person(id, lastNameArg, firstNameArg, numDependentsArg);
                        Registry.addPerson(result);
                        return result;
                        }</pre>
                        Updating an object takes a simple instance method.
                        <pre>class Person...
                        private final static String updateStatementString =
                        "UPDATE people" +
                        " set lastname = ?, firstname = ?, number_of_dependents = ?" +
                        " where id = ?";
                        public void update() {
                        PreparedStatement updateStatement = null;
                        try {
                        updateStatement = DB.prepare(updateStatementString);
                        updateStatement.setString(1, lastName);
                        updateStatement.setString(2, firstName);
                        updateStatement.setInt(3, numberOfDependents);
                        updateStatement.setInt(4, getID().intValue());
                        updateStatement.execute();
                        } catch (Exception e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(updateStatement);
                        }
                        }
                        164 DATA SOURCE ARCHITECTURAL PATTERNS
                        Active
                        Record</pre>
                        Insertions are also mostly pretty simple.
                        <pre>class Person...
                        private final static String insertStatementString =
                        "INSERT INTO people VALUES (?, ?, ?, ?)";
                        public Long insert() {
                        PreparedStatement insertStatement = null;
                        try {
                        insertStatement = DB.prepare(insertStatementString);
                        setID(findNextDatabaseId());
                        insertStatement.setInt(1, getID().intValue());
                        insertStatement.setString(2, lastName);
                        insertStatement.setString(3, firstName);
                        insertStatement.setInt(4, numberOfDependents);
                        insertStatement.execute();
                        Registry.addPerson(this);
                        return getID();
                        } catch (Exception e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(insertStatement);
                        }
                        }
                        Any business logic, such as calculating the exemption, sits directly in the Person class.
                        class Person...
                        public Money getExemption() {
                        Money baseExemption = Money.dollars(1500);
                        Money dependentExemption = Money.dollars(750);
                        return baseExemption.add(dependentExemption.multiply(this.getNumberOfDependents()));
                        }</pre></p>
                <h3 id="165">Data Mapper</h3>
                <p><img src="img/part2.8.png" alt="no img" style="margin-left: 200px;"></p>
                <p>A layer of Mappers (473) that moves data between objects
                        and a database while keeping them independent of
                        each other and the mapper itself.
                        Objects and relational databases have different mechanisms for structuring
                        data. Many parts of an object, such as collections and inheritance, arenâ€™t
                        present in relational databases. When you build an object model with a lot of
                        business logic itâ€™s valuable to use these mechanisms to better organize the data
                        and the behavior that goes with it. Doing so leads to variant schemas; that is,
                        the object schema and the relational schema donâ€™t match up.
                        You still need to transfer data between the two schemas, and this data transfer becomes a complexity in its own right. If the in-memory objects know
                        about the relational database structure, changes in one tend to ripple to the
                        other.</p>
                <p>The Data Mapper is a layer of software that separates the in-memory objects
                        from the database. Its responsibility is to transfer data between the two and
                        also to isolate them from each other. With Data Mapper the in-memory objects
                        neednâ€™t know even that thereâ€™s a database present; they need no SQL interface
                        code, and certainly no knowledge of the database schema. (The database
                        schema is always ignorant of the objects that use it.) Since itâ€™s a form of Mapper
                        (473), Data Mapper itself is even unknown to the domain layer.</p>
                <h3 id="165(2)">How It Works</h3>
                <p>The separation between domain and data source is the main function of a Data
                        Mapper, but there are plenty of details that have to be addressed to make this
                        happen. Thereâ€™s also a lot of variety in how mapping layers are built. Many of
                        the comments here are pretty broad, because I try to give a general overview of
                        what you need to separate the cat from its skin.
                        Weâ€™ll start with a very basic Data Mapper example. This is the simplest style of
                        this layer that you can have and might not seem worth doing. With simple database mapping examples other patterns usually are simpler and thus better. If you
                        are going to use Data Mapper at all you usually need more complicated cases.
                        However, itâ€™s easier to explain the ideas if we start simple at a very basic level.
                        A simple case would have a Person and Person Mapper class. To load a person
                        from the database, a client would call a find method on the mapper (Figure 10.3).
                        The mapper uses an Identity Map (195) to see if the person is already loaded; if
                        not, it loads it.
                        Updates are shown in Figure 10.4. A client asks the mapper to save a domain
                        object. The mapper pulls the data out of the domain object and shuttles it to the
                        database.</p>
                <p>The whole layer of Data Mapper can be substituted, either for testing purposes or to allow a single domain layer to work with different databases.
                        A simple Data Mapper would just map a database table to an equivalent inmemory class on a field-to-field basis. Of course, things arenâ€™t usually simple.
                        Mappers need a variety of strategies to handle classes that turn into multiple
                        fields, classes that have multiple tables, classes with inheritance, and the joys of
                        connecting together objects once theyâ€™ve been sorted out. The various objectrelational mapping patterns in this book are all about that. Itâ€™s usually easier to
                        deploy these patterns with a Data Mapper than it is with the other organizing
                        alternatives.
                        When it comes to inserts and updates, the database mapping layer needs to
                        understand what objects have changed, which new ones have been created, and
                        which ones have been destroyed. It also has to fit the whole workload into a
                        transactional framework. The Unit of Work (184) pattern is a good way to
                        organize this.</p>
                <p>Figure 10.3 suggests that a single request to a find method results in a single
                        SQL query. This isnâ€™t always true. Loading a typical order with multiple order
                        lines may involve loading the order lines as well. The request from the client will
                        usually lead to a graph of objects being loaded, with the mapper designer deciding exactly how much to pull back in one go. The point of this is to minimize
                        database queries, so the finders typically need to know a fair bit about how clients use the objects in order to make the best choices for pulling data back.
                        This example leads to cases where you load multiple classes of domain objects
                        from a single query. If you want to load orders and order lines, it will usually be
                        faster to do a single query that joins the orders and order line tables. You then use
                        the result set to load both the order and the order line instances (page 243).
                <p><img src="img/figure 10.3.png" alt="no img" style="margin-left: 200px;"></p>
                <p><img src="img/figure 10.4.png" alt="no img" style="margin-left: 200px;"></p>
                        Since objects are very interconnected, you usually have to stop pulling the
                        data back at some point. Otherwise, youâ€™re likely to pull back the entire database with a request. Again, mapping layers have techniques to deal with this
                        while minimizing the impact on the in-memory objects, using Lazy Load (200).
                        Hence, the in-memory objects canâ€™t be entirely ignorant of the mapping layer.
                        They may need to know about the finders and a few other mechanisms.</p>
                <p>An application can have one Data Mapper or several. If youâ€™re hardcoding
                        your mappers, itâ€™s best to use one for each domain class or root of a domain
                        hierarchy. If youâ€™re using Metadata Mapping (306), you can get away with a
                        single mapper class. In the latter case the limiting problem is your find methods.
                        With a large application it can be too much to have a single mapper with lots of
                        find methods, so it makes sense to split these methods up by each domain class
                        or head of the domain hierarchy. You get a lot of small finder classes, but itâ€™s
                        easy for a developer to locate the finder she needs.</p>
                <p>As with any database find behavior, the finders need to use an Identity Map
                        (195) in order to maintain the identity of the objects read from the database.
                        Either you can have a Registry (480) of Identity Maps (195), or you can have
                        each finder hold an Identity Map (195) (providing there is only one finder per
                        class per session).</p>
                <p><b>Handling Finders</b> In order to work with an object, you have to load it from the
                        database. Usually the presentation layer will initiate things by loading some initial objects. Then control moves into the domain layer, at which point the code
                        will mainly move from object to object using associations between them. This
                        will work effectively providing that the domain layer has all the objects it needs
                        loaded into memory or that you use Lazy Load (200) to load in additional
                        objects when needed.
                        On occasion you may need the domain objects to invoke find methods on the
                        Data Mapper. However, Iâ€™ve found that with a good Lazy Load (200) you can
                        completely avoid this. For simpler applications, though, may not be worth trying
                        to manage everything with associations and Lazy Load (200). Still, you donâ€™t
                        want to add a dependency from your domain objects to your Data Mapper.
                        You can solve this dilemma by using Separated Interface (476). Put any find
                        methods needed by the domain code into an interface class that you can place
                        in the domain package.</p>
                <p><b>Mapping Data to Domain Fields</b> Mappers need access to the fields in the
                        domain objects. Often this can be a problem because you need public methods
                        to support the mappers you donâ€™t want for domain logic. (Iâ€™m assuming that
                        you wonâ€™t commit the cardinal sin of making fields public.) Thereâ€™s no easy to
                        answer to this. You could use a lower level of visibility by packaging the mappers closer to the domain objects, such as in the same package in Java, but this
                        confuses the bigger dependency picture because you donâ€™t want other parts of
                        the system that know the domain objects to know about the mappers. You can
                        use reflection, which can often bypass the visibility rules of the language. Itâ€™s
                        slower, but the slower speed may end up as just a rounding error compared to
                        the time taken by the SQL call. Or you can use public methods, but guard them
                        with a status field so that they throw an exception if theyâ€™re used outside the
                        context of a database load. If so, name them in such a way that theyâ€™re not mistaken for regular getters and setters.
                        Tied to this is the issue of when you create the object. In essence you have
                        two options. One is to create the object with a rich constructor so that itâ€™s at
                        least created with all its mandatory data. The other is to create an empty object
                        and then populate it with the mandatory data. I usually prefer the former since
                        itâ€™s nice to have a well-formed object from the start. This also means that, if you
                        have an immutable field, you can enforce it by not providing any method to
                        change its value.</p>
                <p>The problem with a rich constructor is that you have to be aware of cyclic
                        references. If you have two objects that reference each other, each time you try
                        to load one it will try to load the other, which will in turn try to load the first
                        one, and so on, until you run out of stack space. Avoiding this requires special
                        case code, often using Lazy Load (200). Writing this special case code is messy,
                        so itâ€™s worth trying to do without it. You can do this by creating an empty
                        object. Use a no-arg constructor to create a blank object and insert that empty
                        object immediately into the Identity Map (195). That way, if you have a cycle,
                        the Identity Map (195) will return an object to stop the recursive loading.
                        Using an empty object like this means you may need some setters for values
                        that are truly immutable when the object is loaded. A combination of a naming
                        convention and perhaps some status-checking guards can fix this. You can also
                        use reflection for data loading.</p>
                <p><b>Metadata-Based Mappings</b> One of the decisions you need to make concerns
                        storing the information about how fields in domain objects are mapped to columns in the database. The simplest, and often best, way to do this is with
                        explicit code, which requires a mapper class for each domain object. The mapper does the mapping through assignments and has fields (usually constant
                        strings) to store the SQL for database access. An alternative is to use Metadata
                        Mapping (306), which stores the metadata as data, either in a class or in a separate file. The great advantage of metadata is that all the variation in the mappers can be handled through data without the need for more source code, either
                        by use of code generation or reflective programming.</p>
                <h3 id="170">When to Use It</h3>
                <p>The primary occasion for using Data Mapper is when you want the database
                        schema and the object model to evolve independently. The most common case
                        for this is with a Domain Model (116). Data Mapperâ€™s primary benefit is that
                        when working on the domain model you can ignore the database, both in
                        design and in the build and testing process. The domain objects have no idea
                        what the database structure is, because all the correspondence is done by the
                        mappers.
                        This helps you in the code because you can understand and work with the
                        domain objects without having to understand how theyâ€™re stored in the database. You can modify the Domain Model (116) or the database without having
                        to alter either. With complicated mappings, particularly those involving existing
                        databases, this is very valuable.</p>
                <p>The price, of course, is the extra layer that you donâ€™t get with Active Record
                        (160), so the test for using these patterns is the complexity of the business logic.
                        If you have fairly simple business logic, you probably wonâ€™t need a Domain
                        Model (116) or a Data Mapper. More complicated logic leads you to Domain
                        Model (116) and therefore to Data Mapper.
                        I wouldnâ€™t choose Data Mapper without Domain Model (116), but can I use
                        Domain Model (116) without Data Mapper? If the domain model is pretty sim-
                        ple, and the database is under the domain model developersâ€™ control, then itâ€™s
                        reasonable for the domain objects to access the database directly with Active
                        Record (160). Effectively this puts the mapper behavior discussed here into the
                        domain objects themselves. As things become more complicated, itâ€™s better to
                        refactor the database behavior out into a separate layer.
                        Remember that you donâ€™t have to build a full-featured database-mapping
                        layer. Itâ€™s a complicated beast to build, and there are products available that do
                        this for you. For most cases I recommend buying a database-mapping layer
                        rather than building one yourself.</p>
                <h3 id="171">Example: A Simple Database Mapper (Java)</h3>
                <p>Hereâ€™s an absurdly simple use of Data Mapper to give you a feel for the basic
                        structure. Our example is a person with an isomorphic people table.
                        <pre>class Person...
                        private String lastName;
                        private String firstName;
                        private int numberOfDependents;</pre>
                        The database schema looks like this:
                        <pre>create table people (ID int primary key, lastname varchar,
                        firstname varchar, number_of_dependents int)</pre>
                        Weâ€™ll use the simple case here, where the Person Mapper class also implements the finder and Identity Map (195). However, Iâ€™ve added an abstract mapper Layer Supertype (475) to indicate where I can pull out some common
                        behavior. Loading involves checking that the object isnâ€™t already in the Identity
                        Map (195) and then pulling the data from the database.
                        The find behavior starts in the Person Mapper, which wraps calls to an
                        abstract find method to find by ID.
                        <pre>class PersonMapper...
                        protected String findStatement() {
                        return "SELECT " + COLUMNS +
                        " FROM people" +
                        " WHERE id = ?";
                        }
                        public static final String COLUMNS = " id, lastname, firstname, number_of_dependents ";
                        public Person find(Long id) {
                        return (Person) abstractFind(id);
                        }
                        public Person find(long id) {
                        return find(new Long(id));
                        }
                        172 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        class AbstractMapper...
                        protected Map loadedMap = new HashMap();
                        abstract protected String findStatement();
                        protected DomainObject abstractFind(Long id) {
                        DomainObject result = (DomainObject) loadedMap.get(id);
                        if (result != null) return result;
                        PreparedStatement findStatement = null;
                        try {
                        findStatement = DB.prepare(findStatement());
                        findStatement.setLong(1, id.longValue());
                        ResultSet rs = findStatement.executeQuery();
                        rs.next();
                        result = load(rs);
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(findStatement);
                        }
                        }</pre>
                        The find method calls the load method, which is split between the abstract
                        and person mappers. The abstract mapper checks the ID, pulling it from the
                        data and registering the new object in the Identity Map (195).
                        <pre>class AbstractMapper...
                        protected DomainObject load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id);
                        DomainObject result = doLoad(id, rs);
                        loadedMap.put(id, result);
                        return result;
                        }
                        abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                        class PersonMapper...
                        protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                        String lastNameArg = rs.getString(2);
                        String firstNameArg = rs.getString(3);
                        int numDependentsArg = rs.getInt(4);
                        return new Person(id, lastNameArg, firstNameArg, numDependentsArg);
                        }</pre>
                        Notice that the Identity Map (195) is checked twice, once by abstractFind and
                        once by load. Thereâ€™s a reason for this madness.
                        I need to check the map in the finder because, if the object is already there, I
                        can save myself a trip to the databaseâ€”I always want to save myself that long
                        hike if I can. But I also need to check in the load because I may have queries
                        DATA MAPPER 173
                        Data Mapper
                        that I canâ€™t be sure of resolving in the Identity Map (195). Say I want to find
                        everyone whose last name matches some search pattern. I canâ€™t be sure that I
                        have all such people already loaded, so I have to go to the database and run a
                        query.
                        <pre>class PersonMapper...
                        private static String findLastNameStatement =
                        "SELECT " + COLUMNS +
                        " FROM people " +
                        " WHERE UPPER(lastname) like UPPER(?)" +
                        " ORDER BY lastname";
                        public List findByLastName(String name) {
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        stmt = DB.prepare(findLastNameStatement);
                        stmt.setString(1, name);
                        rs = stmt.executeQuery();
                        return loadAll(rs);
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(stmt, rs);
                        }
                        }
                        class AbstractMapper...
                        protected List loadAll(ResultSet rs) throws SQLException {
                        List result = new ArrayList();
                        while (rs.next())
                        result.add(load(rs));
                        return result;
                        }</pre>
                        When I do this I may pull back some rows in the result set that correspond to
                        people Iâ€™ve already loaded. I have to ensure that I donâ€™t make a duplicate, so I
                        have to check the Identity Map (195) again.
                        Writing a find method this way in each subclass that needs it involves some
                        basic, but repetitive, coding, which I can eliminate by providing a general
                        method.
                        <pre>class AbstractMapper...
                        public List findMany(StatementSource source) {
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        174 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        stmt = DB.prepare(source.sql());
                        for (int i = 0; i &lt; source.parameters().length; i++)
                        stmt.setObject(i+1, source.parameters()[i]);
                        rs = stmt.executeQuery();
                        return loadAll(rs);
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(stmt, rs);
                        }
                        }</pre>
                        For this to work I need an interface that wraps both the SQL string and the
                        loading of parameters into the prepared statement.
                        <pre>interface StatementSource...
                        String sql();
                        Object[] parameters();</pre>
                        I can then use this facility by providing a suitable implementation as an inner
                        class.
                        <pre>class PersonMapper...
                        public List findByLastName2(String pattern) {
                        return findMany(new FindByLastName(pattern));
                        }
                        static class FindByLastName implements StatementSource {
                        private String lastName;
                        public FindByLastName(String lastName) {
                        this.lastName = lastName;
                        }
                        public String sql() {
                        return
                        "SELECT " + COLUMNS +
                        " FROM people " +
                        " WHERE UPPER(lastname) like UPPER(?)" +
                        " ORDER BY lastname";
                        }
                        public Object[] parameters() {
                        Object[] result = {lastName};
                        return result;
                        }
                        }</pre>
                        This kind of work can be done in other places where thereâ€™s repetitive statement invocation code. On the whole Iâ€™ve made the examples here more straight
                        to make them easier to follow. If you find yourself writing a lot of repetitive
                        straight-ahead code you should consider doing something similar.
                        DATA MAPPER 175
                        Data Mapper
                        With the update the JDBC code is specific to the subtype.
                        <pre>class PersonMapper...
                        private static final String updateStatementString =
                        "UPDATE people " +
                        " SET lastname = ?, firstname = ?, number_of_dependents = ? " +
                        " WHERE id = ?";
                        public void update(Person subject) {
                        PreparedStatement updateStatement = null;
                        try {
                        updateStatement = DB.prepare(updateStatementString);
                        updateStatement.setString(1, subject.getLastName());
                        updateStatement.setString(2, subject.getFirstName());
                        updateStatement.setInt(3, subject.getNumberOfDependents());
                        updateStatement.setInt(4, subject.getID().intValue());
                        updateStatement.execute();
                        } catch (Exception e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(updateStatement);
                        }
                        }</pre>
                        For the insert some code can be factored into the Layer Supertype (475)
                        <pre>class AbstractMapper...
                        public Long insert(DomainObject subject) {
                        PreparedStatement insertStatement = null;
                        try {
                        insertStatement = DB.prepare(insertStatement());
                        subject.setID(findNextDatabaseId());
                        insertStatement.setInt(1, subject.getID().intValue());
                        doInsert(subject, insertStatement);
                        insertStatement.execute();
                        loadedMap.put(subject.getID(), subject);
                        return subject.getID();
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(insertStatement);
                        }
                        }
                        abstract protected String insertStatement();
                        abstract protected void doInsert(DomainObject subject, PreparedStatement insertStatement)
                        throws SQLException;
                        class PersonMapper...
                        protected String insertStatement() {
                        return "INSERT INTO people VALUES (?, ?, ?, ?)";
                        176 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        }
                        protected void doInsert(
                        DomainObject abstractSubject,
                        PreparedStatement stmt)
                        throws SQLException
                        {
                        Person subject = (Person) abstractSubject;
                        stmt.setString(2, subject.getLastName());
                        stmt.setString(3, subject.getFirstName());
                        stmt.setInt(4, subject.getNumberOfDependents());
                        }</pre></p>
                <h3 id="176">Example: Separating the Finders (Java)</h3>
                <p>To allow domain objects to invoke finder behavior I can use Separated Interface
                        (476) to separate the finder interfaces from the mappers (Figure 10.5). I can put
                        these finder interfaces in a separate package thatâ€™s visible to the domain layer,
                        or, as in this case, I can put them in the domain layer itself.
                        One of the most common finds is one that finds an object according to a particular surrogate ID. Much of this processing is quite generic, so it can be handled by a suitable Layer Supertype (475). All it needs is a Layer Supertype (475)
                        for domain objects that know about IDs.
                        The interface for finding lies in the finder interface. Itâ€™s usually best not made
                        generic because you need to know what the return type is.
                        <pre>interface ArtistFinder...
                        Artist find(Long id);
                        Artist find(long id);</pre>
                        The finder interface is best declared in the domain package with the finders
                        held in a Registry (480). In this case Iâ€™ve made the mapper class implement the
                        finder interface.
                        <pre>class ArtistMapper implements ArtistFinder...
                        public Artist find(Long id) {
                        return (Artist) abstractFind(id);
                        }
                        public Artist find(long id) {
                        return find(new Long(id));
                        }</pre>
                        The bulk of the find method is done by the mapperâ€™s Layer Supertype (475),
                        which checks the Identity Map (195) to see if the object is already in memory. If
                <p><img src="img/figure 10.5.png" alt="no img" style="margin-left: 200px;"></p>
                        not, it completes a prepared statement thatâ€™s loaded in by the artist mapper and
                        executes it.
                        <pre>class AbstractMapper...
                        abstract protected String findStatement();
                        protected Map loadedMap = new HashMap();
                        protected DomainObject abstractFind(Long id) {
                        DomainObject result = (DomainObject) loadedMap.get(id);
                        if (result != null) return result;
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        stmt = DB.prepare(findStatement());
                        stmt.setLong(1, id.longValue());
                        Figure 10.5 Defining a finder interface in the domain package.
                        domain
                        find (id)
                        Â«interfaceÂ»
                        Artist Finder
                        find (id)
                        # doLoad
                        Artist Mapper
                        + insert
                        + update
                        # abstractFind
                        # load
                        # doLoad
                        Abstract Mapper
                        Album
                        mapper
                        id: Long
                        Domain Object
                        Artist
                        178 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        rs = stmt.executeQuery();
                        rs.next();
                        result = load(rs);
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {cleanUp(stmt, rs);
                        }
                        }
                        class ArtistMapper...
                        protected String findStatement() {
                        return "select " + COLUMN_LIST + " from artists art where ID = ?";
                        }
                        public static String COLUMN_LIST = "art.ID, art.name";</pre>
                        The find part of the behavior is about getting either the existing object or a new
                        one. The load part is about putting the data from the database into a new object.
                        <pre>class AbstractMapper...
                        protected DomainObject load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong("id"));
                        if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id);
                        DomainObject result = doLoad(id, rs);
                        loadedMap.put(id, result);
                        return result;
                        }
                        abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                        class ArtistMapper...
                        protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                        String name = rs.getString("name");
                        Artist result = new Artist(id, name);
                        return result;
                        }</pre>
                        Notice that the load method also checks the Identity Map (195). Although
                        redundant in this case, the load can be called by other finders that havenâ€™t
                        already done this check. In this scheme all a subclass has to do is develop a
                        doLoad method to load the actual data needed, and return a suitable prepared
                        statement from the findStatement method.
                        You can also do a find based on a query. Say we have a database of tracks
                        and albums and we want a finder that will find all the tracks on a specified
                        album. Again the interface declares the finders.
                        <pre>interface TrackFinder...
                        Track find(Long id);
                        Track find(long id);
                        List findForAlbum(Long albumID);</pre>
                        Since this is a specific find method for this class, itâ€™s implemented in a specific
                        class, such as the track mapper class, rather than in a Layer Supertype (475). As
                        with any finder, there are two methods to the implementation. One sets up the
                        prepared statement; the other wraps the call to the prepared statement and
                        interprets the results.
                        <pre>class TrackMapper...
                        public static final String findForAlbumStatement =
                        "SELECT ID, seq, albumID, title " +
                        "FROM tracks " +
                        "WHERE albumID = ? ORDER BY seq";
                        public List findForAlbum(Long albumID) {
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        stmt = DB.prepare(findForAlbumStatement);
                        stmt.setLong(1, albumID.longValue());
                        rs = stmt.executeQuery();
                        List result = new ArrayList();
                        while (rs.next())
                        result.add(load(rs));
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {cleanUp(stmt, rs);
                        }
                        }</pre>
                        The finder calls a load method for each row in the result set. This method
                        has the responsibility of creating the in-memory object and loading it with the
                        data. As in the previous example, some of this can be handled in a Layer Supertype (475), including checking the Identity Map (195) to see if something is
                        already loaded.</p>
                <h3 id="179">Example: Creating an Empty Object (Java)</h3>
                <p>There are two basic approaches for loading an object. One is to create a fully
                        valid object with a constructor, which is what Iâ€™ve done in the examples above.
                        This results in the following loading code:
                        <pre>class AbstractMapper...
                        protected DomainObject load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id);
                        DomainObject result = doLoad(id, rs);
                        loadedMap.put(id, result);
                        return result;
                        180 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        }
                        abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                        class PersonMapper...
                        protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                        String lastNameArg = rs.getString(2);
                        String firstNameArg = rs.getString(3);
                        int numDependentsArg = rs.getInt(4);
                        return new Person(id, lastNameArg, firstNameArg, numDependentsArg);
                        }</pre>
                        The alternative is to create an empty object and load it with the setters later.
                        <pre>class AbstractMapper...
                        protected DomainObjectEL load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        if (loadedMap.containsKey(id)) return (DomainObjectEL) loadedMap.get(id);
                        DomainObjectEL result = createDomainObject();
                        result.setID(id);
                        loadedMap.put(id, result);
                        doLoad (result, rs);
                        return result;
                        }
                        abstract protected DomainObjectEL createDomainObject();
                        abstract protected void doLoad(DomainObjectEL obj, ResultSet rs) throws SQLException;
                        class PersonMapper...
                        protected DomainObjectEL createDomainObject() {
                        return new Person();
                        }
                        protected void doLoad(DomainObjectEL obj, ResultSet rs) throws SQLException {
                        Person person = (Person) obj;
                        person.dbLoadLastName(rs.getString(2));
                        person.setFirstName(rs.getString(3));
                        person.setNumberOfDependents(rs.getInt(4));
                        }</pre>
                        Notice that Iâ€™m using a different kind of domain object Layer Supertype
                        (475) here, because I want to control the use of the setters. Letâ€™s say that I want
                        the last name of a person to be an immutable field. In this case I donâ€™t want to
                        change the value of the field once itâ€™s loaded, so I add a status field to the
                        domain object.
                        <pre>class DomainObjectEL...
                        private int state = LOADING;
                        private static final int LOADING = 0;
                        private static final int ACTIVE = 1;
                        public void beActive() {
                        state = ACTIVE;
                        }</pre>
                        I can then check the value of this during a load.
                        <pre>class Person...
                        public void dbLoadLastName(String lastName) {
                        assertStateIsLoading();
                        this.lastName = lastName;
                        }
                        class DomainObjectEL...
                        void assertStateIsLoading() {
                        Assert.isTrue(state == LOADING);
                        }</pre>
                        What I donâ€™t like about this is that we now have a method in the interface
                        that most clients of the Person class canâ€™t use. This is an argument for the mapper using reflection to set the field, which will completely bypass Javaâ€™s protection mechanisms.
                        Is the status-based guard worth the trouble? Iâ€™m not entirely sure. On the
                        one hand it will catch bugs caused by people calling update methods at the
                        wrong time. On the other hand is the seriousness of the bugs worth the cost of
                        the mechanism? At the moment I donâ€™t have a strong opinion either way.
                        <i>This page intentionally left blank</i></p>
                <h3 id="183">Chapter 11</h3>
                <h2>Object-Relational Behavioral Patterns</h2>
                <h3 id="184">Unit of Work</h3>
                <p><img src="img/part2.9.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Maintains a list of objects affected by a business transaction
                                and coordinates the writing out of changes and the
                                resolution of concurrency problems.
                                When youâ€™re pulling data in and out of a database, itâ€™s important to keep track
                                of what youâ€™ve changed; otherwise, that data wonâ€™t be written back into the
                                database. Similarly you have to insert new objects you create and remove any
                                objects you delete.
                                You can change the database with each change to your object model, but this
                                can lead to lots of very small database calls, which ends up being very slow.
                                Furthermore it requires you to have a transaction open for the whole interaction, which is impractical if you have a business transaction that spans multiple
                                requests. The situation is even worse if you need to keep track of the objects
                                youâ€™ve read so you can avoid inconsistent reads.
                                A Unit of Work keeps track of everything you do during a business transaction that can affect the database. When youâ€™re done, it figures out everything
                                that needs to be done to alter the database as a result of your work.</p>
                <h3 id="184(2)">How It Works</h3>
                <p>The obvious things that cause you to deal with the database are changes: new
                                object created and existing ones updated or deleted. Unit of Work is an object
                                that keeps track of these things. As soon as you start doing something that may
                                affect a database, you create a Unit of Work to keep track of the changes. Every
                                time you create, change, or delete an object you tell the Unit of Work. You can
                                also let it know about objects youâ€™ve read so that it can check for inconsistent
                                reads by verifying that none of the objects changed on the database during the
                                business transaction.
                                The key thing about Unit of Work is that, when it comes time to commit, the
                                Unit of Work decides what to do. It opens a transaction, does any concurrency
                                checking (using Pessimistic Offline Lock (426) or Optimistic Offline Lock
                                (416)), and writes changes out to the database. Application programmers never
                                explicitly call methods for database updates. This way they donâ€™t have to keep
                                track of whatâ€™s changed or worry about how referential integrity affects the
                                order in which they need to do things.</p>
                <p>Of course for this to work the Unit of Work needs to know what objects it
                                should keep track of. You can do this either by the caller doing it or by getting
                                the object to tell the Unit of Work.
                                With caller registration (Figure 11.1), the user of an object has to remember
                                to register the object with the Unit of Work for changes. Any objects that arenâ€™t
                                registered wonâ€™t be written out on commit. Although this allows forgetfulness
                <p><img src="img/figure 11.1.png" alt="no img" style="margin-left: 200px;"></p>
                                to cause trouble, it does give flexibility in allowing people to make in-memory
                                changes that they donâ€™t want written out. Still, I would argue that itâ€™s going to
                                cause far more confusion than would be worthwhile. Itâ€™s better to make an
                                explicit copy for that purpose.
                                With object registration (Figure 11.2), the onus is removed from the caller.
                                The usual trick here is to place registration methods in object methods. Loading
                                an object from the database registers the object as clean; the setting methods
                                register the object as dirty. For this scheme to work the Unit of Work needs
                                either to be passed to the object or to be in a well-known place. Passing the
                <p><img src="img/figure 11.2.png" alt="no img" style="margin-left: 200px;"></p>
                                Unit of Work around is tedious but usually no problem to have it present in
                                some kind of session object.</p>
                <p>Even object registration leaves something to remember; that is, the developer
                                of the object has to remember to add a registration call in the right places. The
                                consistency becomes habitual, but is still an awkward bug when missed.
                                This is a natural place for code generation to generate appropriate calls, but
                                that only works when you can clearly separate generated and nongenerated
                                code. This problem turns out to be particularly suited to aspect-oriented programming. Iâ€™ve also come across post-processing of the object files to pull this
                                off. In this example a post-processor examined all the Java .class files, looked
                                for the appropriate methods and inserted registration calls into the byte code.
                                Such finicking around feels dirty, but it separates the database code from the
                                regular code. Aspect-oriented programming will do this more cleanly with
                                source code, and as its tools become more commonplace I expect to see this
                                strategy being used.</p>
                <p>Another technique Iâ€™ve seen is unit of work controller (Figure 11.3), which
                                the TOPLink product uses. Here the Unit of Work handles all reads from the
                                database and registers clean objects whenever theyâ€™re read. Rather than marking objects as dirty the Unit of Work takes a copy at read time and then compares the object at commit time. Although this adds overhead to the commit
                                process, it allows a selective update of only those fields that were actually
                                changed; it also avoids registration calls in the domain objects. A hybrid
                                approach is to take copies only of changed objects. This requires registration,
                                but it supports selective update and greatly reduces the overhead of the copy if
                                there are many more reads than updates.
                                Object creation is often a special time to consider caller registration. Itâ€™s not
                                uncommon for people to create objects that are only supposed to be transient.
                                A good example of this is in testing domain objects, where the tests run much
                                faster without database writes. Caller registration can make this apparent.
                                However, there are other solutions, such as providing a transient constructor
                                that doesnâ€™t register with the Unit of Work or, better still, providing a Special
                                Case (496)Unit of Work that does nothing with a commit.</p>
                <p>Another area where a Unit of Work can be helpful is in update order when a
                                database uses referential integrity. Most of the time you can avoid this issue by
                                ensuring that the database only checks referential integrity when the transaction commits rather than with each SQL call. Most databases allow this, and if
                                available thereâ€™s no good reason not to do it. If not, the Unit of Work is the natural place to sort out the update order. In smaller systems this can be done with
                                explicit code that contains details about which tables to write first based on the
                                foreign key dependencies. In a larger application itâ€™s better to use metadata to
                <p><img src="img/figure 11.3.png" alt="no img" style="margin-left: 200px;"></p>
                                figure out which order to write to the database. How you do that is beyond the
                                scope of this book, and itâ€™s a common reason to use a commercial tool. If you
                                have to do it yourself, Iâ€™m told the key to the puzzle is a topological sort.
                                You can use a similar technique to minimize deadlocks. If every transaction
                                uses the same sequence of tables to edit, you greatly reduce the risk of deadlocks. The Unit of Work is an ideal place to hold a fixed sequence of table
                                writes so that you always touch the tables in the same order.
                                Objects need to be able to find their current Unit of Work. A good way to do
                                this is with a thread-scoped Registry (480). Another way is to pass the Unit of
                                Work to objects that need it, either in method calls or when you create an
                                object. In either case make sure that more than one thread canâ€™t get access to a
                                Unit of Workâ€”there lies the way to madness.</p>
                <p>Unit of Work makes an obvious point of handling batch updates. The idea
                                behind a batch update is to send multiple SQL commands as a single unit so
                                that they can be processed in a single remote call. This is particularly important
                                when many updates, inserts, and deletes are sent in rapid succession. Different
                                environments provide different levels of support for batch updates. JDBC has a
                                facility that allows you to batch individual statements. If you donâ€™t have this
                                feature, you can mimic it by building up a string that has multiple SQL statements and then submitting as one statement. [Nilsson] describes an example of
                                this for Microsoft platforms. However, if you do this check to see if it interferes
                                with statement precompilation.
                                Unit of Work works with any transactional resource, not just databases, so
                                you can also use it to coordinate with message queues and transaction monitors.
                                .NET Implementation</p>
                <p>In .NET the Unit of Work is done by the disconnected data set. This makes
                                it a slightly different pattern from the classical variety. Most Units of Work
                                Iâ€™ve come across register and track changes to objects. .NET reads data from
                                the database into a data set, which is a series of objects arranged like database tables, rows, and columns. The data set is essentially an in-memory mirror image of the result of one or more SQL queries. Each data row has the
                                concept of a version (current, original, proposed) and a state (unchanged,
                                added, deleted, modified), which, together with the fact that the data set
                                mimics the database structure, makes for straightforward writing of changes
                                to the database.</p>
                <h3 id="189">When to Use It</h3>
                <p>The fundamental problem that Unit of Work deals with is keeping track of the
                                various objects youâ€™ve manipulated so that you know which ones you need to
                                consider to synchronize your in-memory data with the database. If youâ€™re able
                                to do all your work within a system transaction, the only objects you need to
                                worry about are those you alter. Although Unit of Work is generally the best
                                way of doing this, there are alternatives.
                                Perhaps the simplest alternative is to explicitly save any object whenever you
                                alter it. The problem here is that you may get many more database calls than
                                you want since, if you alter one object at three different points in your work,
                                you get three calls rather than one call in its final state.
                                To avoid multiple database calls, you can leave all your updates to the end.
                                To do this you need to keep track of all the objects that have changed. You can
                                use variables in your code for this, but they soon become unmanageable once
                                you have more than a few. Variables often work fine with a Transaction Script
                                (110), but they can be very difficult with a Domain Model (116).</p>
                <p>Rather than keep objects in variables you can give each object a dirty flag
                                that you set when the object changes. Then you need to find all the dirty objects
                                at the end of your transaction and write them out. The value of this technique
                                hinges on how easy it is to find the dirty objects. If all of them are in a single
                                hierarchy, then you can traverse the hierarchy and write out any that have been
                                changed. However, a more general object network, such as a Domain Model
                                (116), is harder to traverse.
                                The great strength of Unit of Work is that it keeps all this information in one
                                place. Once you have it working for you, you donâ€™t have to remember to do
                                much in order to keep track of your changes. Also, Unit of Work is a firm platform for more complicated situations, such as handling business transactions
                                that span several system transactions using Optimistic Offline Lock (416) and
                                Pessimistic Offline Lock (426).</p>
                <h3 id="190">Example: Unit of Work with Object Registration (Java)</h3>
                <p>Hereâ€™s a Unit of Work that can track all changes for a given business transaction and then commit them to the database when instructed to do so. Our
                                domain layer has a Layer Supertype (475), DomainObject, with which the Unit of
                                Work will interact. To store the change set we use three lists: new, dirty, and
                                removed domain objects.
                                <pre>class UnitOfWork...
                                private List newObjects = new ArrayList();
                                private List dirtyObjects = new ArrayList();
                                private List removedObjects = new ArrayList();</pre>
                                The registration methods maintain the state of these lists. They must perform
                                basic assertions such as checking that an ID isnâ€™t null or that a dirty object isnâ€™t
                                being registered as new.
                                <pre>class UnitOfWork...
                                public void registerNew(DomainObject obj) {
                                Assert.notNull("id not null", obj.getId());
                                Assert.isTrue("object not dirty", !dirtyObjects.contains(obj));
                                Assert.isTrue("object not removed", !removedObjects.contains(obj));
                                Assert.isTrue("object not already registered new", !newObjects.contains(obj));
                                newObjects.add(obj);
                                }
                                UNIT OF WORK 191
                                Unit of Work
                                public void registerDirty(DomainObject obj) {
                                Assert.notNull("id not null", obj.getId());
                                Assert.isTrue("object not removed", !removedObjects.contains(obj));
                                if (!dirtyObjects.contains(obj) && !newObjects.contains(obj)) {
                                dirtyObjects.add(obj);
                                }
                                }
                                public void registerRemoved(DomainObject obj) {
                                Assert.notNull("id not null", obj.getId());
                                if (newObjects.remove(obj)) return;
                                dirtyObjects.remove(obj);
                                if (!removedObjects.contains(obj)) {
                                removedObjects.add(obj);
                                }
                                }
                                public void registerClean(DomainObject obj) {
                                Assert.notNull("id not null", obj.getId());
                                }</pre>
                                Notice that registerClean() doesnâ€™t do anything here. A common practice is to
                                place an Identity Map (195) within a Unit of Work. An Identity Map (195) is
                                necessary almost any time you store domain object state in memory because
                                multiple copies of the same object would result in undefined behavior. Were an
                                Identity Map (195) in place, registerClean() would put the registered object in it.
                                Likewise registerNew() would put a new object in the map and registerRemoved()
                                would remove a deleted object from the map. Without the Identity Map (195)
                                you have the option of not including registerClean() in your Unit of Work. Iâ€™ve
                                seen implementations of this method that remove changed objects from the
                                dirty list, but partially rolling back changes is always tricky. Be careful when
                                reversing any state in the change set.</p>
                <p>commit() will locate the Data Mapper (165) for each object and invoke the
                                appropriate mapping method. updateDirty() and deleteRemoved() arenâ€™t shown, but
                                they would behave like insertNew(), which is as expected.
                                <pre>class UnitOfWork...
                                public void commit() {
                                insertNew();
                                updateDirty();
                                deleteRemoved();
                                }
                                private void insertNew() {
                                for (Iterator objects = newObjects.iterator(); objects.hasNext();) {
                                DomainObject obj = (DomainObject) objects.next();
                                MapperRegistry.getMapper(obj.getClass()).insert(obj);
                                }
                                }</pre>
                                Not included in this Unit of Work is the tracking of any objects weâ€™ve read and
                                want to check for inconsistent read errors upon commit. This is addressed in
                                Optimistic Offline Lock (416).
                                Next we need to facilitate object registration. First each domain object needs
                                to find the Unit of Work serving the current business transaction. Since that
                                Unit of Work will be needed by the entire domain model, passing it around as a
                                parameter is probably unreasonable. As each business transaction executes
                                within a single thread we can associate the Unit of Work with the currently executing thread using the java.lang.ThreadLocal class. Keeping things simple, weâ€™ll
                                add this functionality by using static methods on our Unit of Work class. If we
                                already have some sort of session object associated with the business transaction execution thread we should place the current Unit of Work on that session
                                object rather than add the management overhead of another thread mapping.
                                Besides, the Unit of Work logically belongs to the session.
                                <pre>class UnitOfWork...
                                private static ThreadLocal current = new ThreadLocal();
                                public static void newCurrent() {
                                setCurrent(new UnitOfWork());
                                }
                                public static void setCurrent(UnitOfWork uow) {
                                current.set(uow);
                                }
                                public static UnitOfWork getCurrent() {
                                return (UnitOfWork) current.get();
                                }</pre>
                                Now we can now give our abstract domain object the marking methods to
                                register itself with the current Unit of Work.
                                <pre>class DomainObject...
                                protected void markNew() {
                                UnitOfWork.getCurrent().registerNew(this);
                                }
                                protected void markClean() {
                                UnitOfWork.getCurrent().registerClean(this);
                                }
                                protected void markDirty() {
                                UnitOfWork.getCurrent().registerDirty(this);
                                }
                                protected void markRemoved() {
                                UnitOfWork.getCurrent().registerRemoved(this);
                                }</pre>
                                Concrete domain objects need to remember to mark themselves new and dirty
                                where appropriate.
                                <pre>class Album...
                                public static Album create(String name) {
                                Album obj = new Album(IdGenerator.nextId(), name);
                                obj.markNew();
                                return obj;
                                }
                                public void setTitle(String title) {
                                this.title = title;
                                markDirty();
                                }</pre>
                                Not shown is that the registration of removed objects can be handled by a
                                remove() method on the abstract domain object. Also, and if youâ€™ve implemented
                                registerClean() your Data Mappers (165) will need to register any newly loaded
                                object as clean.
                                The final piece is to register and commit the Unit of Work where appropriate. This can be done either explicitly or implicitly. Hereâ€™s what explicit Unit of
                                Work management looks like:
                                <pre>class EditAlbumScript...
                                public static void updateTitle(Long albumId, String title) {
                                UnitOfWork.newCurrent();
                                Mapper mapper = MapperRegistry.getMapper(Album.class);
                                Album album = (Album) mapper.find(albumId);
                                album.setTitle(title);
                                UnitOfWork.getCurrent().commit();
                                }</pre>
                                Beyond the simplest of applications, implicit Unit of Work management is
                                more appropriate as it avoids repetitive, tedious coding. Hereâ€™s a servlet Layer
                                Supertype (475) that registers and commits the Unit of Work for its concrete
                                subtypes. Subtypes will implement handleGet() rather than override doGet(). Any
                                code executing within handleGet() will have a Unit of Work with which to work.
                                <pre>class UnitOfWorkServlet...
                                final protected void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws ServletException, IOException {
                                try {
                                UnitOfWork.newCurrent();
                                handleGet(request, response);
                                UnitOfWork.getCurrent().commit();
                                } finally {
                                UnitOfWork.setCurrent(null);
                                }
                                }
                                abstract void handleGet(HttpServletRequest request, HttpServletResponse response)
                                throws ServletException, IOException;</pre>
                                The above servlet example is obviously a bit simplistic, in that it skips system transaction control. If you were using Front Controller (344), you would
                                be more likely to wrap Unit of Work management around your commands
                                rather than doGet(). Similar wrapping can be done with just about any execution context.
                                Identity Map</p>
                <h3 id="195">Identity Map</h3>
                <p><img src="img/part2.10.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Ensures that each object gets loaded only once by keeping
                                every loaded object in a map. Looks up objects using
                                the map when referring to them.
                                An old proverb says that a man with two watches never knows what time it is.
                                If two watches are confusing, you can get in an even bigger mess with loading
                                objects from a database. If you arenâ€™t careful you can load the data from the
                                same database record into two different objects. Then, when you update them
                                both youâ€™ll have an interesting time writing the changes out to the database
                                correctly.
                                Related to this is an obvious performance problem. If you load the same data
                                more than once youâ€™re incurring an expensive cost in remote calls. Thus, not
                                loading the same data twice doesnâ€™t just help correctness, but can also speed up
                                your application.
                                An Identity Map keeps a record of all objects that have been read from the
                                database in a single business transaction. Whenever you want an object, you
                                check the Identity Map first to see if you already have it.</p>
                <h3 id="195(2)">How It Works</h3>
                <p>The basic idea behind the Identity Map is to have a series of maps containing
                                objects that have been pulled from the database. In a simple case, with an isomorphic schema, youâ€™ll have one map per database table. When you load an
                                <pre>finder an identity map
                                find (1)
                                found = get (1)
                                [found not null] found
                                database
                                [found is null] found = select where id = 1</pre>
                                object from the database, you first check the map. If thereâ€™s an object in it that
                                corresponds to the one youâ€™re loading, you return it. If not, you go to the database, putting the objects into the map for future reference as you load them.
                                There are a number of implementation choices to worry about. Also, since
                                Identity Maps interact with concurrency management, so you should consider
                                Optimistic Offline Lock (416) as well.
                                Choice of Keys The first thing to consider is the key for the map. The obvious
                                choice is the primary key of the corresponding database table. This works well
                                if the key is a single column and immutable. A surrogate primary key fits in very
                                well with this approach because you can use it as the key in the map. The key
                                will usually be a simple data type so the comparison behavior will work nicely.
                                Explicit or Generic You have to choose whether to make the Identity Map
                                explicit or generic. An explicit Identity Map is accessed with distinct methods
                                for each kind of object you need: such as findPerson(1). A generic map uses a single method for all kinds of objects, with perhaps a parameter to indicate which
                                kind of object you need, such as find("Person", 1). The obvious advantage is that
                                you can support a generic map with a generic and reusable object. Itâ€™s easy to
                                construct a reusable Registry (480) that work for all kinds of objects and
                                doesnâ€™t need updating when you add a new map.</p>
                <p>However, I prefer an explicit Identity Map. For a start this gives you compiletime checking in a strongly typed language. But more than that, it has all the
                                other advantages of an explicit interface: itâ€™s easier to see what maps are available and what theyâ€™re called. It does mean adding a method each time you add
                                a new map, but that is a small overhead for the virtue of explicitness.
                                Your type of key affects the choice. You can only use a generic map if all
                                your objects have the same type of key. This is a good argument for encapsulating different kinds of database key behind a single key object. (See Identity
                                Field (216) for detail.)
                                How Many Here the decision varies between one map per class and one map
                                for the whole session. A single map for the session works only if you have database-unique keys (see the discussion in Identity Field (216) for the trade-offs on
                                that.) Once you have one Identity Map, the benefit is that you have only one
                                place to go and no awkward decisions about inheritance.
                                If you have multiple maps, the obvious route is one map per class or per
                                table, which works well if your database schema and object models are the
                                same. If they look different, itâ€™s usually easier to base the maps on your objects
                                rather than on your tables, as the objects shouldnâ€™t really know about the intricacies of the mapping.
                                Inheritance rears an ugly head here. If you have cars as a subtype of vehicle,
                                do you have one map or separate maps? Keeping them separate can make polymorphic references much more awkward, since any lookup needs to know to
                                look in all maps. As a result I prefer to use a single map for each inheritance
                                tree, but that means that you should also make your keys unique across inheritance trees, which can be awkward if you use Concrete Table Inheritance (293).
                                An advantage of a single map is that you donâ€™t have to add new ones when
                                you add database tables. However, tying your maps to your Data Mappers
                                (165) (see below) wonâ€™t be any extra burden.</p>
                <p>Where to Put Them Identity Maps need to be somewhere where theyâ€™re easy to
                                find. Theyâ€™re also tied to the process context youâ€™re working in. You need to
                                ensure that each session gets itâ€™s own instance thatâ€™s isolated from any other sessionâ€™s instance. Thus, you need to put the Identity Map on a session-specific
                                object. If youâ€™re using Unit of Work (184) thatâ€™s by far the best place for the
                                Identity Maps since the Unit of Work (184) is the main place for keeping track
                                of data coming in or out of the database. If you donâ€™t have a Unit of Work
                                (184), the best bet is a Registry (480) thatâ€™s tied to the session.
                                As Iâ€™ve implied here, you usually see a single Identity Map for a session; otherwise, you need to provide transactional protection for your map, which is
                                more work than any sane developer wants to do. However, there are a couple
                                of exceptions. The biggest one is to use an object database as a transactional
                                cache, even if you use a relational database for record data. While I havenâ€™t seen
                                any independent performance studies, the possibilities suggest that itâ€™s worth
                                taking a look at. Many people I respect are big fans of a transactional cache as
                                a way to improve performance.
                                The other exception is for objects that are read-only in all cases. If an object
                                can never be modified, thereâ€™s no need to worry about it being shared across sessions. In performance-intensive systems it can be very beneficial to load in all
                                read-only data once and have it available to the whole process. In this case you
                                have your read-only Identity Maps held in a process context and your updatable
                                Identity Maps in a session context. This also applies to objects that arenâ€™t completely read-only but are updated so rarely that you donâ€™t mind flushing the process-wide Identity Map and potentially bouncing the server when it happens.
                                Even if youâ€™re inclined to have only one Identity Map you can split it in two
                                along read-only and updatable lines. You can avoid clients having to know
                                which is which by providing an interface that checks both maps.</p>
                <h3 id="198">When to Use It</h3>
                <p>In general you use an Identity Map to manage any object brought from a database and modified. The key reason is that you donâ€™t want a situation where two
                                in-memory objects correspond to a single database recordâ€”you might modify
                                the two records inconsistently and thus confuse the database mapping.
                                Another value in Identity Map is that it acts as a cache for database reads,
                                which means that you can avoid going to the database each time you need some
                                data.
                                You may not need an Identity Map for immutable objects. If you canâ€™t
                                change an object, then you donâ€™t have to worry about modification anomalies.
                                Since Value Objects (486) are immutable, it follows that you donâ€™t need Identity Map for them. Still, Identity Map has advantages here, the most important
                                of which is the performance advantages of the cache, another is that it helps to
                                prevent the use of the wrong form of equality test, a problem prevalent in Java,
                                where you canâ€™t override ==.
                                You donâ€™t need an Identity Map for a Dependent Mapping (262). Since
                                dependent objects have their persistence controlled by their parent, thereâ€™s no
                                need for a map to maintain identity. However, although you donâ€™t need a map,
                                you may want to provide one if you need to access the object through a database key. In this case the map is merely an index, so itâ€™s arguable whether it
                                really counts as a map at all.
                                Identity Map helps avoid update conflicts within a single session, but it
                                doesnâ€™t do anything to handle conflicts that cross sessions. This is a complex
                                problem that we discuss further in Optimistic Offline Lock (416) and Pessimistic Offline Lock (426).</p>
                <h3 id="198(2)">Example: Methods for an Identity Map (Java)</h3>
                <p>For each Identity Map we have a map field and accessors.
                                <pre>private Map people = new HashMap();
                                public static void addPerson(Person arg) {
                                soleInstance.people.put(arg.getID(), arg);
                                }
                                public static Person getPerson(Long key) {
                                return (Person) soleInstance.people.get(key);
                                }
                                public static Person getPerson(long key) {
                                return getPerson(new Long(key));
                                }</pre>
                                One of the annoyances of Java is the fact that long isnâ€™t an object so you canâ€™t
                                use it as an index for a map. This isnâ€™t as annoying as it could have been since
                                we donâ€™t actually do any arithmetic on the index. The one place where it really
                                hurts, though, is when you want to retrieve an object with a literal. You hardly
                                ever need to do that in production code, but you often do in test code, so Iâ€™ve
                                included a getting method that takes a long to make testing easier.</p>
                <h3 id="200">Lazy Load</h3>
                <p><img src="img/part2.11.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that doesnâ€™t contain all of the data you need
                                but knows how to get it.
                                For loading data from a database into memory itâ€™s handy to design things so
                                that as you load an object of interest you also load the objects that are related
                                to it. This makes loading easier on the developer using the object, who otherwise has to load all the objects he needs explicitly.
                                However, if you take this to its logical conclusion, you reach the point where
                                loading one object can have the effect of loading a huge number of related
                                objectsâ€”something that hurts performance when only a few of the objects are
                                actually needed.
                                A Lazy Load interrupts this loading process for the moment, leaving a
                                marker in the object structure so that if the data is needed it can be loaded only
                                when it is used. As many people know, if youâ€™re lazy about doing things youâ€™ll
                                win when it turns out you donâ€™t need to do them at all.</p>
                <h3 id="200(2)">How It Works</h3>
                <p>There are four main ways you can implement Lazy Load: lazy initialization,
                                virtual proxy, value holder, and ghost.
                                a customer the database
                                get orders
                                [orders not loaded]
                                load orders
                                return orders
                                Lazy initialization [Beck Patterns] is the simplest approach. The basic idea is
                                that every access to the field checks first to see if itâ€™s null. If so, it calculates the
                                value of the field before returning the field. To make this work you have to
                                ensure that the field is self-encapsulated, meaning that all access to the field,
                                even from within the class, is done through a getting method.
                                Using a null to signal a field that hasnâ€™t been loaded yet works well, unless
                                null is a legal field value. In this case you need something else to signal that
                                the field hasnâ€™t been loaded, or you need to use a Special Case (496) for the
                                null value.</p>
                <p>Using lazy initialization is simple, but it does tend to force a dependency
                                between the object and the database. For that reason it works best for Active
                                Record (160), Table Data Gateway (144), and Row Data Gateway (152). If
                                youâ€™re using Data Mapper (165), youâ€™ll need an additional layer of indirection,
                                which you can obtain by using a virtual proxy [Gang of Four]. A virtual proxy
                                is an object that looks like the object that should be in the field, but doesnâ€™t
                                actually contain anything. Only when one of its methods is called does it load
                                the correct object from the database.
                                The good thing about a virtual proxy is that it looks exactly like the object
                                thatâ€™s supposed to be there. The bad thing is that it isnâ€™t that object, so you can
                                easily run into a nasty identity problem. Furthermore you can have more than
                                one virtual proxy for the same real object. All of these proxies will have different object identities, yet they represent the same conceptual object. At the very
                                least you have to override the equality method and remember to use it instead
                                of an identity method. Without that, and discipline, youâ€™ll run into some very
                                hard-to-track bugs.<p>
                <p>In some environments another problem is that you end up having to create
                                lots of virtual proxies, one for each class youâ€™re proxying. You can usually
                                avoid this in dynamically typed languages, but in statically typed languages
                                things often get messy. Even when the platform provides handy facilities, such
                                as Javaâ€™s proxies, other inconveniences can come up.
                                These problems donâ€™t hit you if you only use virtual proxies for collections
                                classes, such as lists. Since collections are Value Objects (486), their identity
                                doesnâ€™t matter. Additionally you only have a few collection classes to write virtual collections for.
                                With domain classes you can get around these problems by using a value
                                holder. This concept, which I first came across in Smalltalk, is an object that
                                wraps some other object. To get the underlying object you ask the value holder
                                for its value, but only on the first access does it pull the data from the database.
                                The disadvantages of the value holder are that the class needs to know that itâ€™s
                                present and that you lose the explicitness of strong typing. You can avoid identity
                                problems by ensuring that the value holder is never passed out beyond its owning
                                class.</p>
                <p>A ghost is the real object in a partial state. When you load the object from
                                the database it contains just its ID. Whenever you try to access a field it loads its
                                full state. Think of a ghost as an object, where every field is lazy-initialized in
                                one fell swoop, or as a virtual proxy, where the object is its own virtual proxy.
                                Of course, thereâ€™s no need to load all the data in one go; you may group it in
                                groups that are commonly used together. If you use a ghost, you can put it
                                immediately in its Identity Map (195). This way you maintain identity and
                                avoid all problems due to cyclic references when reading in data.
                                A virtual proxy/ghost doesnâ€™t need to be completely devoid of data. If you
                                have some data thatâ€™s quick to get hold of and commonly used, it may make
                                sense to load it when you load the proxy or ghost. (This is sometimes referred
                                to as a â€œlight object.â€)
                                Inheritance often poses a problem with Lazy Load. If youâ€™re going to use
                                ghosts, youâ€™ll need to know what type of ghost to create, which you often canâ€™t
                                tell without loading the thing properly. Virtual proxies can suffer from the same
                                problem in statically typed languages.</p>
                <p>Another danger with Lazy Load is that it can easily cause more database
                                accesses than you need. A good example of this ripple loading is if you fill a collection with Lazy Loads and then look at them one at a time. This will cause
                                you to go to the database once for each object instead of reading them all in at
                                once. Iâ€™ve seen ripple loading cripple the performance of an application. One
                                way to avoid it is never to have a collection of Lazy Loads but, rather make the
                                collection itself a Lazy Load and, when you load it, load all the contents. The
                                limitation of this tactic is when the collection is very large, such as all the IP
                                addresses in the world. These arenâ€™t usually linked through associations in the
                                object model, so that doesnâ€™t happen very often, but when it does youâ€™ll need a
                                Value List Handler [Alur et al.].
                                Lazy Load is a good candidate for aspect-oriented programming. You can
                                put Lazy Load behavior into a separate aspect, which allows you to change the
                                lazy load strategy separately as well as freeing the domain developers from having to deal with lazy loading issues. Iâ€™ve also seen a project post-process Java
                                bytecode to implement Lazy Load in a transparent way.</p>
                <p>Often youâ€™ll run into situations where different use cases work best with different varieties of laziness. Some need one subset of the object graph; others
                                need another subset. For maximum efficiency you want to load the right subgraph for the right use case.
                                The way to deal with this is to have separate database interaction objects for
                                the different use cases. Thus, if you use Data Mapper (165), you may have two
                                order mapper objects: one that loads the line items immediately and one that
                                loads them lazily. The application code chooses the appropriate mapper depending on the use case. A variation on this is to have the same basic loader object
                                but defer to a strategy object to decide the loading pattern. This is a bit more
                                sophisticated, but it can be a better way to factor behavior.
                                In theory you might want a range of different degrees of laziness, but in practice you really need only two: a complete load and enough of a load for identification purposes in a list. Adding more usually adds more complexity than is
                                worthwhile.</p>
                <h3 id="203">When to Use It</h3>
                <p>Deciding when to use Lazy Load is all about deciding how much you want to
                                pull back from the database as you load an object, and how many database
                                calls that will require. Itâ€™s usually pointless to use Lazy Load on a field thatâ€™s
                                stored in the same row as the rest of the object, because most of the time it
                                doesnâ€™t cost any more to bring back extra data in a call, even if the data field is
                                quite largeâ€”such as a Serialized LOB (272). That means itâ€™s usually only worth
                                considering Lazy Load if the field requires an extra database call to access.
                                In performance terms itâ€™s about deciding when you want to take the hit of
                                bringing back the data. Often itâ€™s a good idea to bring everything youâ€™ll need in
                                one call so you have it in place, particularly if it corresponds to a single interaction with a UI. The best time to use Lazy Load is when it involves an extra call
                                and the data youâ€™re calling isnâ€™t used when the main object is used.
                                Adding Lazy Load does add a little complexity to the program, so my preference is not to use it unless I actively think Iâ€™ll need it.</p>
                <h3 id="203(2)">Example: Lazy Initialization (Java)</h3>
                <p>The essence of lazy initialization is code like this:
                                <pre>class Supplier...
                                public List getProducts() {
                                if (products == null) products = Product.findForSupplier(getID());
                                return products;
                                }</pre>
                                In this way the first access of the products field causes the data to be loaded
                                from the database.</p>
                <h3 id="203(3)">Example: Virtual Proxy (Java)</h3>
                <p>The key to the virtual proxy is providing a class that looks like the actual class
                                you normally use but that actually holds a simple wrapper around the real
                                204 OBJECT-RELATIONAL BEHAVIORAL PATTERNS
                                Lazy Load
                                <pre>class. Thus, a list of products for a supplier would be held with a regular list
                                field.
                                class SupplierVL...
                                private List products;
                                The most complicated thing about producing a list proxy like this is setting it
                                up so that you can provide an underlying list thatâ€™s created only when itâ€™s
                                accessed. To do this we have to pass the code thatâ€™s needed to create the list into
                                the virtual list when itâ€™s instantiated. The best way to do this in Java is to define
                                an interface for the loading behavior.
                                public interface VirtualListLoader {
                                List load();
                                }
                                Then we can instantiate the virtual list with a loader that calls the appropriate
                                mapper method.
                                class SupplierMapper...
                                public static class ProductLoader implements VirtualListLoader {
                                private Long id;
                                public ProductLoader(Long id) {
                                this.id = id;
                                }
                                public List load() {
                                return ProductMapper.create().findForSupplier(id);
                                }
                                }
                                During the load method we assign the product loader to the list field.
                                class SupplierMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String nameArg = rs.getString(2);
                                SupplierVL result = new SupplierVL(id, nameArg);
                                result.setProducts(new VirtualList(new ProductLoader(id)));
                                return result;
                                }
                                The virtual listâ€™s source list is self-encapsulated and evaluates the loader on
                                first reference.
                                class VirtualList...
                                private List source;
                                private VirtualListLoader loader;
                                public VirtualList(VirtualListLoader loader) {
                                this.loader = loader;
                                LAZY LOAD 205
                                Lazy Load
                                }
                                private List getSource() {
                                if (source == null) source = loader.load();
                                return source;
                                }
                                The regular list methods to delegate are then implemented to the source list.
                                class VirtualList...
                                public int size() {
                                return getSource().size();
                                }
                                public boolean isEmpty() {
                                return getSource().isEmpty();
                                }
                                // ... and so on for rest of list methods</pre>
                                This way the domain class knows nothing about how the mapper class does the
                                Lazy Load. Indeed, the domain class isnâ€™t even aware that there is a Lazy Load.</p>
                <h3 id="205">Example: Using a Value Holder (Java)</h3>
                <p>A value holder can be used as a generic Lazy Load. In this case the domain type is
                                aware that something is afoot, since the product field is typed as a value holder.
                                This fact can be hidden from clients of the supplier by the getting method.
                                <pre>class SupplierVH...
                                private ValueHolder products;
                                public List getProducts() {
                                return (List) products.getValue();
                                }</pre>
                                The value holder itself does the Lazy Load behavior. It needs to be passed the
                                necessary code to load its value when itâ€™s accessed. We can do this by defining a
                                loader interface.
                                <pre>class ValueHolder...
                                private Object value;
                                private ValueLoader loader;
                                public ValueHolder(ValueLoader loader) {
                                this.loader = loader;
                                }
                                public Object getValue() {
                                if (value == null) value = loader.load();
                                return value;
                                }
                                public interface ValueLoader {
                                Object load();
                                }
                                206 OBJECT-RELATIONAL BEHAVIORAL PATTERNS
                                Lazy Load
                                A mapper can set up the value holder by creating an implementation of the
                                loader and putting it into the supplier object.
                                class SupplierMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String nameArg = rs.getString(2);
                                SupplierVH result = new SupplierVH(id, nameArg);
                                result.setProducts(new ValueHolder(new ProductLoader(id)));
                                return result;
                                }
                                public static class ProductLoader implements ValueLoader {
                                private Long id;
                                public ProductLoader(Long id) {
                                this.id = id;
                                }
                                public Object load() {
                                return ProductMapper.create().findForSupplier(id);
                                }
                                }</pre></p>
                <h3 id="206">Example: Using Ghosts (C#)</h3>
                <p>Much of the logic for making objects ghosts can be built into Layer Supertypes
                                (475). As a consequence, if you use ghosts you tend to see them used everywhere. Iâ€™ll begin our exploration of ghosts by looking at the domain object
                                Layer Supertype (475). Each domain object knows if itâ€™s a ghost or not.
                                <pre>class DomainObject...
                                LoadStatus Status;
                                public DomainObject (long key) {
                                this.Key = key;
                                }
                                public Boolean IsGhost {
                                get {return Status == LoadStatus.GHOST;}
                                }
                                public Boolean IsLoaded {
                                get {return Status == LoadStatus.LOADED;}
                                }
                                public void MarkLoading() {
                                Debug.Assert(IsGhost);
                                Status = LoadStatus.LOADING;
                                }
                                public void MarkLoaded() {
                                Debug.Assert(Status == LoadStatus.LOADING);
                                Status = LoadStatus.LOADED;
                                }</pre>
                                Domain objects can be in three states: ghost, loading, and loaded. I like to wrap
                                status information with read-only properties and explicit status change methods.
                                The most intrusive element of ghosts is that every accessor needs to be modified so that it will trigger a load if the object actually is a ghost.
                                <pre>class Employee...
                                public String Name {
                                get {
                                Load();
                                return _name;
                                }
                                set {
                                Load();
                                _name = value;
                                }
                                }
                                String _name;
                                class Domain Object...
                                protected void Load() {
                                if (IsGhost)
                                DataSource.Load(this);
                                }</pre>
                                Such a need, which is annoying to remember, is an ideal target for aspect-oriented programming for post-processing the bytecode.
                                In order for the loading to work, the domain object needs to call the correct
                                mapper. However, my visibility rules dictate that the domain code may not see
                                the mapper code. To avoid the dependency, I need to use an interesting combination of Registry (480) and Separated Interface (476) (Figure 11.4). I define a
                                Registry (480) for the domain for data source operations.
                                <pre>class DataSource...
                                public static void Load (DomainObject obj) {
                                instance.Load(obj);
                                }</pre>
                                The instance of the data source is defined using an interface.
                                <pre>class DataSource...
                                public interface IDataSource {
                                void Load (DomainObject obj);
                                }</pre>
                <p><img src="img/figure 11.4.png" alt="no img" style="margin-left: 200px;"></p>
                                A registry of mappers, defined in the data source layer, implements the data
                                source interface. In this case Iâ€™ve put the mappers in a dictionary indexed by
                                domain type. The load method finds the correct mapper and tells it to load the
                                appropriate domain object.
                                <pre>class MapperRegistry : IDataSource...
                                public void Load (DomainObject obj) {
                                Mapper(obj.GetType()).Load (obj);
                                }
                                public static Mapper Mapper(Type type) {
                                return (Mapper) instance.mappers[type];
                                }
                                IDictionary mappers = new Hashtable();</pre>
                                The preceding code shows how the domain objects interact with the data
                                source. The data source logic uses Data Mappers (165). The update logic on the
                                mappers is the same as in the case with no ghostsâ€”the interesting behavior for
                                this example lies in the finding and loading behavior.
                                Concrete mapper classes have their own find methods that use an abstract
                                method and downcast the result.
                                <pre>class EmployeeMapper...
                                public Employee Find (long key) {
                                return (Employee) AbstractFind(key);
                                }
                                class Mapper...
                                public DomainObject AbstractFind (long key) {
                                DomainObject result;
                                result = (DomainObject) loadedMap[key];
                                if (result == null) {
                                result = CreateGhost(key);
                                loadedMap.Add(key, result);
                                }
                                return result;
                                }
                                IDictionary loadedMap = new Hashtable();
                                public abstract DomainObject CreateGhost(long key);
                                class EmployeeMapper...
                                public override DomainObject CreateGhost(long key) {
                                return new Employee(key);
                                }</pre>
                                As you can see, the find method returns an object in its ghost state. The actual
                                data does not come from the database until the load is triggered by accessing a
                                property on the domain object.
                                <pre>class Mapper...
                                public void Load (DomainObject obj) {
                                if (! obj.IsGhost) return;
                                IDbCommand comm = new OleDbCommand(findStatement(), DB.connection);
                                comm.Parameters.Add(new OleDbParameter("key",obj.Key));
                                IDataReader reader = comm.ExecuteReader();
                                reader.Read();
                                LoadLine (reader, obj);
                                reader.Close();
                                }
                                protected abstract String findStatement();
                                public void LoadLine (IDataReader reader, DomainObject obj) {
                                if (obj.IsGhost) {
                                obj.MarkLoading();
                                doLoadLine (reader, obj);
                                obj.MarkLoaded();
                                }
                                }
                                protected abstract void doLoadLine (IDataReader reader, DomainObject obj);</pre>
                                As is common with these examples, the Layer Supertype (475) handles all of
                                the abstract behavior and then calls an abstract method for a particular subclass to play its part. For this example Iâ€™ve used a data reader, a cursor-based
                                approach thatâ€™s the more common for the various platforms at the moment. Iâ€™ll
                                leave it to you to extend this to a data set, which would actually be more suitable for most cases in .NET.
                                For this employee object, Iâ€™ll show three kinds of property: a name thatâ€™s a
                                simple value, a department thatâ€™s a reference to another object, and a list of
                                timesheet records that shows the case of a collection. All are loaded together in
                                the subclassâ€™s implementation of the hook method.
                                <pre>class EmployeeMapper...
                                protected override void doLoadLine (IDataReader reader, DomainObject obj) {
                                Employee employee = (Employee) obj;
                                employee.Name = (String) reader["name"];
                                DepartmentMapper depMapper =
                                (DepartmentMapper) MapperRegistry.Mapper(typeof(Department));
                                employee.Department = depMapper.Find((int) reader["departmentID"]);
                                loadTimeRecords(employee);
                                }</pre>
                                The nameâ€™s value is loaded simply by reading the appropriate column from
                                the data readerâ€™s current cursor. The department is read by using the find
                                method on the departmentâ€™s mapper object. This will end up setting the property to a ghost of the department; the departmentâ€™s data will only be read when
                                the department object itself is accessed.
                                The collection is the most complicated case. To avoid ripple loading, itâ€™s
                                important to load all the time records in a single query. For this we need a special list implementation that acts as a ghost list. This list is just a thin wrapper
                                around a real list object, to which all the real behavior is just delegated. The
                                only thing the ghost does is ensure that any accesses to the real list triggers a
                                load.
                                <pre>class DomainList...
                                IList data {
                                get {
                                Load();
                                return _data;
                                }
                                set {_data = value;}
                                }
                                IList _data = new ArrayList();
                                public int Count {
                                get {return data.Count;}
                                }</pre>
                                The domain list class is used by domain objects and is part of the domain
                                layer. The actual loading needs access to SQL commands, so I use a delegate to
                                define a loading function that can be supplied by the mapping layer.
                                <pre>class DomainList...
                                public void Load () {
                                if (IsGhost) {
                                MarkLoading();
                                RunLoader(this);
                                MarkLoaded();
                                }
                                }
                                public delegate void Loader(DomainList list);
                                public Loader RunLoader;</pre>
                                Think of a delegate as a special variety of Separated Interface (476) for a single
                                function. Indeed, declaring an interface with a single function in it is a reasonable alternative way of doing this.
                <p><img src="img/figure 11.5.png" alt="no img" style="margin-left: 200px;"></p>
                <p><img src="img/figure 11.6.png" alt="no img" style="margin-left: 200px;"></p>
                                The loader itself has properties to specify the SQL for the load and mapper
                                to use for mapping the time records. The employeeâ€™s mapper sets up the loader
                                when it loads the employee object.
                                <pre>class EmployeeMapper...
                                void loadTimeRecords(Employee employee) {
                                ListLoader loader = new ListLoader();
                                loader.Sql = TimeRecordMapper.FIND_FOR_EMPLOYEE_SQL;
                                loader.SqlParams.Add(employee.Key);
                                loader.Mapper = MapperRegistry.Mapper(typeof(TimeRecord));
                                loader.Attach((DomainList) employee.TimeRecords);
                                }
                                Figure 11.6 Classes for a ghost list. As yet thereâ€™s no accepted standard for showing
                                delegates in UML models. This is my current approach.
                                Domain List
                                IList
                                1
                                + Load (DomainList)
                                + Attach (DomainList)
                                Sql : String
                                SqlParams : IList
                                List Loader
                                RunLoader Loader(DomainList)
                                Â«delegateÂ»
                                Mapper
                                Â«delegateÂ»
                                Load
                                1
                                1
                                data source
                                domain
                                class ListLoader...
                                public String Sql;
                                public IList SqlParams = new ArrayList();
                                public Mapper Mapper;</pre>
                                Since the syntax for the delegate assignment is a bit complicated, Iâ€™ve given the
                                loader an attach method.
                                <pre>class ListLoader...
                                public void Attach (DomainList list) {
                                list.RunLoader = new DomainList.Loader(Load);
                                }
                                When the employee is loaded, the time records collection stays in a ghost
                                state until one of the access methods fires to trigger the loader. At this point the
                                loader executes the query to fill the list.
                                class ListLoader...
                                public void Load (DomainList list) {
                                list.IsLoaded = true;
                                IDbCommand comm = new OleDbCommand(Sql, DB.connection);
                                foreach (Object param in SqlParams)
                                comm.Parameters.Add(new OleDbParameter(param.ToString(),param));
                                IDataReader reader = comm.ExecuteReader();
                                while (reader.Read()) {
                                DomainObject obj = GhostForLine(reader);
                                Mapper.LoadLine(reader, obj);
                                list.Add (obj);
                                }
                                reader.Close();
                                }
                                private DomainObject GhostForLine(IDataReader reader) {
                                return Mapper.AbstractFind((System.Int32)reader[Mapper.KeyColumnName]);
                                }</pre>
                                Using ghost lists like this is important to reduce ripple loading. It doesnâ€™t
                                completely eliminate it, as there are other cases where it appears. In this example, a more sophisticated mapping could load the departmentâ€™s data in a single
                                query with the employee. However, always loading all the elements in a collection together helps eliminate the worst cases.
                                ObjectRelational</p>
                <h3 id="215">Chapter 12</h3>
                <h2>Object-Relational Structural Patterns</h2>
                <h3 id="216">Identity Field</h3>
                <p><img src="img/part2.12.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Saves a database ID field in an object to maintain identity between
                                an in-memory object and a database row.
                                Relational databases tell one row from another by using keyâ€”in particular, the
                                primary key. However, in-memory objects donâ€™t need such a key, as the object
                                system ensures the correct identity under the covers (or in C++â€™s case with raw
                                memory locations). Reading data from a database is all very well, but in order
                                to write data back you need to tie the database to the in-memory object system.
                                In essence, Identity Field is mind-numbingly simple. All you do is store the
                                primary key of the relational database table in the objectâ€™s fields.</p>
                <h3 id="216(2)">How It Works</h3>
                <p>Although the basic notion of Identity Field is very simple, there are oodles of
                                complicated issues that come up.
                                Choosing Your Key The first issue is what kind of key to choose in your database. Of course, this isnâ€™t always a choice, since youâ€™re often dealing with an
                                existing database that already has its key structures in place. Thereâ€™s a lot of discussion and material on this in the database community. Still, mapping to
                                objects does add some concerns to your decision.
                                The first concern is whether to use meaningful or meaningless keys. A meaningful key is something like the U.S. Social Security number for identifying a
                                person. A meaningless key is essentially a random number the database dreams
                                up thatâ€™s never intended for human use. The danger with a meaningful key is
                                that, while in theory they make good keys, in practice they donâ€™t. To work at
                                all, keys need to be unique; to work well, they need to be immutable. While
                                assigned numbers are supposed to be unique and immutable, human error often
                                makes them neither. If you mistype my SSN for my wifeâ€™s the resulting record is
                                neither unique nor immutable (assuming you would like to fix the mistake.)
                                The database should detect the uniqueness problem, but it can only do that
                                id : long
                                Person
                                after my record goes into the system, and of course that might not happen until
                                after the mistake. As a result, meaningful keys should be distrusted. For small
                                systems and/or very stable cases you may get away with it, but usually you
                                should take a rare stand on the side of meaninglessness.</p>
                <p>The next concern is simple versus compound keys. A simple key uses only
                                one database field; a compound key uses more than one. The advantage of a
                                compound key is that itâ€™s often easier to use when one table makes sense in the
                                context of another. A good example is orders and line items, where a good key
                                for the line item is a compound of the order number and a sequence number
                                makes a good key for a line item. While compound keys often make sense, there
                                is a lot to be said for the sheer uniformity of simple keys. If you use simple keys
                                everywhere, you can use the same code for all key manipulation. Compound
                                keys require special handling in concrete classes. (With code generation this
                                isnâ€™t a problem). Compound keys also carry a bit of meaning, so be careful
                                about the uniqueness and particularly the immutability rule with them.
                                You have to choose the type of the key. The most common operation youâ€™ll
                                do with a key is equality checking, so you want a type with a fast equality operation. The other important operation is getting the next key. Hence a long integer type is often the best bet. Strings can also work, but equality checking may
                                be slower and incrementing strings is a bit more painful. Your DBAâ€™s preferences may well decide the issue.
                                (Beware about using dates or times in keys. Not only are they meaningful,
                                they also lead to problems with portability and consistency. Dates in particular
                                are vulnerable to this because they are often stored to some fractional second
                                precision, which can easily get out of sync and lead to identity problems.)
                                You can have keys that are unique to the table or unique database-wide. A
                                table-unique key is unique across the table, which is what you need for a key in
                                any case. A database-unique key is unique across every row in every table in the
                                database. A table-unique key is usually fine, but a database-unique key is often
                                easier to do and allows you to use a single Identity Map (195). Modern values
                                being what they are, itâ€™s pretty unlikely that youâ€™ll run out of numbers for new
                                keys. If you really insist, you can reclaim keys from deleted objects with a simple database script that compacts the key spaceâ€”although running this script
                                will require that you take the application offline. However, if you use 64-bit
                                keys (and you might as well) youâ€™re unlikely to need this.</p>
                <p>Be wary of inheritance when you use table-unique keys. If youâ€™re using Concrete Table Inheritance (293) or Class Table Inheritance (285), life is much easier with keys that are unique to the hierarchy rather than unique to each table. I
                                still use the term â€œtable-unique,â€ even if it should strictly be something like
                                â€œinheritance graph unique.â€
                                The size of your key may effect performance, particularly with indexes. This
                                is dependent on your database system and/or how many rows you have, but itâ€™s
                                worth doing a crude check before you get fixed into your decision.
                                Representing the Identity Field in an Object The simplest form of Identity
                                Field is a field that matches the type of the key in the database. Thus, if you use
                                a simple integral key, an integral field will work very nicely.
                                Compound keys are more problematic. The best bet with them is to make a
                                key class. A generic key class can store a sequence of objects that act as the elements of the key. The key behavior for the key object (I have a quota of puns
                                per book to fill) is equality. Itâ€™s also useful to get parts of the key when youâ€™re
                                mapping to the database.
                                If you use the same basic structure for all keys, you can do all of the key handling in a Layer Supertype (475). You can put default behavior that will work
                                for most cases in the Layer Supertype (475) and extend it for the exceptional
                                cases in the particular subtypes.</p>
                <p>You can have either a single key class, which takes a generic list of key
                                objects, or key class for each domain class with explicit fields for each part of
                                the key. I usually prefer to be explicit, but in this case Iâ€™m not sure it buys very
                                much. You end up with lots of small classes that donâ€™t do anything interesting.
                                The main benefit is that you can avoid errors caused by users putting the elements of the key in the wrong order, but that doesnâ€™t seem to be a big problem
                                in practice.
                                If youâ€™re likely to import data between different database instances, you need
                                to remember that youâ€™ll get key collisions unless you come up with some
                                scheme to separate the keys between different databases. You can solve this
                                with some kind of key migration on the imports, but this can easily get very
                                messy.
                                Getting a New Key To create an object, youâ€™ll need a key. This sounds like a
                                simple matter, but it can often be quite a problem. You have three basic choices:
                                get the database to auto-generate, use a GUID, or generate your own.
                                The auto-generate route should be the easiest. Each time you insert data for
                                the database, the database generates a unique primary key without you having
                                to do anything. It sounds too good to be true, and sadly it often is. Not all databases do this the same way. Many that do, handle it in such a way that causes
                                problems for object-relational mapping.</p>
                <p>The most common auto-generation method is declaring one auto-generated
                                field, which, whenever you insert a row, is incremented to a new value. The
                                problem with this scheme is that you canâ€™t easily determine what value got gen-
                                erated as the key. If you want to insert an order and several line items, you need
                                the key of the new order so you can put the value in the line itemâ€™s foreign key.
                                Also, you need this key before the transaction commits so you can save everything within the transaction. Sadly, databases usually donâ€™t give you this information, so you usually canâ€™t use this kind of auto-generation on any table in
                                which you need to insert connected objects.
                                An alternative approach to auto-generation is a database counter, which
                                Oracle uses with its sequence. An Oracle sequence works by sending a select
                                statement that references a sequence; the database then returns an SQL record
                                set consisting of the next sequence value. You can set a sequence to increment
                                by any integer, which allows you to get multiple keys at once. The sequence
                                query is automatically carried out in a separate transaction, so that accessing
                                the sequence wonâ€™t lock out other transactions inserting at the same time. A
                                database counter like this is perfect for our needs, but itâ€™s nonstandard and not
                                available in all databases.</p>
                <p>A GUID (Globally Unique IDentifier) is a number generated on one
                                machine thatâ€™s guaranteed to be unique across all machines in space and time.
                                Often platforms give you the API to generate a GUID. The algorithm is an
                                interesting one involving ethernet card addresses, time of the day in nanoseconds, chip ID numbers, and probably the number of hairs on your left wrist.
                                All that matters is that the resulting number is completely unique and thus a
                                safe key. The only disadvantage to a GUID is that the resulting key string is
                                big, and that can be an equally big problem. There are always times when
                                someone needs to type in a key to a window or SQL expression, and long keys
                                are hard both to type and to read. They may also lead to performance problems, particularly with indexes.
                                The last option is rolling your own. A simple staple for small systems is to
                                use a table scan using the SQL max function to find the largest key in the table
                                and then add one to use it. Sadly, this read-locks the entire table while youâ€™re
                                doing it, which means that it works fine if inserts are rare, but your performance will be toasted if you have inserts running concurrently with updates on
                                the same table. You also have to ensure you have complete isolation between
                                transactions; otherwise, you can end up with multiple transactions getting the
                                same ID value.</p>
                <p>A better approach is to use a separate key table. This table is typically one
                                with two columns: name and next available value. If you use database-unique
                                keys, youâ€™ll have just one row in this table. If you use table-unique keys, youâ€™ll
                                have one row for each table in the database. To use the key table, all you need
                                to do is read that one row and note the number, the increment, the number and
                                write it back to the row. You can grab many keys at a time by adding a suitable
                                number when you update the key table. This cuts down on expensive database
                                calls and reduces contention on the key table.</p>
                <p>If you use a key table, itâ€™s a good idea to design it so that access to it is in a
                                separate transaction from the one that updates the table youâ€™re inserting into.
                                Say Iâ€™m inserting an order into the orders table. To do this Iâ€™ll need to lock the
                                orders row on the key table with a write lock (since Iâ€™m updating). That lock
                                will last for the entire transaction that Iâ€™m in, locking out anyone else who
                                wants a key. For table-unique keys, this means anyone inserting into the orders
                                table; for database-unique keys it means anyone inserting anywhere.
                                By putting access to the key table in a separate transaction, you only lock the
                                row for that, much shorter, transaction. The downside is that, if you roll back
                                on your insert to the orders, the key you got from the key table is lost to everyone. Fortunately, numbers are cheap, so thatâ€™s not a big issue. Using a separate
                                transaction also allows you to get the ID as soon as you create the in-memory
                                object, which is often some before you open the transaction to commit the business transaction.
                                Using a key table affects the choice of database-unique or table-unique keys.
                                If you use a table-unique key, you have to add a row to the key table every time
                                you add a table to the database. This is more effort, but it reduces contention
                                on the row. If you keep your key table accesses in a different transaction, contention is not so much of a problem, especially if you get multiple keys in a single call. But if you canâ€™t arrange for the key table update to be in a separate
                                transaction, you have a strong reason against database-unique keys.
                                Itâ€™s good to separate the code for getting a new key into its own class, as that
                                makes it easier to build a Service Stub (504) for testing purposes.</p>
                <h3 id="220">When to Use It</h3>
                <p>Use Identity Field when thereâ€™s a mapping between objects in memory and rows
                                in a database. This is usually when you use Domain Model (116) or Row Data
                                Gateway (152). You donâ€™t need this mapping if youâ€™re using Transaction Script
                                (110), Table Module (125), or Table Data Gateway (144).
                                For a small object with value semantics, such as a money or date range
                                object that wonâ€™t have its own table, itâ€™s better to use Embedded Value (268).
                                For a complex graph of objects that doesnâ€™t need to be queried within the relational database, Serialized LOB (272) is usually easier to write and gives faster
                                performance.
                                One alternative to Identity Field is to extend Identity Map (195) to maintain
                                the correspondence. This can be used for systems where you donâ€™t want to store
                                an Identity Field in the in-memory object. Identity Map (195) needs to look up
                                IDENTITY FIELD 221
                                Identity Field
                                both ways: give me a key for an object or an object for a key. I donâ€™t see this
                                very often because usually itâ€™s easier to store the key in the object.</p>
                <h3 id="221">Further Reading</h3>
                <p> [Marinescu] discusses several techniques for generating keys.</p>
                <h3 id="221(2)">Example: Integral Key (C#)</h3>
                <p>The simplest form of Identity Field is a integral field in the database that maps
                                to an integral field in an in-memory object.
                                <pre>class DomainObject...
                                public const long PLACEHOLDER_ID = -1;
                                public long Id = PLACEHOLDER_ID;
                                public Boolean isNew() {return Id == PLACEHOLDER_ID;}</pre>
                                An object thatâ€™s been created in memory but not saved to the database will not
                                have a value for its key. For a .NET value object this is a problem since .NET
                                values cannot be null. Hence, the placeholder value.
                                The key becomes important in two places: finding and inserting. For finding
                                you need to form a query using a key in a where clause. In .NET you can load
                                many rows into a data set and then select a particular one with a find operation.
                                <pre>class CricketerMapper...
                                public Cricketer Find(long id) {
                                return (Cricketer) AbstractFind(id);
                                }
                                class Mapper...
                                protected DomainObject AbstractFind(long id) {
                                DataRow row = FindRow(id);
                                return (row == null) ? null : Find(row);
                                }
                                protected DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                }
                                public DomainObject Find (DataRow row) {
                                DomainObject result = CreateDomainObject();
                                Load(result, row);
                                return result;
                                }
                                abstract protected DomainObject CreateDomainObject();
                                222 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                Most of this behavior can live on the Layer Supertype (475), but youâ€™ll often
                                need to define the find on the concrete class just to encapsulate the downcast.
                                Naturally, you can avoid this in a language that doesnâ€™t use compile-time typing.
                                With a simple integral Identity Field the insertion behavior can also be held
                                at the Layer Supertype (475).
                                class Mapper...
                                public virtual long Insert (DomainObject arg) {
                                DataRow row = table.NewRow();
                                arg.Id = GetNextID();
                                row["id"] = arg.Id;
                                Save (arg, row);
                                table.Rows.Add(row);
                                return arg.Id;
                                }</pre>
                                Essentially insertion involves creating the new row and using the next key for
                                it. Once you have it you can save the in-memory objectâ€™s data to this new row.</p>
                <h3 id="222">Example: Using a Key Table (Java)</h3>
                <p>If your database supports a database counter and youâ€™re not worried about
                                being dependent on database-specific SQL, you should use the counter. Even if
                                youâ€™re worried about being dependent on a database you should still consider
                                itâ€”as long as your key generation code is nicely encapsulated, you can always
                                change it to a portable algorithm later. You could even have a strategy [Gang of
                                Four] to use counters when you have them and roll your own when you donâ€™t.
                                For the moment letâ€™s assume that we have to do this the hard way. The first
                                thing we need is a key table in the database.
                                CREATE TABLE keys (name varchar primary key, nextID int)
                                INSERT INTO keys VALUES ('orders', 1)
                                This table contains one row for each counter thatâ€™s in the database. In this case
                                weâ€™ve initialized the key to 1. If youâ€™re preloading data in the database, youâ€™ll
                                need to set the counter to a suitable number. If you want database-unique keys,
                                youâ€™ll only need one row, if you want table-unique keys, youâ€™ll need one row
                                per table.</p>
                <p>You can wrap all of your key generation code into its own class. That way
                                itâ€™s easier to use it more widely around one or more applications and itâ€™s easier
                                to put key reservation into its own transaction.
                                We construct a key generator with its own database connection, together
                                with information on how many keys to take from the database at one time.
                                <pre>class KeyGenerator...
                                private Connection conn;
                                private String keyName;
                                private long nextId;
                                private long maxId;
                                private int incrementBy;
                                public KeyGenerator(Connection conn, String keyName, int incrementBy) {
                                this.conn = conn;
                                this.keyName = keyName;
                                this.incrementBy = incrementBy;
                                nextId = maxId = 0;
                                try {
                                conn.setAutoCommit(false);
                                } catch(SQLException exc) {
                                throw new ApplicationException("Unable to turn off autocommit", exc);
                                }
                                }</pre>
                                We need to ensure that no auto-commit is going on since we absolutely must
                                have the select and update operating in one transaction.
                                When we ask for a new key, the generator looks to see if it has one cached
                                rather than go to the database.
                                <pre>class KeyGenerator...
                                public synchronized Long nextKey() {
                                if (nextId == maxId) {
                                reserveIds();
                                }
                                return new Long(nextId++);
                                }
                                If the generator hasnâ€™t got one cached, it needs to go to the database.
                                class KeyGenerator...
                                private void reserveIds() {
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                long newNextId;
                                try {
                                stmt = conn.prepareStatement("SELECT nextID FROM keys WHERE name = ? FOR UPDATE");
                                stmt.setString(1, keyName);
                                rs = stmt.executeQuery();
                                rs.next();
                                newNextId = rs.getLong(1);
                                }
                                224 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                catch (SQLException exc) {
                                throw new ApplicationException("Unable to generate ids", exc);
                                }
                                finally {
                                DB.cleanUp(stmt, rs);
                                }
                                long newMaxId = newNextId + incrementBy;
                                stmt = null;
                                try {
                                stmt = conn.prepareStatement("UPDATE keys SET nextID = ? WHERE name = ?");
                                stmt.setLong(1, newMaxId);
                                stmt.setString(2, keyName);
                                stmt.executeUpdate();
                                conn.commit();
                                nextId = newNextId;
                                maxId = newMaxId;
                                }
                                catch (SQLException exc) {
                                throw new ApplicationException("Unable to generate ids", exc);
                                }
                                finally {
                                DB.cleanUp(stmt);
                                }
                                }</pre>
                                In this case we use SELECT... FOR UPDATE to tell the database to hold a write lock
                                on the key table. This is an Oracle-specific statement, so your mileage will vary
                                if youâ€™re using something else. If you canâ€™t write-lock on the select, you run the
                                risk of the transaction failing should another one get in there before you. In this
                                case, however, you can pretty safely just rerun reserveIds until you get a pristine
                                set of keys.</p>
                <h3 id="224">Example: Using a Compound Key (Java)</h3>
                <p>Using a simple integral key is a good, simple solution, but you often need other
                                types or compound keys.
                                A Key Class As soon as you need something else itâ€™s worth putting together a
                                key class. A key class needs to be able to store multiple elements of the key and
                                to be able to tell if two keys are equal.
                                <pre>class Key...
                                private Object[] fields;
                                public boolean equals(Object obj) {
                                if (!(obj instanceof Key)) return false;
                                Key otherKey = (Key) obj;
                                if (this.fields.length != otherKey.fields.length) return false;
                                IDENTITY FIELD 225
                                Identity Field
                                for (int i = 0; i < fields.length; i++)
                                if (!this.fields[i].equals(otherKey.fields[i])) return false;
                                return true;
                                }
                                The most elemental way to create a key is with an array parameter.
                                class Key...
                                public Key(Object[] fields) {
                                checkKeyNotNull(fields);
                                this.fields = fields;
                                }
                                private void checkKeyNotNull(Object[] fields) {
                                if (fields == null) throw new IllegalArgumentException("Cannot have a null key");
                                for (int i = 0; i < fields.length; i++)
                                if (fields[i] == null)
                                throw new IllegalArgumentException("Cannot have a null element of key");
                                }
                                If you find you commonly create keys with certain elements, you can add
                                convenience constructors. The exact ones will depend on what kinds of keys
                                your application has.
                                class Key...
                                public Key(long arg) {
                                this.fields = new Object[1];
                                this.fields[0] = new Long(arg);
                                }
                                public Key(Object field) {
                                if (field == null) throw new IllegalArgumentException("Cannot have a null key");
                                this.fields = new Object[1];
                                this.fields[0] = field;
                                }
                                public Key(Object arg1, Object arg2) {
                                this.fields = new Object[2];
                                this.fields[0] = arg1;
                                this.fields[1] = arg2;
                                checkKeyNotNull(fields);
                                }
                                Donâ€™t be afraid to add these convenience methods. After all, convenience is
                                important to everyone using the keys.
                                Similarly you can add accessor functions to get parts of keys. The application
                                will need to do this for the mappings.
                                class Key...
                                public Object value(int i) {
                                return fields[i];
                                }
                                226 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                public Object value() {
                                checkSingleKey();
                                return fields[0];
                                }
                                private void checkSingleKey() {
                                if (fields.length > 1)
                                throw new IllegalStateException("Cannot take value on composite key");
                                }
                                public long longValue() {
                                checkSingleKey();
                                return longValue(0);
                                }
                                public long longValue(int i) {
                                if (!(fields[i] instanceof Long))
                                throw new IllegalStateException("Cannot take longValue on non long key");
                                return ((Long) fields[i]).longValue();
                                }
                                In this example weâ€™ll map to an order and line item tables. The order table
                                has a simple integral primary key,
                                the line item tableâ€™s primary key is a compound of the orderâ€™s primary key and a sequence number.
                                CREATE TABLE orders (ID int primary key, customer varchar)
                                CREATE TABLE line_items (orderID int, seq int, amount int, product varchar,
                                primary key (orderID, seq))
                                The Layer Supertype (475) for domain objects needs to have a key field.
                                class DomainObjectWithKey...
                                private Key key;
                                protected DomainObjectWithKey(Key ID) {
                                this.key = ID;
                                }
                                protected DomainObjectWithKey() {
                                }
                                public Key getKey() {
                                return key;
                                }
                                public void setKey(Key key) {
                                this.key = key;
                                }</pre>
                                Reading As with other examples in this book Iâ€™ve split the behavior into find
                                (which gets to the right row in the database) and load (which loads data from
                                that row into the domain object). Both responsibilities are affected by the use of
                                a key object.</p>
                <p>The primary difference between these and the other examples in this book
                                (which use simple integral keys) is that we have to factor out certain pieces of
                                behavior that are overridden by classes that have more complex keys. For this
                                example Iâ€™m assuming that most tables use simple integral keys. However, some
                                use something else, so Iâ€™ve made the default case the simple integral and have
                                embedded the behavior for it the mapper Layer Supertype (475). The order
                                class is one of those simple cases. Hereâ€™s the code for the find behavior:
                                <pre>class OrderMapper...
                                public Order find(Key key) {
                                return (Order) abstractFind(key);
                                }
                                public Order find(Long id) {
                                return find(new Key(id));
                                }
                                protected String findStatementString() {
                                return "SELECT id, customer from orders WHERE id = ?";
                                }
                                class AbstractMapper...
                                abstract protected String findStatementString();
                                protected Map loadedMap = new HashMap();
                                public DomainObjectWithKey abstractFind(Key key) {
                                DomainObjectWithKey result = (DomainObjectWithKey) loadedMap.get(key);
                                if (result != null) return result;
                                ResultSet rs = null;
                                PreparedStatement findStatement = null;
                                try {
                                findStatement = DB.prepare(findStatementString());
                                loadFindStatement(key, findStatement);
                                rs = findStatement.executeQuery();
                                rs.next();
                                if (rs.isAfterLast()) return null;
                                result = load(rs);
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {
                                DB.cleanUp(findStatement, rs);
                                }
                                }
                                // hook method for keys that arenâ€™t simple integral
                                protected void loadFindStatement(Key key, PreparedStatement finder) throws SQLException {
                                finder.setLong(1, key.longValue());
                                }</pre>
                                Iâ€™ve extracted out the building of the find statement, since that requires different
                                parameters to be passed into the prepared statement. The line item is a compound key, so it needs to override that method.
                                <pre>class LineItemMapper...
                                public LineItem find(long orderID, long seq) {
                                Key key = new Key(new Long(orderID), new Long(seq));
                                return (LineItem) abstractFind(key);
                                }
                                public LineItem find(Key key) {
                                return (LineItem) abstractFind(key);
                                }
                                protected String findStatementString() {
                                return
                                "SELECT orderID, seq, amount, product " +
                                " FROM line_items " +
                                " WHERE (orderID = ?) AND (seq = ?)";
                                }
                                // hook methods overridden for the composite key
                                protected void loadFindStatement(Key key, PreparedStatement finder) throws SQLException {
                                finder.setLong(1, orderID(key));
                                finder.setLong(2, sequenceNumber(key));
                                }
                                //helpers to extract appropriate values from line itemâ€™s key
                                private static long orderID(Key key) {
                                return key.longValue(0);
                                }
                                private static long sequenceNumber(Key key) {
                                return key.longValue(1);
                                }</pre>
                                As well as defining the interface for the find methods and providing an SQL
                                string for the find statement, the subclass needs to override the hook method to
                                allow two parameters to go into the SQL statement. Iâ€™ve also written two helper
                                methods to extract the parts of the key information. This makes for clearer
                                code than I would get by just putting explicit accessors with numeric indices
                                from the key. Such literal indices are a bad smell.
                                The load behavior shows a similar structureâ€”default behavior in the Layer
                                Supertype (475) for simple integral keys, overridden for the more complex
                                cases. In this case the orderâ€™s load behavior looks like this:
                                <pre>class AbstractMapper...
                                protected DomainObjectWithKey load(ResultSet rs) throws SQLException {
                                Key key = createKey(rs);
                                if (loadedMap.containsKey(key)) return (DomainObjectWithKey) loadedMap.get(key);
                                DomainObjectWithKey result = doLoad(key, rs);
                                loadedMap.put(key, result);
                                return result;
                                }
                                abstract protected DomainObjectWithKey doLoad(Key id, ResultSet rs) throws SQLException;
                                // hook method for keys that arenâ€™t simple integral
                                protected Key createKey(ResultSet rs) throws SQLException {
                                return new Key(rs.getLong(1));
                                }
                                class OrderMapper...
                                protected DomainObjectWithKey doLoad(Key key, ResultSet rs) throws SQLException {
                                String customer = rs.getString("customer");
                                Order result = new Order(key, customer);
                                MapperRegistry.lineItem().loadAllLineItemsFor(result);
                                return result;
                                }
                                The line item needs to override the hook to create a key based on two fields.
                                class LineItemMapper...
                                protected DomainObjectWithKey doLoad(Key key, ResultSet rs) throws SQLException {
                                Order theOrder = MapperRegistry.order().find(orderID(key));
                                return doLoad(key, rs, theOrder);
                                }
                                protected DomainObjectWithKey doLoad(Key key, ResultSet rs, Order order)
                                throws SQLException
                                {
                                LineItem result;
                                int amount = rs.getInt("amount");
                                String product = rs.getString("product");
                                result = new LineItem(key, amount, product);
                                order.addLineItem(result);//links to the order
                                return result;
                                }
                                //overrides the default case
                                protected Key createKey(ResultSet rs) throws SQLException {
                                Key key = new Key(new Long(rs.getLong("orderID")), new Long(rs.getLong("seq")));
                                return key;
                                }
                                The line item also has a separate load method for use when loading all the
                                lines for the order.
                                class LineItemMapper...
                                public void loadAllLineItemsFor(Order arg) {
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                stmt = DB.prepare(findForOrderString);
                                stmt.setLong(1, arg.getKey().longValue());
                                rs = stmt.executeQuery();
                                while (rs.next())
                                load(rs, arg);
                                230 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally { DB.cleanUp(stmt, rs);
                                }
                                }
                                private final static String findForOrderString =
                                "SELECT orderID, seq, amount, product " +
                                "FROM line_items " +
                                "WHERE orderID = ?";
                                protected DomainObjectWithKey load(ResultSet rs, Order order) throws SQLException {
                                Key key = createKey(rs);
                                if (loadedMap.containsKey(key)) return (DomainObjectWithKey) loadedMap.get(key);
                                DomainObjectWithKey result = doLoad(key, rs, order);
                                loadedMap.put(key, result);
                                return result;
                                }</pre>
                                You need the special handling because the order object isnâ€™t put into the orderâ€™s
                                Identity Map (195) until after itâ€™s created. Creating an empty object and inserting it directly into the Identity Field would avoid the need for this (page 169).
                                Insertion Like reading, inserting has a default action for a simple integral key
                                and the hooks to override this for more interesting keys. In the mapper supertype Iâ€™ve provided an operation to act as the interface, together with a template
                                method to do the work of the insertion.
                                <pre>class AbstractMapper...
                                public Key insert(DomainObjectWithKey subject) {
                                try {
                                return performInsert(subject, findNextDatabaseKeyObject());
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                }
                                }
                                protected Key performInsert(DomainObjectWithKey subject, Key key) throws SQLException {
                                subject.setKey(key);
                                PreparedStatement stmt = DB.prepare(insertStatementString());
                                insertKey(subject, stmt);
                                insertData(subject, stmt);
                                stmt.execute();
                                loadedMap.put(subject.getKey(), subject);
                                return subject.getKey();
                                }
                                abstract protected String insertStatementString();
                                class OrderMapper...
                                protected String insertStatementString() {
                                return "INSERT INTO orders VALUES(?,?)";
                                }</pre>
                                The data from the object goes into the insert statement through two methods
                                that separate the data of the key from the basic data of the object. I do this
                                because I can provide a default implementation for the key that will work for
                                any class, like order, that uses the default simple integral key.
                                <pre>class AbstractMapper...
                                protected void insertKey(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(1, subject.getKey().longValue());
                                }
                                The rest of the data for the insert statement is dependent on the particular
                                subclass, so this behavior is abstract on the superclass.
                                class AbstractMapper...
                                abstract protected void insertData(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException;
                                class OrderMapper...
                                protected void insertData(DomainObjectWithKey abstractSubject, PreparedStatement stmt) {
                                try {
                                Order subject = (Order) abstractSubject;
                                stmt.setString(2, subject.getCustomer());
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                }
                                }
                                The line item overrides both of these methods. It pulls two values out for
                                key.
                                class LineItemMapper...
                                protected String insertStatementString() {
                                return "INSERT INTO line_items VALUES (?, ?, ?, ?)";
                                }
                                protected void insertKey(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(1, orderID(subject.getKey()));
                                stmt.setLong(2, sequenceNumber(subject.getKey()));
                                }
                                232 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                It also provides its own implementation of the insert statement for the rest of
                                the data.
                                class LineItemMapper...
                                protected void insertData(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                LineItem item = (LineItem) subject;
                                stmt.setInt(3, item.getAmount());
                                stmt.setString(4, item.getProduct());
                                }</pre>
                                Putting the data loading into the insert statement like this is only worthwhile
                                if most classes use the same single field for the key. If thereâ€™s more variation for
                                the key handling, then having just one command to insert the information is
                                probably easier.
                                Coming up with the next database key is also something that I can separate
                                into a default and an overridden case. For the default case I can use the key
                                table scheme that I talked about earlier. But for the line item we run into a
                                problem. The line itemâ€™s key uses the key of the order as part of its composite
                                key. However, thereâ€™s no reference from the line item class to the order class, so
                                itâ€™s impossible to tell a line item to insert itself into the database without providing the correct order as well. This leads to the always messy approach of implementing the superclass method with an unsupported operation exception.
                                <pre>class LineItemMapper...
                                public Key insert(DomainObjectWithKey subject) {
                                throw new UnsupportedOperationException
                                ("Must supply an order when inserting a line item");
                                }
                                public Key insert(LineItem item, Order order) {
                                try {
                                Key key = new Key(order.getKey().value(), getNextSequenceNumber(order));
                                return performInsert(item, key);
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                }
                                }</pre>
                                Of course, we can avoid this by having a back link from the line item to the
                                order, effectively making the association between the two bidirectional. Iâ€™ve
                                chosen not to do it here to illustrate what to do when you donâ€™t have that
                                link.
                                By supplying the order, itâ€™s easy to get the orderâ€™s part of the key. The next
                                problem is to come up with a sequence number for the order line. To find that
                                number, we need to find out what the next available sequence number is for an
                                order, which we can do either with a max query in SQL or by looking at the line
                                items on the order in memory. For this example Iâ€™ll do the latter.
                                <pre>class LineItemMapper...
                                private Long getNextSequenceNumber(Order order) {
                                loadAllLineItemsFor(order);
                                Iterator it = order.getItems().iterator();
                                LineItem candidate = (LineItem) it.next();
                                while (it.hasNext()) {
                                LineItem thisItem = (LineItem) it.next();
                                if (thisItem.getKey() == null) continue;
                                if (sequenceNumber(thisItem) > sequenceNumber(candidate)) candidate = thisItem;
                                }
                                return new Long(sequenceNumber(candidate) + 1);
                                }
                                private static long sequenceNumber(LineItem li) {
                                return sequenceNumber(li.getKey());
                                }
                                //comparator doesn't work well here due to unsaved null keys
                                protected String keyTableRow() {
                                throw new UnsupportedOperationException();
                                }</pre>
                                This algorithm would be much nicer if I used the Collections.max method, but
                                since we may (and indeed will) have at least one null key, that method would
                                fail.
                                Updates and Deletes After all of that, updates and deletes are mostly harmless.
                                Again we have an abstract method for the assumed usual case and an override
                                for the special cases.
                                Updates work like this:
                                <pre>class AbstractMapper...
                                public void update(DomainObjectWithKey subject) {
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(updateStatementString());
                                loadUpdateStatement(subject, stmt);
                                stmt.execute();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {
                                DB.cleanUp(stmt);
                                }
                                }
                                abstract protected String updateStatementString();
                                abstract protected void loadUpdateStatement(DomainObjectWithKey subject,
                                PreparedStatement stmt)
                                throws SQLException;
                                class OrderMapper...
                                protected void loadUpdateStatement(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                Order order = (Order) subject;
                                stmt.setString(1, order.getCustomer());
                                stmt.setLong(2, order.getKey().longValue());
                                }
                                protected String updateStatementString() {
                                return "UPDATE orders SET customer = ? WHERE id = ?";
                                }
                                class LineItemMapper...
                                protected String updateStatementString() {
                                return
                                "UPDATE line_items " +
                                " SET amount = ?, product = ? " +
                                " WHERE orderId = ? AND seq = ?";
                                }
                                protected void loadUpdateStatement(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(3, orderID(subject.getKey()));
                                stmt.setLong(4, sequenceNumber(subject.getKey()));
                                LineItem li = (LineItem) subject;
                                stmt.setInt(1, li.getAmount());
                                stmt.setString(2, li.getProduct());
                                }
                                Deletes work like this:
                                class AbstractMapper...
                                public void delete(DomainObjectWithKey subject) {
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(deleteStatementString());
                                loadDeleteStatement(subject, stmt);
                                stmt.execute();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {
                                DB.cleanUp(stmt);
                                }
                                }
                                abstract protected String deleteStatementString();
                                protected void loadDeleteStatement(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(1, subject.getKey().longValue());
                                }
                                IDENTITY FIELD 235
                                Identity Field
                                class OrderMapper...
                                protected String deleteStatementString() {
                                return "DELETE FROM orders WHERE id = ?";
                                }
                                class LineItemMapper...
                                protected String deleteStatementString() {
                                return "DELETE FROM line_items WHERE orderid = ? AND seq = ?";
                                }
                                protected void loadDeleteStatement(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(1, orderID(subject.getKey()));
                                stmt.setLong(2, sequenceNumber(subject.getKey()));
                                }</pre></p>
                <h3 id="236">Foreign Key Mapping</h3>
                <p><img src="img/part.13.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Maps an association between objects to a foreign
                                key reference between tables.
                                Objects can refer to each other directly by object references. Even the simplest
                                object-oriented system will contain a bevy of objects connected to each other in
                                all sorts of interesting ways. To save these objects to a database, itâ€™s vital to save
                                these references. However, since the data in them is specific to the specific
                                instance of the running program, you canâ€™t just save raw data values. Further
                                complicating things is the fact that objects can easily hold collections of references to other objects. Such a structure violates the first normal form of relational databases.
                                A Foreign Key Mapping maps an object reference to a foreign key in the
                                database.</p>
                <h3 id="236(2)">How It Works</h3>
                <p>The obvious key to this problem is Identity Field (216). Each object contains
                                the database key from the appropriate database table. If two objects are
                                linked together with an association, this association can be replaced by a foreign key in the database. Put simply, when you save an album to the database,
                                you save the ID of the artist that the album is linked to in the album record,
                                as in Figure 12.1.
                <p><img src="img/figure 12.1.png" alt="no img" style="margin-left: 200px;"></p>
                                Thatâ€™s the simple case. A more complicated case turns up when you have a
                                collection of objects. You canâ€™t save a collection in the database, so you have
                                to reverse the direction of the reference. Thus, if you have a collection of tracks
                                in the album, you put the foreign key of the album in the track record, as in
                                Figures 12.2 and 12.3. The complication occurs when you have an update.
                                Updating implies that tracks can be added to and removed from the collection
                                within an album. How can you tell what alterations to put in the database?
                                Essentially you have three options: (1) delete and insert, (2) add a back pointer,
                                and (3) diff the collection.
                <p><img src="img/figure 12.2.png" alt="no img" style="margin-left: 200px;"></p>
                <p><img src="img/figure 12.3.png" alt="no img" style="margin-left: 200px;"></p>
                                With delete and insert you delete all the tracks in the database that link to
                                the album, and then insert all the ones currently on the album. At first glance
                                this sounds pretty appalling, especially if you havenâ€™t changed any tracks. But
                                the logic is easy to implement and as such it works pretty well compared to the
                                alternatives. The drawback is that you can only do this if tracks are Dependent
                                Mappings (262), which means they must be owned by the album and canâ€™t be
                                referred to outside it.</p>
                <p>Adding a back pointer puts a link from the track back to the album, effectively making the association bidirectional. This changes the object model, but
                                now you can handle the update using the simple technique for single-valued
                                fields on the other side.
                                If neither of those appeals, you can do a diff. There are two possibilities here:
                                diff with the current state of the database or diff with what you read the first
                                time. Diffing with the database involves rereading the collection back from the
                                database and then comparing the collection you read with the collection in the
                                album. Anything in the database that isnâ€™t in the album was clearly removed;
                                anything in the album that isnâ€™t on the disk is clearly a new item to be added.
                                Then look at the logic of the application to decide what to do with each item.
                                Diffing with what you read in the first place means that you have to keep
                                what you read. This is better as it avoids another database read. You may also
                                need to diff with the database if youâ€™re using Optimistic Offline Lock (416).
                                In the general case anything thatâ€™s added to the collection needs to be
                                checked first to see if itâ€™s a new object. You can do this by seeing if it has a key;
                                if it doesnâ€™t, one needs to be added to the database. This step is made a lot easFigure 12.3 Classes and tables for a multivalued reference.
                                ier with Unit of Work (184) because that way any new object will be automatically inserted first. In either case you then find the linked row in the database
                                and update its foreign key to point to the current album.</p>
                <p>For removal you have to know whether the track was moved to another
                                album, has no album, or has been deleted altogether. If itâ€™s been moved to
                                another album it should be updated when you update that other album. If it has
                                no album, you need to null the foreign key. If the track was deleted, then it
                                should be deleted when things get deleted. Handling deletes is much easier if the
                                back link is mandatory, as it is here, where every track must be on an album.
                                That way you donâ€™t have to worry about detecting items removed from the collection since they will be updated when you process the album theyâ€™ve been
                                added to.
                                If the link is immutable, meaning that you canâ€™t change a trackâ€™s album, then
                                adding always means insertion and removing always means deletion. This
                                makes things simpler still.
                                One thing to watch out for is cycles in your links. Say you need to load an
                                order, which has a link to a customer (which you load). The customer has a set
                                of payments (which you load), and each payment has orders that itâ€™s paying for,
                                which might include the original order youâ€™re trying to load. Therefore, you
                                load the order (now go back to the beginning of this paragraph.)</p>
                <p>To avoid getting lost in cycles you have two choices that boil down to how
                                you create your objects. Usually itâ€™s a good idea for a creation method to
                                include data that will give you a fully formed object. If you do that, youâ€™ll need
                                to place Lazy Load (200) at appropriate points to break the cycles. If you miss
                                one, youâ€™ll get a stack overflow, but if youâ€™re testing is good enough you can
                                manage that burden.
                                The other choice is to create empty objects and immediately put them in an
                                Identity Map (195). That way, when you cycle back around, the object is
                                already loaded and youâ€™ll end the cycle. The objects you create arenâ€™t fully
                                formed, but they should be by the end of the load procedure. This avoids having to make special case decisions about the use of Lazy Load (200) just to do a
                                correct load.</p>
                <h3 id="239">When to Use It</h3>
                <p>A Foreign Key Mapping can be used for almost all associations between classes.
                                The most common case where it isnâ€™t possible is with many-to-many associations. Foreign keys are single values, and first normal form means that you canâ€™t
                                store multiple foreign keys in a single field. Instead you need to use Association
                                Table Mapping (248).
                                If you have a collection field with no back pointer, you should consider
                                whether the many side should be a Dependent Mapping (262). If so, it can simplify your handling of the collection.
                                If the related object is a Value Object (486) then you should use Embedded
                                Value (268).</p>
                <h3 id="240">Example: Single-Valued Reference (Java)</h3>
                                This is the simplest case, where an album has a single reference to an artist.
                                <pre>class Artist...
                                private String name;
                                public Artist(Long ID, String name) {
                                super(ID);
                                this.name = name;
                                }
                                public String getName() {
                                return name;
                                }
                                public void setName(String name) {
                                this.name = name;
                                }
                                class Album...
                                private String title;
                                private Artist artist;
                                public Album(Long ID, String title, Artist artist) {
                                super(ID);
                                this.title = title;
                                this.artist = artist;
                                }
                                public String getTitle() {
                                return title;
                                }
                                public void setTitle(String title) {
                                this.title = title;
                                }
                                public Artist getArtist() {
                                return artist;
                                }
                                public void setArtist(Artist artist) {
                                this.artist = artist;
                                }</pre>
                                Figure 12.4 shows how you can load an album. When an album mapper is
                                told to load a particular album it queries the database and pulls back the result
                                set for it. It then queries the result set for each foreign key field and finds that
                                object. Now it can create the album with the appropriate found objects. If the
                <p><img src="img/figure 12.4.png" alt="no img" style="margin-left: 200px;"></p>
                                artist object was already in memory it would be fetched from the cache; otherwise, it would be loaded from the database in the same way.
                                The find operation uses abstract behavior to manipulate an Identity Map
                                (195).
                                <pre>class AlbumMapper...
                                public Album find(Long id) {
                                return (Album) abstractFind(id);
                                }
                                protected String findStatement() {
                                return "SELECT ID, title, artistID FROM albums WHERE ID = ?";
                                }
                                class AbstractMapper...
                                abstract protected String findStatement();
                                protected DomainObject abstractFind(Long id) {
                                DomainObject result = (DomainObject) loadedMap.get(id);
                                if (result != null) return result;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                Figure 12.4 Sequence for loading a single-valued field.
                                an Album Mapper
                                find (1)
                                database
                                select * from albums where ID = 1
                                a result set album result set
                                get artist id
                                an Album
                                new (anArtist)
                                an artist mapper
                                find('3')
                                '3'
                                an artist
                                242 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Foreign Key
                                Mapping
                                stmt = DB.prepare(findStatement());
                                stmt.setLong(1, id.longValue());
                                rs = stmt.executeQuery();
                                rs.next();
                                result = load(rs);
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {cleanUp(stmt, rs);}
                                }
                                private Map loadedMap = new HashMap();
                                The find operation calls a load operation to actually load the data into the
                                album.
                                class AbstractMapper...
                                protected DomainObject load(ResultSet rs) throws SQLException {
                                Long id = new Long(rs.getLong(1));
                                if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id);
                                DomainObject result = doLoad(id, rs);
                                doRegister(id, result);
                                return result;
                                }
                                protected void doRegister(Long id, DomainObject result) {
                                Assert.isFalse(loadedMap.containsKey(id));
                                loadedMap.put(id, result);
                                }
                                abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                                class AlbumMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String title = rs.getString(2);
                                long artistID = rs.getLong(3);
                                Artist artist = MapperRegistry.artist().find(artistID);
                                Album result = new Album(id, title, artist);
                                return result;
                                }
                                To update an album the foreign key value is taken from the linked artist
                                object.
                                class AbstractMapper...
                                abstract public void update(DomainObject arg);
                                class AlbumMapper...
                                public void update(DomainObject arg) {
                                PreparedStatement statement = null;
                                try {
                                FOREIGN KEY MAPPING 243
                                Foreign Key
                                Mapping
                                statement = DB.prepare(
                                "UPDATE albums SET title = ?, artistID = ? WHERE id = ?");
                                statement.setLong(3, arg.getID().longValue());
                                Album album = (Album) arg;
                                statement.setString(1, album.getTitle());
                                statement.setLong(2, album.getArtist().getID().longValue());
                                statement.execute();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {
                                cleanUp(statement);
                                }
                                }</pre></p>
                <h3 id="243">Example: Multitable Find (Java)</h3>
                <p>While itâ€™s conceptually clean to issue one query per table, itâ€™s often inefficient
                                since SQL consists of remote calls and remote calls are slow. Therefore, itâ€™s
                                often worth finding ways to gather information from multiple tables in a single
                                query. I can modify the above example to use a single query to get both the
                                album and the artist information with a single SQL call. The first alteration is
                                that of the SQL for the find statement.
                                <pre>class AlbumMapper...
                                public Album find(Long id) {
                                return (Album) abstractFind(id);
                                }
                                protected String findStatement() {
                                return "SELECT a.ID, a.title, a.artistID, r.name " +
                                " from albums a, artists r " +
                                " WHERE ID = ? and a.artistID = r.ID";
                                }
                                I then use a different load method that loads both the album and the artist
                                information together.
                                class AlbumMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String title = rs.getString(2);
                                long artistID = rs.getLong(3);
                                ArtistMapper artistMapper = MapperRegistry.artist();
                                Artist artist;
                                if (artistMapper.isLoaded(artistID))
                                artist = artistMapper.find(artistID);
                                else
                                artist = loadArtist(artistID, rs);
                                244 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Foreign Key
                                Mapping
                                Album result = new Album(id, title, artist);
                                return result;
                                }
                                private Artist loadArtist(long id, ResultSet rs) throws SQLException {
                                String name = rs.getString(4);
                                Artist result = new Artist(new Long(id), name);
                                MapperRegistry.artist().register(result.getID(), result);
                                return result;
                                }</pre>
                                Thereâ€™s tension surrounding where to put the method that maps the SQL
                                result into the artist object. On the one hand itâ€™s better to put it in the artistâ€™s
                                mapper since thatâ€™s the class that usually loads the artist. On the other hand, the
                                load method is closely coupled to the SQL and thus should stay with the SQL
                                query. In this case Iâ€™ve voted for the latter.</p>
                <h3 id="244">Example: Collection of References (C#)</h3>
                <p>The case for a collection of references occurs when you have a field that constitutes a collection. Here Iâ€™ll use an example of teams and players where weâ€™ll
                                assume that we canâ€™t make player a Dependent Mapping (262) (Figure 12.5).
                                <pre>class Team...
                                public String Name;
                                public IList Players {
                                get {return ArrayList.ReadOnly(playersData);}
                                set {playersData = new ArrayList(value);}
                                }
                                public void AddPlayer(Player arg) {
                                playersData.Add(arg);
                                }
                                private IList playersData = new ArrayList();
                                In the database this will be handled with the player record having a foreign key
                                to the team (Figure 12.6).
                                class TeamMapper...
                                public Team Find(long id) {
                                return (Team) AbstractFind(id);
                                }</pre>
                <p><img src="img/figure 12.5.png" alt="no img" style="margin-left: 200px;"></p>
                <p><img src="img/figure 12.6.png" alt="no img" style="margin-left: 200px;"></p>
                                <pre>class TeamMapper...
                                protected override String TableName {
                                get {return "Teams";}
                                }</pre>
                                The data set holder is a class that holds onto the data set in use, together
                                with the adapters needed to update it to the database.
                                class DataSetHolder...
                                public DataSet Data = new DataSet();
                                private Hashtable DataAdapters = new Hashtable();
                                For this example, weâ€™ll assume that it has already been populated by some
                                appropriate queries.
                                The find method calls a load to actually load the data into the new object.
                                <pre>class AbstractMapper...
                                protected DomainObject Load (DataRow row) {
                                long id = (int) row ["id"];
                                if (identityMap[id] != null) return (DomainObject) identityMap[id];
                                Figure 12.6 Database structure for a team with multiple players.
                                ID : long
                                Â«tableÂ»
                                Team
                                ID : long
                                teamID : long
                                Â«tableÂ»
                                Player
                                246 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Foreign Key
                                Mapping
                                else {
                                DomainObject result = CreateDomainObject();
                                result.Id = id;
                                identityMap.Add(result.Id, result);
                                doLoad(result,row);
                                return result;
                                }
                                }
                                abstract protected DomainObject CreateDomainObject();
                                private IDictionary identityMap = new Hashtable();
                                abstract protected void doLoad (DomainObject obj, DataRow row);
                                class TeamMapper...
                                protected override void doLoad (DomainObject obj, DataRow row) {
                                Team team = (Team) obj;
                                team.Name = (String) row["name"];
                                team.Players = MapperRegistry.Player.FindForTeam(team.Id);
                                }
                                To bring in the players, I execute a specialized finder on the player mapper.
                                class PlayerMapper...
                                public IList FindForTeam(long id) {
                                String filter = String.Format("teamID = {0}", id);
                                DataRow[] rows = table.Select(filter);
                                IList result = new ArrayList();
                                foreach (DataRow row in rows) {
                                result.Add(Load (row));
                                }
                                return result;
                                }
                                To update, the team saves its own data and delegates the player mapper to
                                save the data into the player table.
                                class AbstractMapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg, FindRow(arg.Id));
                                }
                                abstract protected void Save (DomainObject arg, DataRow row);
                                class TeamMapper...
                                protected override void Save (DomainObject obj, DataRow row){
                                Team team = (Team) obj;
                                row["name"] = team.Name;
                                savePlayers(team);
                                }
                                private void savePlayers(Team team){
                                foreach (Player p in team.Players) {
                                MapperRegistry.Player.LinkTeam(p, team.Id);
                                }
                                }
                                class PlayerMapper...
                                public void LinkTeam (Player player, long teamID) {
                                DataRow row = FindRow(player.Id);
                                row["teamID"] = teamID;
                                }</pre>
                                The update code is made much simpler by the fact that the association from
                                player to team is mandatory. If we move a player from one team to another, as
                                long as we update both team, we donâ€™t have to do a complicated diff to sort the
                                players out. Iâ€™ll leave that case as an exercise for the reader.</p>
                <h3 id="248">Association Table Mapping</h3>
                <p><img src="img/part2.14.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Saves an association as a table with foreign keys to the tables
                                that are linked by the association.
                                Objects can handle multivalued fields quite easily by using collections as field
                                values. Relational databases donâ€™t have this feature and are constrained to single-valued fields only. When youâ€™re mapping a one-to-many association you can
                                handle this using Foreign Key Mapping (236), essentially using a foreign key for
                                the single-valued end of the association. But a many-to-many association canâ€™t
                                do this because there is no single-valued end to hold the foreign key.
                                The answer is the classic resolution thatâ€™s been used by relational data people
                                for decades: create an extra table to record the relationship. Then use Association Table Mapping to map the multivalued field to this link table.</p>
                <h3 id="248(2)">How It Works</h3>
                <p>The basic idea behind Association Table Mapping is using a link table to store
                                the association. This table has only the foreign key IDs for the two tables that
                                are linked together, it has one row for each pair of associated objects.
                                The link table has no corresponding in-memory object. As a result it has no
                                ID. Its primary key is the compound of the two primary keys of the tables that
                                are associated.
                                In simple terms, to load data from the link table you perform two queries.
                                Consider loading the skills for an employee. In this case, at least conceptually,
                                you do queries in two stages. The first stage queries the skillsEmployees table to
                                find all the rows that link to the employee you want. The second stage finds the
                                skill object for the related ID for each row in the link table.</p>
                <p>If all the information is already in memory, this scheme works fine. If it isnâ€™t,
                                this scheme can be horribly expensive in queries, since you do a query for each
                                skill thatâ€™s in the link table. You can avoid this cost by joining the skills table to
                                the link table, which allows you to get all the data in a single query, albeit at the
                                cost of making the mapping a bit more complicated.
                                Updating the link data involves many of the issues in updating a many-valued
                                field. Fortunately, the matter is made much easier since you can in many ways
                                treat the link table like a Dependent Mapping (262). No other table should
                                refer to the link table, so you can freely create and destroy links as you need
                                them.</p>
                <h3 id="249">When to Use It</h3>
                <p>The canonical case for Association Table Mapping is a many-to-many association, since there are really no any alternatives for that situation.
                                Association Table Mapping can also be used for any other form of association. However, because itâ€™s more complex than Foreign Key Mapping (236) and
                                involves an extra join, itâ€™s not usually the right choice. Even so, in a couple of
                                cases Association Table Mapping is appropriate for a simpler association; both
                                involve databases where you have less control over the schema. Sometimes you
                                may need to link two existing tables, but you arenâ€™t able to add columns to
                                those tables. In this case you can make a new table and use Association Table
                                Mapping. Other times an existing schema uses an associative table, even when
                                it isnâ€™t really necessary. In this case itâ€™s often easier to use Association Table
                                Mapping than to simplify the database schema.
                                In a relational database design you may often have association tables that
                                also carry information about the relationship. An example is a person/company
                                associative table that also contains information about a personâ€™s employment
                                with the company. In this case the person/company table really corresponds to a
                                true domain object.</p>
                <h3 id="250">Example: Employees and Skills (C#)</h3>
                <p>Hereâ€™s a simple example using the sketchâ€™s model. We have an employee class
                                with a collection of skills, each of which can appear for more than one
                                employee.
                                <pre>class Employee...
                                public IList Skills {
                                get {return ArrayList.ReadOnly(skillsData);}
                                set {skillsData = new ArrayList(value);}
                                }
                                public void AddSkill (Skill arg) {
                                skillsData.Add(arg);
                                }
                                public void RemoveSkill (Skill arg) {
                                skillsData.Remove(arg);
                                }
                                private IList skillsData = new ArrayList();</pre>
                                To load an employee from the database, we need to pull in the skills using an
                                employee mapper. Each employee mapper class has a find method that creates
                                an employee object. All mappers are subclasses of the abstract mapper class
                                that pulls together common services for the mappers.
                                <pre>class EmployeeMapper...
                                public Employee Find(long id) {
                                return (Employee) AbstractFind(id);
                                }
                                class AbstractMapper...
                                protected DomainObject AbstractFind(long id) {
                                Assert.True (id != DomainObject.PLACEHOLDER_ID);
                                DataRow row = FindRow(id);
                                return (row == null) ? null : Load(row);
                                }
                                protected DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                }
                                protected DataTable table {
                                get {return dsh.Data.Tables[TableName];}
                                }
                                public DataSetHolder dsh;
                                abstract protected String TableName {get;}
                                class EmployeeMapper...
                                protected override String TableName {
                                get {return "Employees";}
                                }</pre>
                                The data set holder is a simple object that contains an ADO.NET data set
                                and the relevant adapters to save it to the database.
                                <pre>class DataSetHolder...
                                public DataSet Data = new DataSet();
                                private Hashtable DataAdapters = new Hashtable();
                                To make this example simpleâ€”indeed, simplisticâ€”weâ€™ll assume that the data
                                set has already been loaded with all the data we need.
                                The find method calls load methods to load data for the employee.
                                class AbstractMapper...
                                protected DomainObject Load (DataRow row) {
                                long id = (int) row ["id"];
                                if (identityMap[id] != null) return (DomainObject) identityMap[id];
                                else {
                                DomainObject result = CreateDomainObject();
                                result.Id = id;
                                identityMap.Add(result.Id, result);
                                doLoad(result,row);
                                return result;
                                }
                                }
                                abstract protected DomainObject CreateDomainObject();
                                private IDictionary identityMap = new Hashtable();
                                abstract protected void doLoad (DomainObject obj, DataRow row);
                                class EmployeeMapper...
                                protected override void doLoad (DomainObject obj, DataRow row) {
                                Employee emp = (Employee) obj;
                                emp.Name = (String) row["name"];
                                loadSkills(emp);
                                }
                                Loading the skills is sufficiently awkward to demand a separate method to do
                                the work.
                                class EmployeeMapper...
                                private IList loadSkills (Employee emp) {
                                DataRow[] rows = skillLinkRows(emp);
                                IList result = new ArrayList();
                                foreach (DataRow row in rows) {
                                long skillID = (int)row["skillID"];
                                emp.AddSkill(MapperRegistry.Skill.Find(skillID));
                                }
                                return result;
                                }
                                private DataRow[] skillLinkRows(Employee emp) {
                                String filter = String.Format("employeeID = {0}", emp.Id);
                                return skillLinkTable.Select(filter);
                                }
                                private DataTable skillLinkTable {
                                get {return dsh.Data.Tables["skillEmployees"];}
                                }
                                To handle changes in skills information we use an update method on the
                                abstract mapper.
                                class AbstractMapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg, FindRow(arg.Id));
                                }
                                abstract protected void Save (DomainObject arg, DataRow row);
                                The update method calls a save method in the subclass.
                                class EmployeeMapper...
                                protected override void Save (DomainObject obj, DataRow row) {
                                Employee emp = (Employee) obj;
                                row["name"] = emp.Name;
                                saveSkills(emp);
                                }
                                Again, Iâ€™ve made a separate method for saving the skills.
                                class EmployeeMapper...
                                private void saveSkills(Employee emp) {
                                deleteSkills(emp);
                                foreach (Skill s in emp.Skills) {
                                DataRow row = skillLinkTable.NewRow();
                                row["employeeID"] = emp.Id;
                                row["skillID"] = s.Id;
                                skillLinkTable.Rows.Add(row);
                                }
                                }
                                private void deleteSkills(Employee emp) {
                                DataRow[] skillRows = skillLinkRows(emp);
                                foreach (DataRow r in skillRows) r.Delete();
                                }</pre>
                                The logic here does the simple thing of deleting all existing link table rows
                                and creating new ones. This saves me having to figure out which ones have been
                                added and deleted.</p>
                <h3 id="253">Example: Using Direct SQL (Java)</h3>
                <p>One of the nice things about ADO.NET is that it allows me to discuss the basics
                                of an object-relational mapping without getting into the sticky details of minimizing queries. With other relational mapping schemes youâ€™re closer to the SQL
                                and have to take much of that into account.
                                When youâ€™re going directly to the database itâ€™s important to minimize the
                                queries. For my first version of this Iâ€™ll pull back the employee and all her skills
                                in two queries. This is easy to follow but not quite optimal, so bear with me.</p>
                <p>Hereâ€™s the DDL for the tables:
                                create table employees (ID int primary key, firstname varchar, lastname varchar)
                                create table skills (ID int primary key, name varchar)
                                create table employeeSkills (employeeID int, skillID int, primary key (employeeID, skillID))
                                To load a single Employee Iâ€™ll follow a similar approach to what Iâ€™ve done
                                before. The employee mapper defines a simple wrapper for an abstract find
                                method on the Layer Supertype (475).
                                <pre>class EmployeeMapper...
                                public Employee find(long key) {
                                return find (new Long (key));
                                }
                                public Employee find (Long key) {
                                return (Employee) abstractFind(key);
                                }
                                protected String findStatement() {
                                return
                                "SELECT " + COLUMN_LIST +
                                " FROM employees" +
                                " WHERE ID = ?";
                                }
                                public static final String COLUMN_LIST = " ID, lastname, firstname ";
                                class AbstractMapper...
                                protected DomainObject abstractFind(Long id) {
                                DomainObject result = (DomainObject) loadedMap.get(id);
                                if (result != null) return result;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                254 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Association
                                Table
                                Mapping
                                try {
                                stmt = DB.prepare(findStatement());
                                stmt.setLong(1, id.longValue());
                                rs = stmt.executeQuery();
                                rs.next();
                                result = load(rs);
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }
                                abstract protected String findStatement();
                                protected Map loadedMap = new HashMap();</pre>
                                The find methods then call load methods. An abstract load method handles the
                                ID loading while the actual data for the employee is loaded on the employeeâ€™s
                                mapper.
                                <pre>class AbstractMapper...
                                protected DomainObject load(ResultSet rs) throws SQLException {
                                Long id = new Long(rs.getLong(1));
                                return load(id, rs);
                                }
                                public DomainObject load(Long id, ResultSet rs) throws SQLException {
                                if (hasLoaded(id)) return (DomainObject) loadedMap.get(id);
                                DomainObject result = doLoad(id, rs);
                                loadedMap.put(id, result);
                                return result;
                                }
                                abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                                class EmployeeMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                Employee result = new Employee(id);
                                result.setFirstName(rs.getString("firstname"));
                                result.setLastName(rs.getString("lastname"));
                                result.setSkills(loadSkills(id));
                                return result;
                                }
                                The employee needs to issue another query to load the skills, but it can easily
                                load all the skills in a single query. To do this it calls the skill mapper to load in
                                the data for a particular skill.
                                class EmployeeMapper...
                                protected List loadSkills(Long employeeID) {
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                List result = new ArrayList();
                                stmt = DB.prepare(findSkillsStatement);
                                stmt.setObject(1, employeeID);
                                rs = stmt.executeQuery();
                                while (rs.next()) {
                                Long skillId = new Long (rs.getLong(1));
                                result.add((Skill) MapperRegistry.skill().loadRow(skillId, rs));
                                }
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }
                                private static final String findSkillsStatement =
                                "SELECT skill.ID, " + SkillMapper.COLUMN_LIST +
                                " FROM skills skill, employeeSkills es " +
                                " WHERE es.employeeID = ? AND skill.ID = es.skillID";
                                class SkillMapper...
                                public static final String COLUMN_LIST = " skill.name skillName ";
                                class AbstractMapper...
                                protected DomainObject loadRow (Long id, ResultSet rs) throws SQLException {
                                return load (id, rs);
                                }
                                class SkillMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                Skill result = new Skill (id);
                                result.setName(rs.getString("skillName"));
                                return result;
                                }
                                The abstract mapper can also help find employees.
                                class EmployeeMapper...
                                public List findAll() {
                                return findAll(findAllStatement);
                                }
                                private static final String findAllStatement =
                                "SELECT " + COLUMN_LIST +
                                " FROM employees employee" +
                                " ORDER BY employee.lastname";
                                class AbstractMapper...
                                protected List findAll(String sql) {
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                256 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Association
                                Table
                                Mapping
                                try {
                                List result = new ArrayList();
                                stmt = DB.prepare(sql);
                                rs = stmt.executeQuery();
                                while (rs.next())
                                result.add(load(rs));
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }</pre>
                                All of this works quite well and is pretty simple to follow. Still, thereâ€™s a
                                problem in the number of queries, and that is that each employee takes two
                                SQL queries to load. Although we can load the basic employee data for many
                                employees in a single query, we still need one query per employee to load the
                                skills. Thus, loading a hundred employees takes 101 queries.</p>
                <h3 id="256">Example: Using a Single Query for Multiple Employees (Java)</h3>
                <p>Itâ€™s possible to bring back many employees, with their skills, in a single query.
                                This is a good example of multitable query optimization, which is certainly
                                more awkward. For that reason do this when you need to, rather than every
                                time. Itâ€™s better to put more energy into speeding up your slow queries than into
                                many queries that are less important.
                                The first case weâ€™ll look at is a simple one where we pull back all the skills
                                for an employee in the same query that holds the basic data. To do this Iâ€™ll use a
                                more complex SQL statement that joins across all three tables.
                                <pre>class EmployeeMapper...
                                protected String findStatement() {
                                return
                                "SELECT " + COLUMN_LIST +
                                " FROM employees employee, skills skill, employeeSkills es" +
                                " WHERE employee.ID = es.employeeID AND skill.ID = es.skillID AND employee.ID = ?";
                                }
                                public static final String COLUMN_LIST =
                                " employee.ID, employee.lastname, employee.firstname, " +
                                " es.skillID, es.employeeID, skill.ID skillID, " +
                                SkillMapper.COLUMN_LIST;</pre>
                                The abstractFind and load methods on the superclass are the same as in the
                                previous example, so I wonâ€™t repeat them here. The employee mapper loads its
                                data differently to take advantage of the multiple data rows.
                                <pre>class EmployeeMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                Employee result = (Employee) loadRow(id, rs);
                                loadSkillData(result, rs);
                                while (rs.next()){
                                Assert.isTrue(rowIsForSameEmployee(id, rs));
                                loadSkillData(result, rs);
                                }
                                return result;
                                }
                                protected DomainObject loadRow(Long id, ResultSet rs) throws SQLException {
                                Employee result = new Employee(id);
                                result.setFirstName(rs.getString("firstname"));
                                result.setLastName(rs.getString("lastname"));
                                return result;
                                }
                                private boolean rowIsForSameEmployee(Long id, ResultSet rs) throws SQLException {
                                return id.equals(new Long(rs.getLong(1)));
                                }
                                private void loadSkillData(Employee person, ResultSet rs) throws SQLException {
                                Long skillID = new Long(rs.getLong("skillID"));
                                person.addSkill ((Skill)MapperRegistry.skill().loadRow(skillID, rs));
                                }</pre>
                                In this case the load method for the employee mapper actually runs through the
                                rest of the result set to load in all the data.
                                All is simple when weâ€™re loading the data for a single employee. However,
                                the real benefit of this multitable query appears when we want to load lots of
                                employees. Getting the reading right can be tricky, particularly when we donâ€™t
                                want to force the result set to be grouped by employees. At this point itâ€™s handy
                                to introduce a helper class to go through the result set by focusing on the associative table itself, loading up the employees and skills as it goes along.
                                Iâ€™ll begin with the SQL and the call to the special loader class.
                                <pre>class EmployeeMapper...
                                public List findAll() {
                                return findAll(findAllStatement);
                                }
                                private static final String findAllStatement =
                                "SELECT " + COLUMN_LIST +
                                " FROM employees employee, skills skill, employeeSkills es" +
                                " WHERE employee.ID = es.employeeID AND skill.ID = es.skillID" +
                                " ORDER BY employee.lastname";
                                protected List findAll(String sql) {
                                AssociationTableLoader loader = new AssociationTableLoader(this, new SkillAdder());
                                return loader.run(findAllStatement);
                                }
                                class AssociationTableLoader...
                                private AbstractMapper sourceMapper;
                                private Adder targetAdder;
                                public AssociationTableLoader(AbstractMapper primaryMapper, Adder targetAdder) {
                                this.sourceMapper = primaryMapper;
                                this.targetAdder = targetAdder;
                                }</pre>
                                Donâ€™t worry about the skillAdderâ€”that will become a bit clearer later. For the
                                moment notice that we construct the loader with a reference to the mapper and
                                then tell it to perform a load with a suitable query. This is the typical structure
                                of a method object. A method object [Beck Patterns] is a way of turning a complicated method into an object on its own. The great advantage of this is that it
                                allows you to put values in fields instead of passing them around in parameters.
                                The usual way of using a method object is to create it, fire it up, and then let it
                                die once its duty is done.
                                The load behavior comes in three steps.
                                <pre>class AssociationTableLoader...
                                protected List run(String sql) {
                                loadData(sql);
                                addAllNewObjectsToIdentityMap();
                                return formResult();
                                }</pre>
                                The loadData method forms the SQL call, executes it, and loops through the
                                result set. Since this is a method object, Iâ€™ve put the result set in a field so I donâ€™t
                                have to pass it around.
                                <pre>class AssociationTableLoader...
                                private ResultSet rs = null;
                                private void loadData(String sql) {
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(sql);
                                rs = stmt.executeQuery();
                                while (rs.next())
                                loadRow();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }</pre>
                                The loadRow method loads the data from a single row in the result set. Itâ€™s a bit
                                complicated.
                                <pre>class AssociationTableLoader...
                                private List resultIds = new ArrayList();
                                private Map inProgress = new HashMap();
                                private void loadRow() throws SQLException {
                                Long ID = new Long(rs.getLong(1));
                                if (!resultIds.contains(ID)) resultIds.add(ID);
                                if (!sourceMapper.hasLoaded(ID)) {
                                if (!inProgress.keySet().contains(ID))
                                inProgress.put(ID, sourceMapper.loadRow(ID, rs));
                                targetAdder.add((DomainObject) inProgress.get(ID), rs);
                                }
                                }
                                class AbstractMapper...
                                boolean hasLoaded(Long id) {
                                return loadedMap.containsKey(id);
                                }</pre>
                                The loader preserves any order there is in the result set, so the output list of
                                employees will be in the same order in which it first appeared. So I keep a list of
                                IDs in the order I see them. Once Iâ€™ve got the ID I look to see if itâ€™s already fully
                                loaded in the mapperâ€”usually from a previous query. If not, I load what data I
                                have and keep it in an in-progress list. I need such a list since several rows will
                                combine to gather all the data from the employee and I may not hit those rows
                                consecutively.
                                The trickiest part to this code is ensuring that I can add the skill Iâ€™m loading
                                to the employeesâ€™ list of skills, but still keep the loader generic so it doesnâ€™t
                                depend on employees and skills. To achieve this I need to dig deep into my bag
                                of tricks to find an inner interfaceâ€”the Adder.
                                <pre>class AssociationTableLoader...
                                public static interface Adder {
                                void add(DomainObject host, ResultSet rs) throws SQLException ;
                                }
                                The original caller has to supply an implementation for the interface to bind
                                it to the particular needs of the employee and skill.
                                class EmployeeMapper...
                                private static class SkillAdder implements AssociationTableLoader.Adder {
                                public void add(DomainObject host, ResultSet rs) throws SQLException {
                                Employee emp = (Employee) host;
                                Long skillId = new Long (rs.getLong("skillId"));
                                emp.addSkill((Skill) MapperRegistry.skill().loadRow(skillId, rs));
                                }
                                }</pre>
                                This is the kind of thing that comes more naturally to languages that have
                                function pointers or closures, but at least the class and interface get the job
                                done. (They donâ€™t have to be inner in this case, but it helps bring out their narrow scope.)
                                You may have noticed that I have a load and a loadRow method defined on the
                                superclass and the implementation of the loadRow is to call load. I did this
                                because there are times when you want to be sure that a load action will not
                                move the result set forward. The load does whatever it needs to do to load an
                                object, but loadRow guarantees to load data from a row without altering the position of the cursor. Most of the time these two are the same thing, but in the case
                                of this employee mapper theyâ€™re different.
                                Now all the data is in from the result set. I have two collections: a list of all
                                the employee IDs that were in the result set in the order of first appearance and
                                a list of new objects that havenâ€™t yet made an appearance in the employee mapperâ€™s Identity Map (195).
                                The next step is to put all the new objects into the Identity Map (195).
                                <pre>class AssociationTableLoader...
                                private void addAllNewObjectsToIdentityMap() {
                                for (Iterator it = inProgress.values().iterator(); it.hasNext();)
                                sourceMapper.putAsLoaded((DomainObject)it.next());
                                }
                                class AbstractMapper...
                                void putAsLoaded (DomainObject obj) {
                                loadedMap.put (obj.getID(), obj);
                                }
                                The final step is to assemble the result list by looking up the IDs from the
                                mapper.
                                class AssociationTableLoader...
                                private List formResult() {
                                List result = new ArrayList();
                                for (Iterator it = resultIds.iterator(); it.hasNext();) {
                                Long id = (Long)it.next();
                                result.add(sourceMapper.lookUp(id));
                                }
                                return result;
                                }
                                class AbstractMapper...
                                protected DomainObject lookUp (Long id) {
                                return (DomainObject) loadedMap.get(id);
                                }</pre>
                                Such code is more complex than the average loading code, but this kind of
                                thing can help cut down the number of queries. Since itâ€™s complicated, this is
                                something to be used sparingly when you have laggardly bits of database interaction. However, itâ€™s an example of how Data Mapper (165) can provide good
                                queries without the domain layer being aware of the complexity involved.</p>
                <h3 id="262">Dependent Mapping</h3>
                <p><img src="img/part2.15.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Has one class perform the database mapping for a child class.
                                Some objects naturally appear in the context of other objects. Tracks on an
                                album may be loaded or saved whenever the underlying album is loaded or
                                saved. If they arenâ€™t referenced to by any other table in the database, you can
                                simplify the mapping procedure by having the album mapper perform the mapping for the tracks as wellâ€”treating this mapping as a dependent mapping.</p>
                <h3 id="262(2)">How It Works</h3>
                <p>The basic idea behind Dependent Mapping is that one class (the dependent)
                                relies upon some other class (the owner) for its database persistence. Each
                                dependent can have only one owner and must have one owner.
                                This manifests itself in terms of the classes that do the mapping. For Active
                                Record (160) and Row Data Gateway (152), the dependent class wonâ€™t contain
                                any database mapping code; its mapping code sits in the owner. With Data
                                Mapper (165) thereâ€™s no mapper for the dependent, the mapping code sits in the
                                mapper for the owner. In a Table Data Gateway (144) there will typically be no
                                dependent class at all, all the handling of the dependent is done in the owner.
                                In most cases every time you load an owner, you load the dependents too. If
                                the dependents are expensive to load and infrequently used, you can use a Lazy
                                Load (200) to avoid loading the dependents until you need them.
                                An important property of a dependent is that it doesnâ€™t have an Identity
                                Field (216) and therefore isnâ€™t stored in a Identity Map (195). It therefore canAlbum
                                not be loaded by a find method that looks up an ID. Indeed, thereâ€™s no finder
                                for a dependent since all finds are done with the owner.</p>
                <p>A dependent may itself be the owner of another dependent. In this case the
                                owner of the first dependent is also responsible for the persistence of the second
                                dependent. You can have a whole hierarchy of dependents controlled by a single primary owner.
                                Itâ€™s usually easier for the primary key on the database to be a composite key
                                that includes the ownerâ€™s primary key. No other table should have a foreign key
                                into the dependentâ€™s table, unless that object has the same owner. As a result, no
                                in-memory object other than the owner or its dependents should have a reference to a dependent. Strictly speaking, you can relax that rule providing that
                                the reference isnâ€™t persisted to the database, but having a nonpersistent reference is itself a good source of confusion.
                                In a UML model, itâ€™s appropriate to use composition to show the relationship between an owner and its dependents.
                                Since the writing and saving of dependents is left to the owner, and there are
                                no outside references, updates to the dependents can be handled through deletion and insertion. Thus, if you want to update the collection of dependents you
                                can safely delete all rows that link to the owner and then reinsert all the dependents. This saves you from having to do an analysis of objects added or
                                removed from the ownerâ€™s collection.</p>
                <p>Dependents are in many ways like Value Objects (486), although they often
                                donâ€™t need the full mechanics that you use in making something a Value Object
                                (486) (such as overriding equals). The main difference is that thereâ€™s nothing
                                special about them from a purely in-memory point of view. The dependent
                                nature of the objects is only really due to the database mapping behavior.
                                Using Dependent Mapping complicates tracking whether the owner has
                                changed. Any change to a dependent needs to mark the owner as changed so
                                that the owner will write the changes out to the database. You can simplify this
                                considerably by making the dependent immutable, so that any change to it
                                needs to be done by removing it and adding a new one. This can make the inmemory model harder to work with, but it does simplify the database mapping.
                                While in theory the in-memory and database mapping should be independent
                                when youâ€™re using Data Mapper (165), in practice you have to make the occasional compromise.</p>
                <h3 id="263">When to Use It</h3>
                <p>You use Dependent Mapping when you have an object thatâ€™s only referred to by
                                one other object, which usually occurs when one object has a collection of
                                dependents. Dependent Mapping is a good way of dealing with the awkward
                                situation where the owner has a collection of references to its dependents but
                                thereâ€™s no back pointer. Providing that the many objects donâ€™t need their own
                                identity, using Dependent Mapping makes it easier to manage their persistence.
                                For Dependent Mapping to work there are a number of preconditions.
                                â€¢ A dependent must have exactly one owner.
                                â€¢ There must be no references from any object other than the owner to the
                                dependent.
                                There is a school of OO design that uses the notion of entity objects and
                                dependent objects when designing a Domain Model (116). I tend to think of
                                Dependent Mapping as a technique to simplify database mapping rather than
                                as a fundamental OO design medium. In particular, I avoid large graphs of
                                dependents. The problem with them is that itâ€™s impossible to refer to a dependent from outside the graph, which often leads to complex lookup schemes
                                based around the root owner.
                                I donâ€™t recommend Dependent Mapping if youâ€™re using Unit of Work (184).
                                The delete and reinsert strategy doesnâ€™t help at all if you have a Unit of Work
                                (184) keeping track of things. It can also lead to problems since the Unit of
                                Work (184) isnâ€™t controlling the dependents. Mike Rettig told me about an
                                application where a Unit of Work (184) would keep track of rows inserted for
                                testing and then delete them all when done. Because it didnâ€™t track dependents,
                                orphan rows appeared and caused failures in the test runs.</p>
                <h3 id="264">Example: Albums and Tracks (Java)</h3>
                <p>In this domain model (Figure 12.7) an album holds a collection of tracks. This
                                uselessly simple application doesnâ€™t need anything else to refer to a track, so itâ€™s
                                an obvious candidate for Dependent Mapping. (Indeed, anyone would think
                                the example is deliberately constructed for the pattern.)
                <p><img src="img/figure 12.7.png" alt="no img" style="margin-left: 200px;"></p>
                                This track just has a title. Iâ€™ve defined it as an immutable class.
                                <pre>class Track...
                                private final String title;
                                public Track(String title) {
                                this.title = title;
                                }
                                public String getTitle() {
                                return title;
                                }
                                The tracks are held in the album class.
                                class Album...
                                private List tracks = new ArrayList();
                                public void addTrack(Track arg) {
                                tracks.add(arg);
                                }
                                public void removeTrack(Track arg) {
                                tracks.remove(arg);
                                };
                                public void removeTrack(int i) {
                                tracks.remove(i);
                                }
                                public Track[] getTracks() {
                                return (Track[]) tracks.toArray(new Track[tracks.size()]);
                                }
                                The album mapper class handles all the SQL for tracks and thus defines the
                                SQL statements that access the tracks table.
                                class AlbumMapper...
                                protected String findStatement() {
                                return
                                "SELECT ID, a.title, t.title as trackTitle" +
                                " FROM albums a, tracks t" +
                                " WHERE a.ID = ? AND t.albumID = a.ID" +
                                " ORDER BY t.seq";
                                }
                                The tracks are loaded into the album whenever the album is loaded.
                                class AlbumMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String title = rs.getString(2);
                                Album result = new Album(id, title);
                                loadTracks(result, rs);
                                return result;
                                266 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Dependent
                                Mapping
                                }
                                public void loadTracks(Album arg, ResultSet rs) throws SQLException {
                                arg.addTrack(newTrack(rs));
                                while (rs.next()) {
                                arg.addTrack(newTrack(rs));
                                }
                                }
                                private Track newTrack(ResultSet rs) throws SQLException {
                                String title = rs.getString(3);
                                Track newTrack = new Track (title);
                                return newTrack;
                                }</pre>
                                For clarity Iâ€™ve done the track load in a separate query. For performance, you
                                might want to consider loading them in the same query along the lines of the
                                example on page 243.
                                When the album is updated all the tracks are deleted and reinserted.
                                <pre>class AlbumMapper...
                                public void update(DomainObject arg) {
                                PreparedStatement updateStatement = null;
                                try {
                                updateStatement = DB.prepare("UPDATE albums SET title = ? WHERE id = ?");
                                updateStatement.setLong(2, arg.getID().longValue());
                                Album album = (Album) arg;
                                updateStatement.setString(1, album.getTitle());
                                updateStatement.execute();
                                updateTracks(album);
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(updateStatement);
                                }
                                }
                                public void updateTracks(Album arg) throws SQLException {
                                PreparedStatement deleteTracksStatement = null;
                                try {
                                deleteTracksStatement = DB.prepare("DELETE from tracks WHERE albumID = ?");
                                deleteTracksStatement.setLong(1, arg.getID().longValue());
                                deleteTracksStatement.execute();
                                for (int i = 0; i < arg.getTracks().length; i++) {
                                Track track = arg.getTracks()[i];
                                insertTrack(track, i + 1, arg);
                                }
                                } finally {DB.cleanUp(deleteTracksStatement);
                                }
                                }
                                public void insertTrack(Track track, int seq, Album album) throws SQLException {
                                PreparedStatement insertTracksStatement = null;
                                DEPENDENT MAPPING 267
                                Dependent
                                Mapping
                                try {
                                insertTracksStatement =
                                DB.prepare("INSERT INTO tracks (seq, albumID, title) VALUES (?, ?, ?)");
                                insertTracksStatement.setInt(1, seq);
                                insertTracksStatement.setLong(2, album.getID().longValue());
                                insertTracksStatement.setString(3, track.getTitle());
                                insertTracksStatement.execute();
                                } finally {DB.cleanUp(insertTracksStatement);
                                }
                                }</pre></p>
                <h3 id="268">Embedded Value</h3>
                <p><img src="img/part2.16.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Maps an object into several fields of another objectâ€™s table.
                                Many small objects make sense in an OO system that donâ€™t make sense as
                                tables in a database. Examples include currency-aware money objects and date
                                ranges. Although the default thinking is to save an object as a table, no sane
                                person would want a table of money values.
                                An Embedded Value maps the values of an object to fields in the record of
                                the objectâ€™s owner. In the sketch we have an employment object with links to a
                                date range object and a money object. In the resulting table the fields in those
                                objects map to fields in the employment table rather than make new records
                                themselves.</p>
                <h3 id="268(2)">How It Works</h3>
                <p>This exercise is actually quite simple. When the owning object (employment) is
                                loaded or saved, the dependent objects (date range and money) are loaded and
                                saved at the same time. The dependent classes wonâ€™t have their own persistence
                                methods since all persistence is done by the owner. You can think of Embedded
                                Value as a special case of Dependent Mapping (262), where the value is a single
                                dependent object.</p>
                <h3 id="268(3)">When to Use It</h3>
                <p>This is one of those patterns where the doing of it is very straightforward, but
                                knowing when to use it a little more complicated.
                                The simplest cases for Embedded Value are the clear, simple Value Objects
                                (486) like money and date range. Since Value Objects (486) donâ€™t have identity,
                                you can create and destroy them easily without worrying about such things as
                                Identity Maps (195) to keep them all in sync. Indeed, all Value Objects (486)
                                should be persisted as Embedded Value, since you would never want a table for
                                them there.
                                The grey area is in whether itâ€™s worth storing reference objects, such as an
                                order and a shipping object, using Embedded Value. The principal question
                                here is whether the shipping data has any relevance outside the context of the
                                order. One issue is the loading and saving. If you only load the shipping data
                                into memory when you load the order, thatâ€™s an argument for saving both in the
                                same table. Another question is whether youâ€™ll want to access the shipping data
                                separately though SQL. This can be important if youâ€™re reporting through SQL
                                and donâ€™t have a separate database for reporting.</p>
                <p>If youâ€™re mapping to an existing schema, you can use Embedded Value when
                                a table contains data that you split into more than one object in memory. This
                                may occur because you want a separate object to factor out some behavior in the
                                object model, but itâ€™s all still one entity in the database. In this case you have to
                                be careful that any change to the dependent marks the owner as dirtyâ€”which
                                isnâ€™t an issue with Value Objects (486) that are replaced in the owner.
                                In most cases youâ€™ll only use Embedded Value on a reference object when the
                                association between them is single valued at both ends (a one-to-one association). Occasionally you may use it if there are multiple candidate dependents
                                and their number is small and fixed. Then youâ€™ll have numbered fields for each
                                value. This is messy table design, and horrible to query in SQL, but it may have
                                performance benefits. If this is the case, however, Serialized LOB (272) is usually the better choice.</p>
                <p>Since so much of the logic for deciding when to use Embedded Value is the
                                same as for Serialized LOB (272), thereâ€™s the obvious matter of choosing
                                between the two. The great advantage of Embedded Value is that it allows SQL
                                queries to be made against the values in the dependent object. Although using
                                XML as the serialization, together with XML-based query add-ons to SQL,
                                may alter that in the future, at the moment you really need Embedded Value if
                                you want to use dependent values in a query. This may be important for separate reporting mechanisms on the database
                                Embedded Value can only be used for fairly simple dependents. A solitary
                                dependent, or a few separated dependents, works well. Serialized LOB (272)
                                works with more complex structures, including potentially large object subgraphs.
                                270 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Embedded
                                Value</p>
                <h3 id="270">Further Reading</h3>
                <p>Embedded Value has been called a couple of different names in its history.
                                TOPLink refers to it as aggregate mapping. Visual Age refers to it as composer.</p>
                <h3 id="270(2)">Example: Simple Value Object (Java)</h3>
                <p>This is the classic example of a value object mapped with Embedded Value.
                                Weâ€™ll begin with a simple product offering class with the following fields.
                                <pre>class ProductOffering...
                                private Product product;
                                private Money baseCost;
                                private Integer ID;</pre>
                                In these fields the ID is an Identity Field (216) and the product is a regular
                                record mapping. Weâ€™ll map the base cost using Embedded Value. Weâ€™ll do the
                                overall mapping with Active Record (160) to keep things simple.
                                Since weâ€™re using Active Record (160) we need save and load routines. These
                                simple routines are in the product offering class because itâ€™s the owner. The
                                money class has no persistence behavior at all. Hereâ€™s the load method.
                                <pre>class ProductOffering...
                                public static ProductOffering load(ResultSet rs) {
                                try {
                                Integer id = (Integer) rs.getObject("ID");
                                BigDecimal baseCostAmount = rs.getBigDecimal("base_cost_amount");
                                Currency baseCostCurrency = Registry.getCurrency(rs.getString("base_cost_currency"));
                                Money baseCost = new Money(baseCostAmount, baseCostCurrency);
                                Integer productID = (Integer) rs.getObject("product");
                                Product product = Product.find((Integer) rs.getObject("product"));
                                return new ProductOffering(id, product, baseCost);
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                }
                                }
                                Hereâ€™s the update behavior. Again itâ€™s a simple variation on the updates.
                                class ProductOffering...
                                public void update() {
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(updateStatementString);
                                stmt.setBigDecimal(1, baseCost.amount());
                                stmt.setString(2, baseCost.currency().code());
                                stmt.setInt(3, ID.intValue());
                                stmt.execute();
                                } catch (Exception e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt);}
                                }
                                private String updateStatementString =
                                "UPDATE product_offerings" +
                                " SET base_cost_amount = ?, base_cost_currency = ? " +
                                " WHERE id = ?";</pre></p>
                <h3 id="272">Serialized LOB</h3>
                <p><img src="img/part2.17.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Saves a graph of objects by serializing them into a single large object
                                (LOB), which it stores in a database field.
                                Object models often contain complicated graphs of small objects. Much of the
                                information in these structures isnâ€™t in the objects but in the links between
                                them. Consider storing the organization hierarchy for all your customers. An
                                object model quite naturally shows the composition pattern to represent organizational hierarchies, and you can easily add methods that allow you to get
                                ancestors, siblings, descendents, and other common relationships.
                                Not so easy is putting all this into a relational schema. The basic schema is
                                simpleâ€”an organization table with a parent foreign key, however, its manipulation of the schema requires many joins, which are both slow and awkward.
                                Objects donâ€™t have to be persisted as table rows related to each other.
                                Another form of persistence is serialization, where a whole graph of objects is
                                written out as a single large object (LOB) in a table this Serialized LOB then
                                becomes a form of memento [Gang of Four].</p>
                <h3 id="272(2)">How It Works</h3>
                <p>There are two ways you can do the serialization: as a binary (BLOB) or as textual characters (CLOB). The BLOB is often the simplest to create since many
                                platforms include the ability to automatically serialize an object graph. Saving
                                the graph is a simple matter of applying the serialization in a buffer and saving
                                that buffer in the relevant field.
                                The advantages of the BLOB are that itâ€™s simple to program (if your platform supports it) and that it uses the minimum of space. The disadvantages
                                are that your database must support a binary data type for it and that you
                                canâ€™t reconstruct the graph without the object, so the field is utterly impenetrable to casual viewing. The most serious problem, however, is versioning. If
                                you change the department class, you may not be able to read all its previous
                                serializations; since data can live in the database for a long time, this is no
                                small thing.</p>
                <p>The alternative is a CLOB. In this case you serialize the department graph
                                into a text string that carries all the information you need. The text string can
                                be read easily by a human viewing the row, which helps in casual browsing of
                                the database. However the text approach will usually need more space, and you
                                may need to create your own parser for the textual format you use. Itâ€™s also
                                likely to be slower than a binary serialization.
                                Many of the disadvantages of CLOBs can be overcome with XML. XML
                                parsers are commonly available, so you donâ€™t have to write your own. Furthermore, XML is a widely supported standard so you can take advantage of tools
                                as they become available to do further manipulations. The disadvantage that
                                XML doesnâ€™t help with is the matter of space. Indeed, it makes the space issue
                                much worse because its a very verbose format. One way to deal with that is to
                                use a zipped XML format as your BLOBâ€”you lose the direct human readability, but itâ€™s an option if space is a real issue.</p>
                <p>When you use Serialized LOB beware of identity problems. Say you want to
                                use Serialized LOB for the customer details on an order. For this donâ€™t put the
                                customer LOB in the order table; otherwise, the customer data will be copied
                                on every order, which makes updates a problem. (This is actually a good thing,
                                however, if you want to store a snapshot of the customer data as it was at the
                                placing of the orderâ€”it avoids temporal relationships.) If you want your customer data to be updated for each order in the classical relational sense, you
                                need to put the LOB in a customer table so many orders can link to it. Thereâ€™s
                                nothing wrong with a table that just has an ID and a single LOB field for its
                                data.
                                In general, be careful of duplicating data when using this pattern. Often itâ€™s
                                not a whole Serialized LOB that gets duplicated but part of one that overlaps
                                with another one. The thing to do is to pay careful attention to the data thatâ€™s
                                stored in the Serialized LOB and be sure that it canâ€™t be reached from anywhere
                                but a single object that acts as the owner of the Serialized LOB.</p>
                <h3 id="274">When to Use It</h3>
                <p>Serialized LOB isnâ€™t considered as often as it might be. XML makes it much more
                                attractive since it yields a easy-to-implement textual approach. Its main disadvantage is that you canâ€™t query the structure using SQL. SQL extensions appear to
                                get at XML data within a field, but thatâ€™s still not the same (or portable).
                                This pattern works best when you can chop out a piece of the object model
                                and use it to represent the LOB. Think of a LOB as a way to take a bunch of
                                objects that arenâ€™t likely to be queried from any SQL route outside the application. This graph can then be hooked into the SQL schema.
                                Serialized LOB works poorly when you have objects outside the LOB reference objects buried in it. To handle this you have to come up with some form of
                                referencing scheme that can support references to objects inside a LOBâ€”itâ€™s by
                                no means impossible, but itâ€™s awkward, awkward enough usually not to be worth
                                doing. Again XML, or rather XPath, reduces this awkwardness somewhat.
                                If youâ€™re using a separate database for reporting and all other SQL goes
                                against that database, you can transform the LOB into a suitable table structure. The fact that a reporting database is usually denormalized means that
                                structures suitable for Serialized LOB are often also suitable for a separate
                                reporting database.</p>
                <h3 id="274(2)">Example: Serializing a Department Hierarchy in XML (Java)</h3>
                <p>For this example weâ€™ll take the notion of customers and departments from the
                                sketch and show how you might serialize all the departments into an XML
                                CLOB. As I write this, Javaâ€™s XML handling is somewhat primitive and volatile,
                                so the code may look different when you get to it (Iâ€™m also using an early version of JDOM).
                                The object model of the sketch turns into the following class structures:
                                <pre>class Customer...
                                private String name;
                                private List departments = new ArrayList();
                                class Department...
                                private String name;
                                private List subsidiaries = new ArrayList();</pre>
                                The database for this has only one table.
                                create table customers (ID int primary key, name varchar, departments varchar)
                                Weâ€™ll treat the customer as an Active Record (160) and illustrate writing the
                                data with the insert behavior.
                                <pre>class Customer...
                                public Long insert() {
                                PreparedStatement insertStatement = null;
                                try {
                                insertStatement = DB.prepare(insertStatementString);
                                setID(findNextDatabaseId());
                                insertStatement.setInt(1, getID().intValue());
                                insertStatement.setString(2, name);
                                insertStatement.setString(3, XmlStringer.write(departmentsToXmlElement()));
                                insertStatement.execute();
                                Registry.addCustomer(this);
                                return getID();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(insertStatement);
                                }
                                }
                                public Element departmentsToXmlElement() {
                                Element root = new Element("departmentList");
                                Iterator i = departments.iterator();
                                while (i.hasNext()) {
                                Department dep = (Department) i.next();
                                root.addContent(dep.toXmlElement());
                                }
                                return root;
                                }
                                class Department...
                                Element toXmlElement() {
                                Element root = new Element("department");
                                root.setAttribute("name", name);
                                Iterator i = subsidiaries.iterator();
                                while (i.hasNext()) {
                                Department dep = (Department) i.next();
                                root.addContent(dep.toXmlElement());
                                }
                                return root;
                                }</pre>
                                The customer has a method for serializing its departments field into a single
                                XML DOM. Each department has a method for serializing itself (and its subsidiaries recursively) into a DOM as well. The insert method then takes the
                                DOM of the departments, converts it into a string (via a utility class) and puts it
                                in the database. We arenâ€™t particularly concerned with the structure of the
                                string. Itâ€™s human readable, but we arenâ€™t going to look at it on a regular basis.
                                <pre>&lt;?xml version="1.0" encoding="UTF-8"?>
                                &lt;departmentList&gt;
                                &lt;department name="US"&gt;
                                &lt;department name="New England"&gt;
                                &lt;department name="Boston" /&gt;
                                &lt;department name="Vermont" /&gt;
                                &lt;/department&gt;
                                &lt;department name="California" /&gt;
                                &lt;department name="Mid-West" /&gt;
                                &lt;/department&gt;
                                &lt;department name="Europe" /&gt;
                                &lt;/departmentList&gt;</pre>
                                Reading back is a fairly simple reversal of this process.
                                <pre>class Customer...
                                public static Customer load(ResultSet rs) throws SQLException {
                                Long id = new Long(rs.getLong("id"));
                                Customer result = (Customer) Registry.getCustomer(id);
                                if (result != null) return result;
                                String name = rs.getString("name");
                                String departmentLob = rs.getString("departments");
                                result = new Customer(name);
                                result.readDepartments(XmlStringer.read(departmentLob));
                                return result;
                                }
                                void readDepartments(Element source) {
                                List result = new ArrayList();
                                Iterator it = source.getChildren("department").iterator();
                                while (it.hasNext())
                                addDepartment(Department.readXml((Element) it.next()));
                                }
                                class Department...
                                static Department readXml(Element source) {
                                String name = source.getAttributeValue("name");
                                Department result = new Department(name);
                                Iterator it = source.getChildren("department").iterator();
                                while (it.hasNext())
                                result.addSubsidiary(readXml((Element) it.next()));
                                return result;
                                }</pre>
                                The load code is obviously a mirror image of the insert code. The department
                                knows how to create itself (and its subsidiaries) from an XML element, and the
                                customer knows how to take an XML element and create the list of depart-
                                ments from it. The load method uses a utility class to turn the string from the
                                database into a utility element.
                                An obvious danger here is that someone may try to edit the XML by hand in
                                the database and mess up the XML, making it unreadable by the load routine.
                                More sophisticated tools that would support adding a DTD or XML schema to
                                a field as validation will obviously help with that.</p>
                <h3 id="278">Single Table Inheritance</h3>
                <p><img src="img/part2.18.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Represents an inheritance hierarchy of classes as a single table that
                                has columns for all the fields of the various classes.
                                Relational databases donâ€™t support inheritance, so when mapping from objects
                                to databases we have to consider how to represent our nice inheritance structures in relational tables. When mapping to a relational database, we try to
                                minimize the joins that can quickly mount up when processing an inheritance
                                structure in multiple tables. Single Table Inheritance maps all fields of all classes
                                of an inheritance structure into a single table.</p>
                <h3 id="278(2)">How It Works</h3>
                <p>In this inheritance mapping scheme we have one table that contains all the data
                                for all the classes in the inheritance hierarchy. Each class stores the data thatâ€™s
                                relevant to it in one table row. Any columns in the database that arenâ€™t relevant
                                are left empty. The basic mapping behavior follows the general scheme of
                                Inheritance Mappers (302).
                                When loading an object into memory you need to know which class to
                                instantiate. For this you have a field in the table that indicates which class
                                should be used. This can be the name of the class or a code field. A code field
                                needs to be interpreted by some code to map it to the relevant class. This code
                                needs to be extended when a class is added to the hierarchy. If you embed the
                                class name in the table you can just use it directly to instantiate an instance. The
                                class name, however, will take up more space and may be less easy to process by
                                those using the database table structure directly. As well it may more closely
                                couple the class structure to the database schema.
                                In loading data you read the code first to figure out which subclass to instantiate. On saving the data the code needs be written out by the superclass in the
                                hierarchy.</p>
                <h3 id="279">When to Use It</h3>
                <p>Single Table Inheritance is one of the options for mapping the fields in an inheritance hierarchy to a relational database. The alternatives are Class Table Inheritance (285) and Concrete Table Inheritance (293).
                                These are the strengths of Single Table Inheritance:
                <ul>
                        <li>Thereâ€™s only a single table to worry about on the database.</li>
                        <li>There are no joins in retrieving data.</li>
                        <li>Any refactoring that pushes fields up or down the hierarchy doesnâ€™t require you to change the database.</li>
                </ul>
                The weaknesses of Single Table Inheritance are
                <ul>
                        <li>Fields are sometimes relevant and sometimes not, which can be confusing to people using the tables directly.</li>
                        <li>Columns used only by some subclasses lead to wasted space in the database. How much this is actually a problem depends on the specific data characteristics and how well the database compresses empty columns. Oracle, for example, is very efficient in trimming wasted space, particularly if you keep your optional columns to the right side of the database table. Each database has its own tricks for this.</li>
                        <li>The single table may end up being too large, with many indexes and frequent locking, which may hurt performance. You can avoid this by having separate index tables that either list keys of rows that have a certain property or that copy a subset of fields relevant to an index.</li>
                        <li>You only have a single namespace for fields, so you have to be sure that you donâ€™t use the same name for different fields. Compound names with the name of the class as a prefix or suffix help here.</li>
                </ul>
                                Remember that you donâ€™t need to use one form of inheritance mapping for
                                your whole hierarchy. Itâ€™s perfectly fine to map half a dozen similar classes in a
                                single table, as long as you use Concrete Table Inheritance (293) for any classes
                                that have a lot of specific data.</p>
                <h3 id="280">Example: A Single Table for Players (C#)</h3>
                <p>Like the other inheritance examples, Iâ€™ve based this one on Inheritance Mappers
                                (302), using the classes in Figure 12.8. Each mapper needs to be linked to a data
                                table in an ADO.NET data set. This link can be made generically in the mapper
                                superclass. The gatewayâ€™s data property is a data set that can be loaded by a
                                query.
                <p><img src="img/figure 12.8.png" alt="no img" style="margin-left: 200px;"></p>
                                <pre>class Mapper...
                                protected DataTable table {
                                get {return Gateway.Data.Tables[TableName];}
                                }
                                protected Gateway Gateway;
                                abstract protected String TableName {get;}
                                Since there is only one table, this can be defined by the abstract player
                                mapper.
                                class AbstractPlayerMapper...
                                protected override String TableName {
                                get {return "Players";}
                                }</pre>
                                Each class needs a type code to help the mapper code figure out what kind of
                                player itâ€™s dealing with. The type code is defined on the superclass and implemented in the subclasses.
                                <pre>class AbstractPlayerMapper...
                                abstract public String TypeCode {get;}
                                class CricketerMapper...
                                public const String TYPE_CODE = "C";
                                public override String TypeCode {
                                get {return TYPE_CODE;}
                                }
                                The player mapper has fields for each of the three concrete mapper classes.
                                class PlayerMapper...
                                private BowlerMapper bmapper;
                                private CricketerMapper cmapper;
                                private FootballerMapper fmapper;
                                public PlayerMapper (Gateway gateway) : base (gateway) {
                                bmapper = new BowlerMapper(Gateway);
                                cmapper = new CricketerMapper(Gateway);
                                fmapper = new FootballerMapper(Gateway);
                                }</pre></p>
                <h3 id="281">Loading an Object from the Database</h3>
                <p>Each concrete mapper class has a find method to get an object from the data.
                                <pre>class CricketerMapper...
                                public Cricketer Find(long id) {
                                return (Cricketer) AbstractFind(id);
                                }</pre>
                                This calls generic behavior to find an object.
                                <pre>class Mapper...
                                protected DomainObject AbstractFind(long id) {
                                DataRow row = FindRow(id);
                                return (row == null) ? null : Find(row);
                                }
                                protected DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                }
                                public DomainObject Find (DataRow row) {
                                DomainObject result = CreateDomainObject();
                                Load(result, row);
                                return result;
                                }
                                abstract protected DomainObject CreateDomainObject();
                                class CricketerMapper...
                                protected override DomainObject CreateDomainObject() {
                                return new Cricketer();
                                }</pre>
                                I load the data into the new object with a series of load methods, one on each
                                class in the hierarchy.
                                <pre>class CricketerMapper...
                                protected override void Load(DomainObject obj, DataRow row) {
                                base.Load(obj,row);
                                Cricketer cricketer = (Cricketer) obj;
                                cricketer.battingAverage = (double)row["battingAverage"];
                                }
                                class AbstractPlayerMapper...
                                protected override void Load(DomainObject obj, DataRow row) {
                                base.Load(obj, row);
                                Player player = (Player) obj;
                                player.name = (String)row["name"];
                                }
                                class Mapper...
                                protected virtual void Load(DomainObject obj, DataRow row) {
                                obj.Id = (int) row ["id"];
                                }</pre>
                                I can also load a player through the player mapper. It needs to read the data and
                                use the type code to determine which concrete mapper to use.
                                <pre>class PlayerMapper...
                                public Player Find (long key) {
                                DataRow row = FindRow(key);
                                if (row == null) return null;
                                else {
                                String typecode = (String) row["type"];
                                switch (typecode){
                                case BowlerMapper.TYPE_CODE:
                                return (Player) bmapper.Find(row);
                                case CricketerMapper.TYPE_CODE:
                                return (Player) cmapper.Find(row);
                                case FootballerMapper.TYPE_CODE:
                                return (Player) fmapper.Find(row);
                                default:
                                throw new Exception("unknown type");
                                }
                                }
                                }</pre>
                                Updating an Object The basic operation for updating is the same for all
                                objects, so I can define the operation on the mapper superclass.
                                <pre>class Mapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg, FindRow(arg.Id));
                                }
                                The save method is similar to the load methodâ€”each class defines it to save
                                the data it contains.
                                class CricketerMapper...
                                protected override void Save(DomainObject obj, DataRow row) {
                                base.Save(obj, row);
                                Cricketer cricketer = (Cricketer) obj;
                                row["battingAverage"] = cricketer.battingAverage;
                                }
                                class AbstractPlayerMapper...
                                protected override void Save(DomainObject obj, DataRow row) {
                                Player player = (Player) obj;
                                row["name"] = player.name;
                                row["type"] = TypeCode;
                                }</pre>
                                The player mapper forwards to the appropriate concrete mapper.
                                <pre>class PlayerMapper...
                                public override void Update (DomainObject obj) {
                                MapperFor(obj).Update(obj);
                                }
                                private Mapper MapperFor(DomainObject obj) {
                                if (obj is Footballer)
                                return fmapper;
                                if (obj is Bowler)
                                return bmapper;
                                if (obj is Cricketer)
                                return cmapper;
                                throw new Exception("No mapper available");
                                }</pre>
                                Inserting an Object Insertions are similar to updates; the only real difference is
                                that a new row needs to be made in the table before saving.
                                <pre>class Mapper...
                                public virtual long Insert (DomainObject arg) {
                                DataRow row = table.NewRow();
                                arg.Id = GetNextID();
                                row["id"] = arg.Id;
                                Save (arg, row);
                                table.Rows.Add(row);
                                return arg.Id;
                                }
                                class PlayerMapper...
                                public override long Insert (DomainObject obj) {
                                return MapperFor(obj).Insert(obj);
                                }
                                Deleting an Object Deletes are pretty simple. Theyâ€™re defined at the abstract
                                mapper level or in the player wrapper.
                                class Mapper...
                                public virtual void Delete(DomainObject obj) {
                                DataRow row = FindRow(obj.Id);
                                row.Delete();
                                }
                                class PlayerMapper...
                                public override void Delete (DomainObject obj) {
                                MapperFor(obj).Delete(obj);
                                }</pre></p>
                <h3 id="285">Class Table Inheritance</h3>
                <p><img src="img/part2.19.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Represents an inheritance hierarchy of classes
                                with one table for each class.
                                A very visible aspect of the object-relational mismatch is the fact that relational
                                databases donâ€™t support inheritance. You want database structures that map
                                clearly to the objects and allow links anywhere in the inheritance structure.
                                Class Table Inheritance supports this by using one database table per class in
                                the inheritance structure.</p>
                <h3 id="285(2)">How It Works</h3>
                <p>The straightforward thing about Class Table Inheritance is that it has one table
                                per class in the domain model. The fields in the domain class map directly to
                                fields in the corresponding tables. As with the other inheritance mappings the
                                fundamental approach of Inheritance Mappers (302) applies.
                                One issue is how to link the corresponding rows of the database tables. A
                                possible solution is to use a common primary key value so that, say, the row of
                                key 101 in the footballers table and the row of key 101 in the players table correspond to the same domain object. Since the superclass table has a row for
                                each row in the other tables, the primary keys are going to be unique across the
                                tables if you use this scheme. An alternative is to let each table have its own primary keys and use foreign keys into the superclass table to tie the rows together.
                                The biggest implementation issue with Class Table Inheritance is how to
                                bring the data back from multiple tables in an efficient manner. Obviously,
                                making a call for each table isnâ€™t good since you have multiple calls to the database. You can avoid this by doing a join across the various component tables;
                                however, joins for more than three or four tables tend to be slow because of the
                                way databases do their optimizations.</p>
                <p>On top of this is the problem that in any given query you often donâ€™t know
                                exactly which tables to join. If youâ€™re looking for a footballer, you know to use
                                the footballer table, but if youâ€™re looking for a group of players, which tables
                                do you use? To join effectively when some tables have no data, youâ€™ll need to
                                do an outer join, which is nonstandard and often slow. The alternative is to
                                read the root table first and then use a code to figure out what tables to read
                                next, but this involves multiple queries.</p>
                <h3 id="286">When to Use It</h3>
                <p>Class Table Inheritance, Single Table Inheritance (278) and Concrete Table
                                Inheritance (293) are the three alternatives to consider for inheritance mapping.
                                The strengths of Class Table Inheritance are
                <ul>
                        <li>All columns are relevant for every row so tables are easier to understand and donâ€™t waste space.</li>
                        <li>The relationship between the domain model and the database is very straightforward.</li>
                </ul>
                                The weaknesses of Class Table Inheritance are
                <ul>
                        <li>You need to touch multiple tables to load an object, which means a join or multiple queries and sewing in memory.</li>
                        <li>Any refactoring of fields up or down the hierarchy causes database changes.</li>
                        <li>The supertype tables may become a bottleneck because they have to be accessed frequently.</li>
                        <li>The high normalization may make it hard to understand for ad hoc queries.</li>
                                You donâ€™t have to choose just one inheritance mapping pattern for one class
                                hierarchy. You can use Class Table Inheritance for the classes at the top of the
                                hierarchy and a bunch of Concrete Table Inheritance (293) for those lower
                                down.</p>
                <h3 id="287">Further Reading</h3>
                <p>A number of IBM texts refer to this pattern as Root-Leaf Mapping [Brown et al.].</p>
                <h3 id="287(2)">Example: Players and Their Kin (C#)</h3>
                <p>Hereâ€™s an implementation for the sketch. Again Iâ€™ll follow the familiar (if perhaps
                                a little tedious) theme of players and the like, using Inheritance Mappers (302)
                                (Figure 12.9).
                                Each class needs to define the table that holds its data and a type code for it.
                                <pre>class AbstractPlayerMapper...
                                abstract public String TypeCode {get;}
                                protected static String TABLENAME = "Players";
                                class FootballerMapper...
                                public override String TypeCode {
                                get {return "F";}
                                }
                                protected new static String TABLENAME = "Footballers";</pre>
                                Unlike the other inheritance examples, this one doesnâ€™t have a overridden
                                table name because we have to have the table name for this class even when the
                                instance is an instance of the subclass.
                                Loading an Object If youâ€™ve been reading the other mappings, you know the
                                first step is the find method on the concrete mappers.
                                <pre>class FootballerMapper...
                                public Footballer Find(long id) {
                                return (Footballer) AbstractFind (id, TABLENAME);
                                }</pre>
                                The abstract find method looks for a row matching the key and, if successful,
                                creates a domain object and calls the load method on it.
                                <pre>class Mapper...
                                public DomainObject AbstractFind(long id, String tablename) {
                                DataRow row = FindRow (id, tableFor(tablename));
                                if (row == null) return null;
                                else {
                                DomainObject result = CreateDomainObject();
                                result.Id = id;</pre>
                <p><img src="img/figure 12.9.png" alt="no img" style="margin-left: 200px;"></p>
                                <pre>Load(result);
                                return result;
                                }
                                }
                                protected DataTable tableFor(String name) {
                                return Gateway.Data.Tables[name];
                                }
                                protected DataRow FindRow(long id, DataTable table) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                Figure 12.9 The generic class diagram of Inheritance Mappers (302).
                                + find (key) : Player
                                + insert
                                + update
                                Player Mapper
                                + find (key) : Footballer
                                # save
                                # load
                                Footballer Mapper
                                # save
                                # load
                                Abstract Player
                                + insert (Domain Object) Mapper
                                + update (Domain Object)
                                + delete (Domain Object)
                                -- hook methods
                                # save (Domain Object, Row)
                                # load (Domain Object, Row)
                                Mapper
                                + find (key) : Cricketer
                                # save
                                # load
                                Cricketer Mapper
                                + find (key) : Bowler
                                # save
                                # load
                                Bowler Mapper
                                1
                                1
                                1
                                }
                                protected DataRow FindRow (long id, String tablename) {
                                return FindRow(id, tableFor(tablename));
                                }
                                protected abstract DomainObject CreateDomainObject();
                                class FootballerMapper...
                                protected override DomainObject CreateDomainObject(){
                                return new Footballer();
                                }
                                Thereâ€™s one load method for each class which loads the data defined by that
                                class.
                                class FootballerMapper...
                                protected override void Load(DomainObject obj) {
                                base.Load(obj);
                                DataRow row = FindRow (obj.Id, tableFor(TABLENAME));
                                Footballer footballer = (Footballer) obj;
                                footballer.club = (String)row["club"];
                                }
                                class AbstractPlayerMapper...
                                protected override void Load(DomainObject obj) {
                                DataRow row = FindRow (obj.Id, tableFor(TABLENAME));
                                Player player = (Player) obj;
                                player.name = (String)row["name"];
                                }</pre>
                                As with the other sample code, but more noticeably in this case, Iâ€™m relying
                                on the fact that the ADO.NET data set has brought the data from the database
                                and cached it into memory. This allows me to make several accesses to the
                                table-based data structure without a high performance cost. If youâ€™re going
                                directly to the database, youâ€™ll need to reduce that load. For this example you
                                might do this by creating a join across all the tables and manipulating it.
                                The player mapper determines which kind of player it has to find and then
                                delegates the correct concrete mapper.
                                <pre>class PlayerMapper...
                                public Player Find (long key) {
                                DataRow row = FindRow(key, tableFor(TABLENAME));
                                if (row == null) return null;
                                else {
                                String typecode = (String) row["type"];
                                if (typecode == bmapper.TypeCode)
                                return bmapper.Find(key);
                                if (typecode == cmapper.TypeCode)
                                return cmapper.Find(key);
                                if (typecode == fmapper.TypeCode)
                                return fmapper.Find(key);
                                throw new Exception("unknown type");
                                }
                                }
                                protected static String TABLENAME = "Players";
                                Updating an Object The update method appears on the mapper superclass
                                class Mapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg);
                                }
                                Itâ€™s implemented through a series of save methods, one for each class in the
                                hierarchy.
                                class FootballerMapper...
                                protected override void Save(DomainObject obj) {
                                base.Save(obj);
                                DataRow row = FindRow (obj.Id, tableFor(TABLENAME));
                                Footballer footballer = (Footballer) obj;
                                row["club"] = footballer.club;
                                }
                                class AbstractPlayerMapper...
                                protected override void Save(DomainObject obj) {
                                DataRow row = FindRow (obj.Id, tableFor(TABLENAME));
                                Player player = (Player) obj;
                                row["name"] = player.name;
                                row["type"] = TypeCode;
                                }
                                The player mapperâ€™s update method overrides the general method to forward to
                                the correct concrete mapper.
                                class PlayerMapper...
                                public override void Update (DomainObject obj) {
                                MapperFor(obj).Update(obj);
                                }
                                private Mapper MapperFor(DomainObject obj) {
                                if (obj is Footballer)
                                return fmapper;
                                if (obj is Bowler)
                                return bmapper;
                                if (obj is Cricketer)
                                return cmapper;
                                throw new Exception("No mapper available");
                                }</pre>
                                Inserting an Object The method for inserting an object is declared on the mapper superclass. It has two stages: creating new database rows and then using the
                                save methods to update these blank rows with the necessary data.
                                <pre>class Mapper...
                                public virtual long Insert (DomainObject obj) {
                                obj.Id = GetNextID();
                                AddRow(obj);
                                Save(obj);
                                return obj.Id;
                                }
                                Each class inserts a row into its table.
                                class FootballerMapper...
                                protected override void AddRow (DomainObject obj) {
                                base.AddRow(obj);
                                InsertRow (obj, tableFor(TABLENAME));
                                }
                                class AbstractPlayerMapper...
                                protected override void AddRow (DomainObject obj) {
                                InsertRow (obj, tableFor(TABLENAME));
                                }
                                class Mapper...
                                abstract protected void AddRow (DomainObject obj);
                                protected virtual void InsertRow (DomainObject arg, DataTable table) {
                                DataRow row = table.NewRow();
                                row["id"] = arg.Id;
                                table.Rows.Add(row);
                                }
                                The player mapper delegates to the appropriate concrete mapper.
                                class PlayerMapper...
                                public override long Insert (DomainObject obj) {
                                return MapperFor(obj).Insert(obj);
                                }
                                Deleting an Object To delete an object, each class deletes a row from the corresponding table in the database.
                                class FootballerMapper...
                                public override void Delete(DomainObject obj) {
                                base.Delete(obj);
                                DataRow row = FindRow(obj.Id, TABLENAME);
                                row.Delete();
                                }
                                292 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Class Table
                                Inheritance
                                class AbstractPlayerMapper...
                                public override void Delete(DomainObject obj) {
                                DataRow row = FindRow(obj.Id, tableFor(TABLENAME));
                                row.Delete();
                                }
                                class Mapper...
                                public abstract void Delete(DomainObject obj);
                                The player mapper again wimps out of all the hard work and just delegates to
                                the concrete mapper.
                                class PlayerMapper...
                                override public void Delete(DomainObject obj) {
                                MapperFor(obj).Delete(obj);
                                }</pre></p>
                <h3 id="293">Concrete Table Inheritance</h3>
                <p><img src="img/part2.20.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Represents an inheritance hierarchy of classes with
                                one table per concrete class in the hierarchy.
                                As any object purist will tell you, relational databases donâ€™t support inheritanceâ€”a fact that complicates object-relational mapping. Thinking of tables
                                from an object instance point of view, a sensible route is to take each object in
                                memory and map it to a single database row. This implies Concrete Table Inheritance, where thereâ€™s a table for each concrete class in the inheritance hierarchy.
                                Iâ€™ll confess to having had some difficulty naming this pattern. Most people
                                think of it as leaf oriented since you usually have one table per leaf class in a
                                hierarchy. Following that logic, I could call this pattern leaf table inheritance,
                                and the term â€œleafâ€ is often used for this pattern. Strictly, however, a concrete
                                class that isnâ€™t a leaf usually gets a table as well, so I decided to go with the
                                more correct, if less intuitive term.</p>
                <h3 id="293(2)">How It Works</h3>
                <p>Concrete Table Inheritance uses one database table for each concrete class in
                                the hierarchy. Each table contains columns for the concrete class and all its
                                ancestors, so any fields in a superclass are duplicated across the tables of the
                                subclasses. As with all of these inheritance schemes the basic behavior uses
                                Inheritance Mappers (302).
                                You need to pay attention to the keys with this pattern. Punningly, the key
                                thing is to ensure that keys are unique not just to a table but to all the tables
                                from a hierarchy. A classic example of where you need this is if you have a collection of players and youâ€™re using Identity Field (216) with table-wide keys. If
                                keys can be duplicated between the tables that map the concrete classes, youâ€™ll
                                get multiple rows for a particular key value. Thus, you need a key allocation
                                system that keeps track of key usage across tables; also, you canâ€™t rely on the
                                databaseâ€™s primary key uniqueness mechanism.</p>
                <p>This becomes particularly awkward if youâ€™re hooking up to databases used
                                by other systems. In many of these cases you canâ€™t guarantee key uniqueness
                                across tables. In this situation you either avoid using superclass fields or use a
                                compound key that involves a table identifier.
                                You can get around some of this by not having fields that are typed to the
                                superclass, but obviously that compromises the object model. As alternative is
                                to have accessors for the supertype in the interface but to use several private
                                fields for each concrete type in the implementation. The interface then combines
                                values from the private fields. If the public interface is a single value, it picks
                                whichever of the private values arenâ€™t null. If the public interface is a collection
                                value, it replies with the union of values from the implementation fields.
                                For compound keys you can use a special key object as your ID field for
                                Identity Field (216). This key uses both the primary key of the table and the
                                table name to determine uniqueness.</p>
                <p>Related to this are problems with referential integrity in the database. Consider an object model like Figure 12.10. To implement referential integrity you
                                need a link table that contains foreign key columns for the charity function and
                                for the player. The problem is that thereâ€™s no table for the player, so you canâ€™t
                                put together a referential integrity constraint for the foreign key field that takes
                                either footballers or cricketers. Your choice is to ignore referential integrity or
                                use multiple link tables, one for each of the actual tables in the database. On
                                top of this you have problems if you canâ€™t guarantee key uniqueness.
                                If youâ€™re searching for players with a select statement, you need to look at all
                                tables to see which ones contain the appropriate value. This means using multiple queries or using an outer join, both of which are bad for performance. You
                                donâ€™t suffer the performance hit when you know the class you need, but you do
                                have to use the concrete class to improve performance.
                <p><img src="img/figure 12.10.png" alt="no img" style="margin-left: 200px;"></p>
                                This pattern is often referred to as along the lines of leaf table inheritance.
                                Some people prefer a variation where you have one table per leaf class instead
                                of one table per concrete class. If you donâ€™t have any concrete superclasses in
                                the hierarchy, this ends up as the same thing. Even if you do have concrete
                                superclasses the difference is pretty minor.</p>
                <h3 id="295">When to Use It</h3>
                <p>When figuring out how to map inheritance, Concrete Table Inheritance, Class
                                Table Inheritance (285), and Single Table Inheritance (278) are the alternatives.
                                The strengths of Concrete Table Inheritance are:
                <ul>
                        <li>Each table is self-contained and has no irrelevant fields. As a result it makes good sense when used by other applications that arenâ€™t using the objects.</li>
                        <li>There are no joins to do when reading the data from the concrete mappers.</li>
                        <li>Each table is accessed only when that class is accessed, which can spread the access load.</li>
                </ul>
                                The weaknesses of Concrete Table Inheritance are:
                <ul>
                        <li>Primary keys can be difficult to handle.</li>
                        <li>You canâ€™t enforce database relationships to abstract classes.</li>
                        <li>If the fields on the domain classes are pushed up or down the hierarchy, you have to alter the table definitions. You donâ€™t have to do as much alteration as with Class Table Inheritance (285), but you canâ€™t ignore this as you can with Single Table Inheritance (278).</li>
                        <li>If a superclass field changes, you need to change each table that has this field because the superclass fields are duplicated across the tables.</li>
                        <li>A find on the superclass forces you to check all the tables, which leads to multiple database accesses (or a weird join).</li>
                </ul>
                                Remember that the trio of inheritance patterns can coexist in a single hierarchy. So you might use Concrete Table Inheritance for one or two subclasses and
                                Single Table Inheritance (278) for the rest.</p>
                <h3 id="296">Example: Concrete Players (C#)</h3>
                <p>Here Iâ€™ll show you an implementation for the sketch. As with all inheritance
                                examples in this chapter, Iâ€™m using the basic design of classes from Inheritance
                                Mappers (302), shown in Figure 12.11.
                                Each mapper is linked to the database table thatâ€™s the source of the data. In
                                ADO.NET a data set holds the data table.
                                <pre>class Mapper...
                                public Gateway Gateway;
                                private IDictionary identityMap = new Hashtable();
                                public Mapper (Gateway gateway) {
                                this.Gateway = gateway;
                                }
                                private DataTable table {
                                get {return Gateway.Data.Tables[TableName];}
                                }
                                abstract public String TableName {get;}</pre>
                                The gateway class holds the data set within its data property. The data can be
                                loaded up by supplying suitable queries.
                                <pre>class Gateway...
                                public DataSet Data = new DataSet();
                                Each concrete mapper needs to define the name of the table that holds its data.
                                class CricketerMapper...
                                public override String TableName {
                                get {return "Cricketers";}
                                }</pre>
                <p><img src="img/figure 12.11.png" alt="no img" style="margin-left: 200px;"></p>
                                The player mapper has fields for each concrete mapper.
                                <pre>class PlayerMapper...
                                private BowlerMapper bmapper;
                                private CricketerMapper cmapper;
                                private FootballerMapper fmapper;
                                public PlayerMapper (Gateway gateway) : base (gateway) {
                                bmapper = new BowlerMapper(Gateway);
                                cmapper = new CricketerMapper(Gateway);
                                fmapper = new FootballerMapper(Gateway);
                                }</pre>
                                Loading an Object from the Database Each concrete mapper class has a find
                                method that returns an object given a key value.
                                <pre>class CricketerMapper...
                                public Cricketer Find(long id) {
                                return (Cricketer) AbstractFind(id);
                                }</pre>
                                The abstract behavior on the superclass finds the right database row for the ID,
                                creates a new domain object of the correct type, and uses the load method to
                                load it up (Iâ€™ll describe the load in a moment).
                                <pre>class Mapper...
                                public DomainObject AbstractFind(long id) {
                                DataRow row = FindRow(id);
                                if (row == null) return null;
                                else {
                                DomainObject result = CreateDomainObject();
                                Load(result, row);
                                return result;
                                }
                                }
                                private DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                if (results.Length == 0) return null;
                                else return results[0];
                                }
                                protected abstract DomainObject CreateDomainObject();
                                class CricketerMapper...
                                protected override DomainObject CreateDomainObject(){
                                return new Cricketer();
                                }</pre>
                                The actual loading of data from the database is done by the load method, or
                                rather by several load methods: one each for the mapper class and for all its
                                superclasses.
                                <pre>class CricketerMapper...
                                protected override void Load(DomainObject obj, DataRow row) {
                                base.Load(obj,row);
                                Cricketer cricketer = (Cricketer) obj;
                                cricketer.battingAverage = (double)row["battingAverage"];
                                }
                                class AbstractPlayerMapper...
                                protected override void Load(DomainObject obj, DataRow row) {
                                base.Load(obj, row);
                                Player player = (Player) obj;
                                player.name = (String)row["name"];
                                class Mapper...
                                protected virtual void Load(DomainObject obj, DataRow row) {
                                obj.Id = (int) row ["id"];
                                }</pre>
                                This is the logic for finding an object using a mapper for a concrete class. You
                                can also use a mapper for the superclass: the player mapper, which it needs to
                                find an object from whatever table itâ€™s living in. Since all the data is already in
                                memory in the data set, I can do this like so:
                                <pre>class PlayerMapper...
                                public Player Find (long key) {
                                Player result;
                                result = fmapper.Find(key);
                                if (result != null) return result;
                                result = bmapper.Find(key);
                                if (result != null) return result;
                                result = cmapper.Find(key);
                                if (result != null) return result;
                                return null;
                                }</pre>
                                Remember, this is reasonable only because the data is already in memory. If
                                you need to go to the database three times (or more for more subclasses) this
                                will be slow. It may help to do a join across all the concrete tables, which will
                                allow you to access the data in one database call. However, large joins are often
                                slow in their own right, so youâ€™ll need to do some benchmarks with your own
                                application to find out what works and what doesnâ€™t. Also, this will be an outer
                                join, and as well as slowing the syntax itâ€™s nonportable and often cryptic.
                                Updating an Object The update method can be defined on the mapper
                                superclass.
                                <pre>class Mapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg, FindRow(arg.Id));
                                }</pre>
                                Similar to loading, we use a sequence of save methods for each mapper class.
                                <pre>class CricketerMapper...
                                protected override void Save(DomainObject obj, DataRow row) {
                                base.Save(obj, row);
                                Cricketer cricketer = (Cricketer) obj;
                                row["battingAverage"] = cricketer.battingAverage;
                                }
                                class AbstractPlayerMapper...
                                protected override void Save(DomainObject obj, DataRow row) {
                                Player player = (Player) obj;
                                row["name"] = player.name;
                                }
                                The player mapper needs to find the correct concrete mapper to use and then
                                delegate the update call.
                                class PlayerMapper...
                                public override void Update (DomainObject obj) {
                                MapperFor(obj).Update(obj);
                                }
                                private Mapper MapperFor(DomainObject obj) {
                                if (obj is Footballer)
                                return fmapper;
                                if (obj is Bowler)
                                return bmapper;
                                if (obj is Cricketer)
                                return cmapper;
                                throw new Exception("No mapper available");
                                }</pre>
                                Inserting an Object Insertion is a variation on updating. The extra behavior is
                                creating the new row, which can be done on the superclass.
                                <pre>class Mapper...
                                public virtual long Insert (DomainObject arg) {
                                DataRow row = table.NewRow();
                                arg.Id = GetNextID();
                                row["id"] = arg.Id;
                                Save (arg, row);
                                table.Rows.Add(row);
                                return arg.Id;
                                }</pre>
                                Again, the player class delegates to the appropriate mapper.
                                <pre>class PlayerMapper...
                                public override long Insert (DomainObject obj) {
                                return MapperFor(obj).Insert(obj);
                                }</pre>
                                Deleting an Object Deletion is very straightforward. As before, we have a
                                method defined on the superclass:
                                <pre>class Mapper...
                                public virtual void Delete(DomainObject obj) {
                                DataRow row = FindRow(obj.Id);
                                row.Delete();
                                }</pre>
                                and a delegating method on the player mapper.
                                <pre>class PlayerMapper...
                                public override void Delete (DomainObject obj) {
                                MapperFor(obj).Delete(obj);
                                }</pre></p>
                <h3 id="302">Inheritance Mappers</h3>
                <p><img src="img/part2.21.png" alt="no img" style="margin-left: 200px;"></p>
                <p>A structure to organize database mappers
                                that handle inheritance hierarchies.
                                When you map from an object-oriented inheritance hierarchy in memory to a
                                relational database you have to minimize the amount of code needed to save
                                and load the data to the database. You also want to provide both abstract and
                                concrete mapping behavior that allows you to save or load a superclass or a
                                subclass.
                                Although the details of this behavior vary with your inheritance mapping
                                scheme (Single Table Inheritance (278), Class Table Inheritance (285), and
                                Concrete Table Inheritance (293)) the general structure works the same for all
                                of them.</p>
                <h3 id="303">How It Works</h3>
                <p>You can organize the mappers with a hierarchy so that each domain class has a
                                mapper that saves and loads the data for that domain class. This way you have
                                one point where you can change the mapping. This approach works well for
                                concrete mappers that know how to map the concrete objects in the hierarchy.
                                There are times, however, where you also need mappers for the abstract classes.
                                These can be implemented with mappers that are actually outside of the basic
                                hierarchy but delegate to the appropriate concrete mappers.
                                To best explain how this works, Iâ€™ll start with the concrete mappers. In the
                                sketch the concrete mappers are the mappers for footballer, cricketer, and bowler.
                                Their basic behavior includes the find, insert, update, and delete operations.
                                The find methods are declared on the concrete subclasses because they will
                                return a concrete class. Thus, the find method on BowlerMapper should return
                                a bowler, not an abstract class. Common OO languages canâ€™t let you change the
                                declared return type of a method, so itâ€™s not possible to inherit the find operation and still declare a specific return type. You can, of course, return an
                                abstract type, but that forces the user of the class to downcastâ€”which is best to
                                avoid. (A language with dynamic typing doesnâ€™t have this problem.)</p>
                <p>The basic behavior of the find method is to find the appropriate row in the
                                database, instantiate an object of the correct type (a decision thatâ€™s made by the
                                subclass), and then load the object with data from the database. The load
                                method is implemented by each mapper in the hierarchy which loads the behavior for its corresponding domain object. This means that the bowler mapperâ€™s
                                load method loads the data specific to the bowler class and calls the superclass
                                method to load the data specific to the cricketer, which calls its superclass
                                method, and so on.
                                The insert and update methods operate in a similar way using a save method.
                                Here you can define the interface on the superclassâ€”indeed, on a Layer Supertype (475). The insert method creates a new row and then saves the data from
                                the domain object using the save hook methods. The update method just saves
                                the data, also using the save hook methods. These methods operate similarly to
                                the load hook methods, with each class storing its specific data and calling the
                                superclass save method.</p>
                <p>This scheme makes it easy to write the appropriate mappers to save the
                                information needed for a particular part of the hierarchy. The next step is to
                                support loading and saving an abstract classâ€”in this example, a player. While a
                                first thought is to put appropriate methods on the superclass mapper, that actually gets awkward. While concrete mapper classes can just use the abstract
                                mapperâ€™s insert and update methods, the player mapperâ€™s insert and update
                                need to override these to call a concrete mapper instead. The result is one of
                                those combinations of generalization and composition that twist your brain
                                cells into a knot.
                                I prefer to separate the mappers into two classes. The abstract player mapper
                                is responsible for loading and saving the specific player data to the database.
                                This is an abstract class whose behavior is just used only by the concrete mapper objects. A separate player mapper class is used for the interface for operations at the player level. The player mapper provides a find method and
                                overrides the insert and update methods. For all of these its responsibility is to
                                figure out which concrete mapper should handle the task and delegate to it.
                                Although a broad scheme like this makes sense for each type of inheritance
                                mapping, the details do vary. Therefore, itâ€™s not possible to show a code example for this case. You can find good examples in each of the inheritance mapping pattern sections: Single Table Inheritance (278), Class Table Inheritance
                                (285), and Concrete Table Inheritance (293).</p>
                <h3 id="304">When to Use It</h3>
                <p>This general scheme makes sense for any inheritance-based database mapping.
                                The alternatives involve such things as duplicating superclass mapping code
                                among the concrete mappers and folding the playerâ€™s interface into the abstract
                                player mapper class. The former is a heinous crime, and the latter is possible
                                but leads to a player mapper class thatâ€™s messy and confusing. On the whole,
                                then, its hard to think of a good alternative to this pattern.
                                ObjectRelational
                                Metadata Mapping Patterns</p>
                <h3 id="305">Chapter 13</h3>
                <h2>Object-Relational Metadata Mapping Patterns</h2>
                <h3 id="306">Metadata Mapping</h3>
                <p><img src="img/part2.22.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Holds details of object-relational mapping in metadata.
                                Much of the code that deals with object-relational mapping describes how fields
                                in the database correspond to fields in in-memory objects. The resulting code
                                tends to be tedious and repetitive to write. A Metadata Mapping allows developers to define the mappings in a simple tabular form, which can then be processed by generic code to carry out the details of reading, inserting, and
                                updating the data.</p>
                <h3 id="306(2)">How It Works</h3>
                <p>The biggest decision in using Metadata Mapping is how the information in the
                                metadata manifests itself in terms of running code. There are two main routes
                                to take: code generation and reflective programming.
                                With code generation you write a program whose input is the metadata and
                                whose output is the source code of classes that do the mapping. These classes
                                look as though theyâ€™re hand-written, but theyâ€™re entirely generated during the
                                build process, usually just prior to compilation. The resulting mapper classes
                                are deployed with the server code.
                                If you use code generation, you should make sure that itâ€™s fully integrated
                                into your build process with whatever build scripts youâ€™re using. The generated
                                classes should never be edited by hand and thus shouldnâ€™t need to be held in
                                source code control.</p>
                <p>A reflective program may ask an object for a method named setName, and then
                                run an invoke method on the setName method passing in the appropriate argument. By treating methods (and fields) as data the reflective program can read in
                                field and method names from a metadata file and use them to carry out the
                                mapping. I usually counsel against reflection, partly because itâ€™s slow but
                                mainly because it often causes code thatâ€™s hard to debug. Even so, reflection is
                                actually quite appropriate for database mapping. Since youâ€™re reading in the
                                names of fields and methods from a file, youâ€™re taking full advantage of reflectionâ€™s flexibility.
                                Code generation is a less dynamic approach since any changes to the mapping require recompiling and redeploying at least that part of the software.
                                With a reflective approach, you can just change the mapping data file and the
                                existing classes will use the new metadata. You can even do this during runtime, rereading the metadata when you get a particular kind of interrupt. As it
                                turns out, mapping changes should be pretty rare, since they imply database
                                or code changes. Modern environments also make it easy to redeploy part of
                                an application.</p>
                <p>Reflective programming often suffers in speed, although the problem here
                                depends very much on the actual environment youâ€™re usingâ€”in some a reflective call can be an order of magnitude slower. Remember, though, that the
                                reflection is being done in the context of an SQL call, so its slower speed may
                                not make that much difference considering the slow speed of the remote call. As
                                with any performance issue, you need to measure within your environment to
                                find out how much of a factor this is.
                                Both approaches can be a little awkward to debug. The comparison
                                between them depends very much on how used to generated and reflective
                                code developers are. Generated code is more explicit so you can see whatâ€™s
                                going on in the debugger; as a result I usually prefer generation to reflection,
                                and I think itâ€™s usually easier for less sophisticated developers (which I guess
                                makes me unsophisticated).</p>
                <p>On most occasions you keep the metadata in a separate file format. These
                                days XML is a popular choice as it provides hierarchic structuring while freeing
                                you from writing your own parsers and other tools. A loading step takes this
                                metadata and turns it into programming language structure, which then drive
                                either the code generation output or the reflective mapping.
                                In simpler cases you can skip the external file format and create the metadata
                                representation directly in source code. This saves you from having to parse, but
                                it makes editing the metadata somewhat harder.
                                Another alternative is to hold the mapping information in the database itself,
                                which keeps it together with the data. If the database schema changes, the mapping information is right there.
                                When youâ€™re deciding which way to hold the metadata information, you can
                                mostly neglect the performance of access and parsing. If you use code generation, access and parsing take place only during the build and not during execution. If you use reflective programming, youâ€™ll typically access and parse during
                                execution but only once during system startup; then you can keep the in-memory representation.</p>
                <p>How complex to make your metadata is one of your biggest decisions. When
                                youâ€™re faced with a general relational mapping problem, there are a lot of different factors to keep in metadata, but many projects can manage with much
                                less than a fully general scheme and so their metadata can be much simpler. On
                                the whole itâ€™s worth evolving your design as your needs grow, as it isnâ€™t hard to
                                add new capabilities to metadata-driven software.
                                One of the challenges of metadata is that although a simple metadata scheme
                                often works well 90 percent of the time, there are often special cases that make
                                life much more tricky. To handle these minority cases you often have to add a
                                lot of complexity to metadata. A useful alternative is to override the generic
                                code with subclasses where the special code is handwritten. Such special-case
                                subclasses would be subclasses of either the generated code or the reflective routines. Since these special cases are . . . well . . . special, it isnâ€™t easy to describe in
                                general terms how you arrange things to support the overriding. My advice is to
                                handle them on a case-by-case basis. As you need the overriding, alter the generated/reflective code to isolate a single method that should be overridden and
                                then override it in your special case.</p>
                <h3 id="308">When to Use It</h3>
                <p>Metadata Mapping can greatly reduce the amount of work needed to handle
                                database mapping. However, some setup work is required to prepare the Metadata Mapping framework. Also, while itâ€™s often easy to handle most cases with
                                Metadata Mapping, you can find exceptions that really tangle the metadata.
                                Itâ€™s no surprise that the commercial object-relational mapping tools use
                                Metadata Mappingâ€”when selling a product producing a sophisticated Metadata Mapping is always worth the effort.
                                If youâ€™re building your own system, you should evaluate the trade-offs yourself. Compare adding new mappings using handwritten code with using Metadata Mapping. If you use reflection, look into its consequences for performance;
                                sometimes it causes slowdowns, but sometimes it doesnâ€™t. Your own measurements will reveal whether this is an issue for you.
                                The extra work of hand-coding can be greatly reduced by creating a good
                                Layer Supertype (475) that handles all the common behavior. That way you
                                should only have a few hook routines to add in for each mapping. Usually
                                Metadata Mapping can further reduce the number.</p>
                <p>Metadata Mapping can interfere with refactoring, particularly if youâ€™re using
                                automated tools. If you change the name of a private field, it can break an
                                application unexpectedly. Even automated refactoring tools wonâ€™t be able to
                                find the field name hidden in a XML data file of a map. Using code generation
                                is a little easier, since search mechanisms can find the usage. Still, any automated update will get lost when you regenerate the code. A tool can warn you
                                of a problem, but itâ€™s up to you to change the metadata yourself. If you use
                                reflection, you wonâ€™t even get the warning.
                                On the other hand, Metadata Mapping can make refactoring the database
                                easier, since the metadata represents a statement of the interface of your database schema. Thus, alterations to the database can be contained by changes in
                                the Metadata Mapping.</p>
                <h3 id="309">Example: Using Metadata and Reflection (Java)</h3>
                <p>Most examples in this book use explicit code because itâ€™s the easiest to understand. However, it does lead to pretty tedious programming, and tedious programming is a sign that something is wrong. You can remove a lot of tedious
                                programming by using metadata.
                                Holding the Metadata The first question to ask about metadata is how itâ€™s
                                going to be kept. Here Iâ€™m keeping it in two classes. The data map corresponds
                                to the mapping of one class to one table. This is a simple mapping, but it will do
                                for illustration.
                                <pre>class DataMap...
                                private Class domainClass;
                                private String tableName;
                                private List columnMaps = new ArrayList();</pre>
                                The data map contains a collection of column maps that map columns in the
                                table to fields.
                                <pre>class ColumnMap...
                                private String columnName;
                                private String fieldName;
                                private Field field;
                                private DataMap dataMap;</pre>
                                This isnâ€™t a terribly sophisticated mapping. Iâ€™m just using the default Java type
                                mappings, which means thereâ€™s no type conversion between fields and columns.
                                Iâ€™m also forcing a one-to-one relationship between tables and classes.
                                These structures hold the mappings. The next question is how theyâ€™re populated. For this example Iâ€™m going to populate them with Java code in specific
                                mapper classes. That may seem a little odd, but it buys most of the benefit of
                                metadataâ€”avoiding repetitive code.
                                <pre>class PersonMapper...
                                protected void loadDataMap(){
                                dataMap = new DataMap (Person.class, "people");
                                dataMap.addColumn ("lastname", "varchar", "lastName");
                                dataMap.addColumn ("firstname", "varchar", "firstName");
                                dataMap.addColumn ("number_of_dependents", "int", "numberOfDependents");
                                }</pre>
                                During construction of the column mapper, I build the link to the field.
                                Strictly speaking, this is an optimization so you may not have to calculate the
                                fields. However, doing so reduces the subsequent accesses by an order of magnitude on my little laptop.
                                <pre>class ColumnMap...
                                public ColumnMap(String columnName, String fieldName, DataMap dataMap) {
                                this.columnName = columnName;
                                this.fieldName = fieldName;
                                this.dataMap = dataMap;
                                initField();
                                }
                                private void initField() {
                                try {
                                field = dataMap.getDomainClass().getDeclaredField(getFieldName());
                                field.setAccessible(true);
                                } catch (Exception e) {
                                throw new ApplicationException ("unable to set up field: " + fieldName, e);
                                }
                                }</pre>
                                Itâ€™s not much of a challenge to see how I can write a routine to load the map
                                from an XML file or from a metadata database. Paltry that challenge may be,
                                but Iâ€™ll decline it and leave it to you.
                                Now that the mappings are defined, I can make use of them. The strength of
                                the metadata approach is that all of the code that actually manipulates things is
                                in a superclass, so I donâ€™t have to write the mapping code that I wrote in the
                                explicit cases.
                                Find by ID Iâ€™ll begin with the find by ID method.
                                <pre>class Mapper...
                                public Object findObject (Long key) {
                                if (uow.isLoaded(key)) return uow.getObject(key);
                                String sql = "SELECT" + dataMap.columnList() + " FROM " + dataMap.getTableName() + " WHERE
                                ID = ?";
                                PreparedStatement stmt = null;
                                METADATA MAPPING 311
                                Metadata
                                Mapping
                                ResultSet rs = null;
                                DomainObject result = null;
                                try {
                                stmt = DB.prepare(sql);
                                stmt.setLong(1, key.longValue());
                                rs = stmt.executeQuery();
                                rs.next();
                                result = load(rs);
                                } catch (Exception e) {throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                return result;
                                }
                                private UnitOfWork uow;
                                protected DataMap dataMap;
                                class DataMap...
                                public String columnList() {
                                StringBuffer result = new StringBuffer(" ID");
                                for (Iterator it = columnMaps.iterator(); it.hasNext();) {
                                result.append(",");
                                ColumnMap columnMap = (ColumnMap)it.next();
                                result.append(columnMap.getColumnName());
                                }
                                return result.toString();
                                }
                                public String getTableName() {
                                return tableName;
                                }</pre>
                                The select is built more dynamically than the other examples, but itâ€™s still worth
                                preparing in a way that allows the database session to cache it properly. If itâ€™s
                                an issue, the column list can be calculated during construction and cached,
                                since thereâ€™s no call for updating the columns during the life of the data map.
                                For this example Iâ€™m using a Unit of Work (184) to handle the database session.
                                As is common with the examples in this book Iâ€™ve separated the load from
                                the find, so that we can use the same load method from other find methods.
                                <pre>class Mapper...
                                public DomainObject load(ResultSet rs)
                                throwsInstantiationException, IllegalAccessException, SQLException
                                {
                                Long key = new Long(rs.getLong("ID"));
                                if (uow.isLoaded(key)) return uow.getObject(key);
                                DomainObject result = (DomainObject) dataMap.getDomainClass().newInstance();
                                result.setID(key);
                                uow.registerClean(result);
                                loadFields(rs, result);
                                return result;
                                }
                                private void loadFields(ResultSet rs, DomainObject result) throws SQLException {
                                for (Iterator it = dataMap.getColumns(); it.hasNext();) {
                                ColumnMap columnMap = (ColumnMap)it.next();
                                Object columnValue = rs.getObject(columnMap.getColumnName());
                                columnMap.setField(result, columnValue);
                                }
                                }
                                class ColumnMap...
                                public void setField(Object result, Object columnValue) {
                                try {
                                field.set(result, columnValue);
                                } catch (Exception e) { throw new ApplicationException ("Error in setting " + fieldName, e);
                                }
                                }</pre>
                                This is a classic reflected program. We go through each of the column maps
                                and use them to load the field in the domain object. I separated the loadFields
                                method to show how we might extend this for more complicated cases. If we
                                have a class and a table where the simple assumptions of the metadata donâ€™t
                                hold, I can just override loadFields in a subclass mapper to put in arbitrarily
                                complex code. This is a common technique with metadataâ€”providing a hook
                                to override for more wacky cases. Itâ€™s usually a lot easier to override the wacky
                                cases with subclasses than it is to build metadata sophisticated enough to hold a
                                few rare special cases.
                                Of course, if we have a subclass, we might as well use it to avoid downcasting.
                                <pre>class PersonMapper...
                                public Person find(Long key) {
                                return (Person) findObject(key);
                                }
                                Writing to the Database For updates I have a single update routine.
                                class Mapper...
                                public void update (DomainObject obj) {
                                String sql = "UPDATE " + dataMap.getTableName() + dataMap.updateList() + " WHERE ID = ?";
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(sql);
                                int argCount = 1;
                                for (Iterator it = dataMap.getColumns(); it.hasNext();) {
                                ColumnMap col = (ColumnMap) it.next();
                                stmt.setObject(argCount++, col.getValue(obj));
                                }
                                stmt.setLong(argCount, obj.getID().longValue());
                                stmt.executeUpdate();
                                } catch (SQLException e) {throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt);
                                }
                                }
                                class DataMap...
                                public String updateList() {
                                StringBuffer result = new StringBuffer(" SET ");
                                for (Iterator it = columnMaps.iterator(); it.hasNext();) {
                                ColumnMap columnMap = (ColumnMap)it.next();
                                result.append(columnMap.getColumnName());
                                result.append("=?,");
                                }
                                result.setLength(result.length() - 1);
                                return result.toString();
                                }
                                public Iterator getColumns() {
                                return Collections.unmodifiableCollection(columnMaps).iterator();
                                }
                                class ColumnMap...
                                public Object getValue (Object subject) {
                                try {
                                return field.get(subject);
                                } catch (Exception e) {
                                throw new ApplicationException (e);
                                }
                                }
                                Inserts use a similar scheme.
                                class Mapper...
                                public Long insert (DomainObject obj) {
                                String sql = "INSERT INTO " + dataMap.getTableName() + " VALUES (?" + dataMap.insertList()
                                + ")";
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(sql);
                                stmt.setObject(1, obj.getID());
                                int argCount = 2;
                                for (Iterator it = dataMap.getColumns(); it.hasNext();) {
                                ColumnMap col = (ColumnMap) it.next();
                                stmt.setObject(argCount++, col.getValue(obj));
                                }
                                stmt.executeUpdate();
                                } catch (SQLException e) {throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt);
                                }
                                return obj.getID();
                                }
                                314 OBJECT-RELATIONAL METADATA MAPPING PATTERNS
                                Metadata
                                Mapping
                                class DataMap...
                                public String insertList() {
                                StringBuffer result = new StringBuffer();
                                for (int i = 0; i < columnMaps.size(); i++) {
                                result.append(",");
                                result.append("?");
                                }
                                return result.toString();
                                }
                                Multi-Object Finds There are a couple of routes you can take to get multiple
                                objects with a query. If you want a generic query capability on the generic mapper,
                                you can have a query that takes a SQL where clause as an argument.
                                class Mapper...
                                public Set findObjectsWhere (String whereClause) {
                                String sql = "SELECT" + dataMap.columnList() + " FROM " + dataMap.getTableName() + " WHERE "
                                + whereClause;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                Set result = new HashSet();
                                try {
                                stmt = DB.prepare(sql);
                                rs = stmt.executeQuery();
                                result = loadAll(rs);
                                } catch (Exception e) {
                                throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                return result;
                                }
                                public Set loadAll(ResultSet rs) throws SQLException, InstantiationException,
                                IllegalAccessException {
                                Set result = new HashSet();
                                while (rs.next()) {
                                DomainObject newObj = (DomainObject) dataMap.getDomainClass().newInstance();
                                newObj = load (rs);
                                result.add(newObj);
                                }
                                return result;
                                }
                                An alternative is to provide special case finders on the mapper subtypes.
                                class PersonMapper...
                                public Set findLastNamesLike (String pattern) {
                                String sql =
                                "SELECT" + dataMap.columnList() +
                                " FROM " + dataMap.getTableName() +
                                " WHERE UPPER(lastName) like UPPER(?)";
                                METADATA MAPPING 315
                                Metadata
                                Mapping
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                stmt = DB.prepare(sql);
                                stmt.setString(1, pattern);
                                rs = stmt.executeQuery();
                                return loadAll(rs);
                                } catch (Exception e) {throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }</pre>
                                A further alternative for general selects is a Query Object (316).
                                On the whole, the great advantage of the metadata approach is that I can
                                now add new tables and classes to my data mapping and all I have to do is to
                                provide a loadMap method and any specialized finders that I may fancy.</p>
                <h3 id="316">Query Object</h3>
                <p><img src="img/part2.23.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that represents a database query.
                                SQL can be an involved language, and many developers arenâ€™t particularly
                                familiar with it. Furthermore, you need to know what the database schema
                                looks like to form queries. You can avoid this by creating specialized finder
                                methods that hide the SQL inside parameterized methods, but that makes it difficult to form more ad hoc queries. It also leads to duplication in the SQL statements should the database schema change.
                                A Query Object is an interpreter [Gang of Four], that is, a structure of
                                objects that can form itself into a SQL query. You can create this query by referring to classes and fields rather than tables and columns. In this way those who
                                write the queries can do so independently of the database schema and changes
                                to the schema can be localized in a single place.</p>
                <h3 id="316(2)">How It Works</h3>
                <p>A Query Object is an application of the Interpreter pattern geared to represent
                                a SQL query. Its primary roles are to allow a client to form queries of various
                                kinds and to turn those object structures into the appropriate SQL string.
                                In order to represent any query, you need a flexible Query Object. Often,
                                however, applications can make do with a lot less than the full power of SQL,
                                in which case your Query Object can be simpler. It wonâ€™t be able to represent
                                anything, but it can satisfy your particular needs. Moreover, itâ€™s usually no
                                more work to enhance it when you need more capability than it is to create a
                                fully capable Query Object right from the beginning. As a result you should
                                create a minimally functional Query Object for your current needs and evolve
                                it as those needs grow.
                                A common feature of Query Object is that it can represent queries in the language of the in-memory objects rather than the database schema. That means
                                that, instead of using table and column names, you can use object and field
                                names. While this isnâ€™t important if your objects and database have the same
                                structure, it can be very useful if you get variations between the two. In order to
                                perform this change of view, the Query Object needs to know how the database
                                structure maps to the object structure, a capability that really needs Metadata
                                Mapping (306).</p>
                <p>For multiple databases you can design your Query Object so that it produces
                                different SQL depending on which database the query is running against. At itâ€™s
                                simplest level it can take into account the annoying differences in SQL syntax
                                that keep cropping up; at a more ambitious level it can use different mappings
                                to cope with the same classes being stored in different database schemas.
                                A particularly sophisticated use of Query Object is to eliminate redundant
                                queries against a database. If you see that youâ€™ve run the same query earlier in a
                                session, you can use it to select objects from the Identity Map (195) and avoid a
                                trip to the database. A more sophisticated approach can detect whether one
                                query is a particular case of an earlier query, such as a query that is the same as
                                an earlier one but with an additional clause linked with an AND.
                                Exactly how to achieve these more sophisticated features is beyond the
                                scope of this book, but theyâ€™re the kind of features that O/R mapping tools
                                may provide.
                                A variation on the Query Object is to allow a query to be specified by an
                                example domain object. Thus, you might have a person object whose last name
                                is set to Fowler but all of those other attributes are set to null. You can treat it
                                as a query by example thatâ€™s processed like the Interpreter-style Query Object.
                                That returns all people in the database whose last name is Fowler, and itâ€™s very
                                simple and convenient to use. However, it breaks down for complex queries.</p>
                <h3 id="317">When to Use It</h3>
                <p>Query Objects are a pretty sophisticated pattern to put together, so most
                                projects donâ€™t use them if they have a handbuilt data source layer. You only
                                really need them when youâ€™re using Domain Model (116) and Data Mapper
                                (165); you also really need Metadata Mapping (306) to make serious use of
                                them.
                                318 OBJECT-RELATIONAL METADATA MAPPING PATTERNS
                                Query Object
                                Even then Query Objects arenâ€™t always necessary, as many developers are
                                comfortable with SQL. You can hide many of the details of the database
                                schema behind specific finder methods.
                                The advantages of Query Object come with more sophisticated needs: keeping database schemas encapsulated, supporting multiple databases, supporting
                                multiple schemas, and optimizing to avoid multiple queries. Some projects with
                                a particularly sophisticated data source team might want to build these capabilities themselves, but most people who use Query Object do so with a commercial tool. My inclination is that youâ€™re almost always better off buying a tool.
                                All that said, you may find that a limited Query Object fulfills your needs
                                without being difficult to build on a project that doesnâ€™t justify a fully featured
                                version. The trick is to pare down the functionality to no more than you actually use.</p>
                <h3 id="318">Further Reading</h3>
                <p>You can find an example of Query Object in [Alpert et al.] in the discussion of
                                interpreters. Query Object is also closely linked to the Specification pattern in
                                [Evans and Fowler] and [Evans].</p>
                <h3 id="318(2)">Example: A Simple Query Object (Java)</h3>
                <p>This is a simple example of a Query Objectâ€”rather less than would be useful
                                for most situations but enough to give you an idea of what a Query Object is
                                about. It can query a single table based on set of criteria â€œANDâ€™edâ€ together (in
                                slightly more technical language, it can handle a conjunction of elementary
                                predicates).
                                The Query Object is set up using the language of domain objects rather than
                                that of the table structure. Thus, a query knows the class that itâ€™s for and a collection of criteria that correspond to the clauses of a where clause.
                                <pre>class QueryObject...
                                private Class klass;
                                private List criteria = new ArrayList();
                                A simple criterion is one that takes a field and a value and an SQL operator
                                to compare them.
                                class Criteria...
                                private String sqlOperator;
                                protected String field;
                                protected Object value;</pre>
                                To make it easier to create the right criteria, I can provide an appropriate creation method.
                                <pre>class Criteria...
                                public static Criteria greaterThan(String fieldName, int value) {
                                return Criteria.greaterThan(fieldName, new Integer(value));
                                }
                                public static Criteria greaterThan(String fieldName, Object value) {
                                return new Criteria(" > ", fieldName, value);
                                }
                                private Criteria(String sql, String field, Object value) {
                                this.sqlOperator = sql;
                                this.field = field;
                                this.value = value;
                                }
                                This allows me to find everyone with dependents by forming a query such as
                                class Criteria...
                                QueryObject query = new QueryObject(Person.class);
                                query.addCriteria(Criteria.greaterThan("numberOfDependents", 0));
                                Thus, if I have a person object such as this:
                                class Person...
                                private String lastName;
                                private String firstName;
                                private int numberOfDependents;</pre>
                                I can ask for all people with dependents by creating a query for person and adding a criterion.
                                <pre>QueryObject query = new QueryObject(Person.class);
                                query.addCriteria(Criteria.greaterThan("numberOfDependents", 0));</pre>
                                Thatâ€™s enough to describe the query. Now the query needs to execute by
                                turning itself into a SQL select. In this case I assume that my mapper class supports a method that finds objects based on a string thatâ€™s a where clause.
                                <pre>class QueryObject...
                                public Set execute(UnitOfWork uow) {
                                this.uow = uow;
                                return uow.getMapper(klass).findObjectsWhere(generateWhereClause());
                                }
                                class Mapper...
                                public Set findObjectsWhere (String whereClause) {
                                String sql = "SELECT" + dataMap.columnList() + " FROM " + dataMap.getTableName() + " WHERE "
                                + whereClause;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                Set result = new HashSet();
                                try {
                                stmt = DB.prepare(sql);
                                rs = stmt.executeQuery();
                                result = loadAll(rs);
                                } catch (Exception e) {
                                throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                return result;
                                }</pre>
                                Here Iâ€™m using a Unit of Work (184) that holds mappers indexed by the class
                                and a mapper that uses Metadata Mapping (306). The code is the same as that
                                in the example in Metadata Mapping (306) to save repeating the code in this
                                section.
                                To generate the where clause, the query iterates through the criteria and has
                                each one print itself out, tying them together with ANDs.
                                <pre>class QueryObject...
                                private String generateWhereClause() {
                                StringBuffer result = new StringBuffer();
                                for (Iterator it = criteria.iterator(); it.hasNext();) {
                                Criteria c = (Criteria)it.next();
                                if (result.length() != 0)
                                result.append(" AND ");
                                result.append(c.generateSql(uow.getMapper(klass).getDataMap()));
                                }
                                return result.toString();
                                }
                                class Criteria...
                                public String generateSql(DataMap dataMap) {
                                return dataMap.getColumnForField(field) + sqlOperator + value;
                                }
                                class DataMap...
                                public String getColumnForField (String fieldName) {
                                for (Iterator it = getColumns(); it.hasNext();) {
                                ColumnMap columnMap = (ColumnMap)it.next();
                                if (columnMap.getFieldName().equals(fieldName))
                                return columnMap.getColumnName();
                                }
                                throw new ApplicationException ("Unable to find column for " + fieldName);
                                }</pre>
                                As well as criteria with simple SQL operators, we can create more complex
                                criteria classes that do a little more. Consider a case-insensitive pattern match
                                query, like one that finds all people whose last names start with F. We can form
                                a query object for all people with such dependents.
                                <pre>QueryObject query = new QueryObject(Person.class);
                                query.addCriteria(Criteria.greaterThan("numberOfDependents", 0));
                                query.addCriteria(Criteria.matches("lastName", "f%"));</pre>
                                This uses a different criteria class that forms a more complex clause in the
                                where statement.
                                <pre>class Criteria...
                                public static Criteria matches(String fieldName, String pattern){
                                return new MatchCriteria(fieldName, pattern);
                                }
                                class MatchCriteria extends Criteria...
                                public String generateSql(DataMap dataMap) {
                                return "UPPER(" + dataMap.getColumnForField(field) + ") LIKE UPPER(â€™" + value + "â€™)";
                                }</pre></p>
                <h3 id="322">Repository</h3>
                <p><img src="img/part2.24.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Mediates between the domain and data mapping layers using a
                                collection-like interface for accessing domain objects.
                                A system with a complex domain model often benefits from a layer, such as the
                                one provided by Data Mapper (165), that isolates domain objects from details
                                of the database access code. In such systems it can be worthwhile to build
                                another layer of abstraction over the mapping layer where query construction
                                code is concentrated. This becomes more important when there are a large
                                number of domain classes or heavy querying. In these cases particularly, adding
                                this layer helps minimize duplicate query logic.
                                A Repository mediates between the domain and data mapping layers, acting
                                like an in-memory domain object collection. Client objects construct query
                                specifications declaratively and submit them to Repository for satisfaction.
                                Objects can be added to and removed from the Repository, as they can from a
                                simple collection of objects, and the mapping code encapsulated by the Reposiclient
                                tory will carry out the appropriate operations behind the scenes. Conceptually,
                                a Repository encapsulates the set of objects persisted in a data store and the
                                operations performed over them, providing a more object-oriented view of the
                                persistence layer. Repository also supports the objective of achieving a clean
                                separation and one-way dependency between the domain and data mapping
                                layers.</p>
                <h3 id="323">How It Works</h3>
                <p>Repository is a sophisticated pattern that makes use of a fair number of the
                                other patterns described in this book. In fact, it looks like a small piece of an
                                object-oriented database and in that way itâ€™s similar to Query Object (316),
                                which development teams may be more likely to encounter in an object-relational mapping tool than to build themselves. However, if a team has taken the
                                leap and built Query Object (316), it isnâ€™t a huge step to add a Repository
                                capability. When used in conjunction with Query Object (316), Repository
                                adds a large measure of usability to the object-relational mapping layer without
                                a lot of effort.
                                In spite of all the machinery behind the scenes, Repository presents a simple
                                interface. Clients create a criteria object specifying the characteristics of the
                                objects they want returned from a query. For example, to find person objects
                                by name we first create a criteria object, setting each individual criterion like
                                so: criteria.equals(Person.LAST_NAME, "Fowler"), and criteria.like(Person.FIRST_NAME,
                                "M"). Then we invoke repository.matching(criteria) to return a list of domain
                                objects representing people with the last name Fowler and a first name starting
                                with M. Various convenience methods similar to matching (criteria) can be
                                defined on an abstract repository; for example, when only one match is
                                expected soleMatch(criteria) might return the found object rather than a collection. Other common methods include byObjectId(id), which can be trivially
                                implemented using soleMatch.</p>
                <p>To code that uses a Repository, it appears as a simple in-memory collection
                                of domain objects. The fact that the domain objects themselves typically arenâ€™t
                                stored directly in the Repository is not exposed to the client code. Of course,
                                code that uses Repository should be aware that this apparent collection of
                                objects might very well map to a product table with hundreds of thousands of
                                records. Invoking all() on a catalog systemâ€™s ProductRepository might not be such
                                a good idea.
                                Repository replaces specialized finder methods on Data Mapper (165)
                                classes with a specification-based approach to object selection [Evans and
                                Fowler]. Compare this with the direct use of Query Object (316), in which
                                client code may construct a criteria object (a simple example of the specification pattern), add() that directly to the Query Object (316), and execute the
                                query. With a Repository, client code constructs the criteria and then passes
                                them to the Repository, asking it to select those of its objects that match.
                                From the client codeâ€™s perspective, thereâ€™s no notion of query â€œexecutionâ€;
                                rather thereâ€™s the selection of appropriate objects through the â€œsatisfactionâ€
                                of the queryâ€™s specification. This may seem an academic distinction, but it
                                illustrates the declarative flavor of object interaction with Repository, which
                                is a large part of its conceptual power.</p>
                <p>Under the covers, Repository combines Metadata Mapping (329) with a
                                Query Object (316) to automatically generate SQL code from the criteria.
                                Whether the criteria know how to add themselves to a query, the Query Object
                                (316) knows how to incorporate criteria objects, or the Metadata Mapping
                                (306) itself controls the interaction is an implementation detail.
                                The object source for the Repository may not be a relational database at all,
                                which is fine as Repository lends itself quite readily to the replacement of the
                                data-mapping component via specialized strategy objects. For this reason it can
                                be especially useful in systems with multiple database schemas or sources for
                                domain objects, as well as during testing when use of exclusively in-memory
                                objects is desirable for speed.
                                Repository can be a good mechanism for improving readability and clarity in
                                code that uses querying extensively. For example, a browser-based system featuring a lot of query pages needs a clean mechanism to process HttpRequest
                                objects into query results. The handler code for the request can usually convert
                                the HttpRequest into a criteria object without much fuss, if not automatically;
                                submitting the criteria to the appropriate Repository should require only an
                                additional line or two of code.</p>
                <h3 id="324">When to Use It</h3>
                <p>In a large system with many domain object types and many possible queries,
                                Repository reduces the amount of code needed to deal with all the querying
                                that goes on. Repository promotes the Specification pattern (in the form of the
                                criteria object in the examples here), which encapsulates the query to be performed in a pure object-oriented way. Therefore, all the code for setting up a
                                query object in specific cases can be removed. Clients need never think in SQL
                                and can write code purely in terms of objects.
                                However, situations with multiple data sources are where we really see
                                Repository coming into its own. Suppose, for example, that weâ€™re sometimes
                                interested in using a simple in-memory data store, commonly when we wants to
                                run a suite of unit tests entirely in memory for better performance. With no
                                database access, many lengthy test suites run significantly faster. Creating fixture for unit tests can also be more straightforward if all we have to do is construct some domain objects and throw them in a collection rather than having
                                to save them to the database in setup and delete them at teardown.</p>
                <p>Itâ€™s also conceivable, when the application is running normally, that certain
                                types of domain objects should always be stored in memory. One such example
                                is immutable domain objects (those that canâ€™t be changed by the user), which
                                once in memory, should remain there and never be queried for again. As weâ€™ll
                                see later in this chapter, a simple extension to the Repository pattern allows different querying strategies to be employed depending on the situation.
                                Another example where Repository might be useful is when a data feed is
                                used as a source of domain objectsâ€”say, an XML stream over the Internet, perhaps using SOAP, might be available as a source. An XMLFeedRepositoryStrategy
                                might be implemented that reads from the feed and creates domain objects
                                from the XML.</p>
                <h3 id="325">Further Reading</h3>
                <p>The specification pattern hasnâ€™t made it into a really good reference source yet.
                                The best published description so far is [Evans and Fowler]. A better description is currently in the works in [Evans].</p>
                <h3 id="325(2)">Example: Finding a Personâ€™s Dependents (Java)</h3>
                <p>From the client objectâ€™s perspective, using a Repository is simple. To retrieve its
                                dependents from the database a person object creates a criteria object representing the search criteria to be matched and sends it to the appropriate Repository.
                                <pre>public class Person {
                                public List dependents() {
                                Repository repository = Registry.personRepository();
                                Criteria criteria = new Criteria();
                                criteria.equal(Person.BENEFACTOR, this);
                                return repository.matching(criteria);
                                }
                                }</pre>
                                Common queries can be accommodated with specialized subclasses of
                                Repository. In the previous example we might make a PersonRepository subclass
                                of Repository and move the creation of the search criteria into the Repository
                                itself.
                                <pre>public class PersonRepository extends Repository {
                                public List list dependentsOf(Person aPerson) {
                                Criteria criteria = new Criteria();
                                criteria.equal(Person.BENEFACTOR, aPerson);
                                return matching(criteria);
                                }
                                }
                                The person object then calls the dependents() method directly on its Repository.
                                public class Person {
                                public List dependents() {
                                return Registry.personRepository().dependentsOf(this);
                                }
                                }</pre></p>
                <h3 id="326">Example: Swapping Repository Strategies (Java)</h3>
                <p>Because Repositoryâ€™s interface shields the domain layer from awareness of the
                                data source, we can refactor the implementation of the querying code inside the
                                Repository without changing any calls from clients. Indeed, the domain code
                                neednâ€™t care about the source or destination of domain objects. In the case of
                                the in-memory store, we want to change the matching() method to select from a
                                collection of domain objects the ones satisfy the criteria. However, weâ€™re not
                                interested in permanently changing the data store used but rather in being able
                                to switch between data stores at will. From this comes the need to change the
                                implementation of the matching() method to delegate to a strategy object that
                                does the querying. The power of this, of course, is that we can have multiple
                                strategies and we can set the strategy as desired. In our case, itâ€™s appropriate to
                                have two: RelationalStrategy, which queries the database, and InMemoryStrategy,
                                which queries the in-memory collection of domain objects. Each strategy implements the RepositoryStrategy interface, which exposes the matching() method, so
                                we get the following implementation of the Repository class:
                                <pre>abstract class Repository {
                                private RepositoryStrategy strategy;
                                protected List matching(Criteria aCriteria) {
                                return strategy.matching(aCriteria);
                                }
                                }</pre>
                                A RelationalStrategy implements matching() by creating a Query Object from
                                the criteria and then querying the database using it. We can set it up with the
                                appropriate fields and values as defined by the criteria, assuming here that the
                                Query Object knows how to populate itself from criteria:
                                <pre>public class RelationalStrategy implements RepositoryStrategy {
                                protected List matching(Criteria criteria) {
                                Query query = new Query(myDomainObjectClass())
                                query.addCriteria(criteria);
                                return query.execute(unitOfWork());
                                }
                                }</pre>
                                An InMemoryStrategy implements matching() by iterating over a collection of
                                domain objects and asking the criteria at each domain object if itâ€™s satisfied by
                                it. The criteria can implement the satisfaction code using reflection to interrogate the domain objects for the values of specific fields. The code to do the
                                selection looks like this:
                                <pre>public class InMemoryStrategy implements RepositoryStrategy {
                                private Set domainObjects;
                                protected List matching(Criteria criteria) {
                                List results = new ArrayList();
                                Iterator it = domainObjects.iterator();
                                while (it.hasNext()) {
                                DomainObject each = (DomainObject) it.next();
                                if (criteria.isSatisfiedBy(each))
                                results.add(each);
                                }
                                return results;
                                }
                                }</pre></p>
                <h3 id="329">Chapter 14</h3>
                <h2>Web Presentation Patterns</h2>
                <h3 id="330">Model View Controller</h3>
                <p><img src="img/part2.25.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Splits user interface interaction into three distinct roles.
                                Model View Controller (MVC) is one of the most quoted (and most misquoted)
                                patterns around. It started as a framework developed by Trygve Reenskaug for
                                the Smalltalk platform in the late 1970s. Since then it has played an influential
                                role in most UI frameworks and in the thinking about UI design.</p>
                <h3 id="330(2)">How It Works</h3>
                <p>MVC considers three roles. The model is an object that represents some
                                information about the domain. Itâ€™s a nonvisual object containing all the data
                                and behavior other than that used for the UI. In its most pure OO form the
                                model is an object within a Domain Model (116). You might also think of a
                                Transaction Script (110) as the model providing that it contains no UI
                                machinery. Such a definition stretches the notion of model, but fits the role
                                breakdown of MVC.</p>
                <p>The view represents the display of the model in the UI. Thus, if our model is
                                a customer object our view might be a frame full of UI widgets or an HTML
                                page rendered with information from the model. The view is only about display
                                of information; any changes to the information are handled by the third member of the MVC trinity: the controller. The controller takes user input, manipulates the model, and causes the view to update appropriately. In this way UI is a
                                combination of the view and the controller.
                                As I think about MVC I see two principal separations: separating the presentation from the model and separating the controller from the view.
                                Of these the separation of presentation from model is one of the most fundamental heuristics of good software design. This separation is important for several reasons.
                <ul>
                        <li>Fundamentally presentation and model are about different concerns. When youâ€™re developing a view youâ€™re thinking about the mechanisms of UI and how to lay out a good user interface. When youâ€™re working with a model you are thinking about business policies, perhaps database interactions. Certainly you will use different very different libraries when working with one or he other. Often people prefer one area to another and they specialize in one side of the line.</li>
                        <li>Depending on context, users want to see the same basic model information in different ways. Separating presentation and view allows you to develop multiple presentationsâ€”indeed, entirely different interfacesâ€”and yet use the same model code. Most noticeably this could be providing the same model with a rich client, a Web browser, a remote API, and a command-line interface. Even within a single Web interface you might have different customer pages at different points in an application.</li>
                        <li>Nonvisual objects are usually easier to test than visual ones. Separating presentation and model allows you to test all the domain logic easily without resorting to things like awkward GUI scripting tools.</li>
                </ul>
                                A key point in this separation is the direction of the dependencies: the presentation depends on the model but the model doesnâ€™t depend on the presentation. People programming in the model should be entirely unaware of what
                                presentation is being used, which both simplifies their task and makes it easier
                                to add new presentations later on. It also means that presentation changes can
                                be made freely without altering the model.</p>
                <p>This principle introduces a common issue. With a rich-client interface of
                                multiple windows itâ€™s likely that there will be several presentations of a model
                                on a screen at once. If a user makes a change to the model from one presentation, the others need to change as well. To do this without creating a dependency you usually need an implementation of the Observer pattern [Gang of
                                Four], such as event propagation or a listener. The presentation acts as the
                                observer of the model: whenever the model changes it sends out an event and
                                the presentations refresh the information.</p>
                <p>The second division, the separation of view and controller, is less important.
                                Indeed, the irony is that almost every version of Smalltalk didnâ€™t actually make
                                a view/controller separation. The classic example of why youâ€™d want to separate them is to support editable and noneditable behavior, which you can do
                                with one view and two controllers for the two cases, where the controllers are
                                strategies [Gang of Four] for the view. In practice most systems have only one
                                controller per view, however, so this separation is usually not done. It has come
                                back into vogue with Web interfaces where it becomes useful for separating the
                                controller and view again.
                                The fact that most GUI frameworks combine view and controller has led to
                                many misquotations of MVC. The model and the view are obvious, but whereâ€™s
                                the controller? The common idea is that it sits between the model and the view,
                                as in the Application Controller (379)â€”it doesnâ€™t help that the word â€œcontrollerâ€ is used in both contexts. Whatever the merits of a Application Controller
                                (379), itâ€™s a very different beast from an MVC controller.
                                For the purposes of this set of patterns these principles are really all you need
                                to know. If you want to dig deeper into MVC the best available reference is
                                [POSA].</p>
                <h3 id="332">When to Use It</h3>
                <p>As I said, the value of MVC lies in its two separations. Of these the separation
                                of presentation and model is one of the most important design principles in
                                software, and the only time you shouldnâ€™t follow it is in very simple systems
                                where the model has no real behavior in it anyway. As soon as you get some
                                nonvisual logic you should apply the separation. Unfortunately, a lot of UI
                                frameworks make it difficult, and those that donâ€™t are often taught without a
                                separation.
                                The separation of view and controller is less important, so Iâ€™d only recommend doing it when it is really helpful. For rich-client systems, that ends up
                                being hardly ever, although itâ€™s common in Web front ends where the controller
                                is separated out. Most of the patterns on Web design here are based on that
                                principle.</p>
                <h3 id="333">Page Controller</h3>
                <p><img src="img/part2.26.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that handles a request for a specific
                                page or action on a Web site.
                                Most peopleâ€™s basic Web experience is with static HTML pages. When you
                                request static HTML you pass to the Web server the name and path for a
                                HTML document stored on it. The key notion is that each page on the Web site
                                is a separate document on the server. With dynamic pages things can get much
                                more interesting since thereâ€™s a much more complex relationship between path
                                names and the file that responds. However, the approach of one path leading to
                                one file that handles the request is a simple model to understand.
                                As a result, Page Controller has one input controller for each logical page of
                                the Web site. That controller may be the page itself, as it often is in server page
                                environments, or it may be a separate object that corresponds to that page.</p>
                <h3 id="333(2)">How It Works</h3>
                <p>The basic idea behind a Page Controller is to have one module on the Web
                                server act as the controller for each page on the Web site. In practice, it doesnâ€™t
                                work out to exactly one module per page, since you may hit a link sometimes
                                and get a different page depending on dynamic information. More strictly, the
                                controllers tie in to each action, which may be clicking a link or a button.
                                The Page Controller can be structured either as a script (CGI script, servlet,
                                etc.) or as a server page (ASP, PHP, JSP, etc.). Using a server page usually combines the Page Controller and a Template View (350) in the same file. This
                                works well for the Template View (350) but less well for the Page Controller
                                because itâ€™s more awkward to properly structure the module. If the page is a
                                simple display, this isnâ€™t a problem. However, if thereâ€™s logic involved in either
                                pulling data out of the request or deciding which actual view to display, then
                                you can end up with awkward scriptlet code in the server page.</p>
                <p>One way of dealing with scriptlet code is to use a helper object. In this case
                                the first thing the server page does is call the helper object to handle all the
                                logic. The helper may return control to the original server page, or it may forward to a different server page to act as the view, in which case the server page
                                is the request handler but most of the controller logic lies in the helper.
                                Another approach is to make a script the handler and controller. The Web
                                server passes control to the script; the script carries out the controllerâ€™s responsibilities and finally forwards to an appropriate view to display any results.
                                The basic responsibilities of a Page Controller are:
                <ul>
                        <li>Decode the URL and extract any form data to figure out all the data for the action.</li>
                        <li>Create and invoke any model objects to process the data. All relevant data from the HTML request should be passed to the model so that the model objects donâ€™t need any connection to the HTML request.</li>
                        <li>Determine which view should display the result page and forward the model information to it.</li>
                </ul>
                                The Page Controller neednâ€™t be a single class but can invoke helper objects.
                                This is particularly useful if several handlers have to do similar tasks. A helper
                                class can then be a good spot to put any code that would otherwise be duplicated.
                                Thereâ€™s no reason that you canâ€™t have some URLs handled by server pages
                                and some by scripts. Any URLs that have little or no controller logic are best
                                handled with a server page, since that provides a simple mechanism thatâ€™s easy
                                to understand and modify. Any URLs with more complicated logic go to a
                                script. Iâ€™ve come across teams who want to handle everything the same way: all
                                server page or everything is a script. Any advantages of consistency in such an
                                application are usually offset by the problems of either scriptlet-laden server
                                pages or lots of simple pass-through scripts.</p>
                <h3 id="334">When to Use It</h3>
                                The main decision point is whether to use Page Controller or Front Controller
                                (344). Of the two, Page Controller is the most familiar to work with and leads
                                to a natural structuring mechanism where particular actions are handled by
                                particular server pages or script classes. Your trade-off is thus the greater complexity of Front Controller (344) against the various advantages of Front Con
                                troller, most of which make a difference in Web sites that have more navigational
                                complexity.
                                Page Controller works particularly well in a site where most of the controller
                                logic is pretty simple. In this case most URLs can be handled with a server page
                                and the more complicated cases with helpers. When your controller logic is simple, Front Controller (344) adds a lot of overhead.
                                Itâ€™s not uncommon to have a site where some requests are dealt with by Page
                                Controllers and others are dealt with by Front Controllers (344), particularly
                                when a team is refactoring from one to another. Actually, the two patterns mix
                                without too much trouble.</p>
                <h3 id="335">Example: Simple Display with a Servlet Controller and a JSP View (Java)</h3>
                <p>A simple example of an Page Controller displays some information about
                                something. Here weâ€™ll show it displaying some information about a recording artist. The URL runs along the lines of http://www.thingy.com/recordingApp/
                                artist?name=danielaMercury.
                <p><img src="img/figure 14.1.png" alt="no img" style="margin-left: 200px;"></p>
                                The Web server needs to be configured to recognize /artist as a call to ArtistController. In Tomcat you do this with the following code in the web.xml file:
                                <pre><servlet>
                                <servlet-name>artist</servlet-name>
                                <servlet-class>actionController.ArtistController</servlet-class>
                                </servlet>
                                <servlet-mapping>
                                <servlet-name>artist</servlet-name>
                                <url-pattern>/artist</url-pattern>
                                </servlet-mapping></pre>
                                The artist controller needs to implement a method to handle the request.
                                <pre>class ArtistController...
                                public void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException {
                                Artist artist = Artist.findNamed(request.getParameter("name"));
                                if (artist == null)
                                forward("/MissingArtistError.jsp", request, response);
                                else {
                                request.setAttribute("helper", new ArtistHelper(artist));
                                forward("/artist.jsp", request, response);
                                }
                                }</pre>
                                Although this is a very simple case, it covers the salient points. First the controller needs to create the necessary model objects to do their thing, here just
                                finding the correct model object to display. Second it puts the right information
                                in the HTTP request so that the JSP can display it properly. In this case it creates a helper and puts it into the request. Finally it forwards to the Template
                                View (350) to handle the display. Forwarding is a common behavior, so it sits
                                naturally on a superclass for all Page Controllers.
                                <pre>class ActionServlet...
                                protected void forward(String target,
                                HttpServletRequest request,
                                HttpServletResponse response)
                                throws IOException, ServletException
                                {
                                RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(target);
                                dispatcher.forward(request, response);
                                }</pre>
                                The main point of coupling between the Template View (350) and the Page
                                Controller is the parameter names in the request to pass on any objects that the
                                JSP needs.
                                The controller logic here is really very simple, but as it gets more complex we
                                can continue to use the servlet as a controller. We can have a similar behavior
                                for albums, with the twist that classical albums both have a different model
                                object and are rendered with a different JSP. To do this behavior we can again
                                use a controller class.
                                <pre>class AlbumController...
                                public void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException
                                {
                                Album album = Album.find(request.getParameter("id"));
                                if (album == null) {
                                forward("/missingAlbumError.jsp", request, response);
                                return;
                                }
                                request.setAttribute("helper", album);
                                if (album instanceof ClassicalAlbum)
                                forward("/classicalAlbum.jsp", request, response);
                                else
                                forward("/album.jsp", request, response);
                                }</pre>
                                Notice that in this case Iâ€™m using the model objects as helpers rather than creating a separate helper class. This is worth doing if a helper class is just a dumb
                                forwarder to the model class. If you do it, though, make sure that the model
                                class doesnâ€™t contain any servlet-dependent code. Any servlet-dependent code
                                should be in a separate helper class.</p>
                <h3 id="337">Example: Using a JSP as a Handler (Java)</h3>
                <p>Using a servlet as a controller is one route to take, but the most common route
                                is to make the server page itself the controller. The problem with this approach
                                is that it results in scriptlet code at the beginning of the server page and, as you
                                may have gathered, I think that scriptlet code has the same relationship to welldesigned software that professional wrestling has to sport.
                                Despite this you can make a server page as the request handler while delegating control to the helper to actually carry out the controller function. This preserves the simple property of having your URLs denoted by server pages. Iâ€™ll do
                                this for the album display, using the URL of the form http://localhost:8080/isa/
                                album.jsp?id=zero. Most albums are displayed directly with the album JSP, but
                                classical recordings require a different display, a classical album JSP.
                                This controller behavior appears in a helper class to the JSP. The helper is set
                                up in the album JSP itself.
                                <pre>album.jsp...
                                <jsp:useBean id="helper" class="actionController.AlbumConHelper"/>
                                <%helper.init(request, response);%>
                                The call to init sets the helper up to carry out the controller behavior.
                                class AlbumConHelper extends HelperController...
                                public void init(HttpServletRequest request, HttpServletResponse response) {
                                super.init(request, response);
                                if (getAlbum() == null) forward("missingAlbumError.jsp", request, response);
                                if (getAlbum() instanceof ClassicalAlbum) {
                                request.setAttribute("helper", getAlbum());
                                forward("/classicalAlbum.jsp", request, response);
                                }
                                }
                                Common helper behavior naturally sits on a helper superclass.
                                class HelperController...
                                public void init(HttpServletRequest request, HttpServletResponse response) {
                                this.request = request;
                                this.response = response;
                                }
                                protected void forward(String target,
                                HttpServletRequest request,
                                HttpServletResponse response)
                                {
                                try {
                                RequestDispatcher dispatcher = request.getRequestDispatcher(target);
                                if (dispatcher == null) response.sendError(response.SC_NO_CONTENT);
                                else dispatcher.forward(request, response);
                                } catch (IOException e) {
                                throw new ApplicationException(e);
                                } catch (ServletException e) {
                                throw new ApplicationException(e);
                                }
                                }</pre>
                                The key difference between the controller behavior here and that when using
                                a servlet is that the handler JSP is also the default view and, unless the controller forwards to a different JSP, control reverts to the original handler. This is an
                                advantage when you have pages where the JSP directly acts as the view most of
                                the time and so thereâ€™s no forwarding to be done. The initialization of the
                                helper acts to kick off any model behavior and set things up for the view later
                                on. Itâ€™s a simple model to follow, since people generally associate a Web page
                                with the server page that acts as its view. Often this also fits naturally with Web
                                server configuration.
                                The call to initialize the handler is a little clumsy. In a JSP environment this
                                awkwardness can be much better handled with a custom tag. Such a tag can
                                automatically create an appropriate object, put it in the request, and initialize
                                it. With that all you need is a simple tag in the JSP page.
                                <pre><helper:init name = "actionController.AlbumConHelper"/>
                                The custom tagâ€™s implementation then does the work.
                                class HelperInitTag extends HelperTag...
                                private String helperClassName;
                                public void setName(String helperClassName) {
                                this.helperClassName = helperClassName;
                                }
                                public int doStartTag() throws JspException {
                                HelperController helper = null;
                                try {
                                helper = (HelperController) Class.forName(helperClassName).newInstance();
                                } catch (Exception e) {
                                throw new ApplicationException("Unable to instantiate " + helperClassName, e);
                                }
                                initHelper(helper);
                                pageContext.setAttribute(HELPER, helper);
                                return SKIP_BODY;
                                }
                                private void initHelper(HelperController helper) {
                                HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();
                                HttpServletResponse response = (HttpServletResponse) pageContext.getResponse();
                                helper.init(request, response);
                                }
                                class HelperTag...
                                public static final String HELPER = "helper";
                                If Iâ€™m going to use custom tags like this, I might as well make them for property access too.
                                class HelperGetTag extends HelperTag...
                                private String propertyName;
                                public void setProperty(String propertyName) {
                                this.propertyName = propertyName;
                                }
                                public int doStartTag() throws JspException {
                                try {
                                pageContext.getOut().print(getProperty(propertyName));
                                } catch (IOException e) {
                                throw new JspException("unable to print to writer");
                                }
                                return SKIP_BODY;
                                }
                                class HelperTag...
                                protected Object getProperty(String property) throws JspException {
                                Object helper = getHelper();
                                try {
                                final Method getter = helper.getClass().getMethod(gettingMethod(property), null);
                                return getter.invoke(helper, null);
                                } catch (Exception e) {
                                throw new JspException
                                ("Unable to invoke " + gettingMethod(property) + " - " + e.getMessage());
                                }
                                }
                                private Object getHelper() throws JspException {
                                Object helper = pageContext.getAttribute(HELPER);
                                if (helper == null) throw new JspException("Helper not found.");
                                return helper;
                                }
                                private String gettingMethod(String property) {
                                String methodName = "get" + property.substring(0, 1).toUpperCase() +
                                property.substring(1);
                                return methodName;
                                }</pre>
                                (You may think itâ€™s better to use the Java Beans mechanism than to just
                                invoke a getter using reflection. If so, youâ€™re probably right . . . and also probably intelligent enough to figure out how to change the method to do that.)
                                With the getting tag defined, I can use it to pull information out of the helper.
                                The tag is shorter and eliminates any chance of my mizpelling â€œhelper.â€</p>
                                <B><helper:get property = "title"/></B>
                <h3 id="340">Example: Page Handler with a Code Behind (C#)</h3>
                <p>The Web system in .NET is designed to work with the Page Controller and
                                Template View (350) patterns, although you can certainly decide to handle Web
                                events with a different approach. In this next example, Iâ€™ll use the preferred
                                style of .NET, building the presentation layer on top of a domain using Table
                                Module (125) and using data sets as the main carrier of information between
                                layers.
                                This time weâ€™ll have a page that displays runs scored and the run rate for one
                                innings of a cricket match. As I know Iâ€™ll have many readers who are afflicted
                                with no material experience of this art form, let me summarize by saying that
                                the runs scored are the score of the batsman and the run rate is how many runs
                                he scores divided by the number of balls he faces. The runs scored and balls
                                faced are in the database; the run rate needs to be calculated by the applicationâ€”a tiny but pedagogically useful piece of domain logic.
                                The handler in this design is an ASP.NET Web page, captured in a .aspx file.
                                As with other server page constructs, this file allows you to embed programming logic directly into the page as scriptlets. Since you know Iâ€™d rather drink
                                bad beer than write scriptlets, you know thereâ€™s little chance that Iâ€™d do that.
                                My savior in this case is ASP.NETâ€™s code behind mechanism that allows you to
                                associate a regular file and class with the aspx page, signaled in the header of
                                the aspx page.
                                <%@ Page language="c#" Codebehind="bat.aspx.cs" AutoEventWireup="false" trace="False"
                                Inherits="batsmen.BattingPage" %></p>
                <p>The page is set up as a subclass of the code behind class, and as such can use
                                all its protected properties and methods. The page object is the handler of the
                                request, and the code behind can define the handling by defining a Page_Load
                                method. If most pages follow a common flow, I can define a Layer Supertype
                                (475) that has a template method [Gang of Four] for this.
                                <pre>class CricketPage...
                                protected void Page_Load(object sender, System.EventArgs e) {
                                db = new OleDbConnection(DB.ConnectionString);
                                if (hasMissingParameters())
                                errorTransfer (missingParameterMessage);
                                DataSet ds = getData();
                                if (hasNoData (ds))
                                errorTransfer ("No data matches your request");
                                applyDomainLogic (ds);
                                DataBind();
                                prepareUI(ds);
                                }</pre>
                                The template method breaks down the request handling into a number of common steps. This way we can define a single common flow for handling Web
                                requests, while allowing each Page Controller to supply implementations for the
                                specific steps. If you do this, once youâ€™ve written a few Page Controllers, youâ€™ll
                                know what common flow to use for the template method. If any page needs to do
                                something completely different, it can always override the page load method.
                                The first task is to do validation on the parameters coming into the page. In a
                                more realistic example this might entail initial sanity checking of various form
                                values, but in this case weâ€™re just decoding a URL of the form http://localhost/
                                batsmen/bat.aspx?team=England&innings=2&match=905. The only validation in this example
                                is that the various parameters required for the database query are present. As
                                usual Iâ€™ve been overly simplistic in the error handling until somebody writes a
                                good set of patterns on validationâ€”so here the particular page defines a set of
                                mandatory parameters and the Layer Supertype (475) has the logic for checking
                                them.
                                <pre>class CricketPage...
                                abstract protected String[] mandatoryParameters();
                                private Boolean hasMissingParameters() {
                                foreach (String param in mandatoryParameters())
                                if (Request.Params[param] == null) return true;
                                return false;
                                }
                                private String missingParameterMessage {
                                get {
                                String result = "<P>This page is missing mandatory parameters:</P>";
                                result += "<UL>";
                                foreach (String param in mandatoryParameters())
                                if (Request.Params[param] == null)
                                result += String.Format("<LI>{0}</LI>", param);
                                result += "</UL>";
                                return result;
                                }
                                }
                                protected void errorTransfer (String message) {
                                Context.Items.Add("errorMessage", message);
                                Context.Server.Transfer("Error.aspx");
                                }
                                class BattingPage...
                                override protected String[] mandatoryParameters() {
                                String[] result = {"team", "innings", "match"};
                                return result;
                                }</pre>
                                The next stage is to pull the data out of the database and put it in an
                                ADO.NET disconnected data set object. Here this is a single query to the batting table.
                                <pre>class CricketPage...
                                abstract protected DataSet getData();
                                protected Boolean hasNoData(DataSet ds) {
                                foreach (DataTable table in ds.Tables)
                                if (table.Rows.Count != 0) return false;
                                return true;
                                }
                                class BattingPage...
                                override protected DataSet getData() {
                                OleDbCommand command = new OleDbCommand(SQL, db);
                                command.Parameters.Add(new OleDbParameter("team", team));
                                command.Parameters.Add(new OleDbParameter("innings", innings));
                                command.Parameters.Add(new OleDbParameter("match", match));
                                OleDbDataAdapter da = new OleDbDataAdapter(command);
                                DataSet result = new DataSet();
                                da.Fill(result, Batting.TABLE_NAME);
                                return result;
                                }
                                private const String SQL =
                                @"SELECT * from batting
                                WHERE team = ? AND innings = ? AND matchID = ?
                                ORDER BY battingOrder";</pre>
                                Now the domain logic gets its turn to play, organized as a Table Module
                                (125). The controller passes the retrieved data set to the Table Module (125) for
                                processing.
                                <pre>class CricketPage...
                                protected virtual void applyDomainLogic (DataSet ds) {}
                                class BattingPage...
                                override protected void applyDomainLogic (DataSet dataSet) {
                                batting = new Batting(dataSet);
                                batting.CalculateRates();
                                }</pre>
                                At this point the controller part of the page handler is done. By this I mean,
                                in classic Model View Controller (330) terms, that the controller should now
                                hand over to the view to do display. In this design the BattingPage acts as both
                                the controller and the view and the last call to prepareUI is part of the view
                                behavior. I can now say farewell to this example in this pattern. However, I suspect youâ€™ll find this to lack a certain dramatic closure, so you can find the example continued later (page 350).</p>
                <h3 id="344">Front Controller</h3>
                <p><img src="img/part2.27.png" alt="no img" style="margin-left: 200px;"></p>
                <p>A controller that handles all requests for a Web site.
                                In a complex Web site there are many similar things you need to do when handling a request. These things include security, internationalization, and providing particular views for certain users. If the input controller behavior is
                                scattered across multiple objects, much of this behavior can end up duplicated.
                                Also, itâ€™s difficult to change behavior at runtime.
                                The Front Controller consolidates all request handling by channeling
                                requests through a single handler object. This object can carry out common
                                behavior, which can be modified at runtime with decorators. The handler then
                                dispatches to command objects for behavior particular to a request.</p>
                <h3 id="344(2)">How It Works</h3>
                <p>A Front Controller handles all calls for a Web site, and is usually structured in
                                two parts: a Web handler and a command hierarchy. The Web handler is the
                                object that actually receives post or get requests from the Web server. It pulls
                                just enough information from the URL and the request to decide what kind of
                                action to initiate and then delegates to a command to carry out the action
                <p><img src="img/figure 14.2.png" alt="no img" style="margin-left: 200px;"></p>
                                The Web handler is almost always implemented as a class rather than as a
                                server page, as it doesnâ€™t produce any response. The commands are also classes
                                rather than server pages and in fact donâ€™t need any knowledge of the Web environment, although theyâ€™re often passed the HTTP information. The Web handler itself is usually a fairly simple program that does nothing other than decide
                                which command to run.
                                The Web handler can decide which command to run either statically or
                                dynamically. The static version involves parsing the URL and using conditional
                                logic; the dynamic version usually involves taking a standard piece of the URL
                                and using dynamic instantiation to create a command class.
                                The static case has the advantage of explicit logic, compile time error checking on the dispatch, and lots of flexibility in the look of your URLs. The
                                dynamic case allows you to add new commands without changing the Web
                                handler.</p>
                <p>With dynamic invocation you can put the name of the command class into
                                the URL or you can use a properties file that binds URLs to command class
                                names. The properties file is another file to edit, but it does make it easier to
                                change your class names without a lot of searching through your Web pages.
                                A particularly useful pattern to use in conjunction with Front Controller is
                                Intercepting Filter, described in [Alur et al.]. This is essentially a decorator that
                                wraps the handler of the front controller allowing you to build a filter chain (or
                                pipeline of filters) to handle issues such as authentication, logging, and locale
                                identification. Using filters allows you to dynamically set up the filters to use at
                                configuration time.
                                Rob Mee showed me an interesting variation of Front Controller using a
                                two stage Web handler separated into a degenerate Web handler and a dispatcher. The degenerate Web handler pulls the basic data out of the http
                                parameters and hands it to the dispatcher in such a way that the dispatcher is
                                completely independent of the Web server framework. This makes testing easier because test code can drive the dispatcher directly without having to run in
                                a Web server.
                                Remember that both the handler and the commands are part of the controller. As a result the commands can (and should) choose which view to use for the
                                response. The only responsibility of the handler is in choosing which command
                                to execute. Once thatâ€™s done, it plays no further part in that request.</p>
                <h3 id="346">When to Use It</h3>
                <p>The Front Controller is a more complicated design than its obvious counterpart,
                                Page Controller (333). It therefore needs a few advantages to be worth the effort.
                                Only one Front Controller has to be configured into the Web server; the Web
                                handler does the rest of the dispatching. This simplifies the configuration of the
                                Web server, which is an advantage if the Web server is awkward to configure.
                                With dynamic commands you can add new commands without changing anything. They also ease porting since you only have to register the handler in a
                                Web-server-specific way.
                                Because you create new command objects with each request, you donâ€™t
                                have to worry about making the command classes thread-safe. In this way
                                you avoid the headaches of multi-threaded programming; however, you do
                                have to make sure that you donâ€™t share any other objects, such as the model
                                objects.</p>
                <p>A commonly stated advantage of a Front Controller is that it allows you to
                                factor out code thatâ€™s otherwise duplicated in Page Controller (333). To be fair,
                                however, you can also do much of this with a superclass Page Controller (333).
                                Thereâ€™s just one controller, so you can easily enhance its behavior at runtime
                                with decorators [Gang of Four]. You can have decorators for authentication,
                                character encoding, internationalization, and so forth, and add them using a
                                configuration file or even while the server is running. ([Alur et al.] describe this
                                approach in detail under the name Intercepting Filter.)</p>
                <h3 id="347">Further Reading</h3>
                <p>[Alur et al.] give a detailed description of how to implement Front Controller in
                                Java. They also describe Intercepting Filter, which goes very well with Front
                                Controller.
                                A number of Java Web frameworks use this pattern. An excellent example
                                appears in [Struts].</p>
                <h3 id="347(2)">Example: Simple Display (Java)</h3>
                <p>Hereâ€™s a simple case of using Front Controller for the original and innovative task
                                of displaying information about a recording artist. Weâ€™ll use dynamic commands
                                with a URL of the form http://localhost:8080/isa/music?name=barelyWorks&command=
                                Artist. The command parameter tells the Web handler which command to use.
                                Figure 14.3 The classes that implement Front Controller.
                <p><img src="img/figure 14.3.png" alt="no img" style="margin-left: 200px;"></p>
                                Weâ€™ll begin with the handler, which Iâ€™ve implemented as a servlet.
                                <pre>class FrontServlet...
                                public void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException {
                                FrontCommand command = getCommand(request);
                                command.init(getServletContext(), request, response);
                                command.process();
                                }
                                private FrontCommand getCommand(HttpServletRequest request) {
                                try {
                                return (FrontCommand) getCommandClass(request).newInstance();
                                } catch (Exception e) {
                                throw new ApplicationException(e);
                                }
                                }
                                private Class getCommandClass(HttpServletRequest request) {
                                Class result;
                                final String commandClassName =
                                "frontController." + (String) request.getParameter("command") + "Command";
                                try {
                                result = Class.forName(commandClassName);
                                } catch (ClassNotFoundException e) {
                                result = UnknownCommand.class;
                                }
                                return result;
                                }</pre>
                                The logic is straightforward. The handler tries to instantiate a class named by
                                concatenating the command name and â€œCommand.â€ Once it has the new command it initializes it with the necessary information from the HTTP server. Iâ€™ve
                                passed in what I need for this simple example. You may well need more, such as
                                the HTTP session. If you canâ€™t find a command, Iâ€™ve used the Special Case (496)
                                pattern and returned an unknown command. As is often the case, Special Case
                                (496) allows you to avoid a lot of extra error checking.
                                Commands share a fair bit of data and behavior. They all need to be initialized with information from the Web server.
                                <pre>class FrontCommand...
                                protected ServletContext context;
                                protected HttpServletRequest request;
                                protected HttpServletResponse response;
                                public void init(ServletContext context,
                                HttpServletRequest request,
                                HttpServletResponse response)
                                {
                                this.context = context;
                                this.request = request;
                                this.response = response;
                                }</pre>
                                They can also provide common behavior, such as a forward method, and define
                                an abstract process command for the actual commands to override.
                                <pre>class FrontCommand...
                                abstract public void process()throws ServletException, IOException ;
                                protected void forward(String target) throws ServletException, IOException
                                {
                                RequestDispatcher dispatcher = context.getRequestDispatcher(target);
                                dispatcher.forward(request, response);
                                }
                                The command object is very simple, at least in this case. It just implements
                                the process method, which involves invoking the appropriate behavior on the
                                model objects, putting the information needed for the view into the request,
                                and forwarding to a Template View (350).
                                class ArtistCommand...
                                public void process() throws ServletException, IOException {
                                Artist artist = Artist.findNamed(request.getParameter("name"));
                                request.setAttribute("helper", new ArtistHelper(artist));
                                forward("/artist.jsp");
                                }
                                The unknown command just brings up a boring error page.
                                class UnknownCommand...
                                public void process() throws ServletException, IOException {
                                forward("/unknown.jsp");
                                }</pre></p>
                <h3 id="350">Template View</h3>
                <p><img src="img/part2.28.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Renders information into HTML by
                                embedding markers in an HTML page.
                                Writing a program that spits out HTML is often more difficult than you might
                                imagine. Although programming languages are better at creating text than
                                they used to be (some of us remember character handling in Fortran and standard Pascal), creating and concatenating string constructs is still painful. If
                                there isnâ€™t much to do, it isnâ€™t too bad, but a whole HTML page is a lot of text
                                manipulation.
                                With static HTML pagesâ€”those that donâ€™t change from request to requestâ€”
                                you can use nice WYSIWG editors. Even those of us who like raw text editors
                                find it easier to just type in the text and tags rather than fiddle with string concatenation in a programming language.
                                Of course the issue is with dynamic Web pagesâ€”those that take the results
                                of something like database queries and embed them into the HTML. The page
                                looks different with each result, and as a result regular HTML editors arenâ€™t up
                                to the job.</p>
                <p>The best way to work is to compose the dynamic Web page as you do a static
                                page but put in markers that can be resolved into calls to gather dynamic information. Since the static part of the page acts as a template for the particular
                                response, I call this a Template View.
                                <pre>Book
                                Author
                                Model
                                <HTML><P><B>
                                <jsp:getProperty
                                name="bookHelper"
                                property="title"/></B>
                                <BR/>
                                Author:
                                <jsp:getProperty
                                name="bookHelper"
                                property="author"/>
                                </P>
                                </HTML>
                                getTitle
                                getAuthor
                                Book Helper</pre></p>
                <h3 id="351">How It Works</h3>
                <p>The basic idea of Template View is to embed markers into a static HTML page
                                when itâ€™s written. When the page is used to service a request, the markers are
                                replaced by the results of some computation, such as a database query. This
                                way the page can be laid out in the usual manner, often with WYSIWYG editors, often by people who arenâ€™t programmers. The markers then communicate
                                with real programs to put in the results.
                                A lot of tools use Template View. As a result this pattern isnâ€™t about how to
                                build one yourself, but about how to use one effectively and what the alternative is.
                                Embedding the Markers There are a number of ways markers can be placed in
                                the HTML. One is to use HTML-like tags. This works well with WYSIWYG
                                editors because they realize that anything between the angled brackets (<>) is
                                special and so either ignore it or treat it differently. If the tags follow the rules
                                for well-formed XML you can also use XML tools on the resulting document
                                (providing your HTML is XHMTL, of course).
                                Another way to do this is to use special text markers in the body text. WYSIWYG editors treat that as regular text, still ignoring it but probably doing
                                annoying things to it like spell checking. The advantage is that the syntax can
                                be easier than the clunky syntax of HTML/XML.</p>
                <p>Many environments provide the set of tags you use but more and more platforms now give you the ability to define your own tags and markers so you can
                                design them to fit in with your particular needs.
                                One of the most popular forms of Template View is a server page such as
                                ASP, JSP, or PHP. These actually go a step further than the basic form of a Template View in that they allow you to embed arbitrary programming logic,
                                referred to as scriptlets, into the page. In my view, however, this feature is actually a big problem and youâ€™re better off limiting yourself to basic Template
                                View behavior when you use server page technology.
                                The most obvious disadvantage of putting a lot of scriptlets into a page is
                                that it eliminates the possibility of nonprogrammers editing the page. This is
                                particularly important when youâ€™re using graphic designers for the page design.
                                However, the biggest problems of embedding scriptlets into the page come from
                                the fact that a page is poor module for a program. Even with an object-oriented
                                language the page construct loses you most of the structural features that make
                                it possible to do a modular design either in OO or in procedural style.
                                Even worse, putting a lot of scriptlets into the page makes it too easy to mingle the different layers of an enterprise application. When domain logic starts
                                turning up on server pages it becomes far too difficult to structure it well and
                                far too easy to duplicate it across different server pages. All in all, the worst
                                code Iâ€™ve seen in the last few years has been server page code.</p>
                <p>Helper Object The key to avoiding scriptlets is to provide a regular object as a
                                helper to each page. This helper has all the real programming logic. The page
                                only has calls into it, which simplifies the page and makes it a more pure Template View. The resulting simplicity allows nonprogrammers to edit the page
                                and programmers to concentrate on the helper. Depending on the actual tool
                                youâ€™re using, you can often reduce all the templates in a page to HTML/XML
                                tags, which keeps the page more consistent and more amenable to tool support.
                                This sounds like a simple and commendable principle, but as ever quite a few
                                dirty issues make things more complicated. The simplest markers are those that
                                get some information from the rest of the system and put in the correct place on
                                the page. They are easily translated into calls to the helper that result in text, (or
                                something thatâ€™s trivially turned into text), and the engine places the text on the
                                page.</p>
                <p>Conditional Display A more knotty issue is conditional page behavior. The
                                simplest case is the situation where something is displayed only if a condition is
                                true. That might be some kind of conditional tag along the lines of <IF condition
                                = "$pricedrop > 0.1"> ...show some stuff </IF>. The trouble with this is that when
                                you start having conditional tags like this, you start going down the path of
                                turning the templates into a programming language in and of themselves. This
                                leads you into all the same problems you face when you embed scriptlets in the
                                page. If you need a full programming language, you might as well use scriptlets,
                                but you know what I think of that idea!</p>
                <p>As a result, I see purely conditional tags as a bad smell, something you
                                should try to avoid. You canâ€™t always avoid them, but you should try to come
                                up with something more focused than a general purpose <IF> tag.
                                If youâ€™re displaying some text conditionally, one option is to move the condition into the helper. The page will then always insert the result of the call into
                                helper. Itâ€™s just that if the condition isnâ€™t true the helper will send back an empty
                                string, but this way the helper holds all the logic. This approach works best if
                                thereâ€™s no markup for the returned text or itâ€™s enough to return empty markup
                                that gets ignored by the browser.</p>
                <p>This doesnâ€™t work if, say, you want to highlight good-selling items in a list by
                                putting their names in bold. In such a situation you always need the names displayed but sometimes you want the special markup. One way to get it is to have
                                the helper generate the markup. This keeps all the logic out of the page, at the
                                cost of moving the choice of highlighting mechanism away from the page
                                designer and giving it to the programming code.
                                In order to keep the choice of HTML in the hands of the page design, you
                                need some form of conditional tag. However itâ€™s important to look beyond a
                                simple <IF>. A good route to go is a focused tag, so rather than a tag that looks
                                like this:
                                <pre><IF expression = "isHighSelling()"><B></IF>
                                <property name = "price"/>
                                <IF expression = "isHighSelling()"></B></IF>
                                you have one like
                                <highlight condition = "isHighSelling" style = "bold">
                                <property name = "price"/>
                                </highlight></pre>
                                In either case itâ€™s important that the condition be done based on a single Boolean property of the helper. Putting any more complex expression into the page
                                is actually putting the logic into the page itself.
                                Another example would be putting information on a page that depends on
                                the locale on which the system is running. Consider some text that should only
                                be shown in the United States or Canada, which, rather than
                                <pre><IF expression = "locale = 'US' || 'CA'"> ...special text </IF>
                                Would be something like
                                <locale includes = "US, CA"> ...special text </locale></pre>
                                Iteration Iterating over a collection presents similar issues. If you want a table
                                where each line corresponds to a line item on an order, you need a construct
                                that allows easy display of information for each line. Here itâ€™s hard to avoid a
                                general iteration over a collection tag, but it usually works simply enough to fit
                                in quite well.
                                Of course the kinds of tag you have to work with are often limited by the
                                environment youâ€™re in. Some environments give you a fixed set of templates,
                                in which case you may be more limited than you would like in following these
                                kinds of guidelines. In other environments, however, you may have more
                                choice in the tags to use; many of them even allow you to define your own tag
                                libraries.</p>
                <p>When to Process The name Template View brings out the fact that the primary
                                function of this pattern is to play the view in Model View Controller (330). For
                                many systems the Template View should only play the view. In simpler systems
                                it may be reasonable for it to play the controller, and possibly even the model,
                                although I would strive to separate model processing as much as possible.
                                Where Template View is taking on responsibilities beyond the view, itâ€™s important to ensure that these responsibilities are handled by the helper, not by the
                                page. Controller and model responsibilities involve program logic, which program logic everywhere, should sit in the helper.
                                Any template system needs extra processing by the Web server. This can
                                either be done by compiling the page after itâ€™s created, compiling the page or on
                                its first request, or by interpreting the page on each request. Obviously the latter
                                isnâ€™t a good idea if the interpretation takes a while to do.
                                One thing to watch with Template View is exceptions. If an exception works
                                its way up to the Web container, you may find yourself with a half-handled
                                page that provides some decidedly odd output to the calling browser instead of
                                a redirect. You need to look into how your Web server handles exceptions; if it
                                does something strange, catch all exceptions yourself in the helper class (yet
                                another reason to disdain scriptlets.)
                                Using Scripts Although server pages are one of the most common forms of
                                Template View these days, you can write scripts in a Template View style. Iâ€™ve
                                seen a fair bit of Perl done this way. Most noticeably demonstrated by perlâ€™s
                                CGI.pm, the trick is to avoid concatenating strings by having function calls that
                                output the appropriate tags to the response. This way you can write the script
                                in your programming language and avoid the mess of interspersing print strings
                                with programming logic.</p>
                <h3 id="354">When to Use It</h3>
                <p>For implementing the view in Model View Controller (330) the main choice is
                                between Template View and Transform View (361). The strength of Template
                                View is that it allows you to compose the content of the page by looking at the
                                page structure. This seems to be easier for most people to do and to learn. In
                                particular it nicely supports the idea of a graphic designer laying out a page
                                with a programmer working on the helper.
                                Template View has two significant weaknesses. First, the common implementations make it too easy to put complicated logic in the page, thus making it
                                hard to maintain, particularly by nonprogrammers. You need good discipline to
                                keep the page simple and display oriented, putting logic in the helper. The second weakness is that Template View is harder to test than Transform View
                                (361). Most implementations of Template View are designed to work within a
                                Web server and are very difficult or impossible to test otherwise. Transform
                                View (361) implementations are much easier to hook into a testing harness and
                                test without a running Web server.</p>
                <p>In thinking about a view you also need to consider Two Step View (365).
                                Depending on your template scheme you may be able to implement this pattern
                                using specialized tags. However, you may find it easier to implement it based on
                                a Transform View (361). If youâ€™re going to need Two Step View (365) you need
                                to take that into account in your choice.</p>
                <h3 id="355">Example: Using a JSP as a View with a Separate Controller (Java)</h3>
                <p>When using a JSP as a view only, itâ€™s always be invoked from a controller rather
                                than directly from the servlet container. Thus, itâ€™s important to pass to the JSP
                                any information it will need to figure out what to display. A good way to do
                                this is to have the controller create a helper object and pass it to the JSP using
                                the HTTP request. Weâ€™ll show this with the simple display example from Page
                                Controller (333). The Web-handling method for the servlet looks like this:
                                <pre>class ArtistController...
                                public void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException {
                                Artist artist = Artist.findNamed(request.getParameter("name"));
                                if (artist == null)
                                forward("/MissingArtistError.jsp", request, response);
                                else {
                                request.setAttribute("helper", new ArtistHelper(artist));
                                forward("/artist.jsp", request, response);
                                }
                                }</pre>
                                As far as the Template View is concerned the important behavior is creating
                                the helper and placing it in the request. The server page can now reach the
                                helper with the useBean tag.
                                <jsp:useBean id="helper" type="actionController.ArtistHelper" scope="request"/>
                                With the helper in place we can use it to access the information we need to
                                display. The model information the helper needs was passed to it when it was
                                created.
                                <pre>class ArtistHelper...
                                private Artist artist;
                                public ArtistHelper(Artist artist) {
                                this.artist = artist;
                                }</pre>
                                We can use the helper to get appropriate information from the model. In the
                                simplest case we provide a method to get some simple data, such as the artistâ€™s
                                name.
                                <pre>class ArtistHelper...
                                public String getName() {
                                return artist.getName();
                                }</pre>
                                Then we access this information by a Java expression.
                                <pre><B> <%=helper.getName()%></B></pre>
                                or a property
                                <pre><B><jsp:getProperty name="helper" property="name"/></B></pre>
                                The choice between properties or expressions depends on who is editing the
                                JSP. Programmers find expressions easy to read and more compact, but HTML
                                editors may not be able to handle them. Nonprogrammers will probably prefer
                                tags, since they fits in the general form of HTML and leave less room for confusing errors.
                                Using a helper is one way to remove awkward scriptlet code. If you want to
                                show a list of albums for an artist, you need to run a loop, which you can do
                                with a scriptlet in the server page.
                                <pre><UL>
                                <%
                                for (Iterator it = helper.getAlbums().iterator(); it.hasNext();) {
                                Album album = (Album) it.next();%>
                                <LI><%=album.getTitle()%></LI>
                                <% } %>
                                </UL></pre>
                                Frankly, this mix of Java and HTML is really horrible to read. An alternative is
                                to move the for loop to the helper.
                                <pre>class ArtistHelper...
                                public String getAlbumList() {
                                StringBuffer result = new StringBuffer();
                                result.append("<UL>");
                                for (Iterator it = getAlbums().iterator(); it.hasNext();) {
                                Album album = (Album) it.next();
                                result.append("<LI>");
                                result.append(album.getTitle());
                                result.append("</LI>");
                                }
                                result.append("</UL>");
                                return result.toString();
                                }
                                public List getAlbums() {
                                return artist.getAlbums();
                                }</pre>
                                I find this easier to follow because the amount of HTML is quite small. It also
                                allows you to use a property to get the list. Many people donâ€™t like putting
                                HTML code in helpers. While I prefer not to, given the choice between this and
                                scriptlets Iâ€™d choose HTML in helpers any day or night.
                                The best route to go is a specialized tag for iteration.
                                <pre><UL><tag:forEach host = "helper" collection = "albums" id = "each">
                                <LI><jsp:getProperty name="each" property="title"/></LI>
                                </tag:forEach></UL></pre>
                                This is a much nicer alternative as it keeps scriptlets out of the JSP and HTML
                                out of the helper.</p>
                <h3 id="357">Example: ASP.NET Server Page (C#)</h3>
                <p>This example continues the one I started in Page Controller (333) (page 340).
                                To remind you, it shows the scores made by batsmen in a single innings of a
                                cricket match. For those who think that cricket is a small noisy insect, Iâ€™ll pass
                                over the long rhapsodies about the worldâ€™s most immortal sport and boil it all
                                down to the fact that the page displays three essential pieces of information:
                <ul>
                        <li>An ID number to reference the match</li>
                        <li>Which teamâ€™s scores are shown and which innings the scores are for</li>
                        <li>A table showing each batsmanâ€™s name, score, and run rate (the runs he scored divided by the number of balls he faced)</li>
                </ul>
                                If you donâ€™t understand what these statistics mean, donâ€™t worry about it.
                                Cricket is full of statisticsâ€”perhaps its greatest contribution to humanity is providing odd statistics for eccentric papers.
                                The Page Controller (333) discussion covered how a Web request is handled.
                                To sum up, the object that acts as both the controller and the view is the aspx
                                ASP.NET page. To keep the controller code out of a scriptlet, you define a separate code behind class.
                                <pre><%@ Page language="c#" Codebehind="bat.aspx.cs" AutoEventWireup="false" trace="False"
                                Inherits="batsmen.BattingPage" %></pre>
                                The page can access the methods and properties of the code behind class
                                directly. Furthermore, the code behind can define a Page_Load method to handle
                                the request. In this case Iâ€™ve defined the Page_Load as a template method [Gang of
                                Four] on a Layer Supertype (475).
                                <pre>class CricketPage...
                                protected void Page_Load(object sender, System.EventArgs e) {
                                db = new OleDbConnection(DB.ConnectionString);
                                if (hasMissingParameters())
                                errorTransfer (missingParameterMessage);
                                DataSet ds = getData();
                                if (hasNoData (ds))
                                errorTransfer ("No data matches your request");
                                applyDomainLogic (ds);
                                DataBind();
                                prepareUI(ds);
                                }</pre>
                                For the purposes of Template View I can ignore all but the last couple of
                                lines of the page load. The call to DataBind allows various page variables to be
                                properly bound to their underlying data sources. That will do for the simpler
                                cases, but for more complicated cases the last line calls a method in the particular pageâ€™s code behind to prepare any objects for its use.
                                The match ID number, team, and innings are single values for the page, all of
                                which came into the page as parameters in the HTTP request. I can provide
                                these values by using properties on the code behind class.
                                <pre>class BattingPage...
                                protected String team {
                                get {return Request.Params["team"];}
                                }
                                protected String match {
                                get {return Request.Params["match"];}
                                }
                                protected String innings {
                                get {return Request.Params["innings"];}
                                }
                                protected String ordinalInnings{
                                get {return (innings == "1") ? "1st" : "2nd";}
                                }</pre>
                                With the properties defined, I can use them in the text of the page.
                                <pre><P>
                                Match id:
                                <asp:label id="matchLabel" Text="<%# match %>" runat="server" font-bold="True">
                                </asp:label>&nbsp;
                                </P>
                                <P>
                                <asp:label id=teamLabel Text="<%# team %>" runat="server" font-bold="True">
                                </asp:label>&nbsp;
                                <asp:Label id=inningsLabel Text="<%# ordinalInnings %>" runat="server">
                                </asp:Label>&nbsp;innings</P>
                                <P></P></pre>
                                The table is a little more complicated, but actually works easily in practice
                                because of the graphical design facilities in Visual Studio. Visual Studio provides a data grid control that can be bound to a single table from a data set. I
                                can do this binding in the prepareUI method thatâ€™s called by the Page_Load method.
                                <pre>class BattingPage...
                                override protected void prepareUI(DataSet ds) {
                                DataGrid1.DataSource = ds;
                                DataGrid1.DataBind();
                                }</pre>
                                The batting class is a Table Module (125) that provides domain logic for the
                                batting table in the database. Its data property is the data from that table
                                enriched by domain logic from Table Module (125). Here the enrichment is the
                                run rate, which is calculated rather than stored in the database.
                                With the ASP.NET data grid you can select which table columns you wish to
                                display in the Web page, together with information about the tableâ€™s appearance. In this case we can select name, runs, and rate columns.
                                <pre><asp:DataGrid id="DataGrid1" runat="server" Width="480px" Height="171px"
                                BorderColor="#336666" BorderStyle="Double" BorderWidth="3px" BackColor="White"
                                CellPadding="4" GridLines="Horizontal" AutoGenerateColumns="False">
                                <SelectedItemStyle Font-Bold="True" ForeColor="White" BackColor="#339966"></
                                SelectedItemStyle>
                                <ItemStyle ForeColor="#333333" BackColor="White"></ItemStyle>
                                <HeaderStyle Font-Bold="True" ForeColor="White" BackColor="#336666"></HeaderStyle>
                                <FooterStyle ForeColor="#333333" BackColor="White"></FooterStyle>
                                <Columns>
                                <asp:BoundColumn DataField="name" HeaderText="Batsman">
                                <HeaderStyle Width="70px"></HeaderStyle>
                                </asp:BoundColumn>
                                <asp:BoundColumn DataField="runs" HeaderText="Runs">
                                <HeaderStyle Width="30px"></HeaderStyle>
                                </asp:BoundColumn>
                                <asp:BoundColumn DataField="rateString" HeaderText="Rate">
                                <HeaderStyle Width="30px"></HeaderStyle>
                                </asp:BoundColumn>
                                </Columns>
                                <PagerStyle HorizontalAlign="Center" ForeColor="White" BackColor="#336666"
                                Mode="NumericPages"></PagerStyle>
                                </asp:DataGrid></P></pre>
                                The HTML for this data grid looks intimidating, but in Visual Studio you
                                donâ€™t manipulate it directly but through property sheets in the development
                                environment, as you do for much of the rest of the page.
                                This ability to have Web form controls on the Web page that understand the
                                ADO.NET abstractions of data sets and data tables is the strength, and limitation, of this scheme. The strength is that you transfer information through data
                                sets, thanks to the kind of tools that Visual Studio provides. The limitation is
                                that it only works seamlessly when you use patterns such as Table Module
                                (125). If you have very complex domain logic, then a Domain Model (116)
                                becomes helpful; to take advantage of the tools, the Domain Model (116) needs
                                to create its own data set.</p>
                <h3 id="361">Transform View</h3>
                <p><img src="img/part2.29.png" alt="no img" style="margin-left: 200px;"></p>
                <p>A view that processes domain data element by
                                element and transforms it into HTML.
                                When you issue requests for data to the domain and data source layers, you get
                                back all the data you need to satisfy them, but without the formatting you need
                                to make a proper Web page. The role of the view in Model View Controller
                                (330) is to render this data into a Web page. Using Transform View means
                                thinking of this as a transformation where you have the modelâ€™s data as input
                                and its HTML as output.</p>
                <h3 id="361(2)">How It Works</h3>
                <p>The basic notion of Transform View is writing a program that looks at domainoriented data and converts it to HTML. The program walks the structure of the
                                domain data and, as it recognizes each form of domain data, it writes out the
                                particular piece of HTML for it. If you think about this in an imperative way,
                                you might have a method called renderCustomer that takes a customer object and
                                renders it into HTML. If the customer contains a lot of orders, this method
                                loops over the orders calling renderOrder.
                                The key difference between Transform View and Template View (350) is the
                                way in which the view is organized. A Template View (350) is organized around
                                the output. A Transform View is organized around separate transforms for each
                                kind of input element. The transform is controlled by something like a simple
                                loop that looks at each input element, finds the appropriate transform for that
                                element, and then calls the transform on it. A typical Transform Viewâ€™s rules
                                can be arranged in any order without affecting the resulting output.
                                You can write a Transform View in any language; at the moment, however, the
                                dominant choice is XSLT. The interesting thing about this is that XSLT is a functional programming language, similar to Lisp, Haskell, and other languages that
                                never quite made it into the IS mainstream. As such it has a different kind of
                                structure to it. For example, rather than explicitly calling routines, XSLT recognizes elements in the domain data and then invokes the appropriate rendering
                                transformations.</p>
                <p>To carry out an XSLT transform we need to begin with some XML data. The
                                simplest way this can happen is if the natural return type of the domain logic is
                                either XML or something automatically transformable to itâ€”for example, a
                                .NET. Failing that, we need to produce the XML ourselves, perhaps by populating a Data Transfer Object (401) that can serialize itself into XML. That way
                                the data can be assembled using a convenient API. In simpler cases a Transaction Script (110) can return XML directly.
                                The XML thatâ€™s fed into the transform donâ€™t have to be a string, unless a
                                string form is needed to cross a communication line. Itâ€™s usually quicker and
                                easier to produce a DOM and hand that to the transform.
                                Once we have the XML we pass it to an XSLT engine, which is becoming
                                increasingly available commercially. The logic for the transform is captured in
                                an XSLT style sheet, which we also pass to the transformer. The transformer
                                then applies the stylesheet to the input XML to yield the output HTML, which
                                we can write directly to the HTTP response.</p>
                <h3 id="362">When to Use It</h3>
                <p>The choice between a Transform View and a Template View (350) mostly
                                comes down to which environment the team working on the view software prefers. The presence of tools is a key factor here. There are more and more
                                HTML editors that you can use to write Template Views (350). Tools for XSLT
                                are, at least so far, much less sophisticated. Also, XSLT can be an awkward language to master because of its functional programming style coupled with its
                                awkward XML syntax.
                                One of the strengths of XSLT is its portability to almost any Web platform.
                                You can use the same XSLT to transform XML created from J2EE or .NET,
                                which can help in putting a common HTML view on data from different sources.
                                XSLT is also often easier if youâ€™re building a view on an XML document.
                                Other environments usually require you to transform such a document into an
                                object or to indulge in walking the XML DOM, which can be complicated.
                                XSLT fits naturally in an XML world.</p>
                <p>Transform View avoids two of the biggest problems with Template View
                                (350). Itâ€™s easier to keep the transform focused only on rendering HTML, thus
                                avoiding having too much other logic in the view. Itâ€™s also easy to run the Transform View and capture the output for testing. This makes it easier to test the
                                view and you donâ€™t need a Web server to run the tests.
                                TRANSFORM VIEW 363
                                Transform
                                View
                                Transform View transforms directly from domain-oriented XML into
                                HTML. If you need to change the overall appearance of a Web site, this can
                                force you to change multiple transform programs. Using common transforms,
                                such as with XSLT includes, helps reduce this problem. Indeed itâ€™s much easier
                                to call common transformations using Transform View than it is using Template View (350). If you need to make global changes easily or support multiple
                                appearances for the same data, you might consider Two Step View (365), which
                                uses a two-stage process.</p>
                <h3 id="363">Example: Simple Transform (Java)</h3>
                <p>Setting up a simple transform involves preparing Java code for invoking the
                                right style sheet to form the response. It also involves preparing the style sheet
                                to format the response. Most of the response to a page is pretty generic, so it
                                makes sense to use Front Controller (344). Iâ€™ll describe only the command here,
                                and you should look at Front Controller (344) to see how the command object
                                fits in with the rest of the request-response handling.
                                All the command object does is invoke the methods on the model to obtain
                                an XML input document, and then pass that XML document through the XML
                                processor.
                                <pre>class AlbumCommand...
                                public void process() {
                                try {
                                Album album = Album.findNamed(request.getParameter("name"));
                                Assert.notNull(album);
                                PrintWriter out = response.getWriter();
                                XsltProcessor processor = new SingleStepXsltProcessor("album.xsl");
                                out.print(processor.getTransformation(album.toXmlDocument()));
                                } catch (Exception e) {
                                throw new ApplicationException(e);
                                }
                                }
                                The XML document may look something like this:
                                <album>
                                <title>Stormcock</title>
                                <artist>Roy Harper</artist>
                                <trackList>
                                <track><title>Hors dâ€™Oeuvres</title><time>8:37</time></track>
                                <track><title>The Same Old Rock</title><time>12:24</time></track>
                                <track><title>One Man Rock and Roll Band</title><time>7:23</time></track>
                                <track><title>Me and My Woman</title><time>13:01</time></track>
                                </trackList>
                                </album></pre>
                                The translation of the XML document is done by an XSLT program. Each
                                template matches a particular part of the XML and produces the appropriate
                                HTML output for the page. In this case Iâ€™ve kept the formatting to a excessively
                                simple level to show just the essentials. The following template clauses match
                                the basic elements of the XML file.
                                <pre></pre>
                                <pre><xsl:template match="album">
                                <HTML><BODY bgcolor="white">
                                <xsl:apply-templates/>
                                </BODY></HTML>
                                </xsl:template>
                                <xsl:template match="album/title">
                                <h1><xsl:apply-templates/></h1>
                                </xsl:template>
                                <xsl:template match="artist">
                                <P><B>Artist: </B><xsl:apply-templates/></P>
                                </xsl:template>
                                These template matches handle the table,
                                which here has alternating rows highlighted in different colors.
                                This is a good example of something that isnâ€™t possible with cascading
                                style sheets but is reasonable with XML.
                                <xsl:template match="trackList">
                                <table><xsl:apply-templates/></table>
                                </xsl:template>
                                <xsl:template match="track">
                                <xsl:variable name="bgcolor">
                                <xsl:choose>
                                <xsl:when test="(position() mod 2) = 1">linen</xsl:when>
                                <xsl:otherwise>white</xsl:otherwise>
                                </xsl:choose>
                                </xsl:variable>
                                <tr bgcolor="{$bgcolor}"><xsl:apply-templates/></tr>
                                </xsl:template>
                                <xsl:template match="track/title">
                                <td><xsl:apply-templates/></td>
                                </xsl:template>
                                <xsl:template match="track/time">
                                <td><xsl:apply-templates/></td>
                                </xsl:template></pre>
                <h3 id="365">Two Step View</h3>
                <p><img src="img/part2.30.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Turns domain data into HTML in two steps: first by forming some
                                kind of logical page, then rendering the logical page into HTML.
                                If you have a Web application with many pages, you often want a consistent
                                look and organization to the site. If every page looks different, you end up with
                                a site that users find confusing. You may also want to make global changes to
                                the appearance of the site easily, but common approaches using Template View
                                (350) or Transform View (361) make this difficult because presentation decisions are often duplicated across multiple pages or transform modules. A global
                                change can force you to change several files.
                                Two Step View deals with this problem by splitting the transformation into
                                two stages. The first transforms the model data into a logical presentation without any specific formatting; the second converts that logical presentation with
                                the actual formatting needed. This way you can make a global change by altering the second stage, or you can support multiple output looks and feels with
                                one second stage each.</p>
                <h3 id="365(2)">How It Works</h3>
                <p>The key to this pattern is in making the transformation to HTML a two-stage
                                process. The first stage assembles the information in a logical screen structure
                                that is suggestive of the display elements yet contains no HTML. The second
                                stage takes that presentation-oriented structure and renders it into HTML
                                This intermediate form is a kind of logical screen. Its elements might include
                                things like fields, headers, footers, tables, choices, and the like. As such itâ€™s certainly presentation-oriented and certainly forces the screens to follow a definite
                                style. You can think of the presentation-oriented model as one that defines the
                                various widgets you can have and the data they contain but doesnâ€™t specify the
                                HTML appearance.</p>
                <p>This presentation-oriented structure is assembled by specific code written for
                                each screen. The first stageâ€™s responsibility is to access a domain-oriented
                                model, either a database, an actual domain model, or a domain-oriented Data
                                Transfer Object (401); to extract the relevant information for that screen; and
                                then to put that information into the presentation-oriented structure.
                                The second stage turns this presentation-oriented structure into HTML. It
                                knows about each element in the presentation-oriented structure and how to
                                show it as HTML. Thus, a system with many screens can be rendered as HTML
                                by a single second stage so that all the HTML formatting decisions are made in
                                one place. Of course, the constraint is that the resulting screen must be derivable from the presentation-oriented structure.
                                There are several ways to build a Two Step View. Perhaps the easiest is with
                                two-step XSLT. Single-step XSLT follows the approach in Transform View
                                (361), in which each page has a single XSLT style sheet that transforms the
                                domain-oriented XML into HTML. In the two-step approach there are two
                                XSLT style sheets. The first-stage style sheet transforms the domain-oriented
                                XML into presentation-oriented XML, the second-stage style sheet renders that
                                XML into HTML.</p>
                <p>Another way is to use classes. Here you define the presentation-oriented
                                structure as a set of classes: with a table class, a row class, and so forth. The
                                first stage takes domain information and instantiates these classes into a structure that models a logical screen. The second stage renders the classes into
                                HTML, either by getting each presentation-oriented class to generate HTML
                                for itself or by having a separate HTML renderer class to do the job.
                                Both approaches are based on Transform View (361). You can also use a
                                Template View (350) based approach, in which you pick templates based on the
                                idea of a logical screenâ€”for example:
                                <pre>&lt;field label = "Name" value = "getName" /&gt;</pre>
                                The template system then converts these logical tags into HTML. In such a
                                scheme the page definition includes no HTML but only these logical screen
                                tags. As a result it will probably be an XML document, which of course means
                                that you lose the ability to use WYSIWYG HTML editors.</p>
                <p><img src="img/figure 14.4.png" alt="no img" style="margin-left: 200px;"></p>
                <h3 id="367">When to Use It</h3>
                <p>Two Step Viewâ€™s key value comes from the separation of first and second stages,
                                allowing you to make global changes more easily. It helps to think of two situations: multiappearance Web applications and single-appearance Web applications. Multiappearance apps are the rarer breed but a growing one. In them the
                                same basic functionality is provided through multiple organizations and each
                                organization has its own distinct look. A current example of this is airline travel
                                sites, where as you look at them you can tell from the page layout and design
                                that theyâ€™re all variations on one base site. I suspect many airlines want that
                                same functionality but with a distinctly individual appearance.
                                Single-appearance apps are more common. Only one organization fronts
                                them, and they want a consistent look throughout the site. This makes them the
                                easiest case to consider first.</p>
                <p>With a single-stage view (either Template View (350) or Transform View
                                (361), you build one view module per Web page (see Figure 14.6). With a Two
                <p><img src="img/figure 14.5.png" alt="no img" style="margin-left: 200px;"></p>
                <p><img src="img/figure 14.6.png" alt="no img" style="margin-left: 200px;"></p>
                                View Step View you have two stages: one first-stage module per page and one secondstage module for the entire application (Figure 14.7). Your pay-off in using Two
                                Step View is that any change to the appearance of the site in the second stage is
                                much easier to make, since one second-stage change affects the site as a whole.
                                With a multiappearance app this advantage is compounded because you
                                have a single-stage view for each combination of screen and appearance
                                (Figure 14.8). Thus, ten screens and three appearances require thirty single
                                stage view modules. Using Two Step View, however (see Figure 14.9), you can
                                get away with ten first stages and three second stages. The more screens and
                                appearances you have, the bigger the saving.</p>
                <p>Nevertheless, your ability to pull this off is entirely dependent on how well
                                you can make the presentation-oriented structure to really serve the needs of the
                                appearance. A design-heavy site, where each page is supposed to look different,
                                wonâ€™t work well with Two Step View because itâ€™s hard to find enough commonality between the screens to get a simple enough presentation-oriented structure.
                                Essentially the site design is constrained by the presentation-oriented structure,
                                and for many sites thatâ€™s too much of a limitation.
                                Another drawback of Two Step View is the tools required to use it. There are
                                a lot of tools for designers with no programming skills to lay out HTML pages
                <p><img src="img/figure 14.7.png" alt="no img" style="margin-left: 200px;"></p>
                                using Template View (350), but Two Step View forces programmers to write the
                                renderer and controller objects. Thus programmers have to be involved in any
                                design change.</p>
                <p>Itâ€™s also true that Two Step View, with its multiple layers, presents a harder
                                programming model to learn, although once youâ€™re used to it itâ€™s not that difficult, and may help reduce repetitive boilerplate code.
                                A variation on the theme of multiple appearances is providing different second stages for different devices, so you can have one second stage for a browser
                                and another for a PDA. The usual limitation here is that both appearances must
                <p><img src="img/figure 14.8.png" alt="no img" style="margin-left: 200px;"></p>
                                follow the same logical screen, and for very different devices this may be too
                                much to ask.</p>
                <h3 id="371">Example: Two Stage XSLT (XSLT)</h3>
                <p>This approach to a Two Step View uses a two-stage XLST transformation. The
                                first stage transforms domain-specific XML into logical screen XML; the second transforms the logical screen XML into HTML.
                                The initial domain oriented XML looks like this:
                                <pre>&lt;album&gt;
                                &lt;title&gt;Zero Hour&lt;/title&gt;
                                &lt;artist&gt;Astor Piazzola&lt;/artist&gt;
                                &lt;trackList&gt;
                                &lt;track&gt;&lt;title&gt;Tanguedia III&lt;/title&gt;&lt;time&gt;4:39&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Milonga del Angel&lt;/title&gt;&lt;time&gt;6:30&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Concierto Para Quinteto&lt;/title&gt;&lt;time&gt;9:00&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Milonga Loca&lt;/title&gt;&lt;time&gt;3:05&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Michelangelo '70&lt;/title&gt;&lt;time&gt;2:50&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Contrabajisimo&lt;/title&gt;&lt;time&gt;10:18&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Mumuki&lt;/title&gt;&lt;time&gt;9:32&lt;/time&gt;&lt;/track&gt;
                                &lt;/trackList&gt;
                                &lt;/album&gt;</pre>
                <p><img src="img/figure 14.9.png" alt="no img" style="margin-left: 200px;"></p>
                                The first stage XSLT processor transforms it into this screen-oriented XML:
                                <pre>&lt;screen&gt;
                                &lt;title&gt;Zero Hour&lt;/title&gt;
                                &lt;field label="Artist"&gt;Astor Piazzola&lt;/field&gt;
                                &lt;table&gt;
                                &lt;row&gt;&lt;cell&gt;Tanguedia III&lt;/cell&gt;&lt;cell&gt;4:39&lt;/cell&gt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Milonga del Angel&lt;/cell&gt;&lt;cell&gt;6:30&lt;/cell&gt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Concierto Para Quinteto&lt;/cell&gt;&lt;cell&gt;9:00&lt;/cell&gt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Milonga Loca&lt;/cell&gt;&lt;cell&gt;3:05&lt;/cell&gt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Michelangelo '70&lt;/cell&gt;&lt;cell&gt;2:50&lt;/cell&lt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Contrabajisimo&lt;/cell&gt;&lt;cell&gt;10:18&lt;/cell&gt;&lt;/row&gt;
                                &lt;row>&lt;cell&gt;Mumuki&lt;/cell&gt;&lt;cell&gt;9:32&lt;/cell&gt;&lt;/row&gt;
                                &lt;/table&gt;
                                &lt;/screen&gt;</pre>
                                To do this we need the following XSLT program:
                                <pre>&lt;xsl:template match="album"&gt;
                                &lt;screen>&lt;xsl:apply-templates/&gt;&lt;/screen&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="album/title"&gt;
                                &lt;title&gt;&lt;xsl:apply-templates/&gt;&lt;/title&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="artist"&gt;
                                &lt;field label="Artist"&gt;&lt;xsl:apply-templates/&gt;&lt;/field&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="trackList"&gt;
                                &lt;table>&lt;xsl:apply-templates/&gt;&lt;/table&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="track"&gt;
                                &lt;row>&lt;xsl:apply-templates/&gt;&lt;/row&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="track/title"&gt;
                                &lt;cell&gt;&lt;xsl:apply-templates/&gt;&lt;/cell&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="track/time"&gt;
                                &lt;cell&gt;&lt;xsl:apply-templates/&gt;&lt;/cell&gt;
                                &lt;/xsl:template&gt;&lt;/p&gt;</pre>
                <p>The screen-oriented XML is very plain. To turn it into HTML we use a
                                second-stage XSLT program.
                                <pre><xsl:template match="screen">
                                <HTML><BODY bgcolor="white">
                                <xsl:apply-templates/>
                                </BODY></HTML>
                                </xsl:template>
                                <xsl:template match="title">
                                <h1><xsl:apply-templates/></h1>
                                </xsl:template><xsl:template match="field">
                                <P><B><xsl:value-of select = "@label"/>: </B><xsl:apply-templates/></P>
                                </xsl:template>
                                <xsl:template match="table">
                                <table><xsl:apply-templates/></table>
                                </xsl:template>
                                <xsl:template match="table/row">
                                <xsl:variable name="bgcolor">
                                <xsl:choose>
                                <xsl:when test="(position() mod 2) = 1">linen</xsl:when>
                                <xsl:otherwise>white</xsl:otherwise>
                                </xsl:choose>
                                </xsl:variable>
                                <tr bgcolor="{$bgcolor}"><xsl:apply-templates/></tr>
                                </xsl:template>
                                <xsl:template match="table/row/cell">
                                <td><xsl:apply-templates/></td>
                                </xsl:template></pre>
                                In assembling the two stages, I used Front Controller (344) to help separate
                                the code that does the work.
                                <pre>class AlbumCommand...
                                public void process() {
                                try {
                                Album album = Album.findNamed(request.getParameter("name"));
                                Assert.notNull(album);
                                PrintWriter out = response.getWriter();
                                XsltProcessor processor = new TwoStepXsltProcessor("album2.xsl", "second.xsl");
                                out.print(processor.getTransformation(album.toXmlDocument()));
                                } catch (Exception e) {
                                throw new ApplicationException(e);
                                }
                                }</pre>
                                Itâ€™s useful to compare this to the single-stage approach in Transform View
                                (361). If you want to change the colors of the alternating rows, Transform View
                                (361) requires editing every XSLT program, but with Two Step View only the
                                single second-stage XSLT program needs to be changed. It might be possible to
                                use callable templates to do something similar, but this needs a fair bit of XSLT
                                gymnastics to pull off. The down side of Two Step View is that the final HTML
                                is very much constrained by the screen-oriented XML.</p>
                <h3 id="374">Example: JSP and Custom Tags (Java)</h3>
                <p>Although the XSLT route is conceptually the easiest way to think about implementing Two Step View, plenty of other ways exist. For this example Iâ€™ll use
                                JSPs and custom tags. Although theyâ€™re both more awkward and less powerful
                                than XSLT, they do show how the pattern can manifest itself in different ways.
                                Iâ€™m being a bit cheeky with this example, for I havenâ€™t seen this done in the
                                field. But I feel a somewhat speculative example will give you an idea of what
                                might be possible.
                                The key rule of Two Step View is that choosing what to display and choosing
                                the HTML that displays it are totally separate. For this example my first stage is
                                handled by a JSP page and its helper; my second stage, by a set of custom tags.
                                The interesting part of the first stage is the JSP page.
                                <pre>&lt;%@ taglib uri="2step.tld" prefix = "2step" %&gt;
                                &lt;%@ page session="false"%&gt;
                                &lt;jsp:useBean id="helper" class="actionController.AlbumConHelper"/&gt;
                                &lt;%helper.init(request, response);%&gt;
                                &lt;2step:screen&gt;
                                &lt;2step:title&gt;&lt;jsp:getProperty name = "helper" property = "title"/&gt;&lt;/2step:title&gt;
                                &lt;2step:field label = "Artist"&gt;&lt;jsp:getProperty name = "helper" property = "artist" &gt;&lt;step:field&gt;
                                &lt;2step:table host = "helper" collection = "trackList" columns = "title, time"/&gt;
                                &lt;/2step:screen&gt;</pre>
                                Iâ€™m using Page Controller (333) for the JSP page with a helper object you can
                                flick over to Page Controller (333) to read more about that. The important
                                thing here is to look at the tags that are part of the 2step namespace. They are
                                the ones Iâ€™m using to invoke the second stage. Also notice that there is no
                                HTML on the JSP page; the only tags present are either second-stage tags or
                                bean manipulation tags to get values out of the helper.
                                Each second-stage tag has an implementation to pump out the necessary
                                HTML for that logical screen element. The simplest of these is the title.
                                <pre>class TitleTag...
                                public int doStartTag() throws JspException {
                                try {
                                pageContext.getOut().print("&lt;H1&gt;");
                                } catch (IOException e) {
                                throw new JspException("unable to print start");
                                }
                                return EVAL_BODY_INCLUDE;
                                }
                                public int doEndTag() throws JspException {
                                try {
                                pageContext.getOut().print("&lt;/H1&gt;");
                                } catch (IOException e) {
                                throw new JspException("unable to print end");
                                }
                                return EVAL_PAGE;
                                }</pre>
                                For those that havenâ€™t indulged, a custom tag works by implementing hook
                                methods called at the beginning and the end of the tagged text. This tag simply
                                wraps its body content with an &lt;H1&gt; tag. A more complex tag, such as the field,
                                can take an attribute. The attribute is tied into the tag class using a setting
                                method.<pre>
                                class FieldTag...
                                private String label;
                                public void setLabel(String label) {
                                this.label = label;
                                }
                                Once the value is set, you can use it in the output.
                                class FieldTag...
                                public int doStartTag() throws JspException {
                                try {
                                pageContext.getOut().print("&lt;P&gt;" + label + ": &lt;B&gt;");
                                } catch (IOException e) {
                                throw new JspException("unable to print start");
                                }
                                return EVAL_BODY_INCLUDE;
                                }
                                public int doEndTag() throws JspException {
                                try {
                                pageContext.getOut().print("&lt;/B&gt;&lt;/P&gt;");
                                } catch (IOException e) {
                                throw new JspException("how are checked exceptions helping me here?");
                                }
                                return EVAL_PAGE;
                                }</pre>
                                The Table is the most sophisticated of the tags. As well as allowing the JSP
                                writer to choose which columns to put in the table, it highlights alternate rows.
                                The tag implementation acts as the second stage, so the highlighting is done
                                there so that a system-wide change can be made globally.
                                The Table tag takes attributes for the name of the collection property, the
                                object on which the collection property sits, and a comma-separated list of column names.
                                <pre>class TableTag...
                                private String collectionName;
                                private String hostName;
                                private String columns;
                                public void setCollection(String collectionName) {
                                this.collectionName = collectionName;
                                }
                                public void setHost(String hostName) {
                                this.hostName = hostName;
                                TWO STEP VIEW 377
                                Two Step
                                View
                                }
                                public void setColumns(String columns) {
                                this.columns = columns;
                                }</pre>
                                I made a helper method to get a property out of an object. Thereâ€™s a good
                                argument for using the various classes that support Java beans, rather than just
                                invoking a â€œgetsomethingâ€ method, but this will do for the example.
                                <pre>class TableTag...
                                private Object getProperty(Object obj, String property) throws JspException {
                                try {
                                String methodName = "get" + property.substring(0, 1).toUpperCase() +
                                property.substring(1);
                                Object result = obj.getClass().getMethod(methodName, null).invoke(obj, null);
                                return result;
                                } catch (Exception e) {
                                throw new JspException("Unable to get property " + property + " from " + obj);
                                }
                                }</pre>
                                This tag doesnâ€™t have a body. When itâ€™s called it pulls the named collection out
                                of the request property and iterates through the collection to generate the rows
                                of the table.
                                <pre>class TableTag...
                                public int doStartTag() throws JspException {
                                try {
                                JspWriter out = pageContext.getOut();
                                out.print("&lt;table&gt;");
                                Collection coll = (Collection) getPropertyFromAttribute(hostName, collectionName);
                                Iterator rows = coll.iterator();
                                int rowNumber = 0;
                                while (rows.hasNext()) {
                                out.print("&lt;tr");
                                if ((rowNumber++ % 2) == 0) out.print(" bgcolor = " + HIGHLIGHT_COLOR);
                                out.print("&gt;");
                                printCells(rows.next());
                                out.print("&lt;/tr&gt;");
                                }
                                out.print("&lt;/table&gt;");
                                } catch (IOException e) {
                                throw new JspException("unable to print out");
                                }
                                return SKIP_BODY;
                                }
                                private Object getPropertyFromAttribute(String attribute, String property)
                                throws JspException
                                {
                                Object hostObject = pageContext.findAttribute(attribute);
                                if (hostObject == null)
                                throw new JspException("Attribute " + attribute + " not found.");
                                return getProperty(hostObject, property);
                                }
                                public static final String HIGHLIGHT_COLOR = "'linen'";
                                During the iteration it sets every other row to the linen background to highlight
                                them.
                                To print the cells for each row, I use the column names as property values on
                                the objects in the collection.
                                class TableTag...
                                private void printCells(Object obj) throws IOException, JspException {
                                JspWriter out = pageContext.getOut();
                                for (int i = 0; i &lt; getColumnList().length; i++) {
                                out.print("&lt;td&gt;");
                                out.print(getProperty(obj, getColumnList()[i]));
                                out.print("&lt;/td&gt;");
                                }
                                }
                                private String[] getColumnList() {
                                StringTokenizer tk = new StringTokenizer(columns, ", ");
                                String[] result = new String[tk.countTokens()];
                                for (int i = 0; tk.hasMoreTokens(); i++)
                                result[i] = tk.nextToken();
                                return result;
                                }</pre>
                                Compared to the XSLT implementation, this solution is rather less constraining on the uniformity of the siteâ€™s layout. An author of one page wanting to slip
                                some individual HTML into it will find that easier to do. Of course, while this
                                allows tweaking of design-intensive pages, itâ€™s also open to inappropriate use by
                                people who are unfamiliar with how things work. Sometimes constraints help
                                prevent mistakes. Thatâ€™s a trade-off a team has to decide for themselves.
                                APPLICATION CONTROLLER 379
                                Application
                                Controller</p>
                <h3 id="379">Application Controller</h3>
                <p><img src="img/part2.32.png" alt="no img" style="margin-left: 200px;"></p>
                <p>A centralized point for handling screen navigation
                                and the flow of an application.
                                Some applications contain a significant amount of logic about the screens to use
                                at different points, which may involve invoking certain screens at certain times
                                in an application. This is the wizard style of interaction, where the user is led
                                through a series of screens in a certain order. In other cases we may see screens
                                that are only brought in under certain conditions, or choices between different
                                screens that depend on earlier input.
                                To some degree the various Model View Controller (330) input controllers
                                can make some of these decisions, but as an application gets more complex this
                                can lead to duplicated code as several controllers for different screens need to
                                know what to do in a certain situation.
                                You can remove this duplication by placing all the flow logic in an Application Controller. Input controllers then ask the Application Controller for the
                                appropriate commands for execution against a model and the correct view to
                                use depending on the application context.</p>
                <h3 id="380">How It Works</h3>
                <p>An Application Controller has two main responsibilities: deciding which
                                domain logic to run and deciding the view with which to display the response.
                                To do this it typically holds two structured collections of class references, one
                                for domain commands to execute against in the domain layer and one of views
                                (Figure 14.10).
                                For both the domain commands and the view, the application controller
                                needs a way to store something it can invoke. A Command [Gang of Four] is a
                                good choice, since it allows it to easily get hold of and run a block of code. Languages that can manipulate functions can hold references to them. Another
                                option is to hold a string that can be used to invoke a method by reflection.
                                The domain commands can be command objects that are part of the Application Controller layer, or they can be references to a Transaction Script (110)
                                or domain object methods in the domain layer.
                                If youâ€™re using server pages as your views, you can use the server page name.
                                If youâ€™re using a class, a command or a string for a reflective call makes sense.
                                You might also use an XSLT transform, to which the Application Controller
                                can hold a string as a reference.</p>
                <p>One decision youâ€™ll need to make is how much to separate the Application
                                Controller from the rest of the presentation. At the first level this decision manifests itself in whether the Application Controller has dependencies to the UI
                                machinery. Perhaps it directly accesses the HTTP session data, forwards to a
                                server page, or invokes methods on a rich-client class.
                <p><img src="img/figure 14.10.png" alt="no img" style="margin-left: 200px;"></p>

                                Although Iâ€™ve seen direct Application Controllers, my preference is for the
                                Application Controller to have no links to the UI machinery. For a start this
                                makes it possible to test the Application Controller independently of the UI,
                                which is a major benefit. Itâ€™s also important to do this if youâ€™re going to use the
                                same Application Controller with multiple presentations. For these reasons
                                many people like to think of the Application Controller as an intermediate layer
                                between the presentation and the domain.</p>
                <p>An application can have multiple Application Controllers to handle each of
                                its different parts. This allows you to split up complex logic into several classes.
                                In this case I usually see the work divided up into broad areas of the user interface and build separate Application Controllers for each area. On a simpler
                                application I might need only a single Application Controller.
                                If you have multiple presentations, such as a Web front end, a rich client, and
                                a PDA, you may be able to use the same Application Controller for each presentation, but donâ€™t be too eager. Often different UIs need a different screen
                                flow to achieve a really usable user interface. However, reusing a single Application Controller may reduce the development effort, and that decreased effort
                                may be worth the cost of a more awkward UI.</p>
                <p>A common way of thinking about a UI is as a state machine, where certain
                                events trigger different responses depending on the state of certain key objects
                                in the application. In this case the Application Controller is particularly amenable to using metadata to represent the state machineâ€™s control flow. The metadata can either be set up by programming language calls (the simplest way) or it
                                can be stored in a separate configuration file.
                                You may find domain logic particular to one request placed in an Application Controller (379). As you might suspect, I come down pretty hard against
                                that notion. However, the boundary between domain and application logic
                                does get very murky. Say Iâ€™m handling insurance applications and I need to
                                show a separate screen of questions only if the applicant is a smoker. Is this
                                application logic or domain logic? If I have only a few such cases I can probably
                                put that kind of logic in the Application Controller (379), but if it occurs in lots
                                of places I need to design the Domain Model (116) in such a way to drive this.</p>
                <h3 id="381">When to Use It</h3>
                <p>If the flow and navigation of your application are simple enough so that anyone
                                can visit any screen in pretty much any order, thereâ€™s little value in a Application
                                Controller. The strength of an Application Controller comes from definite rules
                                about the order in which pages should be visited and different views depending
                                on the state of objects.
                                A good signal to use an Application Controller is if you find yourself having
                                to make similar changes in lots of different places when your applicationâ€™s flow
                                changes.</p>
                <h3 id="382">Further Reading</h3>
                <p>Most of the ideas that underlie the writing of this pattern came from [Knight
                                and Dai]. Although their ideas arenâ€™t exactly new, I found their explanations
                                remarkably clear and compelling.</p>
                <h3 id="382(2)">Example: State Model Application Controller (Java)</h3>
                <p>State models are a common way of thinking about user interfaces. Theyâ€™re particularly appropriate when you need to react differently to events depending on
                                the state of some object. In this example I have a simple state model for a couple of commands on an asset (Figure 14.11). ThoughtWorkâ€™s leasing experts
                                would faint at the virulent oversimplification of this model, but it will do as an
                                example of a state-based Application Controller.
                                As far as the code is concerned our rules are these:
                <ul>
                        <li>When we receive a return command and weâ€™re in the On lease state, we display a page to capture information about the return of the asset.</li>
                        <li>A return event in the in Inventory state is an error, so we show an illegal action page.</li>
                        <li>When we receive a damage command we show different pages depending on whether the asset is in the Inventory or the On lease state.</li>
                </ul>
                <p><img src="img/figure 14.11.png" alt="no img" style="margin-left: 200px;"></p>
                                The input controller is a Front Controller (344). It services the request like
                                this:
                                <pre>class FrontServlet...
                                public void service(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException
                                {
                                ApplicationController appController = getApplicationController(request);
                                String commandString = (String) request.getParameter("command");
                                DomainCommand comm =
                                appController.getDomainCommand(commandString, getParameterMap(request));
                                comm.run(getParameterMap(request));
                                String viewPage =
                                "/" + appController.getView(commandString, getParameterMap(request)) + ".jsp";
                                forward(viewPage, request, response);
                                }</pre>
                                The flow of the service method is pretty straightforward: We find the right
                                application controller for a given request, ask the application controller for the
                                domain command, execute the domain command, ask the application controller for a view, and, finally, forward to the view.
                                In this scheme Iâ€™m assuming a number of Application Controllers, all of
                                which implement the same interface.
                                <pre>interface ApplicationController...
                                DomainCommand getDomainCommand (String commandString, Map params);
                                String getView (String commandString, Map params);</pre>
                                For our commands the appropriate Application Controller is an asset application controller. It uses a response class to hold the domain commands and view
                                references. For the domain command I use a reference to a class; for the view I
                                use a string, which the front controller will turn into a URL for a JSP.
                                <pre>class Response...
                                private Class domainCommand;
                                private String viewUrl;
                                public Response(Class domainCommand, String viewUrl) {
                                this.domainCommand = domainCommand;
                                this.viewUrl = viewUrl;
                                }
                                public DomainCommand getDomainCommand() {
                                try {
                                return (DomainCommand) domainCommand.newInstance();
                                } catch (Exception e) {throw new ApplicationException (e);
                                }
                                }
                                public String getViewUrl() {
                                return viewUrl;
                                }</pre>
                                The application controller holds on to the responses using a map of maps
                                indexed by the command string and an asset status (Figure 14.12).
                                <pre>class AssetApplicationController...
                                private Response getResponse(String commandString, AssetStatus state) {
                                return (Response) getResponseMap(commandString).get(state);
                                }
                                private Map getResponseMap (String key) {
                                return (Map) events.get(key);
                                }
                                private Map events = new HashMap();</pre>
                                When asked for a domain command, the controller looks at the request to
                                figure out the asset ID, goes to the domain to determine the
                <p><img src="img/figure 14.12.png" alt="no img" style="margin-left: 200px;"></p>
                                looks up the appropriate domain command class, instantiates that class, and
                                returns the new object.
                                <pre>class AssetApplicationController...
                                public DomainCommand getDomainCommand (String commandString, Map params) {
                                Response reponse = getResponse(commandString, getAssetStatus(params));
                                return reponse.getDomainCommand();
                                }
                                private AssetStatus getAssetStatus(Map params) {
                                String id = getParam("assetID", params);
                                Asset asset = Asset.find(id);
                                return asset.getStatus();
                                }
                                private String getParam(String key, Map params) {
                                return ((String[]) params.get(key))[0];
                                }</pre>
                                All the domain commands follow a simple interface that allows the front
                                controller to run them.
                                <pre>interface DomainCommand...
                                abstract public void run(Map params);</pre>
                                Once the domain command has done what it needs to do, the Application Controller comes into play again when itâ€™s asked for the view.
                                <pre>class AssetApplicationController...
                                public String getView (String commandString, Map params) {
                                return getResponse(commandString, getAssetStatus(params)).getViewUrl();
                                }</pre>
                                In this case the Application Controller doesnâ€™t return the full URL to the JSP. It
                                returns a string that the front controller turns into an URL. I do this to avoid
                                duplicating the URL paths in the responses. It also makes it easy to add further
                                indirection later should I need it.
                                The Application Controller can be loaded for use with code.
                                <pre>class AssetApplicationController...
                                public void addResponse(String event, Object state, Class domainCommand, String view) {
                                Response newResponse = new Response (domainCommand, view);
                                if ( ! events.containsKey(event))
                                events.put(event, new HashMap());
                                getResponseMap(event).put(state, newResponse);
                                }
                                private static void loadApplicationController(AssetApplicationController appController) {
                                appController = AssetApplicationController.getDefault();
                                appController.addResponse("return", AssetStatus.ON_LEASE,
                                GatherReturnDetailsCommand.class, "return");
                                appController.addResponse("return", AssetStatus.IN_INVENTORY,
                                NullAssetCommand.class, "illegalAction");
                                appController.addResponse("damage", AssetStatus.ON_LEASE,
                                InventoryDamageCommand.class, "leaseDamage");
                                appController.addResponse("damage", AssetStatus.IN_INVENTORY,
                                LeaseDamageCommand.class, "inventoryDamage");
                                }</pre>
                                Doing this from a file instead isnâ€™t rocket science, but even so Iâ€™ll leave it to you.</p>
                <h3 id="387">Chapter 15</h3>
                <h2>Distribution Patterns</h2>
                <h3 id="388">Remote Facade</h3>
                <p><img src="img/part2.33.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Provides a coarse-grained facade on fine-grained
                                objects to improve efficiency over a network.
                                In an object-oriented model, you do best with small objects that have small
                                methods. This gives you lots of opportunity for control and substitution of
                                behavior, and to use good intention revealing naming to make an application
                                easier to understand. One of the consequences of such fine-grained behavior is
                                that thereâ€™s usually a great deal of interaction between objects, and that interaction usually requires lots of method invocations.
                                Within a single address space fine-grained interaction works well, but this
                                happy state does not exist when you make calls between processes. Remote
                                calls are much more expensive because thereâ€™s a lot more to do: Data may have
                                to be marshaled, security may need to be checked, packets may need to be
                                routed through switches. If the two processes are running on machines on
                                opposite sides of the globe, the speed of light may be a factor. The brutal truth
                                is that any inter-process call is orders of magnitude more expensive than an inprocess callâ€”even if both processes are on the same machine. Such a performance effect cannot be ignored, even for believers in lazy optimization.</p>
                <p>As a result any object thatâ€™s intended to be used as a remote objects needs a
                                coarse-grained interface that minimizes the number of calls needed to get something done. Not only does this affect your method calls, it also affects your
                                objects. Rather than ask for an order and its order lines individually, you need
                                to access and update the order and order lines in a single call. This affects your
                                entire object structure. You give up the clear intention and fine-grained control
                                you get with small objects and small methods. Programming becomes more difficult and your productivity slows.
                                A Remote Facade is a coarse-grained facade [Gang of Four] over a web of
                                fine-grained objects. None of the fine-grained objects have a remote interface,
                                and the Remote Facade contains no domain logic. All the Remote Facade does
                                is translate coarse-grained methods onto the underlying fine-grained objects.</p>
                <h3 id="389">How It Works</h3>
                <p>Remote Facade tackles the distribution problem which the standard OO
                                approach of separating distinct responsibilities into different objects; and as a
                                result it has become the standard pattern for this problem. I recognize that finegrained objects are the right answer for complex logic, so I ensure that any
                                complex logic is placed in fine-grained objects that are designed to collaborate
                                within a single process. To allow efficient remote access to them, I make a separate facade object that acts as a remote interface. As the name implies, the
                                facade is merely a thin skin that switches from a coarse-grained to a finegrained interface.
                                In a simple case, like an address object, a Remote Facade replaces all the getting and setting methods of the regular address object with one getter and one
                                setter, often referred to as bulk accessors. When a client calls a bulk setter, the
                                address facade reads the data from the setting method and calls the individual
                                accessors on the real address object (see Figure 15.1) and does nothing more.
                                This way all the logic of validation and computation stays on the address object
                                where it can be factored cleanly and can be used by other fine-grained objects.
                                In a more complex case a single Remote Facade may act as a remote gateway
                                for many fine-grained objects. For example, an order facade may be used to get
                <p><img src="img/figure 15.1.png" alt="no img" style="margin-left: 200px;"></p>
                                and update information for an order, all its order lines, and maybe some customer data as well.
                                In transferring information in bulk like this, you need it to be in a form that
                                can easily move over the wire. If your fine-grained classes are present on both
                                sides of the connection and theyâ€™re serializable, you can transfer them directly
                                by making a copy. In this case a getAddressData method creates a copy of the original address object. The setAddressData receives an address object and uses it to
                                update the actual address objectâ€™s data. (This assumes that the original address
                                object needs to preserve its identity and thus canâ€™t be simply replaced with the
                                new address.)</p>
                <p>Often you canâ€™t do this, however. You may not want to duplicate your domain
                                classes on multiple processes, or it may be difficult to serialize a segment of a
                                domain model due to its complicated relationship structure. The client may not
                                want the whole model but just a simplified subset of it. In these cases it makes
                                sense to use a Data Transfer Object (401) as the basis of the transfer.
                                In the sketch Iâ€™ve shown a Remote Facade that corresponds to a single
                                domain object. This isnâ€™t uncommon and itâ€™s easy to understand, but it isnâ€™t the
                                most usual case. A single Remote Facade would have a number of methods,
                                each designed to pass on information from several objects. Thus, getAddressData
                                and setAddressData would be methods defined on a class like CustomerService,
                                which would also have methods along the lines of getPurchasingHistory and
                                updateCreditData.</p>
                <p>Granularity is one of the most tricky issues with Remote Facade. Some people like to make fairly small Remote Facades, such as one per use case. I prefer
                                a coarser grained structure with much fewer Remote Facades. For even a moderate-sized application I might have just one and even for a large application I
                                may have only half a dozen. This means that each Remote Facade has a lot of
                                methods, but since these methods are small I donâ€™t see this as a problem.
                                You design a Remote Facade based on the needs of a particular clientâ€™s
                                usageâ€”most commonly the need to view and update information through a
                                user interface. In this case you might have a single Remote Facade for a family
                                of screens, for each of which one bulk accessor method loads and saves the
                                data. Pressing buttons on a screen, say to change an orderâ€™s status, invokes
                                command methods on the facade. Quite often youâ€™ll have different methods on
                                the Remote Facade that do pretty much the same thing on the underlying
                                objects. This is common and reasonable. The facade is designed to make life
                                simpler for external users, not for the internal system, so if the client process
                                thinks of it as a different command, it is a different command, even if it all goes
                                to the same internal command.</p>
                <p>Remote Facade can be stateful or stateless. A stateless Remote Facade can be
                                pooled, which can improve resource usage and efficiency, especially in a B2C
                                situation. However, if the interaction involves state across a session, then it
                                needs to store session state somewhere using Client Session State (456) or Database Session State (462), or an implementation of Server Session State (458). As
                                stateful a Remote Facade can hold on to its own state, which makes for an easy
                                implementation of Server Session State (458), but this may lead to performance
                                issues when you have thousands of simultaneous users.
                                As well as providing a coarse-grained interface, several other responsibilities
                                can be added to a Remote Facade. For example, its methods are a natural point
                                at which to apply security. An access control list can say which users can invoke
                                calls on which methods. The Remote Facade methods also are a natural point
                                at which to apply transactional control. A Remote Facade method can start a
                                transaction, do all the internal work, and then commit the transaction at the
                                end. Each call makes a good transaction because you donâ€™t want a transaction
                                open when return goes back to the client, since transactions arenâ€™t built to be
                                efficient for such long running cases.</p>
                <p>One of the biggest mistakes I see in a Remote Facade is putting domain logic
                                in it. Repeat after me three times; â€œRemote Facade has no domain logic.â€ Any
                                facade should be a thin skin that has only minimal responsibilities. If you need
                                domain logic for workflow or coordination either put it in your fine-grained
                                objects or create a separate nonremotable Transaction Script (110) to contain
                                it. You should be able to run the entire application locally without using the
                                Remote Facades or having to duplicate any code.
                                Remote Facade and Session Facade Over the last couple of years the Session
                                Facade [Alur et al.] pattern has been appearing in the J2EE community. In my
                                earlier drafts I considered Remote Facade to be the same pattern as Session
                                Facade and used the Session Facade name. In practice, however, thereâ€™s a crucial
                                difference. Remote Facade is all about having a thin remote skinâ€”hence my
                                diatribe against domain logic in it. In contrast, most descriptions of Session
                                Facade involve putting logic in it, usually of a workflow kind. A large part of
                                this is due to the common approach of using J2EE session beans to wrap entity
                                beans. Any coordination of entity beans has to be done by another object since
                                they canâ€™t be re-entrant.</p>
                <p>As a result, I see a Session Facade as putting several Transaction Scripts
                                (110) in a remote interface. Thatâ€™s a reasonable approach, but it isnâ€™t the same
                                thing as a Remote Facade. Indeed, I would argue that, since the Session Facade
                                contains domain logic, it shouldnâ€™t be called a facade at all!
                                Service Layer A concept familiar to facades is a Service Layer (133). The main
                                difference is that a service layer doesnâ€™t have to be remote and thus doesnâ€™t need to
                                have only fine-grained methods. In simplifying the Domain Model (116), you
                                often end up with coarser-grained methods, but thatâ€™s for clarity, not for network
                                efficiency. Furthermore, thereâ€™s no need for a service layer to use Data Transfer
                                Objects (401). Usually it can happily return real domain objects to the client.
                                If a Domain Model (116) is going to be used both within a process and
                                remotely, you can have a Service Layer (133) and layer a separate Remote
                                Facade on top of it. If the process is only used remotely, itâ€™s probably easier to
                                fold the Service Layer (133) into the Remote Facade, providing the Service
                                Layer (133) has no application logic. If thereâ€™s any application logic in it, then I
                                would make the Remote Facade a separate object.</p>
                <h3 id="392">When to Use It</h3>
                <p>Use Remote Facade whenever you need remote access to a fine-grained object
                                model. You gain the advantages of a coarse-grained interface while still keeping
                                the advantage of fine-grained objects, giving you the best of both worlds.
                                The most common use of this pattern is between a presentation and a
                                Domain Model (116), where the two may run on different processes. Youâ€™ll get
                                this between a swing UI and server domain model or with a servlet and a server
                                object model if the application and Web servers are different processes.
                                Most often you run into this with different processes on different machines,
                                but it turns out that the cost of an inter-process call on the same box is sufficiently large that you need a coarse-grained interface for any inter-process communication regardless of where the processes live.
                                If all your access is within a single process, you donâ€™t need this kind of conversion. Thus, I wouldnâ€™t use this pattern to communicate between a client
                                Domain Model (116) and its presentation or between a CGI script and Domain
                                Model (116) running in one Web server. You donâ€™t see Remote Facade used
                                with a Transaction Script (110) as a rule, since a Transaction Script (110) is
                                inherently coarser grained.
                                Remote Facades imply a synchronousâ€”that is, a remote procedure callâ€”
                                style of distribution. Often you can greatly improve the responsiveness of an
                                application by going with asynchronous, message-based remote communication. Indeed, an asynchronous approach has many compelling advantages.
                                Sadly, discussion of asynchronous patterns is outside the scope of this book.</p>
                <h3 id="392(2)">Example: Using a Java Session Bean as a Remote Facade (Java)</h3>
                <p>If youâ€™re working with the Enterprise Java platform, a good choice for a distributed facade is a session bean because its a remote object and may be stateful or
                                stateless. In this example Iâ€™ll run a bunch of POJOs (plain old Java objects) inside
                                an EJB container and access them remotely through a session bean thatâ€™s designed
                                as a Remote Facade. Session beans arenâ€™t particularly complicated, so everything
                                should make sense even if you havenâ€™t done any work with them before.
                                I feel the need for a couple of side notes here. First, Iâ€™ve been surprised by
                                how many people seem to believe that you canâ€™t run plain objects inside an EJB
                                container in Java. I hear the question, â€œAre the domain objects entity beans?â€
                                The answer is, they can be but they donâ€™t have to be. Simple Java objects work
                                just fine, as in this example.</p>
                <p>My second side note is just to point out that this isnâ€™t the only way to use session beans. They can also be used to host Transaction Scripts (110).
                                In this example Iâ€™ll look at remote interfaces for accessing information about
                                music albums. The Domain Model (116) consists of fine-grained objects that
                                represent an artist, and album, and tracks. Surrounding this are several other
                                packages that provide the data sources for the application (see Figure 15.2).
                                In the figure, the dto package contains Data Transfer Objects (401) that help
                                move data over the wire to the client. They have simple accessor behavior and
                                also the ability to serialize themselves in binary or XML textual formats. In the
                <p><img src="img/figure 15.2.png" alt="no img" style="margin-left: 200px;"></p>
                                remote package are assembler objects that move data between the domain
                                objects and the Data Transfer Objects (401). If youâ€™re interested in how this
                                works see the Data Transfer Object (401) discussion.</p>
                <p>To explain the facade Iâ€™ll assume that I can move data into and out of Data
                                Transfer Objects (401) and concentrate on the remote interfaces. A single logical Java session bean has three actual classes. Two of them make up the remote
                                API (and in fact are Java interfaces); the other is the class that implements the
                                API. The two interfaces are the AlbumService itself and the home object, AlbumHome.
                                The home object is used by the naming service to get access to the distributed
                                facade, but thatâ€™s an EJB detail that Iâ€™ll skip over here. Our interest is in the
                                Remote Facade itself; AlbumService. Its interface is declared in the API package to
                                be used by the client and is just a list of methods.
                                <pre>class AlbumService...
                                String play(String id) throws RemoteException;
                                String getAlbumXml(String id) throws RemoteException;
                                AlbumDTO getAlbum(String id) throws RemoteException;
                                void createAlbum(String id, String xml) throws RemoteException;
                                void createAlbum(String id, AlbumDTO dto) throws RemoteException;
                                void updateAlbum(String id, String xml) throws RemoteException;
                                void updateAlbum(String id, AlbumDTO dto) throws RemoteException;
                                void addArtistNamed(String id, String name) throws RemoteException;
                                void addArtist(String id, String xml) throws RemoteException;
                                void addArtist(String id, ArtistDTO dto) throws RemoteException;
                                ArtistDTO getArtist(String id) throws RemoteException;</pre>
                                Notice that even in this short example I see methods for two different classes
                                in the Domain Model (116): artist and album. I also see minor variations on the
                                same method. Methods have variants that use either the Data Transfer Object
                                (401) or an XML string to move data into the remote service. This allows the
                                client to choose which form to use depending on the nature of the client and of
                                the connection. As you can see, for even a small application this can lead to
                                many methods on AlbumService.
                                Fortunately, the methods themselves are very simple. Here are the ones for
                                manipulating albums:
                                <pre>class AlbumServiceBean...
                                public AlbumDTO getAlbum(String id) throws RemoteException {
                                return new AlbumAssembler().writeDTO(Registry.findAlbum(id));
                                }
                                public String getAlbumXml(String id) throws RemoteException {
                                AlbumDTO dto = new AlbumAssembler().writeDTO(Registry.findAlbum(id));
                                return dto.toXmlString();
                                }
                                public void createAlbum(String id, AlbumDTO dto) throws RemoteException {
                                new AlbumAssembler().createAlbum(id, dto);
                                }
                                public void createAlbum(String id, String xml) throws RemoteException {
                                AlbumDTO dto = AlbumDTO.readXmlString(xml);
                                new AlbumAssembler().createAlbum(id, dto);
                                }
                                public void updateAlbum(String id, AlbumDTO dto) throws RemoteException {
                                new AlbumAssembler().updateAlbum(id, dto);
                                }
                                public void updateAlbum(String id, String xml) throws RemoteException {
                                AlbumDTO dto = AlbumDTO.readXmlString(xml);
                                new AlbumAssembler().updateAlbum(id, dto);
                                }</pre>
                                As you can see, each method really does nothing more than delegate to another
                                object, so itâ€™s only a line or two in length. This snippet illustrates nicely what a
                                distributed facade should look like: a long list of very short methods with very
                                little logic in them. The facade then is nothing more than a packaging mechanism, which is as it should be.
                                Weâ€™ll just finish with a few words on testing. Itâ€™s very useful to be able to do
                                as much testing as possible in a single process. In this case I can write tests for
                                the session bean implementation directly: these can be run without deploying to
                                the EJB container.
                                <pre>class XmlTester...
                                private AlbumDTO kob;
                                private AlbumDTO newkob;
                                private AlbumServiceBean facade = new AlbumServiceBean();
                                protected void setUp() throws Exception {
                                facade.initializeForTesting();
                                kob = facade.getAlbum("kob");
                                Writer buffer = new StringWriter();
                                kob.toXmlString(buffer);
                                newkob = AlbumDTO.readXmlString(new StringReader(buffer.toString()));
                                }
                                public void testArtist() {
                                assertEquals(kob.getArtist(), newkob.getArtist());
                                }</pre>
                                That was one of the JUnit tests to be run in memory. It showed how I can create
                                an instance of the session bean outside the container and run tests on it, allowing a faster testing turnaround.</p>
                <h3 id="395">Example: Web Service (C#)</h3>
                <p>I was talking over this book with Mike Hendrickson, my editor at AddisonWesley. Ever alert to the latest buzzwords, he asked me if I had anything
                                about Web services in it. Iâ€™m actually loathe to rush to every fashionâ€”after
                                all, given the languid pace of book publishing any â€œlatest fashionâ€ that I write
                                about will seem quaint by the time you read about it. Still, itâ€™s a good example
                                of how core patterns so often keep their value even with the latest technological flip-flops.
                                At its heart a Web service is nothing more than an interface for remote usage
                                (with a slow string-parsing step thrown in for good measure). As such the basic
                                advice of Remote Facade holds: Build your functionality in a fine-grained manner and then layer a Remote Facade over the fine-grained model in order to
                                handle Web services.</p>
                <p>For the example, Iâ€™ll use the same basic problem I described previously, but
                                concentrate just on the request for information about a single album.
                                Figure 15.3 shows the various classes that take part. They fall into the familiar
                                groups: album service, the Remote Facade; two Data Transfer Objects (401);
                                three objects in a Domain Model (116); and an assembler to pull data from the
                                Domain Model (116) into the Data Transfer Objects (401).
                                The Domain Model (116) is absurdly simple; indeed, for this kind of problem youâ€™re better off using a Table Data Gateway (144) to create the Data
                                Transfer Objects (401) directly. However, that would rather spoil the example
                                of a Remote Facade layered over a domain model.
                                <pre>class Album...
                                public String Title;
                                public Artist Artist;
                                public IList Tracks {
                                get {return ArrayList.ReadOnly(tracksData);}
                                }
                                public void AddTrack (Track arg) {
                                tracksData.Add(arg);
                                }
                                public void RemoveTrack (Track arg) {
                                tracksData.Remove(arg);
                                }
                                private IList tracksData = new ArrayList();
                                class Artist...
                                public String Name;
                                class Track...
                                public String Title;
                                public IList Performers {
                                get {return ArrayList.ReadOnly(performersData);}
                                }
                                public void AddPerformer (Artist arg) {
                                performersData.Add(arg);
                                }</pre>
                <p><img src="img/figure 15.3.png" alt="no img" style="margin-left: 200px;"></p>
                                <pre>public void RemovePerformer (Artist arg) {
                                performersData.Remove(arg);
                                }</pre>
                                private IList performersData = new ArrayList();
                                I use Data Transfer Objects (401) for passing the data over the wire. These are
                                just data holders that flatten the structure for the purposes of the Web service.
                                <pre>class AlbumDTO...
                                public String Title;
                                public String Artist;
                                public TrackDTO[] Tracks;
                                class TrackDTO...
                                public String Title;
                                public String[] Performers;</pre>
                                Since this is .NET, I donâ€™t need to write any code to serialize and restore into
                                XML. The .NET framework comes with the appropriate serializer class to do
                                the job.
                                This is a Web service, so I also need to declare the structure of the Data
                                Transfer Objects (401) in WSDL. The Visual Studio tools will generate the
                                WSDL for me, and Iâ€™m a lazy kind of guy, so Iâ€™ll let it do that. Hereâ€™s the XML
                                Schema definition that corresponds to the Data Transfer Objects (401):
                                <pre><s:complexType name="AlbumDTO">
                                <s:sequence>
                                <s:element minOccurs="1" maxOccurs="1" name="Title" nillable="true" type="s:string" />
                                <s:element minOccurs="1" maxOccurs="1" name="Artist" nillable="true" type="s:string" />
                                <s:element minOccurs="1" maxOccurs="1" name="Tracks"
                                nillable="true" type="s0:ArrayOfTrackDTO" />
                                </s:sequence>
                                </s:complexType>
                                <s:complexType name="ArrayOfTrackDTO">
                                <s:sequence>
                                <s:element minOccurs="0" maxOccurs="unbounded" name="TrackDTO"
                                nillable="true" type="s0:TrackDTO" />
                                </s:sequence>
                                </s:complexType>
                                <s:complexType name="TrackDTO">
                                <s:sequence>
                                <s:element minOccurs="1" maxOccurs="1" name="Title" nillable="true" type="s:string" />
                                <s:element minOccurs="1" maxOccurs="1" name="Performers"
                                nillable="true" type="s0:ArrayOfString" />
                                </s:sequence>
                                </s:complexType>
                                <s:complexType name="ArrayOfString">
                                <s:sequence>
                                <s:element minOccurs="0" maxOccurs="unbounded" name="string"
                                nillable="true" type="s:string" />
                                </s:sequence>
                                </s:complexType></pre>
                                Being XML, itâ€™s a particularly verbose data structure definition, but it does the
                                job.
                                To get the data from the Domain Model (116) to the Data Transfer Object
                                (401) I need an assembler.
                                <pre>class AlbumAssembler...
                                public AlbumDTO WriteDTO (Album subject) {
                                AlbumDTO result = new AlbumDTO();
                                result.Artist = subject.Artist.Name;
                                result.Title = subject.Title;
                                ArrayList trackList = new ArrayList();
                                foreach (Track t in subject.Tracks)
                                trackList.Add (WriteTrack(t));
                                result.Tracks = (TrackDTO[]) trackList.ToArray(typeof(TrackDTO));
                                return result;
                                }
                                public TrackDTO WriteTrack (Track subject) {
                                TrackDTO result = new TrackDTO();
                                result.Title = subject.Title;
                                result.Performers = new String[subject.Performers.Count];
                                ArrayList performerList = new ArrayList();
                                foreach (Artist a in subject.Performers)
                                performerList.Add (a.Name);
                                result.Performers = (String[]) performerList.ToArray(typeof (String));
                                return result;
                                }
                                The last piece we need is the service definition itself. This comes first from the
                                C# class.
                                class AlbumService...
                                [ WebMethod ]
                                public AlbumDTO GetAlbum(String key) {
                                Album result = new AlbumFinder()[key];
                                if (result == null)
                                throw new SoapException ("unable to find album with key: " +
                                key, SoapException.ClientFaultCode);
                                else return new AlbumAssembler().WriteDTO(result);
                                }</pre>
                                Of course, this isnâ€™t the real interface definitionâ€”that comes from the WSDL
                                file. Here are the relevant bits:
                                <pre><portType name="AlbumServiceSoap">
                                <operation name="GetAlbum">
                                <input message="s0:GetAlbumSoapIn" />
                                <output message="s0:GetAlbumSoapOut" />
                                </operation>
                                </portType>
                                <message name="GetAlbumSoapIn">
                                <part name="parameters" element="s0:GetAlbum" />
                                </message>
                                <message name="GetAlbumSoapOut">
                                <part name="parameters" element="s0:GetAlbumResponse" />
                                </message>
                                <s:element name="GetAlbum">
                                <s:complexType>
                                <s:sequence>
                                <s:element minOccurs="1" maxOccurs="1" name="key" nillable="true" type="s:string" />
                                </s:sequence>
                                </s:complexType>
                                </s:element>
                                <s:element name="GetAlbumResponse">
                                <s:complexType>
                                <s:sequence>
                                <s:element minOccurs="1" maxOccurs="1" name="GetAlbumResult"
                                nillable="true" type="s0:AlbumDTO" />
                                </s:sequence>
                                </s:complexType>
                                </s:element></pre>
                                As expected, WSDL is rather more garrulous than your average politician,
                                but unlike so many of them, it does get the job done. I can now invoke the service by sending a SOAP message of the form
                                <pre><?xml version="1.0" encoding="utf-8"?>
                                <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                                xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                                xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
                                <soap:Body>
                                <GetAlbum xmlns="http://martinfowler.com">
                                <key>aKeyString</key>
                                </GetAlbum>
                                </soap:Body>
                                </soap:Envelope></pre>
                                The important thing to remember about this example isnâ€™t the cool gyrations
                                with SOAP and .NET but the fundamental layering approach. Design an application without distribution, then layer the distribution ability on top of it with
                                Remote Facades and Data Transfer Objects (401).</p>
                <h3 id="401">Data Transfer Object</h3>
                <p><img src="img/part2.34.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that carries data between processes in order
                                to reduce the number of method calls.
                                When youâ€™re working with a remote interface, such as Remote Facade (388),
                                each call to it is expensive. As a result you need to reduce the number of calls,
                                and that means that you need to transfer more data with each call. One way to
                                do this is to use lots of parameters. However, this is often awkward to programâ€”indeed, itâ€™s often impossible with languages such as Java that return
                                only a single value.
                                The solution is to create a Data Transfer Object that can hold all the data for
                                the call. It needs to be serializable to go across the connection. Usually an
                                assembler is used on the server side to transfer data between the DTO and any
                                domain objects.
                                Many people in the Sun community use the term â€œValue Objectâ€ for this pattern. I use it to mean something else. See the discussion on page 487.</p>
                <h3 id="401(2)">How It Works</h3>
                <p>In many ways, a Data Transfer Object is one of those objects our mothers told
                                us never to write. Itâ€™s often little more than a bunch of fields and the getters and
                                setters for them. The value of this usually hateful beast is that it allows you to
                                move several pieces of information over a network in a single callâ€”a trick
                                thatâ€™s essential for distributed systems.
                                Whenever a remote object needs some data, it asks for a suitable Data Transfer Object. The Data Transfer Object will usually carries much more data than
                                what the remote object requested, but it should carry all the data the remote
                                object will need for a while. Due to the latency costs of remote calls, its better
                                to err on the side of sending too much data than have to make multiple calls.
                                A single Data Transfer Object usually contains more than just a single server
                                object. It aggregates data from all the server objects that the remote object is
                                likely to want data from. Thus, if a remote object requests data about an order
                                object, the returned Data Transfer Object will contain data from the order, the
                                customer, the line items, the products on the line items, the delivery informationâ€”all sorts of stuff.
                                You canâ€™t usually transfer objects from a Domain Model (116). This is
                                because the objects are usually connected in a complex web thatâ€™s difficult, if
                                not impossible, to serialize. Also you usually donâ€™t want the domain object
                                classes on the client, which is tantamount to copying the whole Domain Model
                                (116) there. Instead you have to transfer a simplified form of the data from the
                                domain objects.</p>
                <p>The fields in a Data Transfer Object are fairly simple, being primitives, simple classes like strings and dates, or other Data Transfer Objects. Any structure
                                between data transfer objects should be a simple graph structureâ€”normally a
                                hierarchyâ€”as opposed to the more complicated graph structures that you see in
                                a Domain Model (116). Keep these simple attributes because they have to be
                                serializable and they need to be understood by both sides of the wire. As a
                                result the Data Transfer Object classes and any classes they reference must be
                                present on both sides.
                                It makes sense to design the Data Transfer Object around the needs of a particular client. Thatâ€™s why you often see them corresponding to Web pages or
                                GUI screens. You may also see multiple Data Transfer Objects for an order,
                                depending on the particular screen. Of course, if different presentations require
                                similar data, then it makes sense to use a single Data Transfer Object to handle
                                them all.</p>
                <p>A related question to consider is using a single Data Transfer Object for a
                                whole interaction versus different ones for each request. Different Data Transfer Objects make it easier to see what data is transferred in each call, but leads
                                to a lot of Data Transfer Objects. One is less work to write, but makes it harder
                                to see how each call transfers information. Iâ€™m inclined to use just one if thereâ€™s
                                a lot of commonality over the data, but I donâ€™t hesitate to use different Data
                                Transfer Objects if a particular request suggests it. Itâ€™s one of those things you
                                canâ€™t make a blanket rule about, so I might use one Data Transfer Object for
                                most of the interaction and use different ones for a couple of requests and
                                responses.</p>
                <p>A similar question is whether to have a single Data Transfer Object for both
                                request and response or separate ones for each. Again, thereâ€™s no blanket rule. If
                                the data in each case is pretty similar, use one. If theyâ€™re very different, I use two.
                                Some people like to make Data Transfer Objects immutable. In this scheme
                                you receive one Data Transfer Object from the client and create and send back
                                a different one, even if itâ€™s the same class. Other people alter the request Data
                                Transfer Object. I donâ€™t have any strong opinions either way, but on the whole
                                I prefer a mutable Data Transfer Object because itâ€™s easier to put the data in
                                gradually, even if you make a new object for the response. Some arguments in
                                favor of immutable Data Transfer Object have to do with the naming confusion with Value Object (486).
                                A common form for Data Transfer Object is that of a Record Set (508), that
                                is, a set of tabular recordsâ€”exactly what you get back from a SQL query.
                                Indeed, a Record Set (508) is the Data Transfer Object for a SQL database.
                                Architectures often use it throughout the design. A domain model can generate
                                a Record Set (508) of data to transfer to a client, which the client treats as if it
                                was coming directly from SQL. This is useful if the client has tools that bind to
                                Record Set (508) structures. The Record Set (508) can be entirely created by the
                                domain logic, but more likely itâ€™s generated from a SQL query and modified by
                                the domain logic before itâ€™s passed on to the presentation. This style lends itself
                                to Table Module (125).</p>
                <p>Another form of Data Transfer Object is as a generic collection data structure. Iâ€™ve seen arrays used for this, but I discourage that because the array indices obscure the code. The best collection is a dictionary because you can use
                                meaningful strings as keys. The problem is that you lose the advantage of an
                                explicit interface and strong typing. A dictionary can be worth using for ad hoc
                                cases when you donâ€™t have a generator at hand, as itâ€™s easier to manipulate one
                                than to write an explicit object by hand. However, with a generator I think
                                youâ€™re better off with an explicit interface, especially when you consider that it
                                is being used as communication protocol between different components.
                                Serializing the Data Transfer Object Other than simple getters and setters, the
                                Data Transfer Object is also usually responsible for serializing itself into some
                                format that will go over the wire. Which format depends on whatâ€™s on either
                                side of the connection, what can run over the connection itself, and how easy
                                the serialization is. A number of platforms provide built in serialization for simple objects. For example, Java has a built-in binary serialization and .NET has
                                built-in binary and XML serializations. If thereâ€™s a built-in serialization, it usually works right out of the box because Data Transfer Objects are simple structures that donâ€™t deal with the complexities you run into with objects in a
                                domain model. As a result I always use the automatic mechanism if I can.
                                If you donâ€™t have an automatic mechanism, you can usually create one yourself. Iâ€™ve seen several code generators that take a simple record descriptions and
                                generate appropriate classes to hold the data, provide accessors, and read and
                                write the data serializations. The important thing is to make the generator only
                                as complicated as you actually need it to be, and donâ€™t try to put in features you
                                only think youâ€™ll need. It can be a good idea to write the first classes by hand
                                and then use them to help you write the generator.</p>
                <p>You can also use reflective programming to handle the serialization. That
                                way you only have to write the serialization and deserialization routines once
                                and put them in a superclass. There may be a performance cost to this; youâ€™ll
                                have to measure it to find out if the cost is significant.
                                You have to choose a mechanism that both ends of the connection will work
                                with. If you control both ends, you pick the easiest one; if you donâ€™t, you may
                                be able to provide a connector at the end you donâ€™t own. Then you can use a
                                simple Data Transfer Object on both sides of the connection and use the connector to adapt to the foreign component.
                                One of the most common issues you face with Data Transfer Object is
                                whether to use a text or a binary serialization form. Text serializations are easy
                                to read to learn whatâ€™s being communicated. XML is popular because you can
                                easily get tools to create and parse XML documents. The big disadvantages
                                with text are that it needs more bandwidth to send the same data (something
                                particularly true of XML) and thereâ€™s often a performance penalty, which can
                                be quite significant.</p>
                <p>An important factor for serialization is the synchronization of the Data
                                Transfer Object on each side of the wire. In theory, whenever the server changes
                                the definition of the Data Transfer Object, the client updates as well but in
                                practice this may not happen. Accessing a server with an out-of-date client
                                always leads to problems, but the serialization mechanism can make the problems more or less painful. With a pure binary serialization of a Data Transfer
                                Object the result will be that its communication is entirely lost, since any
                                change to its structure usually causes an error on deserialization. Even an
                                innocuous change, such as adding an optional field, will have this effect. As a
                                result direct binary serialization can introduce a lot of fragility into the communication lines.
                                Other serialization schemes can avoid this. One is XML serialization, which
                                can usually be written in a way that makes the classes more tolerant of changes.
                                Another is a more tolerant binary approach, such as serializing the data using a
                                dictionary. Although I donâ€™t like using a dictionary as the Data Transfer Object,
                                it can be a useful way of doing a binary serialization of the data, since that
                                introduces some tolerance into the synchronization.</p>
                <p>Assembling a Data Transfer Object from Domain Objects A Data Transfer Object doesnâ€™t know about how to connect with domain objects. This is because
                                it should be deployed on both sides of the connection. For that reason I donâ€™t
                                want the Data Transfer Object to be dependent on the domain object. Nor do
                                I want the domain objects to be dependent of the Data Transfer Object since
                                the Data Transfer Object structure will change when I alter interface formats.
                                As a general rule, I want to keep the domain model independent of the external interfaces.
                                As a result I like to make a separate assembler object responsible for creating
                                a Data Transfer Object from the domain model and updating the model from it
                                (Figure 15.4). The assembler is an example of a Mapper (473) in that it maps
                                between the Data Transfer Object and the domain objects.
                                I may also have multiple assemblers share the same Data Transfer Object. A
                                common case for this is different update semantics in different scenarios using
                <p><img src="img/figure 15.4.png" alt="no img" style="margin-left: 200px;"></p>
                                the same data. Another reason to separate the assembler is that the Data Transfer Object can easily be generated automatically from a simple data description.
                                Generating the assembler is more difficult and indeed often impossible.</p>
                <h3 id="406">When to Use It</h3>
                <p>Use a Data Transfer Object whenever you need to transfer multiple items of
                                data between two processes in a single method call.
                                There are some alternatives to Data Transfer Object, although Iâ€™m not a fan
                                of them. One is to not use an object at all but simply to use a setting method
                                with many arguments or a getting method with several pass-by reference arguments. The problem is that many languages, such as Java, allow only one object
                                as a return value, so, although this can be used for updates, it canâ€™t be used for
                                retrieving information without playing games with callbacks.
                                Another alternative is to use a some form of string representation directly,
                                without an object acting as the interface to it. Here the problem is that everything
                                else is coupled to the string representation. Itâ€™s good to hide the precise representation behind an explicit interface; that way, if you want to change the string or
                                replace it with a binary structure, you donâ€™t have to change anything else.
                                In particular, itâ€™s worth creating a Data Transfer Object when you want to
                                communicate between components using XML. The XML DOM is a pain in
                                the neck to manipulate, and itâ€™s much better to use a Data Transfer Object that
                                encapsulates it, especially since the Data Transfer Object is so easy to generate.
                                Another common purpose for a Data Transfer Object is to act as a common
                                source of data for various components in different layers. Each component
                                makes some changes to the Data Transfer Object and then passes it on to the
                                next layer. The use of Record Set (508) in COM and .NET is a good example of
                                this, where each layer knows how to manipulate record set based data, whether
                                it comes directly from a SQL database or has been modified by other layers.
                                .NET expands on this by providing a built-in mechanism to serialize record sets
                                into XML.</p>
                <p>Although this book focuses on synchronous systems, thereâ€™s an interesting
                                asynchronous use for Data Transfer Object. This is where you want to use an
                                interface both synchronously and asynchronously. Return a Data Transfer
                                Object as usual for the synchronous case; for the asynchronous case create a
                                Lazy Load (200) of the Data Transfer Object and return that. Connect the
                                Lazy Load (200) to wherever the results from the asynchronous call should
                                appear. The user of the Data Transfer Object will block only when it tries to
                                access the results of the call.</p>
                <h3 id="407">Further Reading</h3>
                <p>[Alur et al.] discuss this pattern under the name Value Object, which I said earlier is equivalent to my Data Transfer Object; my Value Object (486) is a different pattern entirely. This is a name collision; many people have used â€œValue
                                Objectâ€ in the sense that I use it. As far as I can tell, its use to mean what I call
                                Data Transfer Object occurs only within the J2EE community. As a result, Iâ€™ve
                                followed the more general usage.
                                The Value Object Assembler [Alur et al.] is a discussion of the assembler. I
                                chose not to make it a separate pattern, although I use the â€œassemblerâ€ name
                                rather than a name based on Mapper (473).
                                [Marinescu] discusses Data Transfer Object and several implementation
                                variants. [Riehle et al.] discuss flexible ways to serialize, including switching
                                between different forms of serialization.</p>
                <h3 id="407(2)">Example: Transferring Information About Albums (Java)</h3>
                <p>For this example Iâ€™ll use the domain model in Figure 15.5. The data I want to
                                transfer is the data about these linked objects, and the structure for the data
                                transfer objects is the one in Figure 15.6.
                                The data transfer objects simplify this structure a good bit. The relevant data
                                from the artist class is collapsed into the album DTO, and the performers for a
                                track are represented as an array of strings. This is typical of the collapsing of
                <p><img src="img/figure 15.5.png" alt="no img" style="margin-left: 200px;"></p>
                <p><img src="img/figure 15.6.png" alt="no img" style="margin-left: 200px;"></p>
                                structure you see for a data transfer object. There are two data transfer objects
                                present, one for the album and one for each track. In this case I donâ€™t need one
                                for the artist, as all the data is present on one of the other two. I only have the
                                track as a transfer object because there are several tracks in the album and each
                                one can contain more than one data item.
                                Hereâ€™s the code to write a Data Transfer Object from the domain model. The
                                assembler is called by whatever object is handling the remote interface, such as
                                a Remote Facade (388).
                                <pre>class AlbumAssembler...
                                public AlbumDTO writeDTO(Album subject) {
                                AlbumDTO result = new AlbumDTO();
                                result.setTitle(subject.getTitle());
                                result.setArtist(subject.getArtist().getName());
                                writeTracks(result, subject);
                                return result;
                                }
                                private void writeTracks(AlbumDTO result, Album subject) {
                                List newTracks = new ArrayList();
                                Iterator it = subject.getTracks().iterator();
                                while (it.hasNext()) {
                                TrackDTO newDTO = new TrackDTO();
                                Track thisTrack = (Track) it.next();
                                newDTO.setTitle(thisTrack.getTitle());
                                writePerformers(newDTO, thisTrack);
                                newTracks.add(newDTO);
                                }
                                result.setTracks((TrackDTO[]) newTracks.toArray(new TrackDTO[0]));
                                }
                                private void writePerformers(TrackDTO dto, Track subject) {
                                List result = new ArrayList();
                                Iterator it = subject.getPerformers().iterator();
                                while (it.hasNext()) {
                                Artist each = (Artist) it.next();
                                result.add(each.getName());
                                }
                                dto.setPerformers((String[]) result.toArray(new String[0]));
                                }
                                Figure 15.6 A class diagram of data transfer objects.
                                title: String
                                artist: String
                                Album DTO
                                title: String
                                performers: Array of String
                                Track DTO
                                1 *</pre>
                                Updating the model from the Data Transfer Object is usually more involved.
                                For this example thereâ€™s a difference between creating a new album and updating an existing one. Hereâ€™s the creation code:
                                <pre>class AlbumAssembler...
                                public void createAlbum(String id, AlbumDTO source) {
                                Artist artist = Registry.findArtistNamed(source.getArtist());
                                if (artist == null)
                                throw new RuntimeException("No artist named " + source.getArtist());
                                Album album = new Album(source.getTitle(), artist);
                                createTracks(source.getTracks(), album);
                                Registry.addAlbum(id, album);
                                }
                                private void createTracks(TrackDTO[] tracks, Album album) {
                                for (int i = 0; i < tracks.length; i++) {
                                Track newTrack = new Track(tracks[i].getTitle());
                                album.addTrack(newTrack);
                                createPerformers(newTrack, tracks[i].getPerformers());
                                }
                                }
                                private void createPerformers(Track newTrack, String[] performerArray) {
                                for (int i = 0; i < performerArray.length; i++) {
                                Artist performer = Registry.findArtistNamed(performerArray[i]);
                                if (performer == null)
                                throw new RuntimeException("No artist named " + performerArray[i]);
                                newTrack.addPerformer(performer);
                                }
                                }</pre>
                                Reading the DTO involves quite a few decisions. Noticeable here is how to
                                deal with the artist names as they come in. My requirements are that artists
                                should already be in a Registry (480) when I create the album, so if I canâ€™t find
                                an artist this is an error. A different create method might decide to create artists
                                when theyâ€™re mentioned in the Data Transfer Object.
                                For this example I have a different method for updating an existing album.
                                <pre>class AlbumAssembler...
                                public void updateAlbum(String id, AlbumDTO source) {
                                Album current = Registry.findAlbum(id);
                                if (current == null)
                                throw new RuntimeException("Album does not exist: " + source.getTitle());
                                if (source.getTitle() != current.getTitle()) current.setTitle(source.getTitle());
                                if (source.getArtist() != current.getArtist().getName()) {
                                Artist artist = Registry.findArtistNamed(source.getArtist());
                                if (artist == null)
                                throw new RuntimeException("No artist named " + source.getArtist());
                                current.setArtist(artist);
                                }
                                updateTracks(source, current);
                                }
                                private void updateTracks(AlbumDTO source, Album current) {
                                for (int i = 0; i < source.getTracks().length; i++) {
                                current.getTrack(i).setTitle(source.getTrackDTO(i).getTitle());
                                current.getTrack(i).clearPerformers();
                                createPerformers(current.getTrack(i), source.getTrackDTO(i).getPerformers());
                                }
                                }</pre>
                                As for updates you can decide to either update the existing domain object or
                                destroy it and replace it with a new one. The question here is whether you have
                                other objects referring to the object you want to update. In this code Iâ€™m updating the album since I have other objects referring to it and its tracks. However,
                                for the title and performers of a track I just replace the objects that are there.
                                Another question concerns an artist changing. Is this changing the name of
                                the existing artist or changing the artist the album is linked to? Again, these
                                questions have to be settled on a case-by-use case basis, and Iâ€™m handling it by
                                linking to a new artist.
                                In this example Iâ€™ve used native binary serialization, which means I have to
                                be careful that the Data Transfer Object classes on both sides of the wire are
                                kept in sync. If I make a change to the data structure of the server Data Transfer Object and donâ€™t change the client, Iâ€™ll get errors in the transfer. I can make
                                the transfer more tolerant by using a map as my serialization.
                                <pre>class TrackDTO...
                                public Map writeMap() {
                                Map result = new HashMap();
                                result.put("title", title);
                                result.put("performers", performers);
                                return result;
                                }
                                public static TrackDTO readMap(Map arg) {
                                TrackDTO result = new TrackDTO();
                                result.title = (String) arg.get("title");
                                result.performers = (String[]) arg.get("performers");
                                return result;
                                }</pre>
                                Now, if I add a field to the server and use the old client, although the new field
                                wonâ€™t be picked up by the client, the rest of the data will transfer correctly.
                                Of course, writing the serialization and deserialization routines like this is
                                tedious. I can avoid much of this tedium by using a reflective routine such as
                                this on the Layer Supertype (475):
                                <pre>class DataTransferObject...
                                public Map writeMapReflect() {
                                Map result = null;
                                try {
                                Field[] fields = this.getClass().getDeclaredFields();
                                result = new HashMap();
                                for (int i = 0; i < fields.length; i++)
                                result.put(fields[i].getName(), fields[i].get(this));
                                } catch (Exception e) {throw new ApplicationException (e);
                                }
                                return result;
                                }
                                public static TrackDTO readMapReflect(Map arg) {
                                TrackDTO result = new TrackDTO();
                                try {
                                Field[] fields = result.getClass().getDeclaredFields();
                                for (int i = 0; i  fields.length; i++)
                                fields[i].set(result, arg.get(fields[i].getName()));
                                } catch (Exception e) {throw new ApplicationException (e);
                                }
                                return result;
                                }</pre>
                                Such a routine will handle most cases pretty well (although youâ€™ll have to add
                                extra code to handle primitives).</p>
                <h3 id="411">Example: Serializing Using XML (Java)</h3>
                <p>As I write this, Javaâ€™s XML handling is very much in flux and APIs, still volatile,
                                are generally getting better. By the time you read it this section may be out of
                                date or completely irrelevant, but the basic concept of converting to XML is
                                pretty much the same.
                                First I get the data structure for the Data Transfer Object; then I need to
                                decide how to serialize it. In Java you get free binary serialization simply by
                                using a marker interface. This works completely automatically for a Data
                                Transfer Object so itâ€™s my first choice. However, text-based serialization is often
                                necessary. For this example then, Iâ€™ll use XML.
                                For this example, Iâ€™m using JDOM since that makes working with XML
                                much easier than using the W3C standard interfaces. I write methods to read
                                and write an XML element to represent each Data Transfer Object class.
                                <pre>class AlbumDTO...
                                Element toXmlElement() {
                                Element root = new Element("album");
                                root.setAttribute("title", title);
                                root.setAttribute("artist", artist);
                                for (int i = 0; i < tracks.length; i++)
                                root.addContent(tracks[i].toXmlElement());
                                return root;
                                }
                                static AlbumDTO readXml(Element source) {
                                AlbumDTO result = new AlbumDTO();
                                result.setTitle(source.getAttributeValue("title"));
                                result.setArtist(source.getAttributeValue("artist"));
                                List trackList = new ArrayList();
                                Iterator it = source.getChildren("track").iterator();
                                while (it.hasNext())
                                trackList.add(TrackDTO.readXml((Element) it.next()));
                                result.setTracks((TrackDTO[]) trackList.toArray(new TrackDTO[0]));
                                return result;
                                }
                                class TrackDTO...
                                Element toXmlElement() {
                                Element result = new Element("track");
                                result.setAttribute("title", title);
                                for (int i = 0; i < performers.length; i++) {
                                Element performerElement = new Element("performer");
                                performerElement.setAttribute("name", performers[i]);
                                result.addContent(performerElement);
                                }
                                return result;
                                }
                                static TrackDTO readXml(Element arg) {
                                TrackDTO result = new TrackDTO();
                                result.setTitle(arg.getAttributeValue("title"));
                                Iterator it = arg.getChildren("performer").iterator();
                                List buffer = new ArrayList();
                                while (it.hasNext()) {
                                Element eachElement = (Element) it.next();
                                buffer.add(eachElement.getAttributeValue("name"));
                                }
                                result.setPerformers((String[]) buffer.toArray(new String[0]));
                                return result;
                                }</pre>
                                Of course, these methods only create the elements in the XML DOM. To perform the serialization I need to read and write text. Since the track is transferred only in the context of the album, I just need to write this album code.
                                <pre>class AlbumDTO...
                                public void toXmlString(Writer output) {
                                Element root = toXmlElement();
                                Document doc = new Document(root);
                                XMLOutputter writer = new XMLOutputter();
                                try {
                                writer.output(doc, output);
                                } catch (IOException e) {
                                e.printStackTrace();
                                }
                                }
                                public static AlbumDTO readXmlString(Reader input) {
                                try {
                                SAXBuilder builder = new SAXBuilder();
                                Document doc = builder.build(input);
                                Element root = doc.getRootElement();
                                AlbumDTO result = readXml(root);
                                return result;
                                } catch (Exception e) {
                                e.printStackTrace();
                                throw new RuntimeException();
                                }
                                }</pre>
                                Although it isnâ€™t rocket science, Iâ€™ll be glad when JAXB makes this kind of stuff
                                unnecessary.</p>
                <h3 id="415">Chapter 16</h3>
                <h2>Offline Concurrency Patterns</h2>
                <h3 id="416">Optimistic Offline Lock</h3>
                <p><img src="img/part2.35.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Prevents conflicts between concurrent business transactions
                                by detecting a conflict and rolling back the transaction.
                                Often a business transaction executes across a series of system transactions.
                                Once outside the confines of a single system transaction, we canâ€™t depend on
                                our database manager alone to ensure that the business transaction will leave
                                the record data in a consistent state. Data integrity is at risk once two sessions
                                begin to work on the same records and lost updates are quite possible. Also,
                                with one session editing data that another is reading an inconsistent read
                                becomes likely.
                                Optimistic Offline Lock solves this problem by validating that the changes
                                about to be committed by one session donâ€™t conflict with the changes of another
                                session. A successful pre-commit validation is, in a sense, obtaining a lock indicating itâ€™s okay to go ahead with the changes to the record data. So long as the
                                validation and the updates occur within a single system transaction the business
                                transaction will display consistency.
                                Whereas Pessimistic Offline Lock (426) assumes that the chance of session
                                conflict is high and therefore limits the systemâ€™s concurrency, Optimistic Offline
                                Lock assumes that the chance of conflict is low. The expectation that session conflict isnâ€™t likely allows multiple users to work with the same data at the same time.</p>
                <h3 id="417">How It Works</h3>
                <p>An Optimistic Offline Lock is obtained by validating that, in the time since a
                                session loaded a record, another session hasnâ€™t altered it. It can be acquired at
                                any time but is valid only during the system transaction in which it is obtained.
                                Thus, in order that a business transaction not corrupt record data it must
                                acquire an Optimistic Offline Lock for each member of its change set during
                                the system transaction in which it applies changes to the database.
                                The most common implementation is to associate a version number with
                                each record in your system. When a record is loaded that number is maintained
                                by the session along with all other session state. Getting the Optimistic Offline
                                Lock is a matter of comparing the version stored in your session data to the
                                current version in the record data. Once the verification succeeds, all changes,
                                including an increment of the version, can be committed. The version increment
                                is what prevents inconsistent record data, as a session with an old version canâ€™t
                                acquire the lock.</p>
                <p>With an RDBMS data store the verification is a matter of adding the version
                                number to the criteria of any SQL statements used to update or delete a record.
                                A single SQL statement can both acquire the lock and update the record data.
                                The final step is for the business transaction to inspect the row count returned
                                by the SQL execution. A row count of 1 indicates success; 0 indicates that the
                                record has been changed or deleted. With a row count of 0 the business transaction must rollback the system transaction to prevent any changes from entering
                                the record data. At this point the business transaction must either abort or
                                attempt to resolve the conflict and retry.
                                In addition to a version number for each record, storing information as to
                                who last modified a record and when can be quite useful when managing concurrency conflicts. When informing a user of a failed update due to a concurrency violation a proper application will tell when the record was altered and
                                by whom. Itâ€™s a bad idea to use the modification timestamp rather than a version count for your optimistic checks because system clocks are simply too
                                unreliable, especially if youâ€™re coordinating across multiple servers.
                                In an alternative implementation the where clause in the update includes
                                every field in the row. The advantage here is that you can use the where clause
                                without using some form of version field, which can be handy if you canâ€™t add a
                                version field by altering the database tables. The problem is that this complicates the UPDATE statement with a potentially large where clause, which may
                                also be a performance impact depending on how clever the database is about
                                using the primary key index.</p>
                <p><img src="img/figure 16.1.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Often implementing Optimistic Offline Lock is left at including the version
                                in UPDATE and DELETE statements, but this fails to address the problem of an
                                inconsistent read. Think of a billing system that creates charges and calculates
                                appropriate sales tax. A session creates the charge and then looks up the customerâ€™s address to calculate the tax on it, but during the charge generation session a separate customer maintenance session edits the customerâ€™s address. As
                                tax rates depend on location, the rate calculated by the charge generation session might be invalid, but since the charge generation session didnâ€™t make any
                                changes to the address the conflict wonâ€™t be detected.
                                Thereâ€™s no reason why Optimistic Offline Lock canâ€™t be used to detect an
                                inconsistent read. In the example above the charge generation session needs to
                                recognize that its correctness depends on the value of the customerâ€™s address. It
                                therefore should perform a version check on the address as well, perhaps by
                                adding the address to the change set or maintaining a separate list of items to be
                                version-checked. The latter requires a bit more work to set up, but results in
                                code that more clearly states its intent. If youâ€™re checking for a consistent read
                                simply by rereading the version rather than an artificial update, be especially
                                aware of your system transaction isolation level. The version reread will only
                                work with repeatable read or stronger isolation. Anything weaker requires an
                                increment of the version.</p>
                <p>A version check might be overkill for certain inconsistent read problems.
                                Often a transaction depends only on the presence of a record or maybe the value
                                of only one of its fields. In such a case you might improve your systemâ€™s liveliness
                                by checking conditions rather than the version, as fewer concurrent updates will
                                result in the failure of competing business transactions. The better you understand your concurrency issues, the better you can manage them in your code.
                                The Coarse-Grained Lock (438) can help with certain inconsistent read
                                conundrums by treating a group of objects as a single lockable item. Another
                                option is to simply execute all of the steps of the problematic business transaction within a long-running transaction. The ease of implementation might
                                prove worth the resource hit of using a few long transactions here and there.
                                Detection of an inconsistent read gets a bit difficult when your transaction is
                                dependent on the results of a dynamic query rather than the reading of specific
                                records. Itâ€™s possible for you to save the initial results and compare them to the
                                results of the same query at commit time as a means of obtaining an Optimistic
                                Offline Lock.
                                As with all locking schemes, Optimistic Offline Lock by itself doesnâ€™t provide adequate solutions to some of the trickier concurrency and temporal issues
                                in a business application. I canâ€™t stress enough that in a business application
                                concurrency management is as much a domain issue as it is a technical one. Is
                                the customer address scenario above really a conflict? It might be okay that I
                                calculated the sales tax with an older version of the customer, but which version
                                should I actually be using? This is a business issue. Or consider a collection.
                                What if two sessions simultaneously add items to a collection? The typical
                                Optimistic Offline Lock scheme wonâ€™t prevent this even though it might very
                                well be a violation of business rules.</p>
                <p>Thereâ€™s one system using Optimistic Offline Locks that we all should be familiar with: source code management (SCM). When an SCM system detects a conflict between programmers it usually can figure out the correct merge and retry the
                                commit. A quality merge strategy makes Optimistic Offline Lock very powerful
                                not only because the systemâ€™s concurrency is quite high but because users rarely
                                have to redo any work. Of course, the big difference between an SCM system and
                                an enterprise business application is that the SCM must implement only one type
                                of merge while the business system might implement hundreds. Some might be of
                                such complexity that theyâ€™re not worth the cost of coding. Others might be of
                                such value to the business that the merge should be coded by all means. Despite
                                rarely being done, the merging of business objects is possible. In fact, merging
                                business data is a pattern unto its own. Iâ€™ll leave it at that rather than butcher the
                                topic, but do understand the power that merging adds to Optimistic Offline Lock.
                                Optimistic Offline Lock only lets us know during the last system transaction
                                if a business transaction will commit. But itâ€™s occasionally useful to know earlier if a conflict has occurred. For this you can provide a checkCurrent method
                                that checks if anyone else has updated the data. It canâ€™t guarantee that you
                                wonâ€™t get a conflict, but it may be worthwhile to stop a complicated process if
                                you can tell in advance that it wonâ€™t commit. Use this checkCurrent at any time
                                that failing early may be useful, but remember that it never guarantees that you
                                wonâ€™t fail at commit time.</p>
                <h3 id="420">When to Use It</h3>
                <p>Optimistic concurrency management is appropriate when the chance of conflict
                                between any two business transactions is low. If conflicts are likely itâ€™s not user
                                friendly to announce one only when the user has finished his work and is ready
                                to commit. Eventually heâ€™ll assume the failure of business transactions and stop
                                using the system. Pessimistic Offline Lock (426) is more appropriate when the
                                chance of conflict is high or the expense of a conflict is unacceptable.
                                As optimistic locking is much easier to implement and not prone to the same
                                defects and runtime errors as a Pessimistic Offline Lock (426), consider using it
                                as the default approach to business transaction conflict management in any system you build. The pessimistic version works well as a complement to its optimistic counterpart, so rather than asking when to use an optimistic approach to
                                conflict avoidance, ask when the optimistic approach alone isnâ€™t good enough.
                                The correct approach to concurrency management will maximize concurrent
                                access to data while minimizing conflicts.</p>
                <h3 id="421">Example: Domain Layer with Data Mappers (165) (Java)</h3>
                <p>The shortest example of Optimistic Offline Lock would involve only a database
                                table with a version column and UPDATE and DELETE statements that use
                                that version as part of their update criteria. Of course, youâ€™ll be building more
                                sophisticated applications so I present an implementation using a Domain
                                Model (116) and Data Mappers (165). This will reveal more of the issues that
                                commonly arise when implementing Optimistic Offline Lock.
                                One of the first things to do is to make sure that your domain Layer Supertype (475) is capable of storing any information required to implement Optimistic Offline Lockâ€”namely, modification and version data.
                                <pre>class DomainObject...
                                private Timestamp modified;
                                private String modifiedBy;
                                private int version;</pre>
                                Our data is stored in a relational database, so each table must also store version
                                and modification data. Hereâ€™s the schema for a customer table as well as the
                                standard CRUD SQL necessary to support the Optimistic Offline Lock:
                                <pre>table customer...
                                create table customer(id bigint primary key, name varchar, createdby varchar,
                                created datetime, modifiedby varchar, modified datetime, version int)
                                SQL customer CRUD...
                                INSERT INTO customer VALUES (?, ?, ?, ?, ?, ?, ?)
                                SELECT * FROM customer WHERE id = ?
                                UPDATE customer SET name = ?, modifiedBy = ?, modified = ?, version = ?
                                WHERE id = ? and version = ?
                                DELETE FROM customer WHERE id = ? and version = ?</pre>
                                Once you have more than a few tables and domain objects, youâ€™ll want to
                                introduce a Layer Supertype (475) for your Data Mappers (165) that handles
                                the tedious, repetitive segments of O/R mapping. This not only saves a lot of
                                work when writing Data Mappers (165) but also allows the use of an Implicit
                                Lock (449) to prevent a developer from subverting a locking strategy by forgetting to code a bit of locking mechanics.
                                The first piece to move into your abstract mapper is SQL construction. This
                                requires that you provide mappers with a bit of metadata about your tables. An
                                alternative to having your mapper build SQL at runtime is to code-generate it.
                                However, Iâ€™ll leave the construction of SQL statements as an exercise for the
                                reader. In the abstract mapper below youâ€™ll see that Iâ€™ve made a number of
                                assumptions about the column names and positions for our modification data.
                                This becomes less feasible with legacy data. The abstract mapper will likely
                                require a bit of column metadata to be supplied by each concrete mapper.
                                Once the abstract mapper has SQL statements it can manage the CRUD
                                operations. Hereâ€™s how a find executes:
                                <pre>class AbstractMapper...
                                public AbstractMapper(String table, String[] columns) {
                                this.table = table;
                                this.columns = columns;
                                buildStatements();
                                }
                                public DomainObject find(Long id) {
                                DomainObject obj = AppSessionManager.getSession().getIdentityMap().get(id);
                                if (obj == null) {
                                Connection conn = null;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                stmt = conn.prepareStatement(loadSQL);
                                stmt.setLong(1, id.longValue());
                                rs = stmt.executeQuery();
                                if (rs.next()) {
                                obj = load(id, rs);
                                String modifiedBy = rs.getString(columns.length + 2);
                                Timestamp modified = rs.getTimestamp(columns.length + 3);
                                int version = rs.getInt(columns.length + 4);
                                obj.setSystemFields(modified, modifiedBy, version);
                                AppSessionManager.getSession().getIdentityMap().put(obj);
                                } else {
                                throw new SystemException(table + " " + id + " does not exist");
                                }
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected error finding " + table + " " + id);
                                } finally {
                                cleanupDBResources(rs, conn, stmt);
                                }
                                }
                                return obj;
                                }</pre>
                                protected abstract DomainObject load(Long id, ResultSet rs) throws SQLException;
                                There are a few items of note here. First, the mapper checks an Identity Map
                                (195) to make sure that the object isnâ€™t loaded already. Not using an Identity
                                Map (195) could result in different versions of an object being loaded at different times in a business transaction, leading to undefined behavior in your application as well as make a mess of any version checks. Once a result set is
                                obtained the mapper defers to an abstract load method that each concrete mapper must implement to extract its fields and return an activated object. The
                                mapper calls setSystemFields() to set the version and modification data on the
                                abstract domain object. While a constructor might seem the more appropriate
                                means of passing this data, doing so would push part of the version storage
                                responsibility down to each concrete mapper and domain object and thus
                                weaken the Implicit Lock (449).
                                Hereâ€™s what a concrete load() method looks like:
                                <pre>class CustomerMapper extends AbstractMapper...
                                protected DomainObject load(Long id, ResultSet rs) throws SQLException {
                                String name = rs.getString(2);
                                return Customer.activate(id, name, addresses);
                                }</pre>
                                The abstract mapper will similarly manage execution of update and delete
                                operations. The job here is to check that the database operation returns a row
                                count of 1. If no rows have been updated, the optimistic lock canâ€™t be obtained
                                and the mapper must then throw a concurrency exception. Here is the delete
                                operation:
                                <pre>class class AbstractMapper...
                                public void delete(DomainObject object) {
                                AppSessionManager.getSession().getIdentityMap().remove(object.getId());
                                Connection conn = null;
                                PreparedStatement stmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                stmt = conn.prepareStatement(deleteSQL);
                                stmt.setLong(1, object.getId().longValue());
                                int rowCount = stmt.executeUpdate();
                                if (rowCount == 0) {
                                throwConcurrencyException(object);
                                }
                                } catch (SQLException e) {
                                throw new SystemException("unexpected error deleting");
                                } finally {
                                cleanupDBResources(conn, stmt);
                                }
                                }
                                protected void throwConcurrencyException(DomainObject object) throws SQLException {
                                Connection conn = null;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                stmt = conn.prepareStatement(checkVersionSQL);
                                stmt.setInt(1, (int) object.getId().longValue());
                                rs = stmt.executeQuery();
                                if (rs.next()) {
                                int version = rs.getInt(1);
                                String modifiedBy = rs.getString(2);
                                Timestamp modified = rs.getTimestamp(3);
                                if (version > object.getVersion()) {
                                String when = DateFormat.getDateTimeInstance().format(modified);
                                throw new ConcurrencyException(table + " " + object.getId() +
                                " modified by " + modifiedBy + " at " + when);
                                } else {
                                throw new SystemException("unexpected error checking timestamp");
                                }
                                } else {
                                throw new ConcurrencyException(table + " " + object.getId() +
                                " has been deleted");
                                }
                                } finally {
                                cleanupDBResources(rs, conn, stmt);
                                }
                                }</pre>
                                The SQL used to check the version in a concurrency exception also needs to
                                be known by the abstract mapper. Your mapper should construct it when it
                                constructs the CRUD SQL. It will look something like this:
                                checkVersionSQL...
                                SELECT version, modifiedBy, modified FROM customer WHERE id = ?
                                This code doesnâ€™t give much of a feel for the various pieces executing across
                                multiple system transactions within a single business transaction. The most
                                important thing to remember is that acquisition of Optimistic Offline Locks
                                must occur within the same system transaction that holds the commit of your
                                changes in order to maintain record data consistency. With the check bundled
                                into UPDATE and DELETE statements this wonâ€™t be a problem.</p>
                <p>Take a look at the use of a version object in the Coarse-Grained Lock (438)
                                sample code. While Coarse-Grained Lock (438) can solve some inconsistent
                                read problems, a simple nonshared version object can help detect inconsistent
                                reads because itâ€™s a convenient place to add optimistic check behavior such as
                                increment() or checkVersionIsLatest(). Hereâ€™s a Unit of Work (184) where we add
                                consistent read checks to our commit process via the more drastic measure of
                                incrementing the version because we donâ€™t know the isolation level:
                                <pre>class UnitOfWork...
                                private List reads = new ArrayList();
                                public void registerRead(DomainObject object) {
                                reads.add(object);
                                }
                                public void commit() {
                                try {
                                checkConsistentReads();
                                insertNew();
                                deleteRemoved();
                                updateDirty();
                                } catch (ConcurrencyException e) {
                                rollbackSystemTransaction();
                                throw e;
                                }
                                }
                                public void checkConsistentReads() {
                                for (Iterator iterator = reads.iterator(); iterator.hasNext();) {
                                DomainObject dependent = (DomainObject) iterator.next();
                                dependent.getVersion().increment();
                                }
                                }</pre>
                                Notice that the Unit of Work (184) rolls back the system transaction when it
                                detects a concurrency violation. Most likely you would decide to roll back for
                                any exception during the commit. Do not forget this step! As an alternative to
                                version objects, you can add version checks to your mapper interface.
                                426 OFFLINE CONCURRENCY PATTERNS
                                Pessimistic
                                Offline Lock</p>
                <h3 id="426">Pessimistic Offline Lock</h3>
                <p><img src="img/part2.36.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Prevents conflicts between concurrent business
                                transactions by allowing only one business
                                transaction at a time to access data.
                                Since offline concurrency involves manipulating data for a business transaction
                                that spans multiple requests, the simplest approach would seem to be having a
                                system transaction open for the whole business transaction. Sadly, however, this
                                doesnâ€™t always work well because transaction systems arenâ€™t geared to work
                                with long transactions. For that reason you have to use multiple system transacMartin's Session Database David's Session
                                tions, at which point youâ€™re left to your own devices to manage concurrent
                                access to your data.</p>
                <p>The first approach to try is Optimistic Offline Lock (416). However, that
                                pattern has its problems. If several people access the same data within a business transaction, one of them will commit easily but the others will conflict
                                and fail. Since the conflict is only detected at the end of the business transaction, the victims will do all the transaction work only to find at the last minute
                                that the whole thing will fail and their time will have been wasted. If this happens a lot on lengthy business transactions the system will soon become very
                                unpopular.
                                Pessimistic Offline Lock prevents conflicts by avoiding them altogether. It
                                forces a business transaction to acquire a lock on a piece of data before it starts
                                to use it, so that, most of the time, once you begin a business transaction you
                                can be pretty sure youâ€™ll complete it without being bounced by concurrency
                                control.</p>
                <h3 id="427">How It Works</h3>
                <p>You implement Pessimistic Offline Lock in three phases: determining what type
                                of locks you need, building a lock manager, and defining procedures for a business transaction to use locks. Additionally, if youâ€™re using Pessimistic Offline
                                Lock as a complement to Optimistic Offline Lock (416) you need to determine
                                which record types to lock.
                                As for lock types, the first option is an exclusive write lock, which require
                                only that a business transaction acquire a lock in order to edit session data.
                                This avoids conflict by not allowing two business transactions to make changes
                                to the same record simultaneously. What this locking scheme ignores is the
                                reading of data, so if itâ€™s not critical that a view session have the most recent
                                data this strategy will suffice.
                                If it becomes critical that a business transaction must always have the most
                                recent data, regardless of its intention to edit, use the exclusive read lock. This
                                requires that a business transaction acquire a lock simply to load the record.
                                Clearly such a strategy has the potential to severely restrict a systemâ€™s concurrency. For most enterprise systems the exclusive write lock will afford much
                                more concurrent record access than this lock will.</p>
                <p>A third strategy combines the two lock types to provide the restrictive locking of the exclusive read lock as well as the increased concurrency of the exclusive write lock. Called the read/write lock, itâ€™s a bit more complicated than the
                                first two. The relationship of the read and write locks is the key to getting the
                                best of both worlds:
                <ul>
                        <li>Read and write locks are mutually exclusive. A record canâ€™t be writelocked if any other business transaction owns a read lock on it; it canâ€™t be read-locked if any other business transaction owns a write lock on it.</li>
                        <li>Concurrent read locks are acceptable. The existence of a single read lock prevents any business transaction from editing the record, so thereâ€™s no harm in allowing any number of sessions as readers once one has been allowed to read.</li>
                </ul>
                                Allowing multiple read locks is what increases system concurrency. The
                                downside of this scheme is that itâ€™s a bit nasty to implement and presents more
                                of a challenge for domain experts to wrap their heads around when theyâ€™re
                                modeling the system.</p>
                <p>In choosing the correct lock type think about maximizing system concurrency, meeting business needs, and minimizing code complexity. Also keep in
                                mind that the locking strategy must be understood by domain modelers and
                                analysts. Locking is not just a technical problem; the wrong lock type, simply
                                locking every record, or locking the wrong types of records can result an ineffective Pessimistic Offline Lock strategy. An ineffective Pessimistic Offline Lock
                                strategy is one that doesnâ€™t prevent conflict at the onset of the business transaction or that degrades the concurrency of your multi-user system such that it
                                seems more like single-user system. The wrong locking strategy canâ€™t be saved
                                by a proper technical implementation. In fact, itâ€™s not a bad idea to include Pessimistic Offline Lock in your domain model.
                                Once youâ€™ve decided upon your lock type, define your lock manager. The
                                lock managerâ€™s job is to grant or deny any request by a business transaction to
                                acquire or release a lock. To do its job it needs to know whatâ€™s being locked as
                                well as the intended owner of the lockâ€”the business transaction. Itâ€™s quite
                                possible that your concept of a business transaction isnâ€™t some thing that can
                                be uniquely identified, which makes it a bit difficult to pass a business transaction to the lock manager. In this case consider your concept of a session, as
                                youâ€™re more likely to have a session object at your disposal. The terms â€œsessionâ€ and â€œbusiness transactionâ€ are fairly interchangeable. As long as business transactions execute serially within a session the session will be fine as a
                                Pessimistic Offline Lock owner. The code example should shed some light on
                                this idea.</p>
                <p>The lock manager shouldnâ€™t consist of much more than a table that maps
                                locks to owners. A simple one might wrap an in-memory hash table, or it might
                                be a database table. Whatever, you must have one and only one lock table, so if
                                itâ€™s in memory be sure to use a singleton [Gang of Four]. If your application
                                server is clustered, an in-memory lock table wonâ€™t work unless itâ€™s pinned to a
                                single server instance. The database-based lock manager is probably more
                                appropriate once youâ€™re in a clustered application server environment.
                                The lock, whether implemented as an object or as SQL against a database
                                table, should remain private to the lock manager. Business transactions should
                                interact only with the lock manager, never with a lock object.</p>
                <p>Now itâ€™s time to define the protocol according to which a business transaction must use the lock manager. This protocol has to include what to lock and
                                when, when to release a lock, and how to act when a lock canâ€™t be acquired.
                                What to lock depends upon when to lock, so letâ€™s look at when first. Generally, the business transaction should acquire a lock before loading the data, as
                                thereâ€™s not much point in acquiring a lock without a guarantee that youâ€™ll have
                                the latest version of the locked item. Since weâ€™re acquiring locks within a system
                                transaction, however, there are circumstances where the order of the lock and
                                load wonâ€™t matter. Depending on your lock type, if youâ€™re using serializable or
                                repeatable read transactions, the order in which you load objects and acquire
                                locks might not matter. An option is to perform an optimistic check on an item
                                after you acquire the Pessimistic Offline Lock. You should be very sure that you
                                have the latest version of an object after youâ€™ve locked it, which usually translates to acquiring the lock before loading the data.
                                Now, what are we locking? It seems that weâ€™re locking objects or records or
                                just about anything, but what we usually lock is actually the ID, or primary key,
                                that we use to find those objects. This allows us to obtain the lock before we
                                load them. Locking the object works fine so long as it doesnâ€™t force you to
                                break the rule about an objectâ€™s being current after you acquire its lock.
                                The simplest rule for releasing locks is to do it when the business transaction
                                completes. Releasing a lock prior to completion might be allowable, depending
                                on your lock type and your intention to use that object again within the transaction. Still, unless you have a very specific reason to release early, such as a
                                particularly nasty system liveliness issue, stick to doing it upon completion of
                                the business transaction.</p>
                <p>The easiest course of action for a business transaction that canâ€™t acquire a
                                lock is to abort. The user should find this acceptable since Pessimistic Offline
                                Lock should result in failure rather early in the transaction. The developer and
                                designer can certainly help the situation by not waiting until late in the transaction to acquire a particularly contentious lock. If at all possible acquire all of
                                your locks before the user begins work.
                                For any given item that you intend to lock, access to the lock table must be
                                serialized. With an in-memory lock table itâ€™s easiest to serialize access to the
                                entire lock manager with whatever constructs your programming language provides. If you need concurrency greater than this affords, be aware you are entering complex territory.
                                If the lock table is stored in a database the first rule, of course, is to interact
                                with it within a system transaction. Take full advantage of the serialization
                                capabilities that a database provides. With the exclusive read and exclusive
                                write locks serialization is a simple matter of having the database enforce a
                                uniqueness constraint on the column storing the lockable itemâ€™s ID. Storing
                                read/write locks in a database makes things a bit more difficult since the logic
                                requires reads of the lock table in addition to inserts and so it becomes imperative to avoid inconsistent reads. A system transaction with an isolation level of
                                serializable provides ultimate safety as it guarantees no inconsistent reads.
                                Using serializable transactions throughout our system might get us into performance trouble, but a separate serializable system transaction for lock acquisition and a less strict isolation level for other work might ease this problem.
                                Another option is to investigate whether a stored procedure might help with
                                lock management. Concurrency management can be tough, so donâ€™t be afraid
                                to defer to your database at key moments.</p>
                <p>The serial nature of lock management screams performance bottleneck. A
                                big consideration here is lock granularity, as the fewer locks required the less of
                                a bottleneck youâ€™ll have. A Coarse-Grained Lock (438) can address lock table
                                contention.
                                With a system transaction pessimistic locking scheme, such as â€œSELECT
                                FOR UPDATE...â€ or entity EJBs, deadlock is a distinct possibility because these
                                locking mechanisms will wait until a lock becomes available. Think of deadlock
                                this way. Two users need resources A and B. If one gets the lock on A and the
                                other gets the lock on B, both transactions might sit and wait forever for the
                                other lock. Given that weâ€™re spanning multiple system transactions, waiting for
                                a lock doesnâ€™t make much sense, especially since a business transaction might
                                take 20 minutes. Nobody wants to wait for those locks. And this is good
                                because coding for a wait involves timeouts and quickly gets complicated. Simply have your lock manager throw an exception as soon as a lock is unavailable. This removes the burden of coping with deadlock.
                                A final requirement is managing lock timeouts for lost sessions. If a client
                                machine crashes in the middle of a transaction that lost transaction is unable to
                                complete and release any owned locks. This is a big deal for a Web application
                                where sessions are regularly abandoned by users. Ideally youâ€™ll have a timeout
                                mechanism managed by your application server rather than make your application handle timeouts. Web application servers provide an HTTP session for this.
                                Timeouts can be implemented by registering a utility object that releases all locks
                                when the HTTP session becomes invalid. Another option is to associate a timestamp with each lock and consider invalid any lock older than a certain age.</p>
                <h3 id="431">When to Use It</h3>
                <p>Pessimistic Offline Lock is appropriate when the chance of conflict between
                                concurrent sessions is high. A user should never have to throw away work.
                                Locking is also appropriate when the cost of a conflict is too high regardless of
                                its likelihood. Locking every entity in a system will almost surely create tremendous data contention problems, so remember that Pessimistic Offline Lock is
                                very complementary to Optimistic Offline Lock (416) and only use Pessimistic
                                Offline Lock where itâ€™s truly required.
                                If you have to use Pessimistic Offline Lock, you should also consider a long
                                transaction. Long transactions are never a good thing, but in some situations
                                they may be no more damaging than Pessimistic Offline Lock and much easier
                                to program. Do some load testing before you choose.</p>
                <p>Donâ€™t use these techniques if your business transactions fit within a single
                                system transaction. Many system transaction pessimistic locking techniques
                                ship with the application and database servers youâ€™re already using, among
                                them the â€œSELECT FOR UPDATEâ€ SQL statement for database locking and
                                the entity EJB for application server locking. Why worry about timeouts, lock
                                visibility, and such, when thereâ€™s no need to? Understanding these locking types
                                can certainly add a lot of value to your implementation of Pessimistic Offline
                                Lock. Understand, though, that the inverse isnâ€™t true! What you read here
                                wonâ€™t prepare you to write a database manager or transaction monitor. All the
                                offline locking techniques presented in this book depend on your system having
                                a real transaction monitor of its own.</p>
                <h3 id="431(2)">Example: Simple Lock Manager (Java)</h3>
                <p>In this example weâ€™ll first build a lock manager for exclusive read locksâ€”
                                remember that you need these locks to read or edit an object. Then weâ€™ll demonstrate how the lock manager might be used for a business transaction that
                                spans multiple system transactions.
                                The first step is to define our lock manager interface.
                                <pre>interface ExclusiveReadLockManager...
                                public static final ExclusiveReadLockManager INSTANCE =
                                (ExclusiveReadLockManager) Plugins.getPlugin(ExclusiveReadLockManager.class);
                                public void acquireLock(Long lockable, String owner) throws ConcurrencyException;
                                public void releaseLock(Long lockable, String owner);
                                public void relaseAllLocks(String owner);</pre>
                                Notice that weâ€™re identifying lockable with a long and owner with a string. Lockable
                                is a long because each table in our database uses a long primary key thatâ€™s
                                unique across the entire system and so serves as a nice lockable ID (which must
                                be unique across all types handled by the lock table). The owner ID is a string
                                because the example will be a Web application, and the HTTP session ID makes
                                a good lock owner within it.
                                Weâ€™ll write a lock manager that interacts directly with a lock table in our
                                database rather than with a lock object. Note that this is our own table called
                                lock, like any other application table, and not part of the databaseâ€™s internal
                                locking mechanism. Acquiring a lock is a matter of successfully inserting a row
                                into the lock table. Releasing it is a matter of deleting that row. Hereâ€™s the
                                schema for the lock table and part of the lock manager implementation:
                                <pre>table lock...
                                create table lock(lockableid bigint primary key, ownerid varchar)
                                class ExclusiveReadLockManagerDBImpl implements ExclusiveReadLockManager...
                                private static final String INSERT_SQL =
                                "insert into lock values(?, ?)";
                                private static final String DELETE_SINGLE_SQL =
                                "delete from lock where lockableid = ? and ownerid = ?";
                                private static final String DELETE_ALL_SQL =
                                "delete from lock where ownerid = ?";
                                private static final String CHECK_SQL =
                                "select lockableid from lock where lockableid = ? and ownerid = ?";
                                public void acquireLock(Long lockable, String owner) throws ConcurrencyException {
                                if (!hasLock(lockable, owner)) {
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(INSERT_SQL);
                                pstmt.setLong(1, lockable.longValue());
                                pstmt.setString(2, owner);
                                pstmt.executeUpdate();
                                } catch (SQLException sqlEx) {
                                throw new ConcurrencyException("unable to lock " + lockable);
                                } finally {
                                closeDBResources(conn, pstmt);
                                }
                                }
                                }
                                public void releaseLock(Long lockable, String owner) {
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(DELETE_SINGLE_SQL);
                                pstmt.setLong(1, lockable.longValue());
                                pstmt.setString(2, owner);
                                pstmt.executeUpdate();
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected error releasing lock on " + lockable);
                                } finally {
                                closeDBResources(conn, pstmt);
                                }
                                }</pre>
                                Not shown in the lock manager are the public releaseAllLocks() and the private
                                hasLock() methods. releaseAllLocks() does exactly as its name implies and releases
                                all locks for an owner. hasLock() queries the database to check if an owner
                                already owns a lock. Itâ€™s not uncommon for session code to attempt to acquire a
                                lock it already owns. This means that acquireLock() must first check that the
                                owner doesnâ€™t already have the lock before attempting to insert the lock row. As
                                the lock table is usually a point of resource contention, these repetitive reads can
                                degrade application performance. It may be necessary for you to cache owned
                                locks at the session level for the ownership checks. Be careful doing this.
                                Now letâ€™s put together a simple Web application to maintain customer
                                records. First weâ€™ll set up a bit of infrastructure to facilitate business transaction
                                processing. Some concept of a user session will be required by the layers
                                beneath the Web tier, so we wonâ€™t be able to rely solely on the HTTP session.
                                Letâ€™s refer to this new session as the application session to distinguish it from
                                the HTTP session. Application sessions will store their ID, a user name, and an
                                Identity Map (195) to cache objects loaded or created during the business transaction. Theyâ€™ll be associated with the currently executing thread in order that
                                they be found.
                                <pre>class AppSession...
                                private String user;
                                private String id;
                                private IdentityMap imap;
                                public AppSession(String user, String id, IdentityMap imap) {
                                this.user = user;
                                this.imap = imap;
                                this.id = id;
                                }
                                class AppSessionManager...
                                private static ThreadLocal current = new ThreadLocal();
                                public static AppSession getSession() {
                                return (AppSession) current.get();
                                }
                                public static void setSession(AppSession session) {
                                current.set(session);
                                }</pre>
                                Weâ€™re going to use a Front Controller (344) to handle requests, so weâ€™ll need
                                to define a command. The first thing each command must do is indicate its
                                intention to either start a new business transaction or continue one that already
                                exists. This is a matter of setting up a new application session or finding the
                                current one. Here we have an abstract command that provides convenience
                                methods for establishing business transaction context.
                                <pre>interface Command...
                                public void init(HttpServletRequest req, HttpServletResponse rsp);
                                public void process() throws Exception;
                                abstract class BusinessTransactionCommand implements Command...
                                public void init(HttpServletRequest req, HttpServletResponse rsp) {
                                this.req = req;
                                this.rsp = rsp;
                                }
                                protected void startNewBusinessTransaction() {
                                HttpSession httpSession = getReq().getSession(true);
                                AppSession appSession = (AppSession) httpSession.getAttribute(APP_SESSION);
                                if (appSession != null) {
                                ExclusiveReadLockManager.INSTANCE.relaseAllLocks(appSession.getId());
                                }
                                appSession = new AppSession(getReq().getRemoteUser(),
                                httpSession.getId(), new IdentityMap());
                                AppSessionManager.setSession(appSession);
                                httpSession.setAttribute(APP_SESSION, appSession);
                                httpSession.setAttribute(LOCK_REMOVER,
                                new LockRemover(appSession.getId()));
                                }
                                protected void continueBusinessTransaction() {
                                HttpSession httpSession = getReq().getSession();
                                AppSession appSession = (AppSession) httpSession.getAttribute(APP_SESSION);
                                AppSessionManager.setSession(appSession);
                                }
                                protected HttpServletRequest getReq() {
                                return req;
                                }
                                protected HttpServletResponse getRsp() {
                                return rsp;
                                }</pre>
                                Notice that when we establish a new application session we remove locks for
                                any existing one. We also add a listener to the HTTP sessionâ€™s binding events
                                that will remove any locks owned by an application session when the corresponding HTTP session expires.
                                <pre>class LockRemover implements HttpSessionBindingListener...
                                private String sessionId;
                                public LockRemover(String sessionId) {
                                this.sessionId = sessionId;
                                }
                                public void valueUnbound(HttpSessionBindingEvent event) {
                                try {
                                beginSystemTransaction();
                                ExclusiveReadLockManager.INSTANCE.relaseAllLocks(this.sessionId);
                                commitSystemTransaction();
                                } catch (Exception e) {
                                handleSeriousError(e);
                                }
                                }</pre>
                                Our commands contain both standard business logic and lock management,
                                and each command must execute within the bounds of a single system transaction. To ensure this we can decorate [Gang of Four] it with a transactional command object. Be sure that all locking and standard domain business for a single
                                request occur within a single system transaction. The methods that define system transaction boundaries depend on your deployment context. Itâ€™s mandatory to roll back the system transaction when a concurrency exception, and any
                                other exception in this case, is detected, as that will prevent any changes from
                                entering the permanent record data when a conflict occurs.
                                <pre>class TransactionalComamnd implements Command...
                                public TransactionalCommand(Command impl) {
                                this.impl = impl;
                                }
                                public void process() throws Exception {
                                beginSystemTransaction();
                                try {
                                impl.process();
                                commitSystemTransaction();
                                } catch (Exception e) {
                                rollbackSystemTransaction();
                                throw e;
                                }
                                }</pre>
                                Now itâ€™s a matter of writing the controller servlet and concrete commands.
                                The controller servlet has the responsibility of wrapping each command with
                                transaction control. The concrete commands are required to establish business
                                transaction context, execute domain logic, and acquire and release locks where
                                appropriate.
                                <pre>class ControllerServlet extends HttpServlet...
                                protected void doGet(HttpServletRequest req, HttpServletResponse rsp)
                                throws ServletException, IOException {
                                try {
                                String cmdName = req.getParameter("command");
                                Command cmd = getCommand(cmdName);
                                cmd.init(req, rsp);
                                cmd.process();
                                } catch (Exception e) {
                                writeException(e, rsp.getWriter());
                                }
                                }
                                private Command getCommand(String name) {
                                try {
                                String className = (String) commands.get(name);
                                Command cmd = (Command) Class.forName(className).newInstance();
                                return new TransactionalCommand(cmd);
                                } catch (Exception e) {
                                e.printStackTrace();
                                throw new SystemException("unable to create command object for " + name);
                                }
                                }
                                class EditCustomerCommand implements Command...
                                public void process() throws Exception {
                                startNewBusinessTransaction();
                                Long customerId = new Long(getReq().getParameter("customer_id"));
                                ExclusiveReadLockManager.INSTANCE.acquireLock(
                                customerId, AppSessionManager.getSession().getId());
                                Mapper customerMapper = MapperRegistry.INSTANCE.getMapper(Customer.class);
                                Customer customer = (Customer) customerMapper.find(customerId);
                                getReq().getSession().setAttribute("customer", customer);
                                forward("/editCustomer.jsp");
                                }
                                class SaveCustomerCommand implements Command...
                                public void process() throws Exception {
                                continueBusinessTransaction();
                                Customer customer = (Customer) getReq().getSession().getAttribute("customer");
                                String name = getReq().getParameter("customerName");
                                customer.setName(name);
                                Mapper customerMapper = MapperRegistry.INSTANCE.getMapper(Customer.class);
                                customerMapper.update(customer);
                                ExclusiveReadLockManager.INSTANCE.releaseLock(customer.getId(),
                                AppSessionManager.getSession().getId());
                                forward("/customerSaved.jsp");
                                }</pre>
                                The commands just shown will prevent any two sessions from working with
                                the same customer at the same time. Any other command in the application
                                that works with a customer object must be sure either to acquire the lock or to
                                work only with a customer locked by a previous command in the same business
                                transaction. Given that we have a hasLock() check in the lock manager we could
                                simply acquire the lock in every command. This might be bad for performance,
                                but it would certainly guarantee that we have a lock. Implicit Lock (449) discusses other foolproof approaches to locking mechanics.
                                The amount of framework code might seem a bit out of proportion to the
                                amount of domain code. Indeed, Pessimistic Offline Lock requires at a minimum choreographing an application session, a business transaction, a lock
                                manager, and a system transaction, which is clearly a challenge. This example
                                serves more as an inspiration than as an architecture template, as it lacks
                                robustness in many areas.</p>
                <h3 id="438">Coarse-Grained Lock</h3>
                <p><img src="img/part2.37.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Locks a set of related objects with a single lock.
                                Objects can often be edited as a group. Perhaps you have a customer and its set
                                of addresses. If so, when using the application it makes sense to lock all of these
                                items if you want to lock any one of them. Having a separate lock for individual objects presents a number of challenges. First, anyone manipulating them
                                has to write code that can find them all in order to lock them. This is easy
                                enough for a customer and its addresses, but it gets tricky as you get more locking groups. And what if the groups get complicated? Where is this behavior
                                when your framework is managing lock acquisition? If your locking strategy
                                requires that an object be loaded in order to be locked, such as with Optimistic
                                Offline Lock (416), locking a large group affects performance. And with Pessimistic Offline Lock (426) a large lock set is a management headache and
                                increases lock table contention.
                                A Coarse-Grained Lock is a single lock that covers many objects. It not only
                                simplifies the locking action itself but also frees you from having to load all the
                                members of a group in order to lock them.</p>
                <h3 id="438(2)">How It Works</h3>
                <p>The first step in implementing Coarse-Grained Lock is to create a single point
                                of contention for locking a group of objects. This makes only one lock necessary for locking the entire set. Then you provide the shortest path possible to
                                finding that single lock point in order to minimize the group members that must
                                be identified and possibly loaded into memory in the process of obtaining that
                                lock.
                                With Optimistic Offline Lock (416), having each item in a group share a version (see Figure 16.2) creates the single point of contention, which means sharing the same version, not an equal version. Incrementing this version will lock
                                the entire group with a shared lock. Set up your model to point every member
                                of the group at the shared version and you have certainly minimized the path to
                                the point of contention.
                                A shared Pessimistic Offline Lock (426) requires that each member of the
                                group share some sort of lockable token, on which it must then be acquired. As
                                Pessimistic Offline Lock (426) is often used as a complement to Optimistic
                                Offline Lock (416), a shared version object makes an excellent candidate for
                                the lockable token role (Figure 16.3).</p>
                <p>Eric Evans and David Siegel [Evans] define an aggregate as a cluster of associated objects that we treat as a unit for data changes. Each aggregate has a root
                                that provides the only access point to members of the set and a boundary that
                                defines whatâ€™s included in the set. The aggregateâ€™s characteristics call for a
                                Coarse-Grained Lock, since working with any of its members requires locking
                                all of them. Locking an aggregate yields an alternative to a shared lock that I
                                call a root lock (see Figure 16.4). By definition locking the root locks all members of the aggregate. The root lock gives us a single point of contention.
                                Using a root lock as a Coarse-Grained Lock makes it necessary to implement
                                navigation to the root in your object graph. This allows a locking mechanism,
                                when asked to lock any object in the aggregate,
                <p><img src="img/figure 16.2.png" alt="no img" style="margin-left: 200px;"></p>
                <p><img src="img/figure 16.3.png" alt="no img" style="margin-left: 200px;"></p>
                                it instead. This navigation can be accomplished in a couple of ways. You can
                                maintain a direct navigation to the root for each object in the aggregate, or you
                                can use a sequence of intermediate relationships. For example, in a hierarchy
                                the obvious root is the top level parent, to which you can link the descendents
                                directly. Alternatively, you can give each node a link to its immediate parent
                                and navigate that structure to reach the root. In a large graph the latter strategy
                                might cause performance problems as each parent must be loaded in order to
                                determine whether it has a parent of its own. Be sure to use a Lazy Load (200)
                                when loading the objects that make up the path to your root. This not only prevents
                <p><img src="img/figure 16.4.png" alt="no img" style="margin-left: 200px;"></p>
                                objects from being loaded before theyâ€™re needed but prevents an infinite
                                mapping loop when you map a bidirectional relationship. Be wary of the fact
                                that Lazy Loads (200) for a single aggregate can occur across multiple system
                                transactions and so you may end up with an aggregate built from inconsistent
                                parts. Of course, thatâ€™s not good.</p>
                <p>Note that a shared lock also works for aggregate locking as locking any
                                object in the aggregate will simultaneously lock the root.
                                The shared lock and root lock implementations of Coarse-Grained Lock
                                both have their trade-offs. When using a relational database the shared lock
                                carries the burden that almost all of your selects will require a join to the version table. But loading objects while navigating to the root can be a performance hit as well. The root lock and Pessimistic Offline Lock (426) perhaps
                                make an odd combination. By the time you navigate to the root and lock it you
                                may need to reload a few objects to guarantee their freshness. And, as always,
                                building a system against a legacy data store will place numerous constraints on
                                your implementation choice. Locking implementations abound, and the subtleties are even more numerous. Be sure to arrive at an implementation that suits
                                your needs.</p>
                <h3 id="441">When to Use It</h3>
                <p>The most obvious reason to use a Coarse-Grained Lock is to satisfy business
                                requirements. This is the case when locking an aggregate. Consider a lease
                                object that owns a collection of assets. It probably doesnâ€™t make business sense
                                for one user to edit the lease and another user to simultaneously edit an asset.
                                Locking either the asset or the lease ought to result in the lease and all of its
                                assets being locked.
                                A very positive outcome of using Coarse-Grained Locks is that acquiring
                                and releasing lock is cheaper. This is certainly a legitimate motivation for using
                                them. The shared lock can be used beyond the concept of the [Evans] aggregate,
                                but be careful when working from nonfunctional requirements such as performance. Beware of creating unnatural object relationships in order to facilitate
                                Coarse-Grained Lock.</p>
                <h3 id="441(2)">Example: Shared Optimistic Offline Lock (416) (Java)</h3>
                <p>For this example we have a domain model with Layer Supertype (475), a relational database as our persistent store, and Data Mappers (165).
                                The first thing to do is create a version class and table. To keep things simple
                                weâ€™ll create a rather versatile version class that will not only store its value but
                                442 OFFLINE CONCURRENCY PATTERNS
                                CoarseGrained
                                Lock
                                will also have a static finder method. Note that weâ€™re using an identity map to
                                cache versions for a session. If objects share a version itâ€™s critical that they all
                                point to the exact same instance of it. As the version class is a part of our
                                domain model itâ€™s probably poor form to put database code in there, so Iâ€™ll
                                leave separating version database code into the mapper layer as an exercise for
                                you.
                                <pre>table version...
                                create table version(id bigint primary key, value bigint,
                                modifiedBy varchar, modified datetime)
                                class Version...
                                private Long id;
                                private long value;
                                private String modifiedBy;
                                private Timestamp modified;
                                private boolean locked;
                                private boolean isNew;
                                private static final String UPDATE_SQL =
                                "UPDATE version SET VALUE = ?, modifiedBy = ?, modified = ? " +
                                "WHERE id = ? and value = ?";
                                private static final String DELETE_SQL =
                                "DELETE FROM version WHERE id = ? and value = ?";
                                private static final String INSERT_SQL =
                                "INSERT INTO version VALUES (?, ?, ?, ?)";
                                private static final String LOAD_SQL =
                                "SELECT id, value, modifiedBy, modified FROM version WHERE id = ?";
                                public static Version find(Long id) {
                                Version version = AppSessionManager.getSession().getIdentityMap().getVersion(id);
                                if (version == null) {
                                version = load(id);
                                }
                                return version;
                                }
                                private static Version load(Long id) {
                                ResultSet rs = null;
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                Version version = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(LOAD_SQL);
                                pstmt.setLong(1, id.longValue());
                                rs = pstmt.executeQuery();
                                if (rs.next()) {
                                long value = rs.getLong(2);
                                String modifiedBy = rs.getString(3);
                                Timestamp modified = rs.getTimestamp(4);
                                version = new Version(id, value, modifiedBy, modified);
                                AppSessionManager.getSession().getIdentityMap().putVersion(version);
                                } else {
                                throw new ConcurrencyException("version " + id + " not found.");
                                }
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected sql error loading version", sqlEx);
                                } finally {
                                cleanupDBResources(rs, conn, pstmt);
                                }
                                return version;
                                }</pre>
                                The version also knows how to create itself. The database insert is separated
                                from the creation to allow deferment of insertion until at least one owner is
                                inserted into the database. Each of our domain Data Mappers (165) can safely
                                call insert on the version when inserting the corresponding domain object. The
                                version tracks whether itâ€™s new to make sure it will only be inserted once.
                                <pre>class Version...
                                public static Version create() {
                                Version version = new Version(IdGenerator.INSTANCE.nextId(), 0,
                                AppSessionManager.getSession().getUser(), now());
                                version.isNew = true;
                                return version;
                                }
                                public void insert() {
                                if (isNew()) {
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(INSERT_SQL);
                                pstmt.setLong(1, this.getId().longValue());
                                pstmt.setLong(2, this.getValue());
                                pstmt.setString(3, this.getModifiedBy());
                                pstmt.setTimestamp(4, this.getModified());
                                pstmt.executeUpdate();
                                AppSessionManager.getSession().getIdentityMap().putVersion(this);
                                isNew = false;
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected sql error inserting version", sqlEx);
                                } finally {
                                cleanupDBResources(conn, pstmt);
                                }
                                }
                                }</pre>
                                Next, we have an increment() method that increases the value of the version in
                                the corresponding database row. Itâ€™s likely that multiple objects in a change set
                                will share the same version, so the version first makes sure itâ€™s not already
                                locked before incrementing itself. After calling the database, the increment()
                                method must check that the version row was indeed updated. If it returns a row
                                count of zero, it has detected a concurrency violation and throws an exception.
                                <pre>class Version...
                                public void increment() throws ConcurrencyException {
                                if (!isLocked()) {
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(UPDATE_SQL);
                                pstmt.setLong(1, value + 1);
                                pstmt.setString(2, getModifiedBy());
                                pstmt.setTimestamp(3, getModified());
                                pstmt.setLong(4, id.longValue());
                                pstmt.setLong(5, value);
                                int rowCount = pstmt.executeUpdate();
                                if (rowCount == 0) {
                                throwConcurrencyException();
                                }
                                value++;
                                locked = true;
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected sql error incrementing version", sqlEx);
                                } finally {
                                cleanupDBResources(conn, pstmt);
                                }
                                }
                                }
                                private void throwConcurrencyException() {
                                Version currentVersion = load(this.getId());
                                throw new ConcurrencyException(
                                "version modified by " + currentVersion.modifiedBy + " at " +
                                DateFormat.getDateTimeInstance().format(currentVersion.getModified()));
                                }</pre>
                                With the code here be sure to invoke increment only in the system transaction
                                in which you commit the business transaction. The isLocked flag makes it so that
                                incrementing in earlier transactions will result in false lock acquisition during
                                the commit transaction. This isnâ€™t a problem because the whole point of an
                                optimistic lock is that you only get the lock when you commit.
                                When you use this pattern you may want to see if your data is still current
                                with the database in an earlier system transaction. You can do this by adding a
                                checkCurrent method to the version class that simply checks if an Optimistic
                                Offline Lock (416) is available without updating.</p>
                <p>Not shown is a delete method that executes the SQL to remove the version
                                from the database. If the returned row count is zero, a concurrency exception is
                                thrown. Coarse Grained Lock. This is because the Optimistic Offline Lock (416) probably wasnâ€™t
                                obtained when deleting the last of the objects using this version. That should
                                never happen. The real trick is knowing when itâ€™s okay to delete a shared version. If youâ€™re sharing a version across an aggregate, simply delete it after you
                                delete the aggregate root. Other scenarios make things much more problematic.
                                One possibility is for the version object to keep a reference count of its owners
                                and delete itself when the count reaches zero. Be warned that this could make
                                for a version object thatâ€™s rather sophisticated. Once your version gets complicated you might consider making it a full-blown domain object. This makes
                                good sense, but, of course, it will be a special domain object without a version.
                                Now letâ€™s look at how we use the shared version. The domain Layer Supertype (475) contains a version object rather than a simple count. Each Data
                                Mapper (165) can set the version when loading the domain object.
                                <pre>class DomainObject...
                                private Long id;;
                                private Timestamp modified;
                                private String modifiedBy;
                                private Version version;
                                public void setSystemFields(Version version, Timestamp modified, String modifiedBy) {
                                this.version = version;
                                this.modified = modified;
                                this.modifiedBy = modifiedBy;
                                }</pre>
                                For creation, letâ€™s look at an aggregate consisting of a customer root and its
                                addresses. The customerâ€™s create method will create the shared version. Customer will have an addAddress() method that creates an address, passing along
                                the customerâ€™s version. Our abstract database mapper will insert the version
                                before it inserts corresponding domain objects. Remember that the version will
                                ensure that itâ€™s only inserted once.
                                <pre>class Customer extends DomainObject...
                                public static Customer create(String name) {
                                return new Customer(IdGenerator.INSTANCE.nextId(), Version.create(),
                                name, new ArrayList());
                                }
                                class Customer extends DomainObject...
                                public Address addAddress(String line1, String city, String state) {
                                Address address = Address.create(this, getVersion(), line1, city, state);
                                addresses.add(address);
                                return address;
                                }
                                class Address extends DomainObject...
                                public static Address create(Customer customer, Version version,
                                String line1, String city, String state) {
                                return new Address(IdGenerator.INSTANCE.nextId(), version, customer,
                                line1, city, state);
                                }
                                class AbstractMapper...
                                public void insert(DomainObject object) {
                                object.getVersion().insert();
                                Increment should be called on a version by the Data Mapper (165) before it
                                updates or deletes an object.
                                class AbstractMapper...
                                public void update(DomainObject object) {
                                object.getVersion().increment();
                                class AbstractMapper...
                                public void delete(DomainObject object) {
                                object.getVersion().increment();
                                As this is an aggregate, we delete the addresses when we delete the customer.
                                This allows us to delete the version immediately after that.
                                class CustomerMapper extends AbstractMapper...
                                public void delete(DomainObject object) {
                                Customer cust = (Customer) object;
                                for (Iterator iterator = cust.getAddresses().iterator(); iterator.hasNext();) {
                                Address add = (Address) iterator.next();
                                MapperRegistry.getMapper(Address.class).delete(add);
                                }
                                super.delete(object);
                                cust.getVersion().delete();
                                }</pre></p>
                <h3 id="446">Example: Shared Pessimistic Offline Lock (426) (Java)</h3>
                <p>We need some sort of lockable token that we can associate with all objects in
                                the related set. As discussed above weâ€™ll use Pessimistic Offline Lock (426) as a
                                complement to Optimistic Offline Lock (416) so we can use as the lockable
                                token the shared version. Weâ€™ll use all of the same code to arrive at a shared
                                version.
                                The only issue is that some of our data must be loaded in order to get the
                                version. If we acquire the Pessimistic Offline Lock (426) after loading its data,
                                how do we know that the data is current? Something we can easily do is increment the version within the system transaction where we obtained the Pessimistic Offline Lock (426). Once that system transaction commits, our pessimistic
                                lock is valid and we know that we have the latest copy of any data sharing that
                                version, regardless of where we loaded within the system transaction.
                                <pre>class LoadCustomerCommand...
                                try {
                                Customer customer = (Customer) MapperRegistry.getMapper(Customer.class).find(id);
                                ExclusiveReadLockManager.INSTANCE.acquireLock
                                (customer.getId(), AppSessionManager.getSession().getId());
                                customer.getVersion().increment();
                                TransactionManager.INSTANCE.commit();
                                } catch (Exception e) {
                                TransactionManager.INSTANCE.rollback();
                                throw e;
                                }</pre>
                                You can see that the version increment might be something that you would
                                want to build into your lock manager. At least you want to decorate [Gang of
                                Four] your lock manager with code that increments the version. Your production code will, of course, require more robust exception handling and transaction control than the example shows.</p>
                <h3 id="447">Example: Root Optimistic Offline Lock (416) (Java)</h3>
                <p>This example makes most of the same assumptions as the previous examples,
                                including a domain Layer Supertype (475) and Data Mappers (165). Thereâ€™s a
                                version object, but in this case it wonâ€™t be shared. It simply provides a convenient increment() method to more easily allow acquisition of the Optimistic
                                Offline Lock (416) outside of the Data Mapper (165). Weâ€™re also using a Unit
                                of Work (184) to track our change set.
                                Our aggregate contains parent-child relationships, so weâ€™ll use child-toparent navigation to find the root. Weâ€™ll need to accommodate this in our
                                domain and data models.
                                <pre>class DomainObject...
                                private Long id;
                                private DomainObject parent;
                                public DomainObject(Long id, DomainObject parent) {
                                this.id = id;
                                this.parent = parent;
                                }
                                Once we have our owners we can acquire our root locks before we commit
                                the Unit of Work.
                                class UnitOfWork...
                                public void commit() throws SQLException {
                                for (Iterator iterator = _modifiedObjects.iterator(); iterator.hasNext();) {
                                DomainObject object = (DomainObject) iterator.next();
                                for (DomainObject owner = object; owner != null; owner = owner.getParent()) {
                                owner.getVersion().increment();
                                }
                                }
                                for (Iterator iterator = _modifiedObjects.iterator(); iterator.hasNext();) {
                                DomainObject object = (DomainObject) iterator.next();
                                Mapper mapper = MapperRegistry.getMapper(object.getClass());
                                mapper.update(object);
                                }
                                }</pre></p>
                <h3 id="449">Implicit Lock</h3>
                <p><img src="img/part2.38.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Allows framework or layer supertype code to acquire offline locks.
                                The key to any locking scheme is that there are no gaps in its use. Forgetting to
                                write a single line of code that acquires a lock can render an entire offline locking scheme useless. Failing to retrieve a read lock where other transactions use
                                write locks means you might not get up-to-date session data; failing to use a
                                version count properly can result in unknowingly writing over someoneâ€™s
                                changes. Generally, if an item might be locked anywhere it must be locked
                                everywhere. Ignoring its applicationâ€™s locking strategy allows a business transaction to create inconsistent data. Not releasing locks wonâ€™t corrupt your
                                record data, but it will eventually bring productivity to a halt. Because offline
                                concurrency management is difficult to test, such errors might go undetected by
                                all of your test suites.
                                One solution is to not allow developers to make such a mistake. Locking
                                tasks that cannot be overlooked should be handled not explicitly by developers
                                but implicitly by the application. The fact that most enterprise applications
                                make use of some combination of framework, Layer Supertypes (475), and
                                code generation provides us with ample opportunity to facilitate Implicit Lock.</p>
                <h3 id="450">How It Works</h3>
                <p>Implementing Implicit Lock is a matter of factoring your code such that any
                                locking mechanics that absolutely cannot be skipped can be carried out by your
                                application framework. For lack of a better word weâ€™ll use â€œframeworkâ€ to
                                mean a combination of Layer Supertypes (475), framework classes, and any
                                other â€œplumbingâ€ code. Code generation tools are another avenue to enforce
                                proper locking. I realize this is by no means a ground-breaking idea. Youâ€™re
                                very likely to head down this path once youâ€™ve coded the same locking mechanics a few times over in your application. Still, Iâ€™ve seen it done poorly often
                                enough that it merits a quick look.
                                The first step is to assemble a list of what tasks are mandatory for a business
                                transaction to work within your locking strategy. For Optimistic Offline Lock
                                (416) that list will contain items such as storing a version count for each
                                record, including the version in update SQL criteria, and storing an incremented version when changing the record. The Pessimistic Offline Lock (426)
                                list will include items along the lines of acquiring any lock necessary to load a
                                piece of dataâ€”typically the exclusive read lock or the read portion of the read/
                                write lockâ€”and releasing all locks when the business transaction or session
                                completes.</p>
                <p>Note that the Pessimistic Offline Lock (426) list doesnâ€™t include acquiring
                                any lock necessary only for editing a piece of dataâ€”that is, exclusive write
                                lock and the write portion of the read/write lock. Yes, these are mandatory if
                                your business transaction wants to edit the data, but implicitly acquiring them
                                presents, should the locks be unavailable, a couple of difficulties. First, the
                                only points where we might implicitly acquire a write lock, such as the registration of a dirty object within a Unit of Work (184), offer us no promise
                                should the locks be unavailable, that the transaction will abort as soon as the
                                user begins to work. The application canâ€™t figure out on its own when is a
                                good time to acquire these locks. A transaction not failing rapidly conflicts
                                with an intent of Pessimistic Offline Lock (426)â€”that a user not have to perform work twice.
                                Second, and just as important, is that these lock types most greatly limit system concurrency. Avoiding Implicit Lock here helps us think about how we
                                impact concurrency by forcing the issue out of the technical arena and into the
                                business domain. Still we have to make sure that locks necessary for writing are
                                acquired before changes are committed. What your framework can do is ensure
                                that a write lock has already been obtained before committing any changes.</p>
                <p>Not having acquired the lock by commit time is a programmer error and the
                                code should at least throw an assertion failure. I advise skipping the assertion
                                and throwing a concurrency exception here, as you really donâ€™t want any such
                                errors in your production system when assertions are turned off.
                                A word of caution about using the Implicit Lock. While it allows developers
                                to ignore much of the locking mechanics it doesnâ€™t allow them to ignore consequences. For example, if developers are using Implicit Lock with a pessimistic
                                locking scheme that waits for locks, they still need to think about deadlock possibilities. The danger with Implicit Lock is that business transactions can fail in
                                unexpected ways once developers stop thinking about locking.
                                Making locking work is a matter of determining the best way to get your
                                framework to implicitly carry out the locking mechanics. See Optimistic Offline
                                Lock (416) for samples of implicit handling of that lock type. The possibilities
                                for a quality Implicit Lock implementation are far too numerous to demonstrate them all here.</p>
                <h3 id="451">When to Use It</h3>
                <p>Implicit Lock should be used in all but the simplest of applications that have no
                                concept of framework. The risk of a single forgotten lock is too great.</p>
                <h3 id="451(2)">Example: Implicit Pessimistic Offline Lock (426) (Java)</h3>
                <p>Letâ€™s consider a system that uses an exclusive read lock. Our architecture contains a Domain Model (116), and weâ€™re using Data Mappers (165) to mediate
                                between our domain objects and our relational database. With the exclusive
                                read lock the framework must acquire a lock on a domain object before allowing a business transaction to do anything with it.
                                Any domain object used in a business transaction is located via the find()
                                method on a mapper. This is true whether the business transaction uses the
                                mapper directly by invoking find() or indirectly by navigating the object graph.
                                Now itâ€™s possible for us to decorate [Gang of Four] our mappers with required
                                locking functionality. Weâ€™ll write a locking mapper that acquires a lock before
                                attempting to find an object.
                                <pre>interface Mapper...
                                public DomainObject find(Long id);
                                public void insert(DomainObject obj);
                                public void update(DomainObject obj);
                                public void delete(DomainObject obj);
                                452 OFFLINE CONCURRENCY PATTERNS
                                Implicit Lock
                                class LockingMapper implements Mapper...
                                private Mapper impl;
                                public LockingMapper(Mapper impl) {
                                this.impl = impl;
                                }
                                public DomainObject find(Long id) {
                                ExclusiveReadLockManager.INSTANCE.acquireLock(
                                id, AppSessionManager.getSession().getId());
                                return impl.find(id);
                                }
                                public void insert(DomainObject obj) {
                                impl.insert(obj);
                                }
                                public void update(DomainObject obj) {
                                impl.update(obj);
                                }
                                public void delete(DomainObject obj) {
                                impl.delete(obj);
                                }</pre>
                                Because itâ€™s quite common to look up an object more than once in a session,
                                for the above code to work the lock manager must first check that the session
                                doesnâ€™t already have a lock before it obtains one. If we were using an exclusive
                                write lock rather than the exclusive read lock weâ€™d write a mapper decorator
                                that checked for previous lock acquisition on update and delete rather than
                                actually acquiring a lock.
                                One of the nice things about decorators is that the object being wrapped
                                doesnâ€™t even know that itâ€™s functionality is being enhanced. Here we can wrap
                                the mappers in our registry:
                                <pre>LockingMapperRegistry implements MappingRegistry...
                                private Map mappers = new HashMap();
                                public void registerMapper(Class cls, Mapper mapper) {
                                mappers.put(cls, new LockingMapper(mapper));
                                }
                                public Mapper getMapper(Class cls) {
                                return (Mapper) mappers.get(cls);
                                }</pre>
                                When the business transaction gets its hands on a mapper it thinks that itâ€™s
                                about to invoke a standard update method, but what really happens is shown in</p>
                <p><img src="img/figure 16.5.png" alt="no img" style="margin-left: 200px;"></p>
                <h3 id="455">Chapter 17</h3>
                <h2>Session State Patterns</h2>
                <h3 id="456">Client Session State</h3>
                <h3 id="456(2)">How It Works</h3>
                <p>Even the most server-oriented designs need at least a little Client Session State,
                                if only to hold a session identifier. With some applications you can consider putting all of the session data on the client, in which case the client sends the full
                                set of session data with each request and the server sends back the full session
                                state with each response. This allows the server to be completely stateless.
                                Most of the time youâ€™ll want to use Data Transfer Object (401) to handle the
                                data transfer. The Data Transfer Object (401) can serialize itself over the wire
                                and thus allow even complex data to be transmitted.
                                The client also needs to store the data. If itâ€™s a rich-client application it can
                                do this within its own structures, such as the fields in its interfaceâ€”although I
                                would drink Budweiser rather than do that. A set of nonvisual objects often
                                makes a better bet, such as the Data Transfer Object (401) itself or a domain
                                model. Either way itâ€™s not usually a big problem.
                                With an HTML interface, things get a bit more complicated. There are three
                                common ways to do client session state: URL parameters, hidden fields, and
                                cookies.</p>
                <p>URL parameters are the easiest to work with for a small amount of data.
                                Essentially all URLs on any response page take the session state as a parameter.
                                The clear limit to doing this is that the size of an URL is limited, but if you only
                                have a couple of data items it works well, thatâ€™s why itâ€™s a popular choice for
                                something like a session ID. Some platforms will do automatic URL rewriting
                                to add a session ID. Changing the URL may be a problem with bookmarks, so
                                thatâ€™s an argument against using URL parameters for consumer sites.
                                A hidden field is a field sent to the browser that isnâ€™t displayed on the Web
                                page. You get it with a tag of the form <INPUT type = â€œhiddenâ€>. To make a hidden
                                field work you serialize your session state into it when you make a response and
                                read it back in on each request. Youâ€™ll need a format for putting the data in the
                                hidden field. XML is an obvious standard choice, but of course itâ€™s rather
                                wordy. You can also encode the data in some text-based encoding scheme.
                                Remember that a hidden field is only hidden from the displayed page; anyone
                                can look at the data by looking at the page source.
                                Beware a mixed site that has older or fixed Web pages. You can lose all the
                                session data if you navigate to them.</p>
                <p>The last, and sometimes controversial, choice is cookies, which are sent back
                                and forth automatically. Just like a hidden field you can use a cookie by serializing the session state into it. Youâ€™re limited in how big the cookie can be. Also,
                                many people donâ€™t like cookies and turn them off. If they do that, your site will
                                stop working. However, more and more sites are dependent on cookies now, so
                                that will happen less often, and certainly isnâ€™t a problem for a purely in-house
                                system.
                                Realize that cookies are no more secure than anything else, so assume that
                                prying of all kinds can happen. Cookies also work only within a single domain
                                name, so if your site is separated into different domain names the cookies wonâ€™t
                                travel between them.
                                Some platforms can detect whether cookies are enabled; and if not, they can
                                use URL rewriting. This can make client session state very easy for very small
                                amounts of data.</p>
                <h3 id="457">When to Use It</h3>
                <p>Client Session State contains a number of advantages. In particular, it reacts
                                well in supporting stateless server objects with maximal clustering and failover
                                resiliency. Of course, if the client fails all is lost, but often the user expects that
                                anyway.
                                The arguments against Client Session State vary exponentially with the
                                amount of data involved. With just a few fields everything works nicely. With
                                large amounts of data the issues of where to store the data and the time cost of
                                transferring everything with every request become prohibitive. This is especially
                                true if your stars include an http client.
                                Thereâ€™s also the security issue. Any data sent to the client is vulnerable to
                                being looked at and altered. Encryption is the only way to stop this, but
                                encrypting and decrypting with each request are a performance burden. Without encryption you have to be sure you arenâ€™t sending anything you would
                                rather hide from prying eyes. Fingers can pry too, so donâ€™t assume that what
                                got sent out is the same as what gets sent back. Any data coming back will need
                                to be completely revalidated.
                                You almost always have to use Client Session State for session identification.
                                Fortunately, this should be just one number, which wonâ€™t burden any of the
                                above schemes. You should still be concerned about session stealing, which is
                                what happens when a malicious user changes his session ID to see if he can snag
                                someone elseâ€™s session. Most platforms come up with a random session ID to
                                reduce this risk; if not, run a simple session ID through a hash.</p>
                <h3 id="458">Server Session State</h3>
                <p>Keeps the session state on a server system in a serialized form.</p>
                <h3 id="458(2)">How It Works</h3>
                <p>In the simplest form of this pattern a session object is held in memory on an
                                application server. You can have some kind of map in memory that holds these
                                session objects keyed by a session ID; all the client needs to do is to give the session ID and the session object can be retrieved from the map to process the
                                request.
                                This basic scenario assumes, of course, that the application server carries
                                enough memory to perform this task. It also assumes that thereâ€™s only one
                                application serverâ€”that is, no clusteringâ€”and that, if the application server
                                fails, itâ€™s appropriate for the session to be abandoned and all work done so far
                                to be lost in the great bit-bucket in the sky.
                                For many applications this set of assumptions is actually not a problem.
                                However, for others it may be problematic. There are ways of dealing with
                                cases where the assumptions are no longer valid, and these introduce common
                                variations that add complexity to an essentially simple pattern.
                                The first issue is that of dealing with memory resources held by the session
                                objects. Indeed, this is the common objection to Server Session State. The
                                answer, of course, is not to keep resources in memory but instead serialize all
                                the session state to a memento [Gang of Four] for persistent storage. This presents two questions: In what form do you persist the Server Session State, and
                                where do you persist it?</p>
                <p>The form to use is usually as simple a form as possible, since the accent of
                                Server Session State is its simplicity in programming. Several platforms provide
                                a simple binary serialization mechanism that allows you to serialize a graph of
                                objects quite easily. Another route is to serialize into another form, such as
                                textâ€”fashionably as an XML file.
                                The binary form is usually easier, since it requires little programming, while
                                the textual form usually requires at least a little code. Binary serializations also
                                require less disk space; although total disk space is rarely a concern, large serialized graphs will take longer to activate into memory.
                                There are two common issues with binary serialization. First, the serialized
                                form is not human readableâ€”which is a problem if humans want to read it.
                                Second, there may be problems with versioning. If you modify a class by, say,
                                adding a field after youâ€™ve serialized it, you may not be able to read it back. Of
                                course, not many sessions are likely to span an upgrade of the server software
                                unless itâ€™s a 24/7 server where you may have a cluster of machines running,
                                some upgraded and some not.</p>
                <p>This brings us to the question of where to store the Server Session State. An
                                obvious possibility is on the application server itself, either in the file system or
                                in a local database. This is the simple route, but it may not support efficient
                                clustering or failover. To support these the passivated Server Session State needs
                                to be somewhere generally accessible, such as on shared server. This will support clustering and failover at the cost of a longer time to activate the serverâ€”
                                although caching may well eliminate much of this cost.
                                This line of reasoning may lead, ironically to storing the serialized Server Session State in the database using a session table indexed by the session ID. This
                                table would require a Serialized LOB (272) to hold the serialized Server Session
                                State. Database performance varies when it comes to handling large objects, so
                                the performance aspects of this one are very database dependent.
                                At this point weâ€™re right at the boundary between Server Session State and
                                Database Session State (462). This boundary is completely arbitrary, but Iâ€™ve
                                drawn the line at the point where you convert the data in the Server Session
                                State into tabular form.</p>
                <p>If youâ€™re storing Server Session State in a database, youâ€™ll have to worry
                                about handling sessions going away, especially in a consumer application. One
                                route is to have a daemon that looks for aged sessions and deletes them, but this
                                can lead to a lot of contention on the session table. Kai Yu told me about an
                                approach he used with success: partitioning the session table into twelve database segments and every two hours rotating the segments, deleting everything in
                                the oldest segment and then directing all inserts to it. While this meant that any
                                session that was active for twenty-four hours got unceremoniously dumped,
                                that would be sufficiently rare to not be a problem.
                                All these variations take more and more effort to do, but the good news is
                                that application servers increasingly support these capabilities automatically.
                                Thus, it may well be that application server vendors can worry their ugly little
                                heads about them.
                                Java Implementation
                                The two most common techniques for Server Session State are using the http
                                session and using a stateful session bean. The http session is the simple route
                                and causes the session data to be stored by the Web server. In most cases this
                                leads to server affinity and it canâ€™t cope with failover. Some vendors are
                                implementing a shared http session capability that allows you to store http
                                session data in a database thatâ€™s available to all application servers. (You
                                can also do this manually, of course.)</p>
                <p>The other common route is via a stateful session bean, which requires an
                                EJB server. The EJB container handles all persistence and passivation, so this
                                makes it very easy to program to. The main disadvantage is that the specification doesnâ€™t ask the application server to avoid server affinity. However,
                                some application servers provide this capability. One, IBMâ€™s WebSphere,
                                can serialize a stateful session bean into a BLOB in DB2, which allows multiple application servers to get at its state.
                                A lot of people say that, since stateless session beans perform better, you
                                should always use them instead of stateful beans. Frankly, thatâ€™s hogwash.
                                Load-test with your environment first to see if you fall into the range of
                                speed difference between stateful and stateless that makes any difference to
                                your application. ThoughtWorks has load-tested apps with a couple of hundred of concurrent users and not found any performance problems due to
                                stateful beans on that size of user load. If the performance advantage isnâ€™t
                                significant for your loads, and stateful beans are easier, then you should use
                                them. There are other reasons to be wary of stateful beansâ€”failover may be
                                more problematic depending on your vendor, but the performance difference only appears under a heavy load.
                                Another alternative is to use an entity bean. On the whole, Iâ€™ve been
                                pretty dismissive of entity beans, but you can use one to store a Serialized
                                LOB (272) of session data. This is pretty simple and less likely to raise many
                                of the issues that usually surround entity beans.
                                .NET Implementation
                                Server Session State is easy to implement with the built-in session state capability. By default .NET stores session data in the server process itself. You
                                can also adjust the storage using a state service, which can reside on the
                                local machine or on any other machine on the network. With a separate
                                state service you can reset the Web server and still retain the session state.
                                You make the change between in-process state and a state service in the configuration file, so you donâ€™t have to change the application.</p>
                <h3 id="460">When to Use It</h3>
                <p>The great appeal of Server Session State is its simplicity. In a number of cases
                                you donâ€™t have to do any programming at all to make this work. Whether you
                                can get away with that depends on if you can get away with the in-memory
                                implementation and, if not, how much help your application server platform
                                gives you.
                                Even without that you may well find that the effort you do need is small.
                                Serializing a BLOB to a database table may turn out to be much less effort than
                                converting the server objects to tabular form.
                                Where the programming effort comes into play is in session maintenance,
                                particularly if you have to roll your own support to enable clustering and
                                failover. It may work out to be more trouble than your other options, especially
                                if you donâ€™t have much session data to deal with or if your session data is easily
                                converted to tabular form.
                                462 SESSION STATE PATTERNS
                                Database
                                Session
                                State</p>
                <h3 id="462">Database Session State</h3>
                <h3 id="462(2)">How It Works</h3>
                <p>When a call goes out from the client to the server, the server object first pulls the
                                data required for the request from the database. Then it does the work it needs
                                to do and saves back to the database all the data required.
                                In order to pull information from the database, the server object will need
                                some information about the session, which requires at least a session ID number to be stored on the client. Usually, however, this information is nothing
                                more than the appropriate set of keys needed to find the appropriate amount of
                                data in the database.
                                The data involved is typically a mix of session data thatâ€™s only local to the
                                current interaction and committed data thatâ€™s relevant to all interactions.
                                One of the key issues to consider here is the fact that session data is usually
                                considered local to the session and shouldnâ€™t affect other parts of the system
                                until the session as a whole is committed. Thus, if youâ€™re working on an order
                                in a session and you want to save its intermediate state to the database, you
                                usually need to handle it differently from an order thatâ€™s confirmed at the end of
                                a session. This is because you donâ€™t want pending orders to appear that often in
                                queries run against the database for such things as book availability and daily
                                revenue.</p>
                <p>So how do you separate the session data? Adding a field to each database
                                row that may have session data is one route.The simplest form of this just
                                requires a Boolean isPending field. However, a better way is to store a session ID
                                as a pending field, which makes it much easier to find all the data for a particular session. All queries that want only record data now need to be modified
                                with a sessionID is not NULL clause, or need a view that filters out that data.
                                Using a session ID field is a very invasive solution because all applications
                                that touch the record database need to know the fieldâ€™s meaning to avoid getting session data. Views will sometimes do the trick and remove the invasiveness, but they often impose costs of their own.
                                A second alternative is a separate set of pending tables. So if you have orders
                                and order lines tables already in your database, you would add tables for pending orders and pending order lines. Pending session data you save to the pending table; when it becomes record data you save it to the real tables. This
                                removes much of the invasiveness. However, youâ€™ll need to add the appropriate
                                table selection logic to your database mapping code, which will certainly add
                                some complications.
                                Often the record data will have integrity rules that donâ€™t apply to pending
                                data. In this case the pending tables allow you to forgo the rules when you
                                donâ€™t want them but to enforce them when you do. Validation rules as well typically arenâ€™t applied when saving pending data. You may face different validation rules depending on where you are in the session, but this usually appears in
                                server object logic.
                                If you use pending tables, they should be exact clones of the real tables. That
                                way you can keep your mapping logic as similar as possible. Use the same field
                                names between the two tables, but add a session ID field to the pending tables
                                so you can easily find all the data for a session.
                                Youâ€™ll need a mechanism to clean out the session data if a session is canceled
                                or abandoned. Using a session ID you can find all data with it and delete it. If
                                users abandon the session without telling you, youâ€™ll need some kind of timeout
                                mechanism. A daemon that runs every few minutes can look for old session
                                data. This requires a table in the database that keeps track of the time of the
                                last interaction with the session.</p>
                <p>Rollback is made much more complicated by updates. If you update an existing order in a session that allows a rollback of the whole session, how do you
                                perform the rollback? One option is not to allow cancellation of a session like
                                this. Any updates to existing record data become part of the record data at the
                                end of the request. This is simple and often fits the usersâ€™ view of the world. The
                                alternative is awkward whether you use pending fields or pending tables. Itâ€™s
                                easy to copy all the data that may be modified into pending tables, modify it
                                there, and commit it back to the record tables at the end of the session. You can
                                do this with a pending field, but only if the session ID becomes part of the key.
                                In this way you can keep the old and new IDs in the same table at the same
                                time, which can get very messy.
                                If youâ€™re going to use separate pending tables that are only read by objects
                                that handle a session, then there may be little point in tabularizing the data. Itâ€™s
                                better to use a Serialized LOB (272). At this point weâ€™ve crossed the boundary
                                into a Server Session State (458).</p>
                <p>You can avoid all of the hassles of pending data by not having any. That is,
                                you design your system so that all data is considered record data. This isnâ€™t
                                always possible, of course, and if it is it can be so awkward that designers
                                would be better off thinking about explicit pending data. Still, if you have the
                                option it makes Database Session State a lot easier to work with.</p>
                <h3 id="464">When to Use It</h3>
                <p>Database Session State is one alternative to handling session state; it should be
                                compared with Server Session State (458) and Client Session State (456).
                                The first aspect to consider with this pattern is performance. Youâ€™ll gain by
                                using stateless objects on the server, thus enabling pooling and easy clustering.
                                However, youâ€™ll pay with the time needed to pull the data in and out of the
                                database with each request. You can reduce this cost by caching the server
                                object so you wonâ€™t have to read the data out of the database whenever the
                                cache is hit, but youâ€™ll still pay the write costs.
                                The second main issue is the programming effort, most of which centers
                                around handling session state. If you have no session state and are able to save
                                all your data as record data in each request, this pattern is an obvious choice
                                because you lose nothing in either effort or performance (if you cache your
                                server objects).
                                In a choice between Database Session State and Server Session State (458)
                                the biggest issue may be how easy it is to support clustering and failover with
                                Server Session State (458) in your particular application server. Clustering and
                                failover with Database Session State are usually more straightforward, at least
                                with the regular solutions.
                                Base
                                Patterns</p>
                <h3 id="465">Chapter 18</h3>
                <h2>Base Patterns</h2>
                <h3 id="466">Gateway</h3>
                <p><img src="img/part2.39.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that encapsulates access to an external system or resource.
                                Interesting software rarely lives in isolation. Even the purest object-oriented
                                system often has to deal with things that arenâ€™t objects, such as relational database tables, CICS transactions, and XML data structures.
                                When accessing external resources like this, youâ€™ll usually get APIs for them.
                                However, these APIs are naturally going to be somewhat complicated because
                                they take the nature of the resource into account. Anyone who needs to understand a resource needs to understand its APIâ€”whether JDBC and SQL for relational databases or W3C or JDOM for XML. Not only does this make the
                                software harder to understand, it also makes it much harder to change should
                                you shift some data from a relational database to an XML message at some
                                point in the future.
                                The answer is so common that itâ€™s hardly worth stating. Wrap all the special
                                API code into a class whose interface looks like a regular object. Other objects
                                access the resource through this Gateway, which translates the simple method
                                calls into the appropriate specialized API. </p>
                <h3 id="466(2)">How It Works</h3>
                <p>In reality this is a very simple wrapper pattern. Take the external resource.
                                What does the application need to do with it? Create a simple API for your
                                usage and use the Gateway to translate to the external source.
                                One of the key uses for a Gateway is as a good point at which to apply a Service Stub (504). You can often alter the design of the Gateway to make it easier
                                to apply a Service Stub (504). Donâ€™t be afraid to do thisâ€”well placed Service
                                Stubs (504) can make a system much easier to test and thus much easier to
                                write.
                                Keep a Gateway as simple as you can. Focus on the essential roles of adapting the external service and providing a good point for stubbing. The Gateway
                                should be as minimal as possible and yet able to handle these tasks. Any more
                                complex logic should be in the Gatewayâ€™s clients.</p>
                <p>Often itâ€™s a good idea to use code generation to create Gateways. By defining
                                the structure of the external resource, you can generate a Gateway class to
                                wrap it. You might use relational metadata to create a wrapper class for a relational table, or an XML schema or DTD to generate code for a Gateway for
                                XML. The resulting Gateways are dumb but they do the trick. Other objects
                                can carry out more complicated manipulations.
                                Sometimes a good strategy is to build the Gateway in terms of more than one
                                object. The obvious form is to use two objects: a back end and a front end. The
                                back end acts as a minimal overlay to the external resource and doesnâ€™t simplify
                                the resourceâ€™s API at all. The front end then transforms the awkward API into a
                                more convenient one for your application to use. This approach is good if the
                                wrapping of the external service and the adaptation to your needs are reasonably complicated, because each responsibility is handled by a single class. Conversely, if the wrapping of the external service is simple, one class can handle
                                that and any adaptation thatâ€™s needed.</p>
                <h3 id="467">When to Use It</h3>
                <p>You should consider Gateway whenever you have an awkward interface to
                                something that feels external. Rather than let the awkwardness spread through
                                the whole system, use a Gateway to contain it. Thereâ€™s hardly any downside to
                                making the Gateway, and the code elsewhere in the system becomes much easier to read.
                                Gateway usually makes a system easier to test by giving you a clear point at
                                which to deploy Service Stubs (504). Even if the external systemâ€™s interface is
                                fine, a Gateway is useful as a first move in applying Service Stub (504).
                                A clear benefit of Gateway is that it also makes it easier for you to swap out
                                one kind of resource for another. Any change in resources means that you only
                                have to alter the Gateway classâ€”the change doesnâ€™t ripple through the rest of
                                the system. Gateway is a simple and powerful form of protected variation. In
                                many cases reasoning about this flexibility is the focus of debate about using
                                Gateway. However, donâ€™t forget that even if you donâ€™t think the resource is ever
                                going to change, you can benefit from the simplicity and testability Gateway
                                gives you.
                                When you have a couple of subsystems like this, another choice for decoupling them is a Mapper (473). However, Mapper (473) is more complicated
                                than Gateway. As a result, I use Gateway for the majority of my external
                                resource access.
                                I must admit that Iâ€™ve struggled a fair bit with whether to make this a new
                                pattern as opposed to referencing existing patterns such as Facade and Adapter
                                [Gang of Four]. I decided to separate it out from these other patterns because I
                                think thereâ€™s a useful distinction to be made.
                <ul>
                        <li>While Facade simplifies a more complex API, itâ€™s usually done by the writer of the service for general use. A Gateway is written by the client for its particular use. In addition, a Facade always implies a different interface to what itâ€™s covering, whereas a Gateway may copy the wrapped facade entirely, being used for substitution or testing purposes.</li>
                        <li>Adapter alters an implementationâ€™s interface to match another interface you need to work with. With Gateway there usually isnâ€™t an existing interface, although you might use an adapter to map an implementation to a Gateway interface. In this case the adapter is part of the Gateway implementation.</li>
                        <li>Mediator usually separates multiple objects so that they donâ€™t know about each other but do know about the mediator. With a Gateway there are usually only two objects involved and the resource thatâ€™s being wrapped doesnâ€™t know about the Gateway.</li>
                </ul>
                </p>
                <h3 id="468">Example: A Gateway to a Proprietary Messaging Service (Java)</h3>
                <p>I was talking about this pattern with my colleague, Mike Rettig, and he
                                described how heâ€™s used it to handle interfaces with Enterprise Application Integration (EAI) software. We decided that this would be a good inspiration for a
                                Gateway example.
                                To keep things at the usual level of ludicrous simplicity, weâ€™ll build a gateway
                                to an interface that just sends a message using the message service. The interface
                                is just a single method.
                                int send(String messageType, Object[] args);
                                The first argument is a string indicating the type of the message; the second is
                                the arguments of the message. The messaging system allows you to send any
                                kind of message, so it needs a generic interface like this. When you configure
                                the message system you specify the types of message the system will send and
                                the number and types of arguments for them. Thus, we might configure the
                                confirm message with the string â€œCNFRMâ€ and have arguments for an ID number
                                as a string, an integer amount, and a string for the ticker code. The messaging
                                system checks the types of the arguments for us and generates an error if we
                                send a wrong message or the right message with the wrong arguments.</p>
                <p>This is laudable, and necessary, flexibility, but the generic interface is awkward to use because it isnâ€™t explicit. You canâ€™t tell by looking at the interface
                                what the legal message types are or what arguments are needed for a certain
                                message type. What we need instead is an interface with methods like this:
                                public void sendConfirmation(String orderID, int amount, String symbol);
                                That way if we want a domain object to send a message, it can do so like this:
                                <pre>class Order...
                                public void confirm() {
                                if (isValid()) Environment.getMessageGateway().sendConfirmation(id, amount, symbol);
                                }</pre>
                                Here the name of the method tells us what message weâ€™re sending, and the
                                arguments are typed and given names. This is a much easier method to call than
                                the generic method. Itâ€™s the gatewayâ€™s role to make a more convenient interface.
                                It does mean, though, that every time we add or change a message type in the
                                messaging system we need to change the gateway class, but we would have to
                                change the calling code anyway. At least this way the compiler can help us find
                                clients and check for errors.
                                Thereâ€™s another problem. When we get an error with this interface it tells us
                                by giving us a return error code. Zero indicates success; anything else indicates
                                failure, and different numbers indicate different errors. This is a natural way for
                                a C programmer to work, but it isnâ€™t the way Java does things. In Java you
                                throw an exception to indicate an error, so the Gatewayâ€™s methods should
                                throw exceptions rather than return error codes.</p>
                <p>The full range of possible errors is something that weâ€™ll naturally ignore. Iâ€™ll
                                focus on just two: sending a message with an unknown message type and sending a message where one of the arguments is null. The return codes are defined
                                in the messaging systemâ€™s interface.
                                <pre>public static final int NULL_PARAMETER = -1;
                                public static final int UNKNOWN_MESSAGE_TYPE = -2;
                                public static final int SUCCESS = 0;</pre>
                                The two errors have a significant difference. The unknown message type
                                error indicates an error in the gateway class; since any client is only calling a
                                fully explicit method, clients should never generate this error. They might pass
                                in a null, however, and thus see the null parameter error. This error isnâ€™t a
                                checked exception since it indicates a programmer errorâ€”not something that
                                you would write a specific handler for. The gateway could actually check for
                                nulls itself, but if the messaging system is going to raise the same error it probably isnâ€™t worth it.
                                For these reasons the gateway has to both translate from the explicit interface to the generic interface and translate the return codes into exceptions.
                                <pre>class MessageGateway...
                                protected static final String CONFIRM = "CNFRM";
                                private MessageSender sender;
                                public void sendConfirmation(String orderID, int amount, String symbol) {
                                Object[] args = new Object[]{orderID, new Integer(amount), symbol};
                                send(CONFIRM, args);
                                }
                                private void send(String msg, Object[] args) {
                                int returnCode = doSend(msg, args);
                                if (returnCode == MessageSender.NULL_PARAMETER)
                                throw new NullPointerException("Null Parameter passed for msg type: " + msg);
                                if (returnCode != MessageSender.SUCCESS)
                                throw new IllegalStateException(
                                "Unexpected error from messaging system #:" + returnCode);
                                }
                                protected int doSend(String msg, Object[] args) {
                                Assert.notNull(sender);
                                return sender.send(msg, args);
                                }</pre>
                                So far, itâ€™s hard to see the point of the doSend method, but itâ€™s there for
                                another key role for a gatewayâ€”testing. We can test objects that use the gateway without the message-sending service being present. To do this we need to
                                create a Service Stub (504). In this case the gateway stub is a subclass of the real
                                gateway and overrides doSend.
                                <pre>class MessageGatewayStub...
                                protected int doSend(String messageType, Object[] args) {
                                int returnCode = isMessageValid(messageType, args);
                                if (returnCode == MessageSender.SUCCESS) {
                                messagesSent++;
                                }
                                return returnCode;
                                }
                                private int isMessageValid(String messageType, Object[] args) {
                                if (shouldFailAllMessages) return -999;
                                if (!legalMessageTypes().contains(messageType))
                                return MessageSender.UNKNOWN_MESSAGE_TYPE;
                                for (int i = 0; i < args.length; i++) {
                                Object arg = args[i];
                                if (arg == null) {
                                return MessageSender.NULL_PARAMETER;
                                }
                                }
                                return MessageSender.SUCCESS;
                                }
                                public static List legalMessageTypes() {
                                List result = new ArrayList();
                                result.add(CONFIRM);
                                return result;
                                }
                                private boolean shouldFailAllMessages = false;
                                public void failAllMessages() {
                                shouldFailAllMessages = true;
                                }
                                public int getNumberOfMessagesSent() {
                                return messagesSent;
                                }
                                Capturing the number of messages sent is a simple way of helping us test that
                                the gateway works correctly with tests like these.
                                class GatewayTester...
                                public void testSendNullArg() {
                                try {
                                gate().sendConfirmation(null, 5, "US");
                                fail("Didnâ€™t detect null argument");
                                } catch (NullPointerException expected) {
                                }
                                assertEquals(0, gate().getNumberOfMessagesSent());
                                }
                                private MessageGatewayStub gate() {
                                return (MessageGatewayStub) Environment.getMessageGateway();
                                }
                                protected void setUp() throws Exception {
                                Environment.testInit();
                                }</pre>
                                You usually set up the Gateway so that classes can find it from a well-known
                                place. Here Iâ€™ve used a static environment interface. You can switch between
                                the real service and the stub at configuration time by using a Plugin (499), or
                                you can have the test setup routines initialize the environment to use the Service
                                Stub (504).
                                In this case Iâ€™ve used a subclass of the gateway to stub the messaging service.
                                Another route is to subclass (or reimplement) the service itself. For testing you
                                connect the gateway to the sending Service Stub (504); it works if reimplementation of the service isnâ€™t too difficult. You always have the choice of stubbing
                                the service or stubbing the gateway. In some cases itâ€™s even useful to stub both,
                                using the stubbed gateway for testing clients of the gateway and the stubbed
                                service to test the gateway itself.</p>
                <h3 id="473">Mapper</h3>
                <p><img src="img/part2.40.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An object that sets up a communication
                                between two independent objects.
                                Sometimes you need to set up communications between two subsystems that
                                still need to stay ignorant of each other. This may be because you canâ€™t modify
                                them or you can but you donâ€™t want to create dependencies between the two or
                                even between them and the isolating element.</p>
                <h3 id="473(2)">How It Works</h3>
                <p>A mapper is an insulating layer between subsystems. It controls the details of
                                the communication between them without either subsystem being aware of it.
                                A mapper often shuffles data from one layer to another. Once activated for
                                this shuffling, itâ€™s fairly easy to see how it works. The complicated part of using
                                a mapper is deciding how to invoke it, since it canâ€™t be directly invoked by
                                either of the subsystems that itâ€™s mapping between. Sometimes a third subsystem drives the mapping and invokes the mapper as well. An alternative is to
                                make the mapper an observer [Gang of Four] of one or the other subsystem.
                                That way it can be invoked by listening to events in one of them.
                                How a mapper works depends on the kind of layers itâ€™s mapping. The most
                                common case of a mapping layer that we run into is in a Data Mapper (165), so
                                look there for more details on how a Mapper is used.</p>
                <h3 id="474">When to Use It</h3>
                <p>Essentially a Mapper decouples different parts of a system. When you want to
                                do this you have a choice between Mapper and Gateway (466). Gateway (466)
                                is by far the most common choice because itâ€™s much simpler to use a Gateway
                                (466) than a Mapper both in writing the code and in using it later.
                                As a result you should only use a Mapper when you need to ensure that neither subsystem has a dependency on this interaction. The only time this is really
                                important is when the interaction between the subsystems is particularly complicated and somewhat independent to the main purpose of both subsystems.
                                Thus, in enterprise applications we mostly find Mapper used for interactions
                                with a database, as in Data Mapper (165).
                                Mapper is similar to Mediator [Gang of Four] in that itâ€™s used to separate
                                different elements. However, the objects that use a mediator are aware of it,
                                even if they arenâ€™t aware of each other; the objects that a Mapper separates
                                arenâ€™t even aware of the mapper.</p>
                <h3 id="475">Layer Supertype</h3>
                <p>Itâ€™s not uncommon for all the objects in a layer to have methods you donâ€™t want
                                to have duplicated throughout the system. You can move all of this behavior
                                into a common Layer Supertype.</p>
                <h3 id="475(2)">How It Works</h3>
                <p>Layer Supertype is a simple idea that leads to a very short pattern. All you need
                                is a superclass for all the objects in a layerâ€”for example, a Domain Object
                                superclass for all the domain objects in a Domain Model (116). Common features, such as the storage and handling of Identity Fields (216), can go there.
                                Similarly all Data Mappers (165) in the mapping layer can have a superclass
                                that relies on the fact that all domain objects have a common superclass.
                                If you have more than one kind of object in a layer, itâ€™s useful to have more
                                than one Layer Supertype.</p>
                <h3 id="475(3)">When to Use It</h3>
                <p>Use Layer Supertype when you have common features from all objects in a layer.
                                I often do this automatically because I make a lot of use of common features.</p>
                <h3 id="475(4)">Example: Domain Object (Java)</h3>
                <p>Domain objects can have a common superclass for ID handling.
                                <pre>class DomainObject...
                                private Long ID;
                                public Long getID() {
                                return ID;
                                }
                                public void setID(Long ID) {
                                Assert.notNull("Cannot set a null ID", ID);
                                this.ID = ID;
                                }
                                public DomainObject(Long ID) {
                                this.ID = ID;
                                }
                                public DomainObject() {
                                }</pre></p>
                <h3 id="476">Separated Interface</h3>
                <p><img src="img/part2.41.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Defines an interface in a separate package from its implementation.
                                As you develop a system, you can improve the quality of its design by reducing
                                the coupling between the systemâ€™s parts. A good way to do this is to group the
                                classes into packages and control the dependencies between them.You can then
                                follow rules about how classes in one package can call classes in anotherâ€”for
                                example, one that says that classes in the domain layer may not call classes in
                                the presentation package.
                                However, you might need to invoke methods that contradict the general
                                dependency structure. If so, use Separated Interface to define an interface in one
                                package but implement it in another. This way a client that needs the depen Customer
                                dency to the interface can be completely unaware of the implementation. The
                                Separated Interface provides a good plug point for Gateway (466).</p>
                <h3 id="477">How It Works</h3>
                <p>This pattern is very simple to employ. Essentially it takes advantage of the fact
                                that an implementation has a dependency to its interface but not vice versa.
                                This means you can put the interface and the implementation in separate packages and the implementation package has a dependency to the interface package. Other packages can depend on the interface package without depending on
                                the implementation package.
                                Of course, the software wonâ€™t work at runtime without some implementation of the interface. This can be either at compile time using a separate package that ties the two together or at configuration time using Plugin (499).
                                You can place the interface in the clientâ€™s package (as in the sketch) or in a
                                third package (Figure 18.1). If thereâ€™s only one client for the implementation, or
                                all the clients are in the same package, then you might as well put the interface in
                                with the client. A good way of thinking about this is that the developers of the
                                client package are responsible for defining the interface. Essentially the client
                                package indicates that it will work with any other package that implements the
                                interface it defines. If you have multiple client packages, a third interface package is better. Itâ€™s also better if you want to show that the interface definition isnâ€™t
                <p><img src="img/figure 18.1.png" alt="no img" style="margin-left: 200px;"></p>
                                the responsibility of the client package developers. This would be the case if the
                                developers of the implementation were responsible for it.</p>
                <p>You have to consider what language feature to use for the interface. For languages that have an interface construct, such as Java and C#, the interface keyword is the obvious choice. However, it may not be the best. An abstract class
                                can make a good interface because you can have common, but optional, implementation behavior in it.
                                One of the awkward things about separate interfaces is how to instantiate
                                the implementation. It usually requires knowledge of the implementation class.
                                The common approach is to use a separate factory object, where again there is
                                a Separated Interface for the factory. You still have to bind an implementation
                                to the factory, and Plugin (499) is a good way to do this. Not only does it mean
                                there is no dependency, but it also defers the decision about implementation
                                class to configuration time.
                                If you donâ€™t want to go all the way to Plugin (499), a simpler alternative is to
                                let yet another package that knows both the interface and the implementation
                                instantiate the right objects at application startup. Any objects that use Separated Interface can either themselves be instantiated or have factories instantiated at startup.</p>
                <h3 id="478">When to Use It</h3>
                <p>You use Separated Interface when you need to break a dependency between
                                two parts of the system. Here are some examples:
                <ul>
                        <li>Youâ€™ve built some abstract code for common cases into a framework package that needs to call some particular application code.</li>
                        <li>You have some code in one layer that needs to call code in another layer that it shouldnâ€™t see, such as domain code calling a Data Mapper (165).</li>
                        <li>You need to call functions developed by another development group but donâ€™t want a dependency into their APIs.</li>
                </ul>
                                I come across many developers who have separate interfaces for every class
                                they write. I think this is excessive, especially for application development. Keeping separate interfaces and implementations is extra work, especially since you
                                often need factory classes (with interfaces and implementations) as well. For
                                applications I recommend using a separate interface only if you want to break a
                                dependency or you want to have multiple independent implementations. If you
                                put the interface and implementation together and need to separate them later,
                                this is a simple refactoring that can be delayed until you need to do it.
                                There is a degree to where the determined management of dependencies in
                                this way can get a little silly. Having only a dependency to create an object, and
                                using the interface ever after, is usually enough. The trouble comes when you
                                want to enforce dependency rules, such as by doing a dependency check at
                                build time. Then all dependencies have to be removed. For a smaller system
                                enforcing dependency rules is less of an issue, but for bigger systems itâ€™s a very
                                worthwhile discipline.</p>
                <h3 id="480">Registry</h3>
                <p><img src="img/part2.42.png" alt="no img" style="margin-left: 200px;"></p>
                <p>A well-known object that other objects can use
                                to find common objects and services.
                                When you want to find an object you usually start with another object that has
                                an association to it, and use the association to navigate to it. Thus, if you want
                                to find all the orders for a customer, you start with the customer object and use
                                a method on it to get the orders. However, in some cases you wonâ€™t have an
                                appropriate object to start with. You may know the customerâ€™s ID number but
                                not have a reference. In this case you need some kind of lookup methodâ€”a
                                finderâ€”but the question remains: How do you get to the finder?
                                A Registry is essentially a global object, or at least it looks like oneâ€”even if
                                it isnâ€™t as global as it may appear. </p>
                <h3 id="480(2)">How It Works</h3>
                <p>As with any object, you have to think about the design of a Registry in terms of
                                interface and implementation. And like many objects, the two are quite different, although people often make the mistake of thinking they should be the
                                same.
                                The first thing to think of is the interface, and for Registries my preferred
                                interface is static methods. A static method on a class is easy to find anywhere
                                in an application. Furthermore, you can encapsulate any logic you like within
                                the static method, including delegation to other methods, either static or
                                instance.
                                However, just because your methods are static doesnâ€™t mean that your data
                                should be in static fields. Indeed, I almost never use static fields unless theyâ€™re
                                constants.
                                Before you decide on how to hold your data, think about the dataâ€™s scope.
                                The data for a Registry can vary with different execution contexts. Some of it is
                                global across an entire process; some, global across a thread; and some, global
                                <pre>getPerson (id)
                                addPerson (Person)</pre>
                                across a session. Different scopes call for different implementations, but they
                                donâ€™t call for different interfaces. The application programmer doesnâ€™t have to
                                know whether a call to a static method yields process-scoped or thread-scoped
                                data. You can have different Registries for different scopes, but you can also
                                have a single Registry in which different methods are at different scopes.
                                If your data is common to a whole process, a static field is an option. However, I rarely use static mutable fields because they donâ€™t allow for substitution.
                                It can be extremely useful to be able to substitute a Registry for a particular
                                purpose, especially for testing (Plugin (499) is a good way to do this).
                                For a process-scoped Registry, then, the usual option is a singleton [Gang of
                                Four]. The Registry class contains a single static field that holds a Registry
                                instance. When people use a singleton they often make its caller explicitly
                                access the underlying data (Registry.soleInstance.getFoo()), but I prefer a static
                                method that hides the singleton object from me (Registry.getFoo()). This works
                                particularly well since C-based languages allow static methods to access private
                                instance data.</p>
                <p>Singletons are widely used in single-threaded applications, but can be a problem for multi-threaded applications. This is because itâ€™s too easy for multiple
                                threads to manipulate the same object in unpredictable ways. You may be able
                                to solve this with synchronization, but the difficulty of writing the synchronization code is likely to drive you into an insane asylum before you get all the bugs
                                out. For that reason I donâ€™t recommend using a singleton for mutable data in a
                                multi-threaded environment. It does work well for immutable data, since anything that canâ€™t change isnâ€™t going to run into thread clash problems. Thus,
                                something like a list of all states in the United States makes a good candidate
                                for a process-scoped Registry. Such data can be loaded when a process starts up
                                and never need changing, or it may be updated rarely with some kind of process
                                interrupt.</p>
                <p>A common kind of Registry data is thread scoped. A good example is a database connection. In this case many environments give you some form of threadspecific storage, such as Javaâ€™s thread local. Another technique is a dictionary
                                keyed by thread whose value is an appropriate data object. A request for a connection results in a lookup in that dictionary by the current thread.
                                The important thing to remember about thread-scoped data is that it
                                looks no different from process-scoped data. I can still use a method such as
                                Registry.getDbConnection(), which is the same form when Iâ€™m accessing processscoped data.
                                A dictionary lookup is also a technique you can use for session-scoped data.
                                Here you need a session ID, but it can be put into a thread-scoped registry when
                                a request begins. Any subsequent accesses for session data can look up the data
                                in a map thatâ€™s keyed by session using the session ID thatâ€™s held in thread-specific storage.
                                If youâ€™re using a thread-scoped Registry with static methods, you may run
                                into a performance issue with multiple threads going through them. In that case
                                direct access to the threadâ€™s instance will avoid the bottleneck.
                                Some applications may have a single Registry; some may have several. Registries are usually divided up by system layer or by execution context. My preference is to divide them up by how they are used, rather than implementation.</p>
                <h3 id="482">When to Use It</h3>
                <p>Despite the encapsulation of a method, a Registry is still global data and as
                                such is something Iâ€™m uncomfortable using. I almost always see some form of
                                Registry in an application, but I always try to access objects through regular
                                inter-object references instead. Basically, you should only use a Registry as a last
                                resort.
                                There are alternatives to using a Registry. One is to pass around any widely
                                needed data in parameters. The problem with this is that parameters are added
                                to method calls where they arenâ€™t needed by the called method but only by
                                some other method thatâ€™s called several layers deep in the call tree. Passing a
                                parameter around when itâ€™s not needed 90 percent of the time is what leads me
                                to use a Registry instead.</p>
                <p>Another alternative Iâ€™ve seen to a Registry is to add a reference to the common data to objects when theyâ€™re created. Although this leads to an extra
                                parameter in a constructor, at least itâ€™s only used by that constructor. Itâ€™s still
                                more trouble than itâ€™s often worth, but if you have data thatâ€™s only used by a
                                subset of classes, this technique allows you to restrict things that way.
                                One of the problems with a Registry is that it has to be modified every time
                                you add a new piece of data. This is why some people prefer to use a map as
                                their holder of global data. I prefer the explicit class because it keeps the methods explicit, so thereâ€™s no confusion about what key you use to find something.
                                With an explicit class you can just look at the source code or generated documentation to see whatâ€™s available. With a map you have to find places in the
                                system where data is read or written to the map to find out what key is used or
                                to rely on documentation that quickly becomes stale. An explicit class also
                                allows you to keep type safety in a statically typed language as well as to encapsulate the structure of the Registry so that you can refactor it as the system
                                grows. A bare map also is unencapsulated, which makes it harder to hide the
                                implementation. This is particularly awkward if you have to change the dataâ€™s
                                execution scope.
                                So there are times when itâ€™s right to use a Registry, but remember that any
                                global data is always guilty until proven innocent. </p>
                <h3 id="483">Example: A Singleton Registry (Java)</h3>
                <p>Consider an application that reads data from a database and then munges on it
                                to turn it into information. Well, imagine a fairly simple system that uses Row
                                Data Gateways (152) for data access. This system has finder objects to encapsulate the database queries. The finders are best made as instances because that
                                way we can substitute them to make a Service Stub (504) for testing. We need a
                                place to put them; a Registry is the obvious choice.
                                A singleton registry is a very simple example of the Singleton pattern [Gang
                                of Four]. You have a static variable for the single instance.
                                <pre>class Registry...
                                private static Registry getInstance() {
                                return soleInstance;
                                }
                                private static Registry soleInstance = new Registry();
                                Everything thatâ€™s stored on the registry is stored on the instance.
                                class Registry...
                                protected PersonFinder personFinder = new PersonFinder();
                                To make access easier, however, I make the public methods static.
                                class Registry...
                                public static PersonFinder personFinder() {
                                return getInstance().personFinder;
                                }
                                I can reinitialize the registry simply by creating a new sole instance.
                                class Registry...
                                public static void initialize() {
                                soleInstance = new Registry();
                                }
                                If I want to use Service Stubs (504) for testing, I use a subclass instead.
                                class RegistryStub extends Registry...
                                public RegistryStub() {
                                personFinder = new PersonFinderStub();
                                }
                                484 BASE PATTERNS
                                Registry
                                The finder Service Stub (504) just returns hardcoded instances of the person
                                Row Data Gateway (152).
                                class PersonFinderStub...
                                public Person find(long id) {
                                if (id == 1) {
                                return new Person("Fowler", "Martin", 10);
                                }
                                throw new IllegalArgumentException("Canâ€™t find id: " + String.valueOf(id));
                                }
                                I put a method on the registry to initialize it in stub mode, but by keeping all
                                the stub behavior in the subclass I can separate all the code required for testing.
                                class Registry...
                                public static void initializeStub() {
                                soleInstance = new RegistryStub();
                                }</pre></p>
                <h3 id="484">Example: Thread-Safe Registry (Java) Matt Foemmel and Martin Fowler</h3>
                <p>The simple example above wonâ€™t work for a multi-threaded application where
                                different threads need their own registry. Java provides Thread Specific Storage
                                variables [Schmidt] that are local to a thread, helpfully called thread local variables. You can use them to create a registry thatâ€™s unique for a thread.
                                <pre>class ThreadLocalRegistry...
                                private static ThreadLocal instances = new ThreadLocal();
                                public static ThreadLocalRegistry getInstance() {
                                return (ThreadLocalRegistry) instances.get();
                                }</pre>
                                The Registry needs to be set up with methods for acquiring and releasing it.
                                You typically do this on a transaction or session call boundary.
                                <pre>class ThreadLocalRegistry...
                                public static void begin() {
                                Assert.isTrue(instances.get() == null);
                                instances.set(new ThreadLocalRegistry());
                                }
                                public static void end() {
                                Assert.notNull(getInstance());
                                instances.set(null);
                                }
                                You can then store person finders as before.
                                class ThreadLocalRegistry...
                                private PersonFinder personFinder = new PersonFinder();;
                                public static PersonFinder personFinder() {
                                return getInstance().personFinder;
                                }</pre>
                                Calls from the outside wrap their use of a registry in the begin and end methods.
                                <pre>try {
                                ThreadLocalRegistry.begin();
                                PersonFinder f1 = ThreadLocalRegistry.personFinder();
                                Person martin = Registry.personFinder().find(1);
                                assertEquals("Fowler", martin.getLastName());
                                } finally {ThreadLocalRegistry.end();
                                }</pre></p>
                <h3 id="486">Value Object</h3>
                <p>A small simple object, like money or a date
                                range, whose equality isnâ€™t based on identity.
                                With object systems of various kinds, Iâ€™ve found it useful to distinguish between
                                reference objects and Value Objects. Of the two a Value Object is usually the
                                smaller; itâ€™s similar to the primitive types present in many languages that arenâ€™t
                                purely object-oriented. </p>
                <h3 id="486(2)">How It Works</h3>
                <p>Defining the difference between a reference object and Value Object can be a
                                tricky thing. In a broad sense we like to think that Value Objects are small
                                objects, such as a money object or a date, while reference objects are large, such
                                as an order or a customer. Such a definition is handy but annoyingly informal.
                                The key difference between reference and value objects lies in how they deal
                                with equality. A reference object uses identity as the basis for equalityâ€”maybe
                                the identity within the programming system, such as the built-in identity of OO
                                programming languages, or maybe some kind of ID number, such as the primary key in a relational database. A Value Object bases its notion of equality
                                on field values within the class. Thus, two date objects may be the same if their
                                day, month, and year values are the same.</p>
                <p>This difference manifests itself in how you deal with them. Since Value
                                Objects are small and easily created, theyâ€™re often passed around by value
                                instead of by reference. You donâ€™t really care about how many March 18, 2001,
                                objects there are in your system. Nor do you care if two objects share the same
                                physical date object or whether they have different yet equal copies.
                                Most languages have no special facility for value objects. For value objects to
                                work properly in these cases itâ€™s a very good idea to make them immutableâ€”
                                that is, once created none of their fields change. The reason for this is to avoid
                                aliasing bugs. An aliasing bug occurs when two objects share the same value
                                object and one of the owners changes the values in it. Thus, if Martin has a hire
                                date of March 18 and we know that Cindy was hired on the same day, we may
                                set Cindyâ€™s hire date to be the same as Martinâ€™s. If Martin then changes the
                                month in his hire date to May, Cindyâ€™s hire date changes too. Whether itâ€™s correct or not, it isnâ€™t what people expect. Usually with small values like this people expect to change a hire date by replacing the existing date object with a new
                                one. Making Value Objects immutable fulfills that expectation.</p>
                <p>Value Objects shouldnâ€™t be persisted as complete records. Instead use
                                Embedded Value (268) or Serialized LOB (272). Since Value Objects are small,
                                Embedded Value (268) is usually the best choice because it also allows SQL
                                querying using the data in a Value Object.
                                If youâ€™re doing a lot of binary serializing, you may find that optimizing the
                                serialization of Value Objects can improve performance, particularly in languages like Java that donâ€™t treat for Value Objects in a special way.
                                For an example of a Value Object see Money (488).
                                .NET Implementation
                                .NET has a first-class treatment of Value Object. In C# an object is marked
                                as a Value Object by declaring it as a struct instead as a class. The environment then treats it with value semantics.</p>
                <h3 id="487">When to Use It</h3>
                <p>Treat something as a Value Object when youâ€™re basing equality on something
                                other than an identity. Itâ€™s worth considering this for any small object thatâ€™s
                                easy to create.
                                Name Collisions Iâ€™ve seen the term Value Object used for this pattern for quite
                                some time. Sadly recently Iâ€™ve seen the J2EE community [Alur et al.] use the
                                term â€œvalue objectâ€ to mean Data Transfer Object (401), which has caused a
                                storm in the teacup of the patterns community. This is just one of those clashes
                                over names that happen all the time in this business. Recently [Alur et al.]
                                decided to use the term transfer object instead.
                                I continue to use Value Object in this way in this text. If nothing else it
                                allows me to be consistent with my previous writings!</p>
                <h3 id="488">Money</h3>
                <p><img src="img/part2.43.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Represents a monetary value.
                                A large proportion of the computers in this world manipulate money, so itâ€™s
                                always puzzled me that money isnâ€™t actually a first class data type in any
                                mainstream programming language. The lack of a type causes problems, the
                                most obvious surrounding currencies. If all your calculations are done in a
                                single currency, this isnâ€™t a huge problem, but once you involve multiple currencies you want to avoid adding your dollars to your yen without taking the
                                currency differences into account. The more subtle problem is with rounding.
                                Monetary calculations are often rounded to the smallest currency unit. When
                                you do this itâ€™s easy to lose pennies (or your local equivalent) because of
                                rounding errors.
                                The good thing about object-oriented programming is that you can fix these
                                problems by creating a Money class that handles them. Of course, itâ€™s still surprising that none of the mainstream base class libraries actually do this.</p>
                <h3 id="488(2)">How It Works</h3>
                <p>The basic idea is to have a Money class with fields for the numeric amount and
                                the currency. You can store the amount as either an integral type or a fixed decimal type. The decimal type is easier for some manipulations, the integral for others. You should absolutely avoid any kind of floating point type, as that will
                                introduce the kind of rounding problems that Money is intended to avoid. Most
                                of the time people want monetary values rounded to the smallest complete unit,
                                such as cents in the dollar. However, there are times when fractional units are
                                needed. Itâ€™s important to make it clear what kind of money youâ€™re working with,
                                especially in an application that uses both kinds. It makes sense to have different
                                types for the two cases as they behave quite differently under arithmetic.
                                <pre>+, -, *
                                allocate
                                >, >, <=, >=, =
                                amount
                                currency
                                Money</pre>
                                Money is a Value Object (486), so it should have its equality and hash code
                                operations overridden to be based on the currency and amount.
                                Money needs arithmetic operations so that you can use money objects as easily as you use numbers. But arithmetic operations for money have some important differences to money operations in numbers. Most obviously, any addition
                                or subtraction needs to be currency aware so you can react if you try to add
                                together monies of different currencies. The simplest, and most common,
                                response is to treat the adding together of disparate currencies as an error. In
                                some more sophisticated situations you can use Ward Cunninghamâ€™s idea of a
                                money bag. This is an object that contains monies of multiple currencies
                                together in one object. This object can then participate in calculations just like
                                any money object. It can also be valued into a currency.
                                Multiplication and division end up being more complicated due to rounding
                                problems. When you multiply money you do it with a scalar. If you want to add
                                5% tax to a bill you multiply by 0.05, so you see multiplication by regular
                                numeric types.
                                The awkward complication comes with rounding, particularly when allocating money between different places. Hereâ€™s Matt Foemmelâ€™s simple conundrum.
                                Suppose I have a business rule that says that I have to allocate the whole amount
                                of a sum of money to two accounts: 70% to one and 30% to another. I have 5
                                cents to allocate. If I do the math I end up with 3.5 cents and 1.5 cents. Whichever way I round these I get into trouble. If I do the usual rounding to nearest
                                then 1.5 becomes 2 and 3.5 becomes 4. So I end up gaining a penny. Rounding
                                down gives me 4 cents and rounding up gives me 6 cents. Thereâ€™s no general
                                rounding scheme I can apply to both that will avoid losing or gaining a penny.
                                Iâ€™ve seen various solutions to this problem.
                <ul>
                        <li>Perhaps the most common is to ignore itâ€”after all, itâ€™s only a penny here
                                and there. However this tends to make accountants understandably nervous.</li>
                        <li>When allocating you always do the last allocation by subtracting from
                                what youâ€™ve allocated so far. This avoids losing pennies, but you can get a
                                cumulative amount of pennies on the last allocation.</li>
                        <li>Allow users of a Money class to declare the rounding scheme when they call
                                the method. This permits a programmer to say that the 70% case rounds up and
                                the 30% rounds down. Things can get complicated when you allocate across ten
                                accounts instead of two. You also have to remember to round. To encourage people to remember Iâ€™ve seen some Money classes force a rounding parameter into
                                the multiply operation. Not only does this force the programmer to think about
                                what rounding she needs, it also might remind her of the tests to write. However,
                                it gets messy if you have a lot of tax calculations that all round the same way.</li>
                        <li>My favorite solution: have an allocator function on the money. The
                                parameter to the allocator is a list of numbers, representing the ratio to be allocated (it would look something like aMoney.allocate([7,3])). The allocator returns
                                a list of monies, guaranteeing that no pennies get dropped by scattering them
                                across the allocated monies in a way that looks pseudo-random from the outside. The allocator has faults: You have to remember to use it and any precise
                                rules about where the pennies go are difficult to enforce.</li>
                </ul>
                                The fundamental issue here is between using multiplication to determine
                                proportional charge (such as a tax) and using it to allocate a sum of money
                                across multiple places. Multiplication works well for the former, but an allocator works better for the latter. The important thing is to consider your intent in
                                using multiplication or division on a monetary value.
                                You may want to convert from one currency to another with a method like
                                aMoney.convertTo(Currency.DOLLARS). The obvious way to do this is to look up an
                                exchange rate and multiply by it. While this works in many situations, there are
                                cases where it doesnâ€™tâ€”again due to rounding. The conversion rules between
                                the fixed euro currencies had specific roundings applied that made simple multiplication unworkable. Thus, itâ€™s wise to have a convertor object to encapsulate
                                the algorithm.</p>
                <p>Comparison operations allow you to sort monies. Like the addition operation, conversions need to be currency aware. You can either choose to throw an
                                exception if you compare different currencies or do a conversion.
                                A Money can encapsulate the printing behavior. This makes it much easier to
                                provide good display on user interfaces and reports. A Money class can also
                                parse a string to provide a currency-aware input mechanism, which again is
                                very useful for the user interface. This is where your platformâ€™s libraries can
                                provide help. Increasingly platforms provide globalization support with specific
                                number formatters for particular countries.
                                Storing a Money in a database always raises an issue, since databases also
                                donâ€™t seem to understand that money is important (although their vendors do.)
                                The obvious route to take is to use Embedded Value (268), which results in
                                storing a currency for every money. That can be overkill when, for instance, an
                                account may have all its entries be in pounds. In this case you may store the
                                currency on the account and alter the database mapping to pull the accountâ€™s
                                currency whenever you load entries. </p>
                <h3 id="490">When to Use It</h3>
                <p>I use Money for pretty much all numeric calculation in object-oriented environments. The primary reason is to encapsulate the handling of rounding behavior,
                                MONEY 491
                                Money
                                which helps reduce the problems of rounding errors. Another reason to use
                                Money is to make multi-currency work much easier. The most common objection to Money is performance, although Iâ€™ve only rarely heard of cases where it
                                makes any noticeable difference, and even then the encapsulation often makes
                                tuning easier.</p>
                <h3 id="491">Example: A Money Class (Java) by Matt Foemmel and Martin Fowler</h3>
                <p>The first decision is what data type to use for the amount. If anyone needs convincing that a floating point number is a bad idea, ask them to run this code.
                                <pre>double val = 0.00;
                                for (int i = 0; i < 10; i++) val += 0.10;
                                System.out.println(val == 1.00);</pre>
                                With floats safely disposed of, the choice lies between fixed-point decimals
                                and integers, which in Java boils down to BigDecimal, BigInteger and long. Using
                                an integral value actually makes the internal math easier, and if we use long we
                                can use primitives and thus have readable math expressions.
                                <pre>class Money...
                                private long amount;
                                private Currency currency;</pre>
                                Iâ€™m using an integral amount, that is, the amount of the smallest base unit,
                                which I refer to as cents in the code because itâ€™s as good a name as any. With a
                                long we get an overflow error if the number gets too big. If you give us
                                $92,233,720,368,547,758.09 weâ€™ll write you a version that uses BigInteger.
                                Itâ€™s useful to provide constructors from various numeric types.
                                <pre>public Money(double amount, Currency currency) {
                                this.currency = currency;
                                this.amount = Math.round(amount * centFactor());
                                }
                                public Money(long amount, Currency currency) {
                                this.currency = currency;
                                this.amount = amount * centFactor();
                                }
                                private static final int[] cents = new int[] { 1, 10, 100, 1000 };
                                private int centFactor() {
                                return cents[currency.getDefaultFractionDigits()];
                                }</pre>
                                Different currencies have different fractional amounts. The Java 1.4 Currency
                                class will tell you the number of fractional digits in a class. We can determine
                                how many minor units there are in a major unit by raising ten to the power, but
                                thatâ€™s such a pain in Java that the array is easier (and probably quicker). Weâ€™re
                                prepared to live with the fact that this code breaks if someone uses four fractional digits.
                                Although most of the time youâ€™ll want to use money operation directly, there
                                are occasions when youâ€™ll need access to the underlying data.
                                <pre>class Money...
                                public BigDecimal amount() {
                                return BigDecimal.valueOf(amount, currency.getDefaultFractionDigits());
                                }
                                public Currency currency() {
                                return currency;
                                }</pre>
                                You should always question your use of accessors. Thereâ€™s almost always a
                                better way that wonâ€™t break encapsulation. One example that we couldnâ€™t avoid
                                is database mapping, as in Embedded Value (268).
                                If you use one currency very frequently for literal amounts, a helper constructor can be useful.
                                <pre>class Money...
                                public static Money dollars(double amount) {
                                return new Money(amount, Currency.USD);
                                }
                                As Money is a Value Object (486) youâ€™ll need to define equals.
                                class Money...
                                public boolean equals(Object other) {
                                return (other instanceof Money) && equals((Money)other);
                                }
                                public boolean equals(Money other) {
                                return currency.equals(other.currency) && (amount == other.amount);
                                }</pre>
                                And wherever thereâ€™s an equals there should be a hash.
                                <pre>class Money...
                                public int hashCode() {
                                return (int) (amount ^ (amount >>> 32));
                                }</pre>
                                Weâ€™ll start going through the arithmetic with addition and subtraction.
                                <pre>class Money...
                                public Money add(Money other) {
                                assertSameCurrencyAs(other);
                                return newMoney(amount + other.amount);
                                }
                                private void assertSameCurrencyAs(Money arg) {
                                Assert.equals("money math mismatch", currency, arg.currency);
                                }
                                private Money newMoney(long amount) {
                                Money money = new Money();
                                money.currency = this.currency;
                                money.amount = amount;
                                return money;
                                }</pre>
                                Note the use of a private factory method here that doesnâ€™t do the usual conversion into the cent-based amount. Weâ€™ll use that a few times inside the Money
                                code itself.
                                With addition defined, subtraction is easy.
                                <pre>class Money...
                                public Money subtract(Money other) {
                                assertSameCurrencyAs(other);
                                return newMoney(amount - other.amount);
                                }
                                The base method for comparison is compareTo.
                                class Money...
                                public int compareTo(Object other) {
                                return compareTo((Money)other);
                                }
                                public int compareTo(Money other) {
                                assertSameCurrencyAs(other);
                                if (amount < other.amount) return -1;
                                else if (amount == other.amount) return 0;
                                else return 1;
                                }</pre>
                                Although thatâ€™s all you get on most Java classes these days, we find code is
                                more readable with the other comparison methods such as these.
                                <pre>class Money...
                                public boolean greaterThan(Money other) {
                                return (compareTo(other) > 0);
                                }</pre>
                                Now weâ€™re ready to look at multiplication. Weâ€™re providing a default rounding mode but you can set one yourself as well.
                                <pre>class Money...
                                public Money multiply(double amount) {
                                return multiply(new BigDecimal(amount));
                                }
                                public Money multiply(BigDecimal amount) {
                                return multiply(amount, BigDecimal.ROUND_HALF_EVEN);
                                }
                                public Money multiply(BigDecimal amount, int roundingMode) {
                                return new Money(amount().multiply(amount), currency, roundingMode);
                                }</pre>
                                If you want to allocate a sum of money among many targets and you donâ€™t
                                want to lose cents, youâ€™ll want an allocation method. The simplest one allocates
                                the same amount (almost) amongst a number of targets.
                                <pre>class Money...
                                public Money[] allocate(int n) {
                                Money lowResult = newMoney(amount / n);
                                Money highResult = newMoney(lowResult.amount + 1);
                                Money[] results = new Money[n];
                                int remainder = (int) amount % n;
                                for (int i = 0; i < remainder; i++) results[i] = highResult;
                                for (int i = remainder; i < n; i++) results[i] = lowResult;
                                return results;
                                }</pre>
                                A more sophisticated allocation algorithm can handle any ratio.
                                <pre>class Money...
                                public Money[] allocate(long[] ratios) {
                                long total = 0;
                                for (int i = 0; i < ratios.length; i++) total += ratios[i];
                                long remainder = amount;
                                Money[] results = new Money[ratios.length];
                                for (int i = 0; i < results.length; i++) {
                                results[i] = newMoney(amount * ratios[i] / total);
                                remainder -= results[i].amount;
                                }
                                for (int i = 0; i < remainder; i++) {
                                results[i].amount++;
                                }
                                return results;
                                }</pre>
                                You can use this to solve Foemmelâ€™s Conundrum.
                                <pre>class Money...
                                public void testAllocate2() {
                                long[] allocation = {3,7};
                                Money[] result = Money.dollars(0.05).allocate(allocation);
                                assertEquals(Money.dollars(0.02), result[0]);
                                assertEquals(Money.dollars(0.03), result[1]);
                                }</pre></p>
                <h3 id="496">Special Case</h3>
                <p><img src="img/part2.44.png" alt="no img" style="margin-left: 200px;"></p>
                <p>A subclass that provides special behavior for particular cases.
                                Nulls are awkward things in object-oriented programs because they defeat
                                polymorphism. Usually you can invoke foo freely on a variable reference of a
                                given type without worrying about whether the item is the exact type or a subclass. With a strongly typed language you can even have the compiler check
                                that the call is correct. However, since a variable can contain null, you may run
                                into a runtime error by invoking a message on null, which will get you a nice,
                                friendly stack trace.
                                If itâ€™s possible for a variable to be null, you have to remember to surround it
                                with null test code so youâ€™ll do the right thing if a null is present. Often the right
                                thing is the same in many contexts, so you end up writing similar code in lots of
                                placesâ€”committing the sin of code duplication.
                                Nulls are a common example of such problems and others crop up regularly.
                                In number systems you have to deal with infinity, which has special rules for
                                things like addition that break the usual invariants of real numbers. One of my
                                earliest experiences in business software was with a utility customer who wasnâ€™t
                                fully known, referred to as â€œoccupant.â€ All of these imply altering the usual
                                behavior of the type.
                                Instead of returning null, or some odd value, return a Special Case that has
                                the same interface as what the caller expects.</p>
                <h3 id="497">How It Works</h3>
                <p>The basic idea is to create a subclass to handle the Special Case. Thus, if you
                                have a customer object and you want to avoid null checks, you make a null customer object. Take all of the methods for customer and override them in the
                                Special Case to provide some harmless behavior. Then, whenever you have a
                                null, put in an instance of null customer instead.
                                Thereâ€™s usually no reason to distinguish between different instances of null
                                customer, so you can often implement a Special Case with a flyweight [Gang of
                                Four]. You canâ€™t do it all the time. For a utility you can accumulate charges
                                against an occupant customer even you canâ€™t do much billing, so itâ€™s important
                                to keep your occupants separate.</p>
                <p>A null can mean different things. A null customer may mean no customer or
                                it may mean that thereâ€™s a customer but we donâ€™t know who it is. Rather than
                                just using a null customer, consider having separate Special Cases for missing
                                customer and unknown customer.
                                A common way for a Special Case to override methods is to return another
                                Special Case, so if you ask an unknown customer for his last bill, you may well
                                get an unknown bill.
                                IEEE 754 floating-point arithmetic offers good examples of Special Case
                                with positive infinity, negative infinity, and not-a-number (NaN). If you divide
                                by zero, instead of getting an exception that you have to deal with, the system
                                just returns NaN, and NaN participates in arithmetic just like any other floating point number.</p>
                <h3 id="497(2)">When to Use It</h3>
                <p>Use Special Case whenever you have multiple places in the system that have the
                                same behavior after a conditional check for a particular class instance, or the
                                same behavior after a null check.</p>
                <h3 id="497(3)">Further Reading</h3>
                <p>I havenâ€™t seen Special Case written up as a pattern yet, but Null Object has been
                                written up in [Woolf]. If youâ€™ll pardon the unresistable pun, I see Null Object as
                                special case of Special Case.
                                498 BASE PATTERNS
                                Special Case</p>
                <h3 id="498">Example: A Simple Null Object (C#)</h3>
                <p>Hereâ€™s a simple example of Special Case used as a null object.
                                We have a regular employee.
                                <pre>class Employee...
                                public virtual String Name {
                                get {return _name;}
                                set {_name = value;}
                                }
                                private String _name;
                                public virtual Decimal GrossToDate {
                                get {return calculateGrossFromPeriod(0);}
                                }
                                public virtual Contract Contract {
                                get {return _contract;}
                                }
                                private Contract _contract;
                                The features of the class could be overridden by a null employee
                                class NullEmployee : Employee, INull...
                                public override String Name {
                                get {return "Null Employee";}
                                set {}
                                }
                                public override Decimal GrossToDate {
                                get {return 0m;}
                                }
                                public override Contract Contract {
                                get {return Contract.NULL;}
                                }</pre>
                                Notice that when you ask a null employee for its contract you get a null contract back.
                                The default values here avoid a lot of null tests if they end up with the same
                                null values. The repeated null values are handled by the null object by default.
                                You can also test for nullness explicitly either by giving the customer an isNull
                                method or by using a type test for a marker interface.</p>
                <h3 id="499">Plugin</h3>
                <p><img src="img/part2.45.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Links classes during configuration rather than compilation.
                                Separated Interface (476) is often used when application code runs in multiple
                                runtime environments, each requiring different implementations of particular
                                behavior. Most developers supply the correct implementation by writing a factory method. Suppose you define your primary key generator with a Separated
                                Interface (476) so that you can use a simple in-memory counter for unit testing
                                but a database-managed sequence for production. Your factory method will
                                most likely contain a conditional statement that looks at a local environment
                                variable, determines if the system is in test mode, and returns the correct key
                                generator. Once you have a few factories you have a mess on your hands.
                                Establishing a new deployment configurationâ€”say â€œexecute unit tests against
                                in-memory database without transaction controlâ€ or â€œexecute in production
                                mode against DB2 database with full transaction controlâ€â€”requires editing
                                conditional statements in a number of factories, rebuilding, and redeploying.
                                Configuration shouldnâ€™t be scattered throughout your application, nor should it
                                require a rebuild or redeployment. Plugin solves both problems by providing
                                centralized, runtime configuration.</p>
                <h3 id="499(2)">How It Works</h3>
                The first thing to do is define with a Separated Interface (476) any behaviors that
                                will have different implementations based on runtime environment. Beyond that,
                                we use the basic factory pattern, only with a few special requirements. The
                                Plugin factory requires its linking instructions to be stated at a single, external
                                point in order that configuration can be easily managed. Additionally, the
                                linking to implementations must occur dynamically at runtime rather than
                                during compilation, so that reconfiguration wonâ€™t require a rebuild.
                <p><img src="img/figure 18.2.png" alt="no img" style="margin-left: 200px;"></p>
                                A text file works quite well as the means of stating linking rules. The Plugin
                                factory will simply read the text file, look for an entry specifying the implementation of a requested interface, and return that implementation.
                                Plugin works best in a language that supports reflection because the factory
                                can construct implementations without compile-time dependencies on them.
                                When using reflection, the configuration file must contain mappings of interface
                                names to implementation class names. The factory can sit independently in a
                                framework package and neednâ€™t be changed when you add new implementations to your configuration options.
                                Even when not using a language that supports reflection itâ€™s still worthwhile
                                to establish a central point of configuration. You can even use a text file to set
                                up linking rules, with the only difference that your factory will use conditional
                                logic to map an interface to the desired implementation. Each implementation
                                type must be accounted for in the factoryâ€”not a big a deal in practice. Just add
                                another option within the factory method whenever you add a new implementation to the code base. To enforce layer and package dependencies with a
                                build-time check, place this factory in its own package to avoid breaking your
                                build process.</p>
                <h3 id="500">When to Use It</h3>
                <p>Use Plugin whenever you have behaviors that require different implementations
                                based on runtime environment.</p>
                <h3 id="501">Example: An Id Generator (Java)</h3>
                <p>As discussed above, key, or ID, generation is a task whose implementation
                                might vary between deployment environments (Figure 18.3).
                                First weâ€™ll write the IdGenerator Separated Interface (476) as well as any
                                needed implementations.
                                <pre>interface IdGenerator...
                                public Long nextId();
                                class OracleIdGenerator implements IdGenerator...
                                public OracleIdGenerator() {
                                this.sequence = Environment.getProperty("id.sequence");
                                this.datasource = Environment.getProperty("id.source");
                                }</pre>
                <p><img src="img/figure 18.3.png" alt="no img" style="margin-left: 200px;"></p>
                                In the OracleIdGenerator, nextId() selects the next available number out of the
                                defined sequence from the defined data source.
                                <pre>class Counter implements IdGenerator...
                                private long count = 0;
                                public synchronized Long nextId() {
                                return new Long(count++);
                                }
                                Now that we have something to construct, letâ€™s write the plugin factory that
                                will realize the current interface-to-implementation mappings.
                                class PluginFactory...
                                private static Properties props = new Properties();
                                static {
                                try {
                                String propsFile = System.getProperty("plugins");
                                props.load(new FileInputStream(propsFile));
                                } catch (Exception ex) {
                                throw new ExceptionInInitializerError(ex);
                                }
                                }
                                public static Object getPlugin(Class iface) {
                                String implName = props.getProperty(iface.getName());
                                if (implName == null) {
                                throw new RuntimeException("implementation not specified for " +
                                iface.getName() + " in PluginFactory propeties.");
                                }
                                try {
                                return Class.forName(implName).newInstance();
                                } catch (Exception ex) {
                                throw new RuntimeException("factory unable to construct instance of " +
                                iface.getName());
                                }
                                }</pre>
                                Note that weâ€™re loading the configuration by looking for a system property
                                named plugins that will locate the file containing our linking instructions.
                                Many options exist for defining and storing linking instructions, but we find a
                                simple properties file the easiest. Using the system property to find the file
                                rather than looking on the classpath makes it simple to specify a new configuration anywhere on your machine. This can be very convenient when moving
                                builds between development, test, and production environments. Hereâ€™s how
                                two different configuration files, one for test and one for production, might
                                look:
                                <pre>config file test.properties...
                                # test configuration
                                IdGenerator=TestIdGenerator
                                config file prod.properties...
                                # production configuration
                                IdGenerator=OracleIdGenerator</pre>
                                Letâ€™s go back to the IdGenerator interface and add a static INSTANCE member
                                thatâ€™s set by a call to the Plugin factory. It combines Plugin with the singleton
                                pattern to provide an extremely simple, readable call to obtain an ID.
                                <pre>interface IdGenerator...
                                public static final IdGenerator INSTANCE =
                                (IdGenerator) PluginFactory.getPlugin(IdGenerator.class);
                                We can now make that call knowing that weâ€™ll get the right ID for the right
                                environment.
                                class Customer extends DomainObject...
                                private Customer(String name, Long id) {
                                super(id);
                                this.name = name;
                                }
                                public Customer create(String name) {
                                Long newObjId = IdGenerator.INSTANCE.nextId();
                                Customer obj = new Customer(name, newObjId);
                                obj.markNew();
                                return obj;
                                }</pre></p>
                <h3 id="504">Service Stub</h3>
                <p><img src="img/part2.46.png" alt="no img" style="margin-left: 200px;"></p>
                <p>Removes dependence upon problematic services during testing.
                                Enterprise systems often depend on access to third-party services such as credit
                                scoring, tax rate lookups, and pricing engines. Any developer who has built
                                such a system can speak to the frustration of being dependent on resources
                                completely out of his control. Feature delivery is unpredictable, and as these
                                services are often remote reliability and performance can suffer as well.
                                At the very least these problems slow the development process. Developers
                                sit around waiting for the service to come back on line or maybe put some
                                hacks into the code to compensate for yet to be delivered features. Much worse,
                                and quite likely, such dependencies will lead to times when tests canâ€™t execute.
                                When tests canâ€™t run the development process is broken.
                                Replacing the service during testing with a Service Stub that runs locally,
                                fast, and in memory improves your development experience.</p>
                <h3 id="504(2)">How It Works</h3>
                <p>The first step is to define access to the service with a Gateway (466). The Gateway (466) should not be a class but rather a Separated Interface (476) so you
                                can have one implementation that calls the real service and at least one thatâ€™s
                                only a Service Stub. The desired implementation of the Gateway (466) should
                                be loaded using a Plugin (499). The key to writing a Service Stub is that you
                                keep it as simple as possibleâ€”complexity will defeat your purpose.
                                Letâ€™s walk through the process of stubbing a sales tax service that provides
                                state sales tax amount and rate, given an address, product type, and sales
                                amount. The simplest way to provide a Service Stub is to write two or three
                                lines of code that use a flat tax rate to satisfy all requests.
                                Tax laws arenâ€™t that simple, of course. Certain products are exempt from
                                taxation in certain states, so we rely on our real tax service to know which
                                product and state combinations are tax exempt. However, a lot of our application functionality depends on whether taxes are charged, so we need to accommodate tax exemption in our Service Stub. The simplest means of adding this
                                behavior to the stub is via a conditional statement that exempt a specific combination of address and product and then uses that same data in any relevant
                                test cases. The number of lines of code in our stub can still be counted on one
                                hand.</p>
                <p>A more dynamic Service Stub maintains a list of exempt product and state
                                combinations, allowing test cases to add to it. Even here weâ€™re at about 10 lines
                                of code. Weâ€™re keeping things simple given our aim of speeding the development
                                process.
                                The dynamic Service Stub brings up an interesting question regarding the
                                dependency between it and test cases. The Service Stub relies on a setup method
                                for adding exemptions that isnâ€™t in the original tax service Gateway (466) interface. To take advantage of a Plugin (499) to load the Service Stub, this method
                                must be added to the Gateway (466), which is fine as it doesnâ€™t add much noise
                                to your code and is done in the name of testing. Be sure that the Gateway (466)
                                implementation that calls the real service throws assertion failures within any
                                test methods.</p>
                <h3 id="505">When to Use It</h3>
                <p>Use Service Stub whenever you find that dependence on a particular service is
                                hindering your development and testing.
                                Many practitioners of Extreme Programming use the term Mock Object, for
                                a Service Stub. Weâ€™ve stuck with Service Stub because itâ€™s been around longer.</p>
                <h3 id="505(2)">Example: Sales Tax Service (Java)</h3>
                <p>Our application uses a tax service thatâ€™s deployed as a Web service. The first item
                                weâ€™ll take care of is defining a Gateway (466) so that our domain code isnâ€™t
                                forced to deal with the wonders of Web services. The Gateway (466) is defined
                                as an interface to facilitate loading of any Service Stubs that we write. Weâ€™ll use
                                Plugin (499) to load the correct tax service implementation.
                                <pre>interface TaxService...
                                public static final TaxService INSTANCE =
                                (TaxService) PluginFactory.getPlugin(TaxService.class);
                                public TaxInfo getSalesTaxInfo(String productCode, Address addr, Money saleAmount);
                                The simple flat rate Service Stub would look like this:
                                class FlatRateTaxService implements TaxService...
                                private static final BigDecimal FLAT_RATE = new BigDecimal("0.0500");
                                public TaxInfo getSalesTaxInfo(String productCode, Address addr, Money saleAmount) {
                                return new TaxInfo(FLAT_RATE, saleAmount.multiply(FLAT_RATE));
                                }</pre>
                                Hereâ€™s a Service Stub that provides tax exemptions for a particular address
                                and product combination:
                                <pre>class ExemptProductTaxService implements TaxService...
                                private static final BigDecimal EXEMPT_RATE = new BigDecimal("0.0000");
                                private static final BigDecimal FLAT_RATE = new BigDecimal("0.0500");
                                private static final String EXEMPT_STATE = "IL";
                                private static final String EXEMPT_PRODUCT = "12300";
                                public TaxInfo getSalesTaxInfo(String productCode, Address addr, Money saleAmount) {
                                if (productCode.equals(EXEMPT_PRODUCT) && addr.getStateCode().equals(EXEMPT_STATE)) {
                                return new TaxInfo(EXEMPT_RATE, saleAmount.multiply(EXEMPT_RATE));
                                } else {
                                return new TaxInfo(FLAT_RATE, saleAmount.multiply(FLAT_RATE));
                                }
                                }</pre>
                                Now hereâ€™s a more dynamic Service Stub whose methods allow a test case to
                                add and reset exemption combinations. Once we feel it necessary to add these
                                test methods we need to go back and add these methods to our simpler Service
                                Stubs as well as to the implementation that calls the actual tax Web service. The
                                unused test methods should all throw assertion failures.
                                <pre>class TestTaxService implements TaxService...
                                private static Set exemptions = new HashSet();
                                public TaxInfo getSalesTaxInfo(String productCode, Address addr, Money saleAmount) {
                                BigDecimal rate = getRate(productCode, addr);
                                return new TaxInfo(rate, saleAmount.multiply(rate));
                                }
                                public static void addExemption(String productCode, String stateCode) {
                                exemptions.add(getExemptionKey(productCode, stateCode));
                                }
                                public static void reset() {
                                exemptions.clear();
                                }
                                private static BigDecimal getRate(String productCode, Address addr) {
                                if (exemptions.contains(getExemptionKey(productCode, addr.getStateCode()))) {
                                return EXEMPT_RATE;
                                } else {
                                return FLAT_RATE;
                                }
                                }</pre>
                                Not shown is the implementation that calls the Web service providing our
                                real tax data, to which our production Plugin (499) configuration would link
                                the tax service interface. Our test Plugin (499) configurations would link to the
                                appropriate Service Stub above.
                                Finally, any caller to the tax service must access the service via the Gateway
                                (466). We have a charge generator here that creates standard charges and then
                                calls the tax service in order to create any corresponding taxes.
                                <pre>class ChargeGenerator...
                                public Charge[] calculateCharges(BillingSchedule schedule) {
                                List charges = new ArrayList();
                                Charge baseCharge = new Charge(schedule.getBillingAmount(), false);
                                charges.add(baseCharge);
                                TaxInfo info = TaxService.INSTANCE.getSalesTaxInfo(
                                schedule.getProduct(), schedule.getAddress(), schedule.getBillingAmount());
                                if (info.getStateRate().compareTo(new BigDecimal(0)) > 0) {
                                Charge taxCharge = new Charge(info.getStateAmount(), true);
                                charges.add(taxCharge);
                                }
                                return (Charge[]) charges.toArray(new Charge[charges.size()]);
                                }</pre></p>
                <h3 id="508">Record Set</h3>
                <p><img src="img/part2.47.png" alt="no img" style="margin-left: 200px;"></p>
                <p>An in-memory representation of tabular data.
                                In the last twenty years, the dominant way to represent data in a database has
                                been the tabular relational form. Backed by database companies big and small,
                                and a fairly standard query language, almost every new development I see uses
                                relational data.
                                On top of this has come a wealth of tools for building UIâ€™s quickly. These
                                data-aware UI frameworks rely on the fact that the underlying data is relational, and they provide UI widgets of various kinds that make it easy to view
                                and manipulate this data with almost no programming.
                                The dark side of these environments is that, while they make display and
                                simple updates ridiculously easy, they have no real facilities in which to place
                                business logic. Any validations beyond â€œis this a valid date,â€ and any business
                                rules or computations have no good place to go. Either theyâ€™re jammed into the
                                database as stored procedures or theyâ€™re mingled with UI code.
                                The idea of the Record Set is to give you your cake and let you eat it, by providing an in-memory structure that looks exactly like the result of an SQL
                                query but can be generated and manipulated by other parts of the system.</p>
                <h3 id="508(2)">How It Works</h3>
                <p>A Record Set is usually something that you wonâ€™t build yourself, provided by
                                the vendor of the software platform youâ€™re working with. Examples include the
                                data set of ADO.NET and the row set of JDBC 2.0.
                                The first essential element of a Record Set is that it looks exactly like the
                                result of a database query. That means you can use the classical two-tier
                                approach of issuing a query and throwing the data directly into a data-aware UI
                                with all the ease that these two-tier tools give you. The second essential element
                                is that you can easily build a Record Set yourself or take one that has resulted
                                from a database query and easily manipulate it with domain logic code.
                                Although platforms often give you a Record Set, you can create one yourself.
                                The problem is that there isnâ€™t that much point without the data-aware UI
                                tools, which you would also need to create yourself. In any case itâ€™s fair to say
                                that building a Record Set structure as a list of maps, which is common in
                                dynamically typed scripting languages, is a good example of this pattern.
                                The ability to disconnect the Record Set from its link to the data source is
                                very valuable. This allows you to pass the Record Set around a network without having to worry about database connections. Furthermore, if you can then
                                easily serialize the Record Set it can also act as a Data Transfer Object (401) for
                                an application.</p>
                <p>Disconnection raises the question of what happens when you update the
                                Record Set. Increasingly platforms are allowing the Record Set to be a form of
                                Unit of Work (184), so you can modify it and then return it to the data source to
                                be committed. A data source can typically use Optimistic Offline Lock (416) to
                                see if there are any conflicts and, if not, write the changes out to the database.
                                Explicit Interface Most Record Set implementations use an implicit interface.
                                This means that to get information out of the Record Set you invoke a generic
                                method with an argument to indicate which field you want. For example, to get
                                the passenger on an airline reservation you use an expression like aReservation["passenger"]. An explicit interface requires a real reservation class with
                                defined methods and properties. With an explicit reservation the expression for
                                a passenger might be aReservation.passenger.
                                Implicit interfaces are flexible in that you can use a generic Record Set for
                                any kind of data. This saves you having to write a new class every time you
                                define a new kind of Record Set. In general, however, I find implicit interfaces
                                to be a Bad Thing. If Iâ€™m programming with a reservation, how do I know how
                                to get the passenger? Is the appropriate string â€œpassengerâ€ or â€œguestâ€ or
                                â€œflyerâ€? The only way I can tell is to wander around the code base trying to find
                                where reservations are created and used. If I have an explicit interface I can
                                look at the definition of the reservation to see what property I need.
                                This problem is exacerbated with statically typed languages. If I want the last
                                name of the passenger, I have to resort to some horrible expression such as ((Person)aReservation["passenger"]).lastName, but then the compiler loses all type information and I have to manually enter it in to get the information I want. An explicit
                                interface can keep the type information so I can use aReservation.passenger.lastName.</p>
                <p>For these reasons, I generally frown on implicit interfaces (and their evil
                                cousin, passing data around in dictionaries). Iâ€™m also not too keen on them with
                                Record Sets, but the saving grace here is that the Record Set usually carries
                                information on the legal columns in it. Furthermore, the column names are
                                defined by the SQL that creates the Record Set, so itâ€™s not too difficult to find
                                the properties when you need them.
                                But itâ€™s nice to go further and have an explicit interface. ADO.NET provides
                                this with its strongly typed data sets, generated classes that provide an explicit
                                and fully typed interface for a Record Set. Since an ADO.NET data set can contain many tables and the relationships between them, strongly typed data sets
                                also provide properties that can use that relationship information. The classes
                                are generated from the XSD data set definition.
                                Implicit interfaces are more common, so Iâ€™ve used untyped data sets in my
                                examples for this book. For production code in ADO.NET, however, I suggest
                                using data sets that are typed. In a non-ADO.NET environment, I suggest using
                                code generation for your own explicit Record Sets.</p>
                <h3 id="510">When to Use It</h3>
                <p>To my mind the value of Record Set comes from having an environment that
                                relies on it as a common way of manipulating data. A lot of UI tools use Record
                                Set, and thatâ€™s a compelling reason to use them yourself. If you have such an
                                environment, you should use Table Module (125) to organize your domain
                                logic: Get a Record Set from the database; pass it to a Table Module (125) to
                                calculate derived information; pass it to a UI for display and editing; and pass it
                                back to a Table Module (125) for validation. Then commit the updates to the
                                database.
                                In many ways the tools that make Record Set so valuable appeared because
                                of the ever-presence of relational databases and SQL and the absence of any
                                real alternative structure and query language. Now, of course, thereâ€™s XML,
                                which has a widely standardized structure and a query language in XPath, and I
                                think itâ€™s likely that weâ€™ll see tools that use a hierarchic structure in the same
                                way that current tools now use Record Set. Perhaps this is actually a particular
                                case of a more generic pattern: something like Generic Data Structure. But Iâ€™ll
                                leave thinking about that pattern until then.
                                511</p>
                <h2 id="511">References</h2>
                <p><pre>[Alexander et al.]
                                Alexander, et al. A Pattern Language. Oxford, 1977.
                                An inspiration for many people in the patterns movement. Iâ€™m less
                                enamored of it than most, but itâ€™s worth looking at to understand an
                                approach that so many draw so much from.
                                [Alpert et al.]
                                Alpert, Brown and Woolf. Design Patterns Smalltalk Companion. AddisonWesley, 1998.
                                Little known outside the Smalltalk community, this book expands and
                                explains many of the classic patterns.
                                [Alur et al.]
                                Alur, Crupi, and Malks. Core J2EE Patterns: Best Practices and Design Strategies. Prentice Hall, 2001.
                                One of the new wave of patterns books that put new life into the form.
                                Although the patterns are expressed specifically for the J2EE platform,
                                most also make sense in other places.
                                [Ambler]
                                http://www.ambysoft.com/mappingObjects.html
                                A useful source of ideas on object-relational mapping.
                                [Beck XP 2000]
                                Beck, Extreme Programming Explained. Addison-Wesley, 2000.
                                The manifesto for Extreme Programming. It should be read by anyone
                                interested in software process.
                                [Beck Patterns]
                                Beck. Smalltalk Best Practice Patterns. Prentice Hall, 1997.
                                Undeservedly little read because of its Smalltalk base. It has more good
                                advice for other OO languages than most books that are specially written
                                for them. The only downside is that you might realize how much we all
                                miss by not programming in Smalltalk.
                                [Beck TDD]
                                Beck. Test-Driven Development: By Example. Addison-Wesley, 2003.
                                Due to be out on the same day as this book. TDD is Kentâ€™s guide to the
                                tight cycle of testing and refactoring that can evolve a design.
                                [Bernstein and Newcomer]
                                Bernstein and Newcomer. Principles of Transaction Processing. Morgan Kaufmann, 1997.
                                An excellent introduction to the head-hurting world of transactions.
                                [Brown et al.]
                                Brown et al. Enterprise Java Programming with IBM Websphere. Addison-Wesley, 2001.
                                Although two-thirds of this book is a software manual, the other third
                                packs more good design advice than do most entire books devoted to the
                                subject.
                                [Brown and Whitenack]
                                http://members.aol.com/kgb1001001/Chasms.htm
                                One of the earliest, and best, papers on object-relational mapping.
                                [Cockburn UC]
                                Cockburn. Writing Effective Use Cases. Addison-Wesley, 2001.
                                By far the best reference on use cases.
                                [Cockburn PloP]
                                Cockburn, â€œPrioritizing Forces in Software Design,â€ in [PLoPD 2].
                                A discussion of application boundaries.
                                REFERENCES 513
                                [Coleman et al.]
                                Coleman, Arnold, and Bodoff. Object-Oriented Development: The Fusion
                                Method, Second Edition. Prentice Hall, 2001.
                                Although much of this pre-UML book is primarily of historic interest, its
                                discussion of the interface model is very helpful to those designing a service
                                layer.
                                [Evans and Fowler]
                                http://martinfowler.com/apsupp/spec.pdf
                                A discussion of the Specification pattern.
                                [Evans]
                                Evans. Domain Driven. Addison Wesley, in preparation.
                                A book on developing domain models. Although I donâ€™t usually like to
                                reference books not yet published, the manuscript promises a fascinating
                                discussion of an important and difficult aspect of enterprise application
                                developments.
                                [Fowler Temporal Patterns]
                                http://martinfowler.com/ap2/timeNarrative.html
                                Patterns dealing with object histories that change over time.
                                [Fowler AP]
                                Fowler. Analysis Patterns. Addison-Wesley, 1997.
                                Domain model patterns.
                                [Fowler Refactoring]
                                Fowler, Refactoring. Addison-Wesley, 1999.
                                A technique for improving the design of an existing code base.
                                [Fowler CI]
                                http://martinfowler.com/articles/continuousIntegration.html
                                An essay that explains how to automatically build software several times a
                                day.
                                514 REFERENCES
                                [Gang of Four]
                                Gamma, Helm, Johnson, and Vlissides. Design Patterns. Addison-Wesley, 1995.
                                The seminal book on patterns.
                                [Hay]
                                Hay. Data Model Patterns. Dorset House, 1995.
                                Patterns of conceptual models from a relational perspective.
                                [Jacobson et al.]
                                Jacobson et al. Object-Oriented Software Engineering. Addison-Wesley, 1992.
                                An early book on OO design; introduces use cases and the interfacecontroller-entity approach to design.
                                [Keller and Coldewey]
                                http://www.objectarchitects.de/ObjectArchitects/orpatterns/index.htm
                                An excellent resource for object-relational mapping.
                                [Kirtland]
                                Kirtland. Designing Component-Based Applications. Microsoft Press, 1998.
                                Description of the DNA architecture.
                                [Knight and Dai]
                                Knight and Dai. â€œObjects and the Web.â€ IEEE Software, March/April 2002.
                                An excellent paper on model view controller, its evolution and use in Web
                                applications.
                                [Larman]
                                Larman. Applying UML and Patterns, Second Edition. Prentice Hall, 2001.
                                Currently my first-choice introduction to OO design.
                                [Lea]
                                Lea. Concurrent Programming in Java, Second Edition. Addison-Wesley, 2000.
                                If you want to program with multiple threads, you need to understand this
                                book first.
                                REFERENCES 515
                                [Marinescu]
                                Marinescu. EJB Design Patterns. New York: John Wiley, 2002.
                                Recent patterns book for Javaâ€™s EJB.
                                [Martin and Odell]
                                Martin and Odell. Object Oriented Methods: A Foundation (UML Edition).
                                Prentice Hall, 1998.
                                Object modeling from a conceptual perspective, as well as investigation
                                into the foundations of what modeling is about.
                                [Nilsson]
                                Nilsson. .NET Enterprise Design with Visual Basic .NET and SQL Server 2000.
                                Sams, 2002.
                                A solid book on architecture for the Microsoft platform.
                                [Peckish]
                                two million (see page 79)
                                [PLoPD 2]
                                Vlissides, Coplien, and Kerth (eds.). Pattern Languages of Program Design 2.
                                Addison-Wesley, 1996.
                                Compendium of patterns papers.
                                [PLoPD 3]
                                Martin, Buschmann, and Rielhe (eds.). Pattern Languages of Program Design 3.
                                Addison-Wesley, 1998.
                                Compendium of patterns papers.
                                [POSA]
                                Buschmann et al. Pattern-Oriented Software Architecture. Wiley, 2000.
                                The best book on broader architectural patterns.
                                [Riehle et al.]
                                Riehle, Siberski, Baumer, Megert, and Zullighoven. â€œSerializer,â€ in [PLoPD 3].
                                In-depth description of serialization of object structures, particularly when
                                you need to serialize into different forms.
                                516 REFERENCES
                                [Schmidt]
                                Schmidt, Stal, Rohnert, and Buschmann. Pattern-Oriented Software Architecture,
                                Volume 2. New York: John Wiley, 2000.
                                Patterns for concurrent and distributed systems. More for people who
                                design application servers than for those who use application servers, but
                                itâ€™s good to have some knowledge of these ideas when you use the results.
                                [Snodgrass]
                                Snodgrass. Developing Time-Oriented Database Applications in SQL. MorganKaufmann, 1999.
                                How to deal with tracking historic information in relational databases.
                                [Struts]
                                http://jakarta.apache.org/struts/
                                A Web presentation framework for Java thatâ€™s growing in popularity.
                                [Waldo et al.]
                                Waldo, Wyant, Wollrath, and Kendall. A Note on Distributed Computing. SMLI
                                TR-94-29, http://research.sun.com/technical-reports/1994/smli_tr-94-29.pdf, Sun
                                Microsystems, 1994.
                                A classic paper on why â€œtransparent distributed objectsâ€ is a dangerous
                                oxymoron.
                                [wiki]
                                http://c2.com/cgi/wiki
                                The original wiki web, developed by Ward Cunningham. A rambling but
                                fascinating open Web site where all sorts of people share all sorts of ideas.
                                [Woolf]
                                Woolf. â€œNull Object,â€ in [PLoPD 3].
                                A description of the Null Object pattern.
                                [Yoder]
                                http://www.joeyoder.com/Research/objectmappings
                                A good source of object-relational patterns.</pre></p>
                <h3 id="517">Index</h3>
                <p><pre>A ACID (atomicity, consistency, isolation, and durability), 71â€“76
                                business and system transactions, 74â€“76
                                reducing transaction isolation for liveness, 73â€“74
                                transactional resources, 72â€“73
                                Active Record, 160â€“64
                                example
                                simple person (Java), 162â€“64
                                how it works, 160â€“61
                                when to use it, 161â€“62
                                ADO.NET data sets, 148â€“51
                                Advice, some technology-specific,
                                100â€“103
                                Java and J2EE, 100â€“101
                                .NET, 101â€“2
                                stored procedures, 102â€“3
                                Web services, 103
                                Affinity, server, 85
                                Albums and tracks (Java), 264â€“67
                                Albums, transferring information about,
                                407â€“11
                                Application Controller, 379â€“86
                                example
                                state model Application Controller
                                (Java), 382â€“86
                                further reading, 382
                                how it works, 380â€“81
                                when to use it, 381â€“82
                                Application Controller, state model,
                                382â€“86
                                Application server concurrency, 78â€“80
                                Applications, evolution of layers in enterprise, 18â€“19
                                Architectural patterns, 33â€“38
                                Architectural patterns, data source,
                                143â€“81
                                Active Record, 160â€“64
                                Data Mapper, 165â€“81
                                Row Data Gateway, 152â€“59
                                Table Data Gateway, 144â€“51
                                ASP.NET server page (C#), 357â€“60
                                Association Table Mapping, 248â€“61
                                examples
                                employees and skills (C#), 250â€“53
                                using direct SQL (Java), 253â€“56
                                using single query for multiple
                                employees (Java), 256â€“61
                                how it works, 248â€“49
                                when to use it, 249
                                B
                                Base patterns, 465â€“510
                                Gateway, 466â€“72
                                Layer Supertype, 475
                                Mapper, 473â€“74
                                Money, 488â€“95
                                Plugin, 499â€“503
                                Record Set, 508â€“10
                                Registry, 480â€“85
                                Separated Interface, 476â€“79
                                Service Stub, 504â€“7
                                Special Case, 496â€“98
                                Value Object, 486â€“87
                                Behavioral patterns, object-relational,
                                183â€“214
                                Identity Map, 195â€“99
                                Lazy Load, 200â€“214
                                Unit of Work, 184â€“94
                                Behavioral problem, 38â€“39
                                Boosters, complexity, 24
                                518 Index
                                Boundaries, working with distribution,
                                91â€“92
                                Brown layers, 104
                                Business and system transactions, 74â€“76
                                Business logic, 20
                                C
                                C#
                                ASP.NET server page, 357â€“60
                                collection of references, 244â€“47
                                concrete players, 296â€“301
                                employees and skills, 250â€“53
                                integral key, 221â€“22
                                page handler with code behind, 340â€“43
                                Person Gateway, 146â€“48
                                players and their kin, 287â€“92
                                revenue recognition with Table Module,
                                129â€“32
                                simple null objects, 498
                                single table for players, 280â€“81
                                using ADO.NET data sets, 148â€“51
                                using ghosts, 206â€“14
                                Web service, 395â€“400
                                Cases, Special, 496â€“98
                                example
                                simple null objects (C#), 498
                                further reading, 497
                                how it works, 497
                                when to use it, 497
                                Class, money, 491â€“95
                                Class Table Inheritance, 285â€“92
                                example
                                players and their kin (C#), 287â€“92
                                further reading, 287
                                how it works, 285â€“86
                                when to use it, 286â€“87
                                Client Session State, 456â€“57
                                how it works, 456â€“57
                                when to use it, 457
                                Coarse-Grained Lock, 438â€“48
                                examples
                                root Optimistic Offline Lock (Java),
                                447â€“48
                                shared Optimistic Offline Lock
                                (Java), 441â€“46
                                shared Pessimistic Offline Lock
                                (Java), 446â€“47
                                how it works, 438â€“41
                                when to use it, 441
                                Committed, read, 73
                                Complexity boosters defined, 24
                                Compound key (Java), 224â€“35
                                Concrete players (C#), 296â€“301
                                Concrete Table Inheritance, 293â€“301
                                example
                                concrete players (C#), 296â€“301
                                how it works, 293â€“95
                                when to use it, 295â€“96
                                Concurrency, 63â€“80
                                application server, 78â€“80
                                application server concurrency, 78â€“80
                                concurrency problems, 64â€“65
                                execution contexts, 65â€“66
                                isolation and immutability, 66â€“67
                                off line, 75
                                offline, 63
                                optimistic and pessimistic concurrency
                                controls, 67â€“71
                                patterns for off line concurrency control, 76â€“78
                                Concurrency controls
                                optimistic and pessimistic, 67â€“71
                                ACID (atomicity, consistency, isolation, and durability), 71â€“76
                                deadlocks, 70â€“71
                                preventing inconsistent reads, 68â€“69
                                transactions, 71
                                patterns for offline, 76â€“78
                                Concurrency patterns, offline, 415â€“53
                                Connections, database, 50â€“52
                                Contexts, execution, 65â€“66
                                Controller, Front, 344â€“49
                                example
                                simple display (Java), 347â€“49
                                further reading, 347
                                how it works, 344â€“46
                                when to use it, 346
                                Controller, Page, 333â€“43
                                examples
                                page handler with code behind (C#),
                                340â€“43
                                simple display with JSP view (Java),
                                335â€“37
                                Index 519
                                simple display with servlet controller
                                (Java), 335â€“37
                                using JSP as handler (Java), 337â€“40
                                how it works, 333â€“34
                                when to use it, 334â€“35
                                Controller patterns, input, 61
                                Controllers
                                simple display with, 335â€“37
                                state model Application, 382â€“86
                                using JSP as view with separate, 355â€“57
                                Controllers, Application, 379â€“86
                                example
                                state model Application Controller
                                (Java), 382â€“86
                                further reading, 382
                                how it works, 380â€“81
                                when to use it, 381â€“82
                                Controls
                                optimistic and pessimistic concurrency,
                                67â€“71
                                ACID (atomicity, consistency, isolation, and durability), 71â€“76
                                deadlocks, 70â€“71
                                preventing inconsistent reads,
                                68â€“69
                                transactions, 71
                                patterns for offline concurrency,
                                76â€“78
                                Correctness, 65
                                Custom tags, JSP and, 374â€“78
                                D
                                Data
                                immutable, 67
                                reading in, 40â€“41
                                record, 83
                                Data holder for domain object (Java),
                                158â€“59
                                Data Mapper, 165â€“81
                                domain layer with, 421â€“25
                                examples
                                creating empty objects (Java), 179â€“81
                                separating finders (Java), 176â€“79
                                simple database mapper (Java),
                                171â€“76
                                how it works, 165â€“70
                                when to use it, 170â€“71
                                Data sets, ADO.NET, 148â€“51
                                Data source
                                architectural patterns, 143â€“81
                                Active Record, 160â€“64
                                Data Mapper, 165â€“81
                                Row Data Gateway, 152â€“59
                                Table Data Gateway, 144â€“51
                                for Domain Models, 98â€“99
                                logic, 20
                                Table Modules, 98
                                for Transaction Scripts, 97â€“98
                                Data source layers, down to, 97â€“100
                                data source for Domain Models, 98â€“99
                                data source for Transaction Scripts,
                                97â€“98
                                data source Table Modules, 98
                                presentation layers, 99â€“100
                                Data Transfer Objects, 401â€“13
                                examples
                                serializing using XML (Java), 411â€“13
                                transferring information about
                                albums (Java), 407â€“11
                                further reading, 407
                                how it works, 401â€“6
                                when to use it, 406
                                Database connections, 50â€“52
                                Database mapper, simple, 171â€“76
                                Database Session State, 462â€“64
                                how it works, 462â€“63
                                when to use it, 464
                                Databases
                                loading objects from, 281â€“84
                                mapping to relational, 33â€“53
                                architectural patterns, 33â€“38
                                behavioral problem, 38â€“39
                                building mapping, 47â€“49
                                database connections, 50â€“52
                                Databases, mapping to relational, continued
                                reading in data, 40â€“41
                                some miscellaneous points, 52â€“53
                                structural mapping patterns, 41â€“47
                                using metadata, 49â€“50
                                Deadlocks, 70â€“71
                                Department hierarchy, serializing, 274â€“77
                                520 Index
                                Dependent Mapping, 262â€“67
                                example
                                albums and tracks (Java), 264â€“67
                                how it works, 262â€“63
                                when to use it, 263â€“64
                                Dependents, finding personâ€™s, 325â€“26
                                Dirty reads, 74
                                Display, simple, 347â€“49
                                Distributed objects, allure of, 87â€“88
                                Distribution boundaries, working with,
                                91â€“92
                                Distribution, interfaces for, 92â€“93
                                Distribution patterns, 387â€“413
                                Data Transfer Objects, 401â€“13
                                Remote Facade, 388â€“400
                                Distribution strategies, 87â€“93
                                allure of distributed objects, 87â€“88
                                interfaces for distribution, 92â€“93
                                remote and local interfaces, 88â€“90
                                where you have to distribute, 90â€“91
                                working with distribution boundaries,
                                91â€“92
                                DNA layers, Microsoft, 105
                                Domain layer with Data Mappers (Java),
                                421â€“25
                                Domain layers, starting with, 96â€“97
                                Domain logic, 20
                                organizing, 25â€“32
                                making choices, 29â€“30
                                Service Layers, 30â€“32
                                patterns, 109â€“41
                                Domain Model, 116â€“24
                                Service Layer, 133â€“41
                                Table Module, 125â€“32
                                Transaction Script, 110â€“15
                                Domain Model, 116â€“24
                                data source for, 98â€“99
                                example
                                revenue recognition (Java),
                                120â€“24
                                further reading, 119â€“20
                                how it works, 116â€“19
                                when to use it, 119
                                Domain objects, data holder for, 158â€“59
                                Domain objects (Java), 475
                                E
                                EAI (Enterprise Application Integration),
                                468
                                Embedded Value, 268â€“71
                                example
                                simple value objects (Java), 270â€“71
                                further reading, 270
                                how it works, 268
                                when to use it, 268â€“69
                                Employees and skills (C#), 250â€“53
                                Employees, using single query for multiple, 256â€“61
                                Enterprise Application Integration (EAI),
                                468
                                Enterprise applications, evolution of layers
                                in, 18â€“19
                                Examples
                                albums and tracks (Java), 264â€“67
                                ASP.NET server page (C#), 357â€“60
                                collection of references (C#), 244â€“47
                                concrete players (C#), 296â€“301
                                data holder for domain object (Java),
                                158â€“59
                                domain objects (Java), 475
                                employees and skills (C#), 250â€“53
                                finding personâ€™s dependents (Java),
                                325â€“26
                                gateway to proprietary messaging service (Java), 468â€“72
                                Id Generator (Java), 501â€“3
                                implicit Pessimistic Offline Lock (Java),
                                451â€“53
                                integral key (C#), 221â€“22
                                lazy initialization (Java), 203
                                methods for Identity Map (Java),
                                198â€“99
                                money class (Java), 491â€“95
                                multitable find (Java}, 243â€“44
                                Person Gateway (C#), 146â€“48
                                person record (Java), 155â€“58
                                players and their kin (C#), 287â€“92
                                revenue recognition (Java), 120â€“24,
                                138â€“41
                                revenue recognition with Table Module
                                (C#), 129â€“32
                                root Optimistic Offline Lock (Java),
                                447â€“48
                                sales tax service (Java), 505â€“7
                                Index 521
                                separating finders (Java), 176â€“79
                                serializing department hierarchy in
                                XML (Java), 274â€“77
                                serializing using XML (Java), 411â€“13
                                shared Optimistic Offline Lock (Java),
                                441â€“46
                                shared Pessimistic Offline Lock (Java),
                                446â€“47
                                simple database mapper (Java), 171â€“76
                                simple display (Java), 347â€“49
                                simple display with servlet controller
                                (Java), 335â€“37
                                simple lock manager (Java), 431â€“37
                                simple null objects (C#), 498
                                simple person (Java), 162â€“64
                                simple Query Object (Java), 318â€“21
                                simple transform (Java), 363â€“64
                                simple value objects (Java), 270â€“71
                                single table for players (C#), 280â€“81
                                single-valued reference (Java), 240â€“43
                                singleton registry (Java), 483â€“84
                                state model Application Controller
                                (Java), 382â€“86
                                swapping Repository strategies (Java),
                                326â€“27
                                thread-safe registry (Java), 484â€“85
                                transferring information about albums
                                (Java), 407â€“11
                                two-stage XSLT (XSLT), 371â€“74
                                Unit of Work with object registration
                                (Java), 190â€“94
                                using ADO.NET data sets (C#),
                                148â€“51
                                using compound key (Java), 224â€“35
                                using direct SQL (Java), 253â€“56
                                using ghosts (C#), 206â€“14
                                using Java session been as Remote
                                Facade (Java), 392â€“95
                                using JSP as handler (Java), 337â€“40
                                using key table (Java), 222â€“24
                                using metadata and reflection(Java),
                                309â€“15
                                using single query for multiple employees (Java), 256â€“61
                                using value holder (Java), 205â€“6
                                virtual proxy (Java), 203â€“5
                                Web service (C#), 395â€“400
                                Execution contexts, 65â€“66
                                F
                                Facade, Remote, 388â€“400
                                examples
                                using Java session been as Remote
                                Facade (Java), 392â€“95
                                Web service (C#), 395â€“400
                                how it works, 389â€“92
                                when to use it, 392
                                Fields, Identity, 216â€“35
                                examples
                                integral key (C#), 221â€“22
                                using compound key (Java), 224â€“35
                                using key table (Java), 222â€“24
                                further reading, 221
                                how it works, 216â€“20
                                when to use it, 220â€“21
                                Find, multitable, 243â€“44
                                Finders, separating, 176â€“79
                                Foreign Key Mapping, 236â€“47
                                examples
                                collection of references (C#), 244â€“47
                                multitable find (Java}, 243â€“44
                                single-valued reference (Java),
                                240â€“43
                                how it works, 236â€“39
                                when to use it, 239â€“40
                                Front Controller, 344â€“49
                                example
                                simple display (Java), 347â€“49
                                further reading, 347
                                how it works, 344â€“46
                                when to use it, 346
                                G
                                Gateway, 466â€“72
                                example
                                gateway to proprietary messaging service (Java), 468â€“72
                                how it works, 466â€“67
                                Gateway, continued
                                Person, 146â€“48
                                when to use it, 467â€“68
                                Gateway, Row Data, 152â€“59
                                examples
                                data holder for domain object (Java),
                                158â€“59
                                522 Index
                                person record (Java), 155â€“58
                                how it works, 152â€“53
                                when to use it, 153â€“55
                                Gateway, Table Data, 144â€“51
                                examples
                                Person Gateway (C#), 146â€“48
                                using ADO.NET data sets (C#),
                                148â€“51
                                further reading, 146
                                how it works, 144â€“45
                                when to use it, 145â€“46
                                Gateway to proprietary messaging service
                                (Java), 468â€“72
                                Generator, Id, 501â€“3
                                Ghosts, 202, 206â€“14
                                Globally Unique IDentifier (GUID), 219
                                GUID (Globally Unique IDentifier), 219
                                H
                                Handlers
                                page, 340â€“43
                                using JSP as, 337â€“40
                                Hierarchy, serializing department, 274â€“77
                                Holder, using value, 205â€“6
                                I
                                Id Generator (Java), 501â€“3
                                Identity Field, 216â€“35
                                examples
                                integral key (C#), 221â€“22
                                using compound key (Java), 224â€“35
                                using key table (Java), 222â€“24
                                further reading, 221
                                how it works, 216â€“20
                                when to use it, 220â€“21
                                Identity Map, 195â€“99
                                example
                                methods for Identity Map (Java),
                                198â€“99
                                how it works, 195â€“97
                                methods for, 198â€“99
                                when to use it, 198
                                Immutability, isolation and, 66â€“67
                                Immutable data, 67
                                Implicit Lock, 449â€“53
                                example
                                implicit Pessimistic Offline Lock
                                (Java), 451â€“53
                                how it works, 450â€“51
                                when to use it, 451
                                Implicit Pessimistic Offline Lock (Java),
                                451â€“53
                                Inconsistent reads, 64
                                preventing, 68â€“69
                                Inheritance, 45â€“47
                                Inheritance, Class Table, 285â€“92
                                example
                                players and their kin (C#), 287â€“92
                                further reading, 287
                                how it works, 285â€“86
                                when to use it, 286â€“87
                                Inheritance, Concrete Table, 293â€“301
                                example
                                concrete players (C#), 296â€“301
                                how it works, 293â€“95
                                when to use it, 295â€“96
                                Inheritance Mappers, 302â€“4
                                how it works, 303â€“4
                                when to use it, 304
                                Inheritance, Single Table
                                example
                                single table for players (C#), 280â€“81
                                how it works, 278â€“79
                                loading objects from databases, 281â€“84
                                when to use it, 279â€“80
                                Initialization, lazy, 203
                                Input controller patterns, 61
                                Integral key (C#), 221â€“22
                                Interfaces
                                for distribution, 92â€“93
                                remote and local, 88â€“90
                                Separated, 476â€“79
                                how it works, 477â€“78
                                when to use it, 478â€“79
                                Isolated threads, 66
                                Isolation
                                and immutability, 66â€“67
                                reducing transaction for liveness,
                                73â€“74
                                J
                                J2EE, Java and, 100â€“101
                                J2EE layers, core, 104
                                Index 523
                                Java
                                albums and tracks, 264â€“67
                                creating empty objects, 179â€“81
                                data holder for domain object, 158â€“59
                                domain layer with Data Mappers,
                                421â€“25
                                domain objects, 475
                                finding personâ€™s dependents, 325â€“26
                                gateway to proprietary messaging service, 468â€“72
                                Id Generator, 501â€“3
                                and J2EE, 100â€“101
                                JSP and custom tags, 374â€“78
                                methods for Identity Map, 198â€“99
                                money class, 491â€“95
                                multitable find, 243â€“44
                                person record, 155â€“58
                                revenue recognition, 113â€“15, 120â€“24,
                                138â€“41
                                root Optimistic Offline Lock, 447â€“48
                                sales tax service, 505â€“7
                                separating finders, 176â€“79
                                serializing department hierarchy in
                                XML, 274â€“77
                                serializing using XML, 411â€“13
                                shared Optimistic Offline Lock, 441â€“46
                                shared Pessimistic Offline Lock, 446â€“47
                                simple database mapper, 171â€“76
                                simple display, 347â€“49
                                simple display with JSP view, 335â€“37
                                simple display with servlet controller,
                                335â€“37
                                simple person, 162â€“64
                                simple Query Object, 318â€“21
                                simple transform, 363â€“64
                                simple value objects, 270â€“71
                                single-valued reference (Java),
                                240â€“43
                                singleton registry, 483â€“84
                                state model Application Controller,
                                382â€“86
                                swapping Repository strategies,
                                326â€“27
                                thread-safe registry, 484â€“85
                                transferring information about albums,
                                407â€“11
                                Unit of Work with object registration,
                                190â€“94
                                using compound key, 224â€“35
                                using direct SQL, 253â€“56
                                using Java session bean as Remote
                                Facade, 392â€“95
                                using JSP as handler, 337â€“40
                                using JSP as view with separate controller, 355â€“57
                                using key table, 222â€“24
                                using metadata and reflection,
                                309â€“15
                                using single query for multiple employees, 256â€“61
                                using value holder, 205â€“6
                                Java session bean, using as Remote Facade
                                (Java), 392â€“95
                                JSP
                                using as handler, 337â€“40
                                using as view, 355â€“57
                                JSP and custom tags (Java), 374â€“78
                                JSP view, simple display with, 335â€“37
                                K
                                Key Mapping, Foreign, 236â€“47
                                Key table, 222â€“24
                                Keys
                                compound, 224â€“35
                                integral, 221â€“22
                                Kin, players and their, 287â€“92
                                L
                                Late transactions, 72
                                Layer Supertype, 475
                                example
                                domain objects (Java), 475
                                how it works, 475
                                when to use it, 475
                                Layering, 17â€“24
                                choosing to run your layers, 22â€“24
                                evolution of layers in enterprise applications, 18â€“19
                                schemes, 103â€“6
                                three principal layers, 19â€“22
                                Layers
                                Brown, 104
                                choosing to run your, 22â€“24
                                524 Index
                                core J2EE, 104
                                down to data source, 97â€“100
                                data source for Domain Models,
                                98â€“99
                                data source for Transaction Scripts,
                                97â€“98
                                data source Table Modules, 98
                                presentation layers, 99â€“100
                                Marinescu, 105
                                Microsoft DNA, 105
                                Nilsson, 106
                                presentation, 99â€“100
                                Service, 30â€“32
                                starting with domain, 96â€“97
                                three principal, 19â€“22
                                Layers, evolution of, 18â€“19
                                Layers, Service, 133â€“41
                                example
                                revenue recognition (Java), 138â€“41
                                further reading, 137
                                how it works, 134â€“37
                                when to use it, 137
                                Lazy initialization (Java), 203
                                Lazy Load, 200â€“214
                                examples
                                lazy initialization (Java), 203
                                using ghosts (C#), 206â€“14
                                using value holder (Java), 205â€“6
                                virtual proxy (Java), 203â€“5
                                how it works, 200â€“203
                                when to use it, 203
                                Liveness, 65
                                reducing transactions isolation for,
                                73â€“74
                                Load, Lazy, 200â€“214
                                examples
                                lazy initialization (Java), 203
                                using ghosts (C#), 206â€“14
                                using value holder (Java), 205â€“6
                                virtual proxy (Java), 203â€“5
                                how it works, 200â€“203
                                when to use it, 203
                                Loading, ripple, 202
                                LOBs (large objects), serialized, 272â€“77
                                example
                                serializing department hierarchy in
                                XML (Java), 274â€“77
                                how it works, 272â€“73
                                when to use it, 274
                                Local interfaces, remote and, 88â€“90
                                Lock manager, simple, 431â€“37
                                Locking
                                optimistic, 67
                                pessimistic, 67
                                Locks
                                root Optimistic Offline, 447â€“48
                                shared Optimistic Offline, 441â€“46
                                shared Pessimistic Offline, 446â€“47
                                Locks, Coarse-Grained, 438â€“48
                                examples
                                root Optimistic Offline Lock (Java),
                                447â€“48
                                shared Optimistic Offline Lock
                                (Java), 441â€“46
                                shared Pessimistic Offline Lock
                                (Java), 446â€“47
                                how it works, 438â€“41
                                when to use it, 441
                                Locks, Implicit, 449â€“53
                                example
                                implicit Pessimistic Offline Lock
                                (Java), 451â€“53
                                how it works, 450â€“51
                                when to use it, 451
                                Locks, implicit Pessimistic Offline, 451â€“53
                                Locks, Optimistic Offline, 416â€“25
                                example
                                domain layer with Data Mappers
                                (Java), 421â€“25
                                how it works, 417â€“20
                                when to use it, 420â€“21
                                Locks, Pessimistic Offline, 426â€“37
                                example
                                simple lock manager (Java),
                                431â€“37
                                how it works, 427â€“31
                                when to use it, 431
                                Logic
                                business, 20
                                data source, 20
                                domain, 20
                                organizing domain, 25â€“32
                                making choices, 29â€“30
                                Service Layers, 30â€“32
                                Index 525
                                presentation, 19â€“20
                                Logic patterns, domain, 109â€“41
                                Domain Model, 116â€“24
                                Service Layer, 133â€“41
                                Table Module, 125â€“32
                                Transaction Script, 110â€“15
                                Long transactions, 72
                                Lost updates, 64
                                M
                                Manager, simple lock, 431â€“37
                                Map, Identity, 195â€“99
                                example
                                methods for Identity Map (Java),
                                198â€“99
                                how it works, 195â€“97
                                when to use it, 198
                                Mapper, 473â€“74
                                how it works, 473
                                when to use it, 474
                                Mapper, Data, 165â€“81
                                examples
                                creating empty objects (Java), 179â€“81
                                separating finders (Java), 176â€“79
                                simple database mapper (Java),
                                171â€“76
                                how it works, 165â€“70
                                when to use it, 170â€“71
                                Mapper, simple database, 171â€“76
                                Mappers, domain layer with Data,
                                421â€“25
                                Mappers, Inheritance, 302â€“4
                                how it works, 303â€“4
                                when to use it, 304
                                Mapping, Association Table, 248â€“61
                                examples
                                employees and skills (C#), 250â€“53
                                using direct SQL (Java), 253â€“56
                                using single query for multiple
                                employees (Java), 256â€“61
                                how it works, 248â€“49
                                when to use it, 249
                                Mapping, building, 47â€“49
                                Mapping, Dependent, 262â€“67
                                example
                                albums and tracks (Java), 264â€“67
                                how it works, 262â€“63
                                when to use it, 263â€“64
                                Mapping, Foreign Key, 236â€“47
                                examples
                                collection of references (C#),
                                244â€“47
                                multitable find (Java}, 243â€“44
                                single-valued reference (Java),
                                240â€“43
                                how it works, 236â€“39
                                when to use it, 239â€“40
                                Mapping, Metadata
                                example
                                using metadata and reflection(Java),
                                309â€“15
                                how it works, 306â€“8
                                when to use it, 308â€“9
                                Mapping patterns
                                object-relational metadata, 305â€“27
                                Metadata Mapping, 306â€“15
                                Query Object, 316â€“21
                                Repository, 322â€“27
                                structural, 41â€“47
                                inheritance, 45â€“47
                                mapping relationships, 41â€“45
                                Mapping relationships, 41â€“45
                                Mapping to relational databases, 33â€“53
                                architectural patterns, 33â€“38
                                behavioral problem, 38â€“39
                                building mapping, 47â€“49
                                database connections, 50â€“52
                                reading in data, 40â€“41
                                some miscellaneous points, 52â€“53
                                structural mapping patterns, 41â€“47
                                using metadata, 49â€“50
                                Marinescu layers, 105
                                Messaging service, gateway to, 468â€“72
                                Metadata and reflection, using, 309â€“15
                                Metadata Mapping, 306â€“15
                                example
                                using metadata and reflection (Java),
                                309â€“15
                                Metadata Mapping, continued
                                how it works, 306â€“8
                                when to use it, 308â€“9
                                Metadata mapping patterns, objectrelational, 305â€“27
                                Metadata Mapping, 306â€“15
                                Query Object, 316â€“21
                                526 Index
                                Repository, 322â€“27
                                Metadata, using, 49â€“50
                                Microsoft DNA layers, 105
                                Migration, session, 85
                                Model, Domain, 116â€“24
                                example
                                revenue recognition (Java), 120â€“24
                                further reading, 119â€“20
                                how it works, 116â€“19
                                when to use it, 119
                                Model View Controller (MVC), 330â€“32
                                Models, data source for Domain, 98â€“99
                                Modules, data source Table, 98
                                Modules, Table, 125â€“32
                                example
                                revenue recognition with Table
                                Module (C#), 129â€“32
                                how it works, 126â€“28
                                when to use it, 128
                                Money, 488â€“95
                                example
                                money class (Java), 491â€“95
                                how it works, 488â€“90
                                when to use it, 490â€“91
                                Money class (Java), 491â€“95
                                Multiple employees, using single query for,
                                256â€“61
                                Multitable find (Java), 243â€“44
                                MVC (Model View Controller), 330â€“32
                                how it works, 330â€“32
                                when to use it, 332
                                N
                                .NET, 101â€“2
                                Nilsson layers, 106
                                Null objects, simple, 498
                                O
                                Object registration, 186
                                Object registration, Unit of Work with,
                                190â€“94
                                Object-relational behavioral patterns,
                                183â€“214
                                Identity Map, 195â€“99
                                Lazy Load, 200â€“214
                                Unit of Work, 184â€“94
                                Object-relational metadata mapping patterns, 305â€“27
                                Metadata Mapping, 306â€“15
                                Query Object, 316â€“21
                                Repository, 322â€“27
                                Object-relational structural patterns,
                                215â€“84
                                Association Table Mapping, 248â€“61
                                Class Table Inheritance, 285â€“92
                                Concrete Table Inheritance, 293â€“301
                                Dependent Mapping, 262â€“67
                                Embedded Value, 268â€“71
                                Foreign Key Mapping, 236â€“47
                                Identity Field, 216â€“35
                                Inheritance Mappers, 302â€“4
                                serialized LOBs (large objects), 272â€“77
                                Single Table Inheritance, 278â€“84
                                Object, simple Query, 318â€“21
                                Objects
                                allure of distributed, 87â€“88
                                creating empty, 179â€“81
                                domain, 475
                                loading from databases, 281â€“84
                                simple null, 498
                                simple value, 270â€“71
                                Objects, Data Transfer, 401â€“13
                                examples
                                serializing using XML (Java), 411â€“13
                                transferring information about
                                albums (Java), 407â€“11
                                further reading, 407
                                how it works, 401â€“6
                                when to use it, 406
                                Objects, Query, 316â€“21
                                example
                                simple Query Object (Java), 318â€“21
                                further reading, 318
                                how it works, 316â€“17
                                when to use it, 317â€“18
                                Objects, Value, 486â€“87
                                how it works, 486â€“87
                                when to use it, 487
                                Offline concurrency, 63, 75
                                Offline concurrency control, patterns for,
                                76â€“78
                                Offline concurrency patterns, 415â€“53
                                Coarse-Grained Lock, 438â€“48
                                Implicit Lock, 449â€“53
                                Optimistic Offline Lock, 416â€“25
                                Pessimistic Offline Lock, 426â€“37
                                Offline Lock, implicit Pessimistic, 451â€“53
                                Index 527
                                Offline Lock, Optimistic, 416â€“25
                                example
                                domain layer with Data Mappers
                                (Java), 421â€“25
                                how it works, 417â€“20
                                when to use it, 420â€“21
                                Offline Lock, Pessimistic, 426â€“37
                                example
                                simple lock manager (Java), 431â€“37
                                how it works, 427â€“31
                                when to use it, 431
                                Offline Lock, root Optimistic, 447â€“48
                                Offline Lock, shared Optimistic, 441â€“46
                                Offline Lock, shared Pessimistic, 446â€“47
                                Optimistic and pessimistic concurrency
                                controls, 67â€“71
                                Optimistic locking, 67
                                Optimistic Offline Lock, 416â€“25
                                example
                                domain layer with Data Mappers
                                (Java), 421â€“25
                                how it works, 417â€“20
                                root, 447â€“48
                                shared, 441â€“46
                                when to use it, 420â€“21
                                P
                                Page Controller, 333â€“43
                                examples
                                page handler with code behind (C#),
                                340â€“43
                                simple display with JSP view (Java),
                                335â€“37
                                simple display with servlet controller
                                (Java), 335â€“37
                                using JSP as handler (Java), 337â€“40
                                how it works, 333â€“34
                                when to use it, 334â€“35
                                Page handler with code behind,
                                340â€“43
                                Patterns
                                architectural, 33â€“38
                                base, 465â€“510
                                Gateway, 466â€“72
                                Layer Supertype, 475
                                Mapper, 473â€“74
                                Money, 488â€“95
                                Plugin, 499â€“503
                                Record Set, 508â€“10
                                Registry, 480â€“85
                                Separated Interface, 476â€“79
                                Service Stub, 504â€“7
                                Special Case, 496â€“98
                                Value Object, 486â€“87
                                data source architectural, 143â€“81
                                Active Record, 160â€“64
                                Data Mapper, 165â€“81
                                Row Data Gateway, 152â€“59
                                Table Data Gateway, 144â€“51
                                distribution, 387â€“413
                                Data Transfer Objects, 401â€“13
                                Remote Facade, 388â€“400
                                domain logic, 109â€“41
                                input controller, 61
                                mapping structural, 41â€“47
                                inheritance, 45â€“47
                                mapping relationships, 41â€“45
                                object-relational behavioral, 183â€“214
                                Identity Map, 195â€“99
                                Lazy Load, 200â€“214
                                Unit of Work, 184â€“94
                                object-relational metadata mapping,
                                305â€“27
                                Metadata Mapping, 306â€“15
                                Query Object, 316â€“21
                                Repository, 322â€“27
                                object-relational structural, 215â€“84
                                Association Table Mapping, 248â€“61
                                Class Table Inheritance, 285â€“92
                                Concrete Table Inheritance, 293â€“301
                                Dependent Mapping, 262â€“67
                                Embedded Value, 268â€“71
                                Foreign Key Mapping, 236â€“47
                                Identity Field, 216â€“35
                                Inheritance Mappers, 302â€“4
                                Serialized LOBs (large objects),
                                272â€“77
                                Single Table Inheritance, 278â€“84
                                Patterns, continued
                                offline concurrency, 415â€“53
                                Coarse-Grained Lock, 438â€“48
                                Implicit Lock, 449â€“53
                                Optimistic Offline Lock, 416â€“25
                                Pessimistic Offline Lock, 426â€“37
                                session state, 455â€“64
                                Client Session State, 456â€“57
                                Database Session State, 462â€“64
                                528 Index
                                Server Session State, 458â€“61
                                view, 58â€“60
                                Web presentation, 329â€“86
                                Application Controller, 379â€“86
                                Front Controller, 344â€“49
                                MVC (Model View Controller),
                                330â€“32
                                Page Controller, 333â€“43
                                Template View, 350â€“60
                                Transform View, 361â€“64
                                Two Step View, 365â€“78
                                Person Gateway (C#), 146â€“48
                                Person record (Java), 155â€“58
                                Person, simple, 162â€“64
                                Personâ€™s dependents, finding, 325â€“26
                                Pessimistic concurrency controls, optimistic and, 67â€“71
                                Pessimistic locking, 67
                                Pessimistic Offline Lock, 426â€“37
                                example
                                simple lock manager (Java),
                                431â€“37
                                how it works, 427â€“31
                                implicit, 451â€“53
                                shared, 446â€“47
                                when to use it, 431
                                Phantoms, 73
                                Plain old Java objects (POJOs), 392
                                Players
                                concrete, 296â€“301
                                single table for, 280â€“81
                                Players and their kin (C#), 287â€“92
                                Plugin, 499â€“503
                                example
                                Id Generator (Java), 501â€“3
                                how it works, 499â€“500
                                when to use it, 500
                                POJOs (plain old Java objects), 392
                                Presentation
                                layers, 99â€“100
                                logic, 19â€“20
                                Web, 55â€“61
                                Presentation patterns, Web, 329â€“86
                                Application Controller, 379â€“86
                                Front Controller, 344â€“49
                                MVC (Model View Controller), 330â€“32
                                Page Controller, 333â€“43
                                Template View, 350â€“60
                                Transform View, 361â€“64
                                Two Step View, 365â€“78
                                Problems
                                behavioral, 38â€“39
                                concurrency, 64â€“65
                                Procedures, stored, 102â€“3
                                Process-per-request, 78
                                Process-per-session, 78
                                Processes defined, 66
                                Proxy, virtual, 203â€“5
                                Putting it all together, 95â€“106
                                down to data source layers, 97â€“100
                                miscellaneous layering schemes, 103â€“6
                                some technology-specific advice,
                                100â€“103
                                starting with domain layers, 96â€“97
                                Q
                                Query Object, 316â€“21
                                example
                                simple Query Object (Java), 318â€“21
                                further reading, 318
                                how it works, 316â€“17
                                when to use it, 317â€“18
                                Query Object, simple, 318â€“21
                                Query, using single, 256â€“61
                                R
                                Read
                                inconsistent, 64
                                repeatable, 73
                                Read committed, 73
                                Read uncommitted, 74
                                Reads
                                dirty, 74
                                preventing inconsistent, 68â€“69
                                Temporal, 69
                                unrepeatable, 73
                                Record data, 83
                                Record Set, 508â€“10
                                how it works, 508â€“10
                                when to use it, 510
                                Records, Active, 160â€“64
                                example
                                simple person (Java), 162â€“64
                                how it works, 160â€“61
                                when to use it, 161â€“62
                                Index 529
                                References
                                collection of, 244â€“47
                                single-valued, 240â€“43
                                Reflection, using metadata and,
                                309â€“15
                                Registration
                                object, 186
                                Unit of Work with object, 190â€“94
                                Registry, 480â€“85
                                examples
                                singleton registry (Java), 483â€“84
                                thread-safe registry (Java), 484â€“85
                                how it works, 480â€“82
                                singleton, 483â€“84
                                thread-safe, 484â€“85
                                when to use it, 482â€“83
                                Relational databases, mapping to,
                                33â€“53
                                architectural patterns, 33â€“38
                                behavioral problem, 38â€“39
                                building mapping, 47â€“49
                                database connections, 50â€“52
                                reading in data, 40â€“41
                                some miscellaneous points, 52â€“53
                                structural mapping patterns, 41â€“47
                                using metadata, 49â€“50
                                Relationships, mapping, 41â€“45
                                Remote and local interfaces, 88â€“90
                                Remote Facade, 388â€“400
                                examples
                                using Java session been as Remote
                                Facade (Java), 392â€“95
                                Web service (C#), 395â€“400
                                how it works, 389â€“92
                                when to use it, 392
                                Remote Facade, using Java session bean
                                as, 392â€“95
                                Repeatable read, 73
                                Repository, 322â€“27
                                examples
                                finding personâ€™s dependents (Java),
                                325â€“26
                                swapping Repository strategies
                                (Java), 326â€“27
                                further reading, 325
                                how it works, 323â€“24
                                when to use it, 324â€“25
                                Repository strategies, swapping, 326â€“27
                                Request transactions, 72
                                Requests, 65
                                Resources, transactional, 72â€“73
                                Revenue recognition (Java), 113â€“15,
                                120â€“24
                                Revenue recognition problem, 112â€“13
                                Revenue recognition with Table Module
                                (C#), 129â€“32
                                Ripple loading, 202
                                Root Optimistic Offline Lock (Java),
                                447â€“48
                                Row Data Gateway, 152â€“59
                                examples
                                data holder for domain object (Java),
                                158â€“59
                                person record (Java), 155â€“58
                                how it works, 152â€“53
                                when to use it, 153â€“55
                                S
                                Safety, 65
                                Sales tax service (Java), 505â€“7
                                Schemes, miscellaneous layering, 103â€“6
                                SCM (source code management), 420
                                Scripts, data source for Transaction,
                                97â€“98
                                Scripts, Transaction, 110â€“15
                                example
                                revenue recognition (Java), 113â€“15
                                how it works, 110â€“11
                                revenue recognition problem, 112â€“13
                                when to use it, 111â€“12
                                Separate controller, using JSP as view
                                with, 355â€“57
                                Separated Interface, 476â€“79
                                how it works, 477â€“78
                                when to use it, 478â€“79
                                Serializable, transactions are, 73
                                Serialized LOBs (large objects), 272â€“77
                                example
                                serializing department hierarchy in
                                XML (Java), 274â€“77
                                how it works, 272â€“73
                                when to use it, 274
                                Serializing using XML (Java), 411â€“13
                                Server affinity, 85
                                Server concurrency, application, 78â€“80
                                530 Index
                                Server page, ASP.NET, 357â€“60
                                Server Session State, 458â€“61
                                how it works, 458â€“60
                                when to use it, 460â€“61
                                Servers, stateless, 81
                                Service Layer, 30â€“32, 133â€“41
                                example
                                revenue recognition (Java), 138â€“41
                                further reading, 137
                                how it works, 134â€“37
                                when to use it, 137
                                Service Stub, 504â€“7
                                example
                                sales tax service (Java), 505â€“7
                                how it works, 504â€“5
                                when to use it, 505
                                Services, gateway to proprietary messaging, 468â€“72
                                Services, Web, 103, 395â€“400
                                Servlet controller, simple display with,
                                335â€“37
                                Session migration, 85
                                Session state, 81, 83â€“86
                                Session State
                                Client, 456â€“57
                                how it works, 456â€“57
                                when to use it, 457
                                Database, 462â€“64
                                how it works, 462â€“63
                                when to use it, 464
                                Server, 458â€“61
                                how it works, 458â€“60
                                when to use it, 460â€“61
                                Session state
                                value of statelessness, 81â€“83
                                ways to store, 84â€“86
                                ways to store session state, 84â€“86
                                Session state patterns, 455â€“64
                                Client Session State, 456â€“57
                                Database Session State, 462â€“64
                                Server Session State, 458â€“61
                                Sessions defined, 66
                                Shared Optimistic Offline Lock (Java),
                                441â€“46
                                Shared Pessimistic Offline Lock (Java),
                                446â€“47
                                Simple display (Java), 347â€“49
                                Simple person (Java), 162â€“64
                                Simple transform (Java), 363â€“64
                                Single Table Inheritance
                                example
                                single table for players (C#),
                                280â€“81
                                how it works, 278â€“79
                                loading objects from databases,
                                281â€“84
                                when to use it, 279â€“80
                                Singleton registry (Java), 483â€“84
                                Skills, employees and, 250â€“53
                                Source code management (SCM), 420
                                Source layers, down to data, 97â€“100
                                Special Case, 496â€“98
                                example
                                simple null objects (C#), 498
                                further reading, 497
                                how it works, 497
                                when to use it, 497
                                SQL, using direct, 253â€“56
                                State
                                session, 81, 83â€“86
                                ways to store session, 84â€“86
                                State model Application Controller (Java),
                                382â€“86
                                Stateless servers, 81
                                Stored procedures, 102â€“3
                                Strategies
                                distribution, 87â€“93
                                allure of distributed objects, 87â€“88
                                interfaces for distribution, 92â€“93
                                remote and local interfaces, 88â€“90
                                where you have to distribute, 90â€“91
                                working with distribution boundaries, 91â€“92
                                swapping Repository, 326â€“27
                                Structural mapping patterns., 41â€“47
                                inheritance, 45â€“47
                                mapping relationships, 41â€“45
                                Structural patterns, object-relational,
                                215â€“84
                                Association Table Mapping, 248â€“61
                                Class Table Inheritance, 285â€“92
                                Concrete Table Inheritance, 293â€“301
                                Dependent Mapping, 262â€“67
                                Embedded Value, 268â€“71
                                Index 531
                                Foreign Key Mapping, 236â€“47
                                Identity Field, 216â€“35
                                Inheritance Mappers, 302â€“4
                                serialized LOBs (large objects),
                                272â€“77
                                Single Table Inheritance, 278â€“84
                                Stub, Service, 504â€“7
                                example
                                sales tax service (Java), 505â€“7
                                how it works, 504â€“5
                                when to use it, 505
                                System transactions, business and,
                                74â€“76
                                T
                                Table Data Gateway, 144â€“51
                                examples
                                Person Gateway (C#), 146â€“48
                                using ADO.NET data sets (C#),
                                148â€“51
                                further reading, 146
                                how it works, 144â€“45
                                when to use it, 145â€“46
                                Table Inheritance, Class, 285â€“92
                                Table Inheritance, Concrete, 293â€“301
                                example
                                concrete players (C#), 296â€“301
                                how it works, 293â€“95
                                when to use it, 295â€“96
                                Table Inheritance, Single
                                example
                                single table for players (C#),
                                280â€“81
                                how it works, 278â€“79
                                loading objects from databases,
                                281â€“84
                                when to use it, 279â€“80
                                Table Mapping, Association, 248â€“61
                                examples
                                employees and skills (C#), 250â€“53
                                using direct SQL (Java), 253â€“56
                                using single query for multiple
                                employees (Java), 256â€“61
                                how it works, 248â€“49
                                when to use it, 249
                                Table Modules, 125â€“32
                                data source, 98
                                example
                                revenue recognition with Table
                                Module (C#), 129â€“32
                                how it works, 126â€“28
                                when to use it, 128
                                Tables, key, 222â€“24
                                Tags, JSP and custom, 374â€“78
                                Tax service, sales, 505â€“7
                                Technology-specific advice, some,
                                100â€“103
                                Java and J2EE, 100â€“101
                                .NET, 101â€“2
                                stored procedures, 102â€“3
                                Web services, 103
                                Template View, 350â€“60
                                examples
                                ASP.NET server page (C#),
                                357â€“60
                                using JSP as view with separate controller (Java), 355â€“57
                                how it works, 351â€“54
                                when to use it, 354â€“55
                                Temporal Reads, 69
                                Thread-safe registry (Java), 484â€“85
                                Threads
                                defined, 66
                                isolated, 66
                                Together, putting it all, 95â€“106
                                down to data source layers, 97â€“100
                                miscellaneous layering schemes,
                                103â€“6
                                some technology-specific advice,
                                100â€“103
                                starting with domain layers, 96â€“97
                                Tracks, albums and, 264â€“67
                                Transaction isolation, reducing for liveness, 73â€“74
                                Transaction Script, 110â€“15
                                example
                                revenue recognition (Java), 113â€“15
                                how it works, 110â€“11
                                revenue recognition problem, 112â€“13
                                when to use it, 111â€“12
                                Transaction Scripts, data source for,
                                97â€“98
                                Transactional resources, 72â€“73
                                Transactions, 66, 71
                                business and system, 74â€“76
                                532 Index
                                late, 72
                                long, 72
                                request, 72
                                system, 74â€“76
                                Transform, simple, 363â€“64
                                Transform View, 361â€“64
                                example
                                simple transform (Java), 363â€“64
                                when to use it, 362â€“63
                                Two-stage XSLT (XSLT), 371â€“74
                                Two Step View, 365â€“78
                                examples
                                JSP and custom tags (Java), 374â€“78
                                two-stage XSLT (XSLT), 371â€“74
                                how it works, 365â€“67
                                when to use it, 367â€“71
                                U
                                Uncommitted, read, 74
                                Unit of Work, 184â€“94
                                example
                                Unit of Work with object registration
                                (Java), 190â€“94
                                how it works, 184â€“89
                                when to use it, 189â€“90
                                Unit of Work with object registration
                                (Java), 190â€“94
                                Unrepeatable reads, 73
                                Updates, lost, 64
                                V
                                Value holder, using, 205â€“6
                                Value Object, 486â€“87
                                how it works, 486â€“87
                                when to use it, 487
                                Value objects, simple, 270â€“71
                                Values, Embedded, 268â€“71
                                example
                                simple value objects (Java), 270â€“71
                                further reading, 270
                                how it works, 268
                                when to use it, 268â€“69
                                View patterns, 58â€“60
                                View, simple display with JSP, 335â€“37
                                Views, Template, 350â€“60
                                examples
                                ASP.NET server page (C#),
                                357â€“60
                                using JSP as view with separate controller (Java), 355â€“57
                                how it works, 351â€“54
                                when to use it, 354â€“55
                                Views, Transform, 361â€“64
                                example
                                simple transform (Java), 363â€“64
                                how it works, 361â€“62
                                when to use it, 362â€“63
                                Views, Two Step, 365â€“78
                                examples
                                JSP and custom tags (Java),
                                374â€“78
                                two-stage XSLT (XSLT), 371â€“74
                                how it works, 365â€“67
                                when to use it, 367â€“71
                                Virtual proxy (Java), 203â€“5
                                W
                                Web presentation, 55â€“61
                                input controller patterns, 61
                                view patterns, 58â€“60
                                Web presentation patterns, 329â€“86
                                Application Controller, 379â€“86
                                Front Controller, 344â€“49
                                MVC (Model View Controller),
                                330â€“32
                                Page Controller, 333â€“43
                                Template View, 350â€“60
                                Transform View, 361â€“64
                                Two Step View, 365â€“78
                                Web service (C#), 395â€“400
                                Web services, 103
                                Work, Unit of, 184â€“94
                                example
                                Unit of Work with object registration
                                (Java), 190â€“94
                                how it works, 184â€“89
                                when to use it, 189â€“90
                                X
                                XML
                                serializing department hierarchy in,
                                274â€“77
                                serializing using, 411â€“13
                                Index 533
                                XSLT, two stage, 371â€“74</pre>
                        </p>
                </div>
        </div>
        <!--<div id="content">
                <div id="contents">
                        <ol>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html" target="_blank">PART2</a>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#Domain_Logic_Patterns" target="_blank">Chapter 9: Domain Logic Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#Transaction_Script" target="_blank">Transaction Script</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#110" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#111" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#112" target="_blank">The Revenue Recognition Problem</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#113" target="_blank">Example: Revenue Recognition (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#116" target="_blank">Domain Model</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#116(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#119" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#119(2)" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#120" target="_blank">Example: Revenue Recognition (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#125" target="_blank">Table Module</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#126" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#128" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#129" target="_blank">Example: Revenue Recognition with a Table Module (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#133" target="_blank">Service Layer <i>(by Randy Stafford)</i></a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#134" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#137" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#137(2)" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#138" target="_blank">Example: Revenue Recognition (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#143" target="_blank">Chapter 10: Data Source Architectural Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#144" target="_blank">Table Data Gateway</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#144(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#145" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#146" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#146(2)" target="_blank">Example: Person Gateway (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#148" target="_blank">Example: Using ADO.NET Data Sets (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#152" target="_blank">Row Data Gateway</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#152(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#153" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#155" target="_blank">Example: A Person Record (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#158" target="_blank">Example: A Data Holder for a Domain Object (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#160" target="_blank">Active Record</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#160(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#161" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#162" target="_blank">Example: A Simple Person (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#165" target="_blank">Data Mapper</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#165(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#170" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#171" target="_blank">Example: A Simple Database Mapper (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#176" target="_blank">Example: Separating the Finders (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#179" target="_blank">Example: Creating an Empty Object (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#183" target="_blank">Chapter 11: Object-Relational Behavioral Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#184" target="_blank">Unit of Work</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#184(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#189" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#190" target="_blank">Example: <i>Unit of Work with Object Registration (Java) (by David Rice)</i> </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#195" target="_blank">Identity Map</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#195(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#198" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#198(2)" target="_blank">Example: Methods for an Identity Map (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#200" target="_blank">Lazy Load</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#200(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#203" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#203(2)" target="_blank">Example: Lazy Initialization (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#203(3)" target="_blank">Example: Virtual Proxy (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#205" target="_blank">Example: Using a Value Holder (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#206" target="_blank">Example: Using Ghosts (C#)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#215" target="_blank">Chapter 12: Object-Relational Structural Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#216" target="_blank">Identity Field</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#216(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#220" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#221" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#221(2)" target="_blank">Example: Integral Key (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#222" target="_blank">Example: Using a Key Table (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#224" target="_blank">Example: Using a Compound Key (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#236" target="_blank">Foreign Key Mapping</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#236(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#239" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#240" target="_blank">Example: Single-Valued Reference (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#243" target="_blank">Example: Multitable Find (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#244" target="_blank">Example: Collection of References (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#248" target="_blank">Association Table Mapping</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#248(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#249" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#250" target="_blank">Example: Employees and Skills (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#253" target="_blank">Example: Using Direct SQL (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#256" target="_blank">Example: Using a Single Query for Multiple Employees (Java) <i>(by Matt Foemmel and Martin Fowler)</i></a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#262" target="_blank">Dependent Mapping</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#262(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#263" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#264" target="_blank">Example: Albums and Tracks (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#268" target="_blank">Embedded Value</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#268(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#268(3)" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#270" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#270(2)" target="_blank">Example: Simple Value Object (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#272" target="_blank">Serialized LOB</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#272(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#274" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#274(2)" target="_blank">Example: Serializing a Department Hierarchy in XML (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#278" target="_blank">Single Table Inheritance</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#278(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#279" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#280" target="_blank">Example: A Single Table for Players (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#281" target="_blank">Loading an Object from the Database</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#285" target="_blank">Class Table Inheritance</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#285(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#286" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#287" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#287(2)" target="_blank">Example: Players and Their Kin (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#293" target="_blank">Concrete Table Inheritance</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#293(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#295" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#296" target="_blank">Example: Concrete Players (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#302" target="_blank">Inheritance Mappers</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#303" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#304" target="_blank">When to Use It</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#305" target="_blank">Chapter 13: Object-Relational Metadata Mapping Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#306" target="_blank">Metadata Mapping</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#306(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#308" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#309" target="_blank">Example: Using Metadata and Reflection (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#316" target="_blank">Query Object</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#316" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#317" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#318" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#318(2)" target="_blank">Example: A Simple Query Object (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#322" target="_blank">Repository (by Edward Hieatt and Rob Mee)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#323" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#324" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#325" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#325(2)" target="_blank">Example: Finding a Personâ€™s Dependents (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#326" target="_blank">Example: Swapping Repository Strategies (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#329" target="_blank">Chapter 14: Web Presentation Patterns.</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#330" target="_blank">Model View Controller</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#330(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#332" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#333" target="_blank">Page Controller</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#333(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#334" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#335" target="_blank">Example: Simple Display with a Servlet Controller and a JSP View (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#337" target="_blank">Example: Using a JSP as a Handler (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#340" target="_blank">Example: Page Handler with a Code Behind (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#344" target="_blank">Front Controller</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#344(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#346" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#347" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#347(2)" target="_blank">Example: Simple Display (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#350" target="_blank">Template View</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#351" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#354" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#355" target="_blank">Example: Using a JSP as a View with a Separate Controller (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#357" target="_blank">Example: ASP.NET Server Page (C#) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#361" target="_blank">Transform View</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#361(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#362" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#363" target="_blank">Example: Simple Transform (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#365" target="_blank">Two Step View</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#365(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#367" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#371" target="_blank">Example: Two Stage XSLT (XSLT)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#374" target="_blank">Example: JSP and Custom Tags (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#379" target="_blank">Application Controller</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#380" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#381" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#382" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#382(2)" target="_blank">Example: State Model Application Controller (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#387" target="_blank">Chapter 15: Distribution Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#388" target="_blank">Remote Facade</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#389" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#392" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#392(2)" target="_blank">Example: Using a Java Session Bean as a Remote Facade (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#395" target="_blank">Example: Web Service (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#401" target="_blank">Data Transfer Object</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#401(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#406" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#407" target="_blank">Further Reading </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#407(2)" target="_blank">Example: Transferring Information About Albums (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#411" target="_blank">Example: Serializing Using XML (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#415" target="_blank">Chapter 16: Offline Concurrency Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#416" target="_blank">Optimistic Offline Lock (by David Rice)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#417" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#420" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#421" target="_blank">Example: Domain Layer with Data Mappers (165) (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#426" target="_blank">Pessimistic Offline Lock (by David Rice)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#427" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#431" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#431(2)" target="_blank">Example: Simple Lock Manager (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#438" target="_blank">Coarse-Grained Lock (by David Rice and Matt Foemmel)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#438(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#441" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#441(2)" target="_blank">Example: Shared Optimistic Offline Lock (416) (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#446" target="_blank">Example: Shared Pessimistic Offline Lock (426) (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#447" target="_blank">Example: Root Optimistic Offline Lock (416) (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#449" target="_blank">Implicit Lock (by David Rice)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#450" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#451" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#451(2)" target="_blank">Example: Implicit Pessimistic Offline Lock (426) (Java)</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#455" target="_blank">Chapter 17: Session State Patterns</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#456" target="_blank">Client Session State</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#456(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#457" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#458" target="_blank">Server Session State</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#458(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#460" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#462" target="_blank">Database Session State</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#462(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#464" target="_blank">When to Use It</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#465" target="_blank">Chapter 18: Base Patterns.</a>
                                        <ol>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#466" target="_blank">Gateway</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#466(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#467" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#468" target="_blank">Example: A Gateway to a Proprietary Messaging Service (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#473" target="_blank">Mapper</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#473(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#474" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#475" target="_blank">Layer Supertype</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#475(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#475(3)" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#475(4)" target="_blank">Example: Domain Object (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#476" target="_blank">Separated Interface</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#477" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#478" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#480" target="_blank">Registry</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#480(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#482" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#483" target="_blank">Example: A Singleton Registry (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#484" target="_blank">Example: Thread-Safe Registry (Java) (by Matt Foemmel and Martin Fowler)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#486" target="_blank">Value Object</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#486(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#487" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#488" target="_blank">Money</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#488(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#490" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#491" target="_blank">Example: A Money Class (Java) (by Matt Foemmel and Martin Fowler)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#496" target="_blank">Special Case</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#497" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#497(2)" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#497(3)" target="_blank">Further Reading</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#498" target="_blank">Example: A Simple Null Object (C#)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#499" target="_blank">Plugin (by David Rice and Matt Foemmel)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#499(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#500" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#501" target="_blank">Example: An Id Generator (Java) </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#504" target="_blank">Service Stub (by David Rice).</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#504(2)" target="_blank">How It Works </a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#505" target="_blank">When to Use It</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#505(2)" target="_blank">Example: Sales Tax Service (Java)</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#508" target="_blank">Record Set</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#508(2)" target="_blank">How It Works</a>
                                                </li>
                                                <li>
                                                        <a href="file:///C:/study/homework/part2.html#510" target="_blank">When to Use It</a>
                                                </li>
                                        </ol>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#511" target="_blank">References</a>
                                </li>
                                <li>
                                        <a href="file:///C:/study/homework/part2.html#517" target="_blank">Index</a>
                                </li>
                        </ol>
                </div>
                <div id="text">
                <h2>The Patterns</h2>
                <p><i>This page intentionally left blank</i></p>
                <h3 id="Domain_Logic_Patterns">Chapter 9</h3>
                <h2>Domain Logic Patterns</h2>
                <h3 id="Transaction_Script">Transaction Script</h3>
                <p>Organizes business logic by procedures where each procedure handles a single request from the presentation.
                        Most business applications can be thought of as a series of transactions. A
                        transaction may view some information as organized in a particular way,
                        another will make changes to it. Each interaction between a client system and a
                        server system contains a certain amount of logic. In some cases this can be as
                        simple as displaying information in the database. In others it may involve many
                        steps of validations and calculations.
                        A Transaction Script organizes all this logic primarily as a single procedure,
                        making calls directly to the database or through a thin database wrapper. Each
                        transaction will have its own Transaction Script, although common subtasks
                        can be broken into subprocedures.</p>
                <h3 id="110">How It Works</h3>
                <p>With Transaction Script the domain logic is primarily organized by the transactions that you carry out with the system. If your need is to book a hotel room,
                        the logic to check room availability, calculate rates, and update the database is
                        found inside the Book Hotel Room procedure.
                        For simple cases there isnâ€™t much to say about how you organize this. Of
                        course, as with any other program you should structure the code into modules in
                        a way that makes sense. Unless the transaction is particularly complicated, that
                        wonâ€™t be much of a challenge. One of the benefits of this approach is that you
                        donâ€™t need to worry about what other transactions are doing. Your task is to get
                        the input, interrogate the database, munge, and save your results to the database.
                        Where you put the Transaction Script will depend on how you organize your
                        layers. It may be in a server page, a CGI script, or a distributed session object.
                        My preference is to separate Transaction Scripts as much as you can. At the
                        very least put them in distinct subroutines; better still, put them in classes separate from those that handle presentation and data source. In addition, donâ€™t
                        have any calls from the Transaction Scripts to any presentation logic; that will
                        make it easier to modify the code and test the Transaction Scripts.
                        You can organize your Transaction Scripts into classes in two ways. The most
                        common is to have several Transaction Scripts in a single class, where each class
                        defines a subject area of related Transaction Scripts. This is straightforward and
                        the best bet for most cases. The other way is to have each Transaction Script in its
                        own class (Figure 9.1), using the Command pattern [Gang of Four]. In this case
                        you define a supertype for your commands that specifies some execute method in
                        which Transaction Script logic fits. The advantage of this is that it allows you to
                        manipulate instances of scripts as objects at runtime, although Iâ€™ve rarely seen a
                        need to do this with the kinds of systems that use Transaction Scripts to organize
                        domain logic. Of course, you can ignore classes completely in many languages
                        and just use global functions. However, youâ€™ll often find that instantiating a new
                        object helps with threading issues as it makes it easier to isolate data.
                        I use the term Transaction Script because most of the time youâ€™ll have one
                        Transaction Script for each database transaction. This isnâ€™t a 100 percent rule,
                        but itâ€™s true to the first approximation.</p>
                <h3 id="111">When to Use It</h3>
                <p>The glory of Transaction Script is its simplicity. Organizing logic this way is
                        natural for applications with only a small amount of logic, and it involves very
                        little overhead either in performance or in understanding.
                        As the business logic gets more complicated, however, it gets progressively
                        harder to keep it in a well-designed state. One particular problem to watch for
                        is its duplication between transactions. Since the whole point is to handle one
                        transaction, any common code tends to be duplicated.
                        Careful factoring can alleviate many of these problems, but more complex
                        business domains need to build a Domain Model (116). A Domain Model (116)
                        will give you many more options in structuring the code, increasing readability
                        and decreasing duplication.</p>
                <p>Itâ€™s hard to quantify the cutover level, especially when youâ€™re more familiar
                        with one pattern than the other. You can refactor a Transaction Script design to
                        a Domain Model (116) design, but itâ€™s a harder change than it otherwise needs
                        to be. Therefore, an early shot is often the best way to move forward.
                        However much of an object bigot you become, donâ€™t rule out Transaction
                        Script. There are a lot of simple problems out there, and a simple solution will
                        get you up and running much faster.</p>
                <h3 id="112">The Revenue Recognition Problem</h3>
                <p>For this pattern, and others that talk about domain logic, Iâ€™m going to use the
                        same problem as an illustration. To avoid typing the problem statement several
                        times, Iâ€™m just putting it in here.
                        Revenue recognition is a common problem in business systems. Itâ€™s all about
                        when you can actually count the money you receive on your books. If I sell you
                        a cup of coffee, itâ€™s a simple matter: I give you the coffee, I take your money,
                        and I count the money to the books that nanosecond. For many things it gets
                        complicated, however. Say you pay me a retainer to be available that year. Even
                        if you pay me some ridiculous fee today, I may not be able to put it on my
                        books right away because the service is to be performed over the course of a
                        year. One approach might be to count only one-twelfth of that fee for each
                        month in the year, since you might pull out of the contract after a month when
                        you realize that writing has atrophied my programming skills.</p>
                <p>The rules for revenue recognition are many, various, and volatile. Some are
                        set by regulation, some by professional standards, and some by company policy. Revenue tracking ends up being quite a complex problem.
                        I donâ€™t fancy delving into the complexity right now, so instead weâ€™ll imagine
                        a company that sells three kinds of products: word processors, databases, and
                        spreadsheets. According to the rules, when you sign a contract for a word processor you can book all the revenue right away. If itâ€™s a spreadsheet, you can
                        book one-third today, one-third in sixty days, and one-third in ninety days. If
                        itâ€™s a database, you can book one-third today, one-third in thirty days, and onethird in sixty days. Thereâ€™s no basis for these rules other than my own fevered
                        imagination. Iâ€™m told that the real rules are equally rational.</p>
                <h3 id="113">Example: Revenue Recognition (Java)</h3>
                <p>This example uses two transaction scripts: one to calculate the revenue recognitions for a contract and one to tell how much revenue on a contract has been
                        recognized by a certain date. The database structure has three tables: one for
                        the products, one for the contracts, and one for the revenue recognitions.
                        <pre >CREATE TABLE products (ID int primary key, name varchar, type varchar)
                        CREATE TABLE contracts (ID int primary key, product int, revenue decimal, dateSigned date)
                        CREATE TABLE revenueRecognitions (contract int, amount decimal, recognizedOn date,
                        PRIMARY KEY (contract, recognizedOn))</pre>
                        The first script calculates the amount of recognition due by a particular day. I
                        can do this in two stages: In the first I select the appropriate rows in the revenue
                        recognitions table; in the second I sum up the amounts.
                        Many Transaction Script designs have scripts that operate directly on the
                        database, putting SQL code in the procedure. Here Iâ€™m using a simple Table
                        Data Gateway (144) to wrap the SQL queries. Since this example is so simple,
                        Iâ€™m using a single gateway rather than one for each table. I can define an appropriate find method on the gateway.
                        <pre>class Gateway...
                        public ResultSet findRecognitionsFor(long contractID, MfDate asof) throws SQLException{
                                PreparedStatement stmt = db.prepareStatement(findRecognitionsStatement);
                                stmt.setLong(1, contractID);
                                stmt.setDate(2, asof.toSqlDate());
                                ResultSet result = stmt.executeQuery();
                                return result;
                        }
                        Figure 9.2 A conceptual model for simplified revenue recognition. Each contract has
                        multiple revenue recognitions that indicate when the various parts of the revenue should
                        be recognized.
                        date signed
                        revenue
                        Contract
                        1 * 1 *
                        if a contract has any revenue
                        recognitions, the contract's revenue
                        should be equal to the sum of the
                        amounts of its revenue recognitions
                        amount
                        date
                        Revenue
                        Recognition
                        type
                        Product
                        Transaction
                        Script
                        private static final String findRecognitionsStatement =
                        "SELECT amount " +
                        " FROM revenueRecognitions " +
                        " WHERE contract = ? AND recognizedOn &lt;= ?";
                        private Connection db;</pre>
                        I then use the script to sum up based on the result set passed back from the
                        gateway.
                        <pre>class RecognitionService...
                        public Money recognizedRevenue(long contractNumber, MfDate asOf) {
                        Money result = Money.dollars(0);
                        try {
                        ResultSet rs = db.findRecognitionsFor(contractNumber, asOf);
                        while (rs.next()) {
                        result = result.add(Money.dollars(rs.getBigDecimal("amount")));
                        }
                        return result;
                        } catch (SQLException e) {throw new ApplicationException (e);
                        }
                        }</pre>
                        When the calculation is as simple as this, you can replace the in-memory script
                        with a call to a SQL statement that uses an aggregate function to sum the
                        amounts.
                        For calculating the revenue recognitions on an existing contract, I use a similar split. The script on the service carries out the business logic.
                        <pre>class RecognitionService...
                        public void calculateRevenueRecognitions(long contractNumber) {
                        try {
                        ResultSet contracts = db.findContract(contractNumber);
                        contracts.next();
                        Money totalRevenue = Money.dollars(contracts.getBigDecimal("revenue"));
                        MfDate recognitionDate = new MfDate(contracts.getDate("dateSigned"));
                        String type = contracts.getString("type");
                        if (type.equals("S")){
                        Money[] allocation = totalRevenue.allocate(3);
                        db.insertRecognition
                        (contractNumber, allocation[0], recognitionDate);
                        db.insertRecognition
                        (contractNumber, allocation[1], recognitionDate.addDays(60));
                        db.insertRecognition
                        (contractNumber, allocation[2], recognitionDate.addDays(90));
                        } else if (type.equals("W")){
                        db.insertRecognition(contractNumber, totalRevenue, recognitionDate);
                        } else if (type.equals("D")) {
                        Money[] allocation = totalRevenue.allocate(3);
                        db.insertRecognition
                        (contractNumber, allocation[0], recognitionDate);
                        TRANSACTION SCRIPT 115
                        Transaction
                        Script
                        db.insertRecognition
                        (contractNumber, allocation[1], recognitionDate.addDays(30));
                        db.insertRecognition
                        (contractNumber, allocation[2], recognitionDate.addDays(60));
                        }
                        } catch (SQLException e) {throw new ApplicationException (e);
                        }
                        }
                        Notice that Iâ€™m using Money (488) to carry out the allocation. When splitting
                        an amount three ways itâ€™s very easy to lose a penny.
                        The Table Data Gateway (144) provides support on the SQL. First thereâ€™s a
                        finder for a contract.
                        class Gateway...
                        public ResultSet findContract (long contractID) throws SQLException{
                        PreparedStatement stmt = db.prepareStatement(findContractStatement);
                        stmt.setLong(1, contractID);
                        ResultSet result = stmt.executeQuery();
                        return result;
                        }
                        private static final String findContractStatement =
                        "SELECT * " +
                        " FROM contracts c, products p " +
                        " WHERE ID = ? AND c.product = p.ID";
                        And secondly thereâ€™s a wrapper for the insert.
                        class Gateway...
                        public void insertRecognition (long contractID, Money amount, MfDate asof) throws SQLException {
                        PreparedStatement stmt = db.prepareStatement(insertRecognitionStatement);
                        stmt.setLong(1, contractID);
                        stmt.setBigDecimal(2, amount.amount());
                        stmt.setDate(3, asof.toSqlDate());
                        stmt.executeUpdate();
                        }
                        private static final String insertRecognitionStatement =
                        "INSERT INTO revenueRecognitions VALUES (?, ?, ?)";</pre>
                        In a Java system the recognition service might be a regular class or a session bean.
                        As you compare this to the example in Domain Model (116), unless your mind
                        is as twisted as mine, youâ€™ll probably be thinking that this is much simpler. The
                        harder thing to imagine is what happens as the rules get more complicated. Typical revenue recognition rules get very involved, varying not just by product but
                        also by date (if the contract was signed before April 15 this rule applies . . .). Itâ€™s
                        difficult to keep a coherent design with Transaction Script once things get that
                        complicated, which is why object bigots like me prefer using a Domain Model
                        (116) in these circumstances.</p>
                <h3 id="116">Domain Model</h3>
                <p>An object model of the domain that incorporates
                        both behavior and data.
                        At its worst business logic can be very complex. Rules and logic describe many
                        different cases and slants of behavior, and itâ€™s this complexity that objects were
                        designed to work with. A Domain Model creates a web of interconnected
                        objects, where each object represents some meaningful individual, whether as
                        large as a corporation or as small as a single line on an order form.</p>
                <h3 id="116(2)">How It Works</h3>
                <p>Putting a Domain Model in an application involves inserting a whole layer of
                        objects that model the business area youâ€™re working in. Youâ€™ll find objects that
                        mimic the data in the business and objects that capture the rules the business
                        uses. Mostly the data and process are combined to cluster the processes close to
                        the data they work with.
                        An OO domain model will often look similar to a database model, yet it will
                        still have a lot of differences. A Domain Model mingles data and process, has
                        multivalued attributes and a complex web of associations, and uses inheritance.
                        As a result I see two styles of Domain Model in the field. A simple Domain
                        Model looks very much like the database design with mostly one domain object
                        for each database table. A rich Domain Model can look different from the database design, with inheritance, strategies, and other [Gang of Four] patterns, and
                        complex webs of small interconnected objects. A rich Domain Model is better
                        for more complex logic, but is harder to map to the database. A simple Domain
                        Model can use Active Record (160), whereas a rich Domain Model requires
                        Data Mapper (165).</p>
                <p>Since the behavior of the business is subject to a lot of change, itâ€™s important to be able to modify, build, and test this layer easily. As a result youâ€™ll
                        want the minimum of coupling from the Domain Model to other layers in the
                        system. Youâ€™ll notice that a guiding force of many layering patterns is to keep
                        as few dependencies as possible between the domain model and other parts of
                        the system.
                        With a Domain Model there are a number of different scopes you might use.
                        The simplest case is a single-user application where the whole object graph is
                        read from a file and put into memory. A desktop application may work this
                        way, but itâ€™s less common for a multitiered IS application simply because there
                        are too many objects. Putting every object into memory consumes too much
                        memory and takes too long. The beauty of object-oriented databases is that
                        they give the impression of doing this while moving objects between memory
                        and disk.</p>
                <p>Without an OO database you have to do this yourself. Usually a session will
                        involve pulling in an object graph of all the objects involved in it. This will certainly not be all objects and usually not all the classes. Thus, if youâ€™re looking at
                        a set of contracts you might pull in only the products referenced by contracts
                        within your working set. If youâ€™re just performing calculations on contracts and
                        revenue recognition objects, you may not pull in any product objects at all.
                        Exactly what you pull into memory is governed by your database mapping
                        objects.
                        If you need the same object graph between calls to the server, you have to
                        save the server state somewhere, which is the subject of the section on saving
                        server state (page 81).</p>
                <p>A common concern with domain logic is bloated domain objects. As you
                        build a screen to manipulate orders youâ€™ll notice that some of the order behavior is only needed for it. If you put these responsibilities on the order, the risk is
                        that the Order class will become too big because itâ€™s full of responsibilities that
                        are only used in a single use case. This concern leads people to consider whether
                        some responsibility is general, in which case it should sit in the order class, or
                        specific, in which case it should sit in some usage-specific class, which might be
                        a Transaction Script (110) or perhaps the presentation itself.
                        The problem with separating usage-specific behavior is that it can lead to
                        duplication. Behavior thatâ€™s separated from the order is harder to find, so people
                        tend to not see it and duplicate it instead. Duplication can quickly lead to more
                        complexity and inconsistency, but Iâ€™ve found that bloating occurs much less frequently than predicted. If it does occur, itâ€™s relatively easy to see and not difficult
                        to fix. My advice is not to separate usage-specific behavior. Put it all in the object
                        thatâ€™s the natural fit. Fix the bloating when, and if, it becomes a problem.</p>
                <h5>Java Implementation</h5>
                <p>Thereâ€™s always a lot of heat generated when people talk about developing a
                        Domain Model in J2EE. Many of the teaching materials and introductory
                        J2EE books suggest that you use entity beans to develop a domain model,
                        but there are some serious problems with this approach, at least with the
                        current (2.0) specification.
                        Entity beans are most useful when you use Container Managed Persistence
                        (CMP). Indeed, I would say thereâ€™s little point in using entity beans without
                        CMP. However, CMP is a limited form of object-relational mapping, and it
                        canâ€™t support many of the patterns that you need in a rich Domain Model.
                        Entity beans canâ€™t be re-entrant. That is, if you call out from one entity
                        bean into another object, that other object (or any object it calls) canâ€™t call
                        back into the first entity bean. A rich Domain Model often uses re-entrancy,
                        so this is a handicap. Itâ€™s made worse by the fact that itâ€™s hard to spot reentrant behavior. As a result, some people say that one entity bean should
                        never call another. While this avoids re-entrancy, it very much cripples the
                        advantages using a Domain Model.</p>
                <p>A Domain Model should use fine-grained objects with fine-grained interfaces. Entity beans may be remotable (prior to version 2.0 they had to be). If
                        you have remote objects with fine-grained interfaces you get terrible performance. You can avoid this problem quite easily by only using local interfaces for your entity beans in a Domain Model.
                        To run with entity beans you need a container and a database connected.
                        This will increase build times and also increase the time to do test runs since
                        the tests have to execute against a database. Entity beans are also tricky to
                        debug.
                        The alternative is to use normal Java objects, although this often causes a
                        surprised reactionâ€”itâ€™s amazing how many people think that you canâ€™t run
                        regular Java objects in an EJB container. Iâ€™ve come to the conclusion that
                        people forget about regular Java objects because they havenâ€™t got a fancy
                        name. Thatâ€™s why, while preparing for a talk in 2000, Rebecca Parsons, Josh
                        Mackenzie, and I gave them one: POJOs (plain old Java objects). A POJO
                        domain model is easy to put together, is quick to build, can run and test outside an EJB container, and is independent of EJB (maybe thatâ€™s why EJB vendors donâ€™t encourage you to use them).</p>
                <p>My view on the whole is that using entity beans as a Domain Model
                        works if you have pretty modest domain logic. If so, you can build a
                        Domain Model that has a simple relationship with the database: where
                        thereâ€™s mostly one entity bean class per database table. If you have a richer
                        domain logic with inheritance, strategies, and other more sophisticated patterns, youâ€™re better off with a POJO domain model and Data Mapper (165),
                        using a commercial tool or with a homegrown layer.
                        The biggest frustration for me with the use of EJB is that I find a rich
                        Domain Model complicated enough to deal with, and I want to keep as independent as possible from the details of the implementation environment. EJB
                        forces itself into your thinking about the Domain Model, which means that I
                        have to worry about both the domain and the EJB environment.</p>
                <h4 id="119">When to Use It</h4>
                <p>If the how for a Domain Model is difficult because itâ€™s such a big subject, the
                        when is hard because of both the vagueness and the simplicity of the advice. It
                        all comes down to the complexity of the behavior in your system. If you have
                        complicated and everchanging business rules involving validation, calculations,
                        and derivations, chances are that youâ€™ll want an object model to handle them.
                        On the other hand, if you have simple not-null checks and a couple of sums to
                        calculate, a Transaction Script (110) is a better bet.
                        One factor that comes into this is comfortable used the development team is
                        with domain objects. Learning how to design and use a Domain Model is a significant exerciseâ€”one that has led to many articles on the â€œparadigm shiftâ€ of
                        objects use. It certainly takes practice and coaching to get used to a Domain
                        Model, but once used to it Iâ€™ve found that few people want to go back to a
                        Transaction Script (110) for any but the simplest problems.
                        If youâ€™re using Domain Model, my first choice for database interaction is
                        Data Mapper (165). This will help keep your Domain Model independent from
                        the database and is the best approach to handle cases where the Domain Model
                        and database schema diverge.
                        When you use Domain Model you may want to consider Service Layer (133)
                        to give your Domain Model a more distinct API.</p>
                <h4 id="119(2)">Further Reading</h4>
                <p>Almost any book on OO design will talk about Domain Models, since most of
                        what people refer to as OO development is centered around their use.
                        If youâ€™re looking for an introductory book on OO design, my current favorite is [Larman]. For examples of Domain Model take a look at [Fowler AP].
                        120 DOMAIN LOGIC PATTERNS
                        Domain
                        Model
                        [Hay] also gives good examples in a relational context. To build a good
                        Domain Model you should have an understanding of conceptual thinking
                        about objects. For this Iâ€™ve always liked [Martin and Odell]. For an understanding of the patterns youâ€™ll see in a rich Domain Model, or any other OO system,
                        you must read [Gang of Four].
                        Eric Evans is currently writing a book [Evans] on building Domain Models.
                        As I write this Iâ€™ve seen only an early manuscript, but it looks very promising.</p>
                <h4 id="120">Example: Revenue Recognition (Java)</h4>
                <p>One of the biggest frustrations of describing a Domain Model is the fact that
                        any example I show is necessarily simple so you can understand it; yet that simplicity hides the Domain Modelâ€™s strength. You only appreciate these strengths
                        when you have a really complicated domain.
                        But even if the example canâ€™t do justice to why you would want a Domain
                        Model, at least it will give you a sense of what one can look like. Therefore, Iâ€™m
                        using the same example (page 112) that I used for Transaction Script (110), a
                        little matter of revenue recognition.
                        An immediate thing to notice is that every class, in this small example (Figure 9.3) contains both behavior and data. Even the humble Revenue Recognition class contains a simple method to find out if that objectâ€™s value is
                        recognizable on a certain date.
                        <pre>class RevenueRecognition...
                        private Money amount;
                        private MfDate date;
                        public RevenueRecognition(Money amount, MfDate date) {
                        this.amount = amount;
                        this.date = date;
                        }
                        public Money getAmount() {
                        return amount;
                        }
                        boolean isRecognizableBy(MfDate asOf) {
                        return asOf.after(date) || asOf.equals(date);
                        }</pre>
                        Calculating how much revenue is recognized on a particular date involves
                        both the contract and revenue recognition classes.
                        <pre>class Contract...
                        private List revenueRecognitions = new ArrayList();
                        public Money recognizedRevenue(MfDate asOf) {
                        Money result = Money.dollars(0);
                        Iterator it = revenueRecognitions.iterator();
                        while (it.hasNext()) {
                        RevenueRecognition r = (RevenueRecognition) it.next();
                        if (r.isRecognizableBy(asOf))
                        result = result.add(r.getAmount());
                        }
                        return result;
                        }</pre>
                        A common thing you find in domain models is how multiple classes interact
                        to do even the simplest tasks. This is what often leads to the complaint that
                        with OO programs you spend a lot of time hunting around from class to class
                        trying to find them. Thereâ€™s a lot of merit to this complaint. The value comes as
                        the decision on whether something is recognizable by a certain date gets more
                        complex and as other objects need to know. Containing the behavior on the
                        object that needs to know avoids duplication and reduces coupling between the
                        different objects.
                        Figure 9.3 Class diagram of the example classes for a Domain Model.
                        recognizedRevenue (date) : Money
                        calculateRecognitions
                        revenue
                        whenSigned
                        Contract
                        calculateRecognitions (Contract)
                        Product
                        isRecognizableBy (date)
                        amount: Money
                        date
                        Revenue Recognition
                        1
                        calculateRevenueRecognitions (Contract)
                        Recognition Strategy
                        calculateRevenueRecognitions (Contract)
                        Complete Recognition Strategy
                        calculateRevenueRecognitions (Contract)
                        firstRecognitionOffset
                        secondRecognitionOffset
                        Three-Way Recognition Strategy
                        * 1
                        *
                        1
                        *
                        122 DOMAIN LOGIC PATTERNS
                        Domain
                        Model</p>
                <p>Looking at calculating and creating these revenue recognition objects further
                        demonstrates the notion of lots of little objects. In this case the calculation and
                        creation begin with the customer and are handed off via the product to a strategy hierarchy. The strategy pattern [Gang of Four] is a well-known OO pattern
                        that allows you to combine a group of operations in a small class hierarchy.
                        Each instance of product is connected to a single instance of recognition strategy, which determines which algorithm is used to calculate revenue recognition.
                        In this case we have two subclasses of recognition strategy for the two different
                        cases. The structure of the code looks like this:
                        <pre>class Contract...
                        private Product product;
                        private Money revenue;
                        private MfDate whenSigned;
                        private Long id;
                        public Contract(Product product, Money revenue, MfDate whenSigned) {
                        this.product = product;
                        this.revenue = revenue;
                        this.whenSigned = whenSigned;
                        }
                        class Product...
                        private String name;
                        private RecognitionStrategy recognitionStrategy;
                        public Product(String name, RecognitionStrategy recognitionStrategy) {
                        this.name = name;
                        this.recognitionStrategy = recognitionStrategy;
                        }
                        public static Product newWordProcessor(String name) {
                        return new Product(name, new CompleteRecognitionStrategy());
                        }
                        public static Product newSpreadsheet(String name) {
                        return new Product(name, new ThreeWayRecognitionStrategy(60, 90));
                        }
                        public static Product newDatabase(String name) {
                        return new Product(name, new ThreeWayRecognitionStrategy(30, 60));
                        }
                        class RecognitionStrategy...
                        abstract void calculateRevenueRecognitions(Contract contract);
                        class CompleteRecognitionStrategy...
                        void calculateRevenueRecognitions(Contract contract) {
                        contract.addRevenueRecognition(new RevenueRecognition(contract.getRevenue(),
                        contract.getWhenSigned()));
                        }
                        DOMAIN MODEL 123
                        Domain
                        Model
                        class ThreeWayRecognitionStrategy...
                        private int firstRecognitionOffset;
                        private int secondRecognitionOffset;
                        public ThreeWayRecognitionStrategy(int firstRecognitionOffset,
                        int secondRecognitionOffset)
                        {
                        this.firstRecognitionOffset = firstRecognitionOffset;
                        this.secondRecognitionOffset = secondRecognitionOffset;
                        }
                        void calculateRevenueRecognitions(Contract contract) {
                        Money[] allocation = contract.getRevenue().allocate(3);
                        contract.addRevenueRecognition(new RevenueRecognition
                        (allocation[0], contract.getWhenSigned()));
                        contract.addRevenueRecognition(new RevenueRecognition
                        (allocation[1], contract.getWhenSigned().addDays(firstRecognitionOffset)));
                        contract.addRevenueRecognition(new RevenueRecognition
                        (allocation[2], contract.getWhenSigned().addDays(secondRecognitionOffset)));
                        }</pre>
                        The great value of the strategies is that they provide well-contained plug points
                        to extend the application. Adding a new revenue recognition algorithm involves
                        creating a new subclass and overriding the calculateRevenueRecognitions method.
                        This makes it easy to extend the algorithmic behavior of the application.
                        When you create products, you hook them up with the appropriate strategy
                        objects. Iâ€™m doing this in my test code.
                        <pre>class Tester...
                        private Product word = Product.newWordProcessor("Thinking Word");
                        private Product calc = Product.newSpreadsheet("Thinking Calc");
                        private Product db = Product.newDatabase("Thinking DB");</pre>
                        Once everything is set up, calculating the recognitions requires no knowledge of
                        the strategy subclasses.
                        <pre>class Contract...
                        public void calculateRecognitions() {
                        product.calculateRevenueRecognitions(this);
                        }
                        class Product...
                        void calculateRevenueRecognitions(Contract contract) {
                        recognitionStrategy.calculateRevenueRecognitions(contract);
                        }</pre>
                        The OO habit of successive forwarding from object to object moves the
                        behavior to the object most qualified to handle it, but it also resolves much of
                        124 DOMAIN LOGIC PATTERNS
                        Domain
                        Model
                        the conditional behavior. Youâ€™ll notice that there are no conditionals in this calculation. You set up the decision path when you create the products with the
                        appropriate strategy. Once everything is wired together like this, the algorithms
                        just follow the path. Domain models work very well when you have similar
                        conditionals because the similar conditionals can be factored out into the object
                        structure itself. This moves complexity out of the algorithms and into the relationships between objects. The more similar the logic, the more you find the
                        same network of relationships used by different parts of the system. Any algorithm thatâ€™s dependent on the type of recognition calculation can follow this
                        particular network of objects.</p>
                <p>Notice in this example that Iâ€™ve shown nothing about how the objects are
                        retrieved from, and written to, the database. This is for a couple of reasons.
                        First, mapping a Domain Model to a database is always somewhat hard, so Iâ€™m
                        chickening out and not providing an example. Second, in many ways the whole
                        point of a Domain Model is to hide the database, both from upper layers and
                        from people working the Domain Model itself. Thus, hiding it here reflects
                        what itâ€™s like to actually program in this environment.</p>
                <h3 id="125">Table Module</h3>
                <p>A single instance that handles the business logic for
                        all rows in a database table or view.
                        One of the key messages of object orientation is bundling the data with the
                        behavior that uses it. The traditional object-oriented approach is based on
                        objects with identity, along the lines of Domain Model (116). Thus, if we have
                        an Employee class, any instance of it corresponds to a particular employee. This
                        scheme works well because once we have a reference to an employee, we can
                        execute operations, follow relationships, and gather data on him.
                        One of the problems with Domain Model (116) is the interface with relational
                        databases. In many ways this approach treats the relational database like a crazy
                        aunt whoâ€™s shut up in an attic and whom nobody wants to talk about. As a result
                        you often need considerable programmatic gymnastics to pull data in and out of
                        the database, transforming between two different representations of the data.
                        A Table Module organizes domain logic with one class per table in the database, and a single instance of a class contains the various procedures that will
                        act on the data. The primary distinction with Domain Model (116) is that, if
                        you have many orders, a Domain Model (116) will have one order object per
                        order while a Table Module will have one object to handle all orders.</p>
                <h4 id="126">How It Works</h4>
                <p>The strength of Table Module is that it allows you to package the data and
                        behavior together and at the same time play to the strengths of a relational
                        database. On the surface Table Module looks much like a regular object. The
                        key difference is that it has no notion of an identity for the objects itâ€™s working
                        with. Thus, if you want to obtain the address of an employee, you use a method
                        like anEmployeeModule.getAddress(long employeeID). Every time you want to do something to a particular employee you have to pass in some kind of identity reference. Often this will be the primary key used in the database.
                        Usually you use Table Module with a backing data structure thatâ€™s table oriented. The tabular data is normally the result of a SQL call and is held in a
                        Record Set (508) that mimics a SQL table. The Table Module gives you an
                        explicit method-based interface that acts on that data. Grouping the behavior
                        with the table gives you many of the benefits of encapsulation in that the behavior is close to the data it will work on.
                        Often youâ€™ll need behavior from multiple Table Modules in order to do some
                        useful work. Many times you see multiple Table Modules operating on the same
                        Record Set (508) (Figure 9.4).</p>
                <p>The most obvious example of Table Module is the use of one for each table
                        in the database. However, if you have interesting queries and views in the database you can have Table Modules for them as well.
                        Table Module The Table Module may be an instance or it may be a collection of static
                        methods. The advantage of an instance is that it allows you to initialize the
                        Table Module with an existing record set, perhaps the result of a query. You can
                        then use the instance to manipulate the rows in the record set. Instances also
                        make it possible to use inheritance, so we can write a rush contract module that
                        contains additional behavior to the regular contract.</p>
                <p>The Table Module may include queries as factory methods. The alternative is
                        a Table Data Gateway (144), but the disadvantage of this is having an extra
                        Table Data Gateway (144) class and mechanism in the design. The advantage is
                        that you can use a single Table Module on data from different data sources,
                        since you use a different Table Data Gateway (144) for each data source.
                        When you use a Table Data Gateway (144) the application first uses the
                        Table Data Gateway (144) to assemble data in a Record Set (508). You then
                        create a Table Module with the Record Set (508) as an argument. If you need
                        behavior from multiple Table Modules, you can create them with the same
                        Record Set (508). The Table Module can then do business logic on the Record
                        Set (508) and pass the modified Record Set (508) to the presentation for display
                        and editing using the table-aware widgets. The widgets canâ€™t tell if the record
                        Table Module sets came directly from the relational database or if a Table Module manipulated the data on the way out. After modification in the GUI, the data set goes
                        back to the Table Module for validation before itâ€™s saved to the database. One
                        of the benefits of this style is that you can test the Table Module by creating a
                        Record Set (508) in memory without going to the database.</p>
                <p>The word â€œtableâ€ in the pattern name suggests that you have one Table
                        Module per table in the database. While this is true to the first approximation,
                        it isnâ€™t completely true. Itâ€™s also useful to have a Table Module for commonly
                        used views or other queries. Indeed, the structure of the Table Module doesnâ€™t
                        really depend on the structure of tables in the database but more on the virtual
                        tables perceived by the application, including views and queries.</p>
                <h4 id="128">When to Use It</h4>
                <p>Table Module is very much based on table-oriented data, so obviously using it
                        makes sense when youâ€™re accessing tabular data using Record Set (508). It also
                        puts that data structure very much in the center of the code, so you also want
                        the way you access the data structure to be fairly straightforward.
                        However, Table Module doesnâ€™t give you the full power of objects in organizing complex logic. You canâ€™t have direct instance-to-instance relationships, and
                        polymorphism doesnâ€™t work well. So, for handling complicated domain logic, a
                        Domain Model (116) is a better choice. Essentially you have to trade off
                        Domain Model (116)â€™s ability to handle complex logic against Table Moduleâ€™s
                        easier integration with the underlying table-oriented data structures.
                        If the objects in a Domain Model (116) and the database tables are relatively
                        similar, it may be better to use a Domain Model (116) that uses Active Record
                        (160). Table Module works better than a combination of Domain Model (116)
                        and Active Record (160) when other parts of the application are based on a
                        common table-oriented data structure. Thatâ€™s why you donâ€™t see Table Module
                        very much in the Java environment, although that may change as row sets
                        become more widely used.
                        The most well-known situation in which Iâ€™ve come across this pattern is in
                        Microsoft COM designs. In COM (and .NET) the Record Set (508) is the primary repository of data in an application. Record sets can be passed to the UI,
                        where data-aware widgets display information. Microsoftâ€™s ADO libraries give
                        you a good mechanism to access the relational data as record sets. In this situation Table Module allows you to fit business logic into the application in a wellorganized manner, without losing the way the various elements work on the
                        tabular data.</p>
                <h4 id="129">Example: Revenue Recognition with a Table Module (C#)</h4>
                <p>Time to revisit the revenue recognition example (page 112) I used in the other
                        domain modeling patterns, this time with a Table Module. To recap, our mission is to recognize revenue on orders when the rules vary depending on the
                        product type. In this example we have different rules for word processors,
                        spreadsheets, and databases.</p>
                <p>Table Module is based on a data schema of some kind, usually a relational
                        data model (although in the future we may well see an XML model used in a
                        similar way). In this case Iâ€™ll use the relational schema from Figure 9.6.
                        The classes that manipulate this data are in pretty much the same form;
                        thereâ€™s one Table Module class for each table. In the .NET architecture a data
                        set object provides an in-memory representation of a database structure. It thus
                        makes sense to create classes that operate on this data set. Each Table Module
                        class has a data member of a data table, which is the .NET system class corresponding to a table within the data set. This ability to read a table is common
                        to all Table Modules and so can appear in a Layer Supertype (475).
                        <pre>class TableModule...
                        protected DataTable table;
                        protected TableModule(DataSet ds, String tableName) {
                        table = ds.Tables[tableName];
                        }</pre>
                        The subclass constructor calls the superclass constructor with the correct
                        table name.
                        <pre>class Contract...
                        public Contract (DataSet ds) : base (ds, "Contracts") {}</pre>
                        Figure 9.6 Database schema for revenue recognition.
                        ID: Number
                        Name: String
                        Type: String
                        Â«tableÂ»
                        Products
                        ID: Number
                        whenSigned: Date
                        Amount: Number
                        Â«tableÂ»
                        Contracts
                        ID: Number
                        amount: Number
                        date: Date
                        Â«tableÂ»
                        Revenue 1 1 Recognitions
                        * *
                        This allows you to create a new Table Module just by passing in a data set to
                        Table Moduleâ€™s constructor
                        <pre>contract = new Contract(dataset);</pre>
                        which keeps the code that creates the data set away from the Table Modules,
                        following the guidelines of ADO.NET. </p>
                <p>A useful feature is the C# indexer, which gets to a particular row in the data
                        table given the primary key.</p>
                        <pre>class Contract...
                        public DataRow this [long key] {
                        get {
                        String filter = String.Format("ID = {0}", key);
                        return table.Select(filter)[0];
                        }
                        }</pre>
                <p>The first piece of functionality calculates the revenue recognition for a contract, updating the revenue recognition table accordingly. The amount recognized depends on the kind of product we have. Since this behavior mainly uses
                        data from the contract table, I decided to add the method to the contract class.
                        <pre>class Contract...
                        public void CalculateRecognitions (long contractID) {
                        DataRow contractRow = this[contractID];
                        Decimal amount = (Decimal)contractRow["amount"];
                        RevenueRecognition rr = new RevenueRecognition (table.DataSet);
                        Product prod = new Product(table.DataSet);
                        long prodID = GetProductId(contractID);
                        if (prod.GetProductType(prodID) == ProductType.WP) {
                        rr.Insert(contractID, amount, (DateTime) GetWhenSigned(contractID));
                        } else if (prod.GetProductType(prodID) == ProductType.SS) {
                        Decimal[] allocation = allocate(amount,3);
                        rr.Insert(contractID, allocation[0], (DateTime) GetWhenSigned(contractID));
                        rr.Insert(contractID, allocation[1], (DateTime)
                        GetWhenSigned(contractID).AddDays(60));
                        rr.Insert(contractID, allocation[2], (DateTime)
                        GetWhenSigned(contractID).AddDays(90));
                        } else if (prod.GetProductType(prodID) == ProductType.DB) {
                        Decimal[] allocation = allocate(amount,3);
                        rr.Insert(contractID, allocation[0], (DateTime) GetWhenSigned(contractID));
                        rr.Insert(contractID, allocation[1], (DateTime)
                        GetWhenSigned(contractID).AddDays(30));
                        rr.Insert(contractID, allocation[2], (DateTime)
                        GetWhenSigned(contractID).AddDays(60));
                        } else throw new Exception("invalid product id");
                        }
                        private Decimal[] allocate(Decimal amount, int by) {
                        Decimal lowResult = amount / by;
                        TABLE MODULE 131
                        Table Module lowResult = Decimal.Round(lowResult,2);
                        Decimal highResult = lowResult + 0.01m;
                        Decimal[] results = new Decimal[by];
                        int remainder = (int) amount % by;
                        for (int i = 0; i &lt; remainder; i++) results[i] = highResult;
                        for (int i = remainder; i &lt; by; i++) results[i] = lowResult;
                        return results;
                        }</pre>
                        Usually I would use Money (488) here, but for varietyâ€™s sake Iâ€™ll show this using
                        a decimal. I use an allocation method similar to the one I use for Money (488).
                        To carry this out, we need some behavior thatâ€™s defined on the other classes.
                        The product needs to be able to tell us which type it is. We can do this with an
                        enum for the product type and a lookup method.
                        <pre>public enum ProductType {WP, SS, DB};
                        class Product...
                        public ProductType GetProductType (long id) {
                        String typeCode = (String) this[id]["type"];
                        return (ProductType) Enum.Parse(typeof(ProductType), typeCode);
                        }
                        GetProductType</pre> encapsulates the data in the data table. Thereâ€™s an argument for
                        doing this for all columns of data, as opposed to accessing them directly as I did
                        with the amount on the contract. While encapsulation is generally a Good
                        Thing, I donâ€™t use it here because it doesnâ€™t fit with the assumption of the environment that different parts of the system access the data set directly. Thereâ€™s no
                        encapsulation when the data set moves over to the UI, so column access functions only make sense when thereâ€™s some additional functionality to be done,
                        such as converting a string to a product type.
                        This is also a good time to mention that, although Iâ€™m using an untyped data
                        set here because these are more common on different platforms, thereâ€™s a strong
                        argument (page 509) for using .NETâ€™s strongly typed data set.
                        The other additional behavior is inserting a new revenue recognition record.
                        <pre>class RevenueRecognition...
                        public long Insert (long contractID, Decimal amount, DateTime date) {
                        DataRow newRow = table.NewRow();
                        long id = GetNextID();
                        newRow["ID"] = id;
                        newRow["contractID"] = contractID;
                        newRow["amount"] = amount;
                        newRow["date"]= String.Format("{0:s}", date);
                        table.Rows.Add(newRow);
                        return id;
                        }</pre>
                        132 DOMAIN LOGIC PATTERNS
                        Table Module Again, the point of this method is less to encapsulate the data row and more to
                        have a method instead of several lines of code that are repeated.
                        The second piece of functionality is to sum up all the revenue recognized on
                        a contract by a given date. Since this uses the revenue recognition table it makes
                        sense to define the method there.
                        <pre>class RevenueRecognition...
                        public Decimal RecognizedRevenue (long contractID, DateTime asOf) {
                        String filter = String.Format("ContractID = {0} AND date &lt;= #{1:d}#", contractID,asOf);
                        DataRow[] rows = table.Select(filter);
                        Decimal result = 0m;
                        foreach (DataRow row in rows) {
                        result += (Decimal)row["amount"];
                        }
                        return result;
                        }</pre>
                        This fragment takes advantage of the really nice feature of ADO.NET that
                        allows you to define a where clause and then select a subset of the data table to
                        manipulate. Indeed, you can go further and use an aggregate function.
                        <pre>class RevenueRecognition...
                        public Decimal RecognizedRevenue2 (long contractID, DateTime asOf) {
                        String filter = String.Format("ContractID = {0} AND date &lt;= #{1:d}#", contractID,asOf);
                        String computeExpression = "sum(amount)";
                        Object sum = table.Compute(computeExpression, filter);
                        return (sum is System.DBNull) ? 0 : (Decimal) sum;
                        }</pre></p>
                <h3 id="133">Service Layer</h3>
                <p>Defines an applicationâ€™s boundary with a layer of services that
                        establishes a set of available operations and coordinates the
                        applicationâ€™s response in each operation.
                        Enterprise applications typically require different kinds of interfaces to the data
                        they store and the logic they implement: data loaders, user interfaces, integration gateways, and others. Despite their different purposes, these interfaces
                        often need common interactions with the application to access and manipulate
                        its data and invoke its business logic. The interactions may be complex, involving transactions across multiple resources and the coordination of several
                        responses to an action. Encoding the logic of the interactions separately in each
                        interface causes a lot of duplication.
                        A Service Layer defines an applicationâ€™s boundary [Cockburn PloP] and its
                        set of available operations from the perspective of interfacing client layers. It
                        encapsulates the applicationâ€™s business logic, controlling transactions and coordinating responses in the implementation of its operations.</p>
                <h4 id="134">How It Works</h4>
                <p>A Service Layer can be implemented in a couple of different ways, without violating the defining characteristics stated above. The differences appear in the
                        allocation of responsibility behind the Service Layer interface. Before I delve
                        into the various implementation possibilities, let me lay a bit of groundwork.</p>
                <p><b>Kinds of â€œBusiness Logicâ€</b> Like Transaction Script (110) and Domain Model
                        (116), Service Layer is a pattern for organizing business logic. Many designers,
                        including me, like to divide â€œbusiness logicâ€ into two kinds: â€œdomain logic,â€
                        having to do purely with the problem domain (such as strategies for calculating
                        revenue recognition on a contract), and â€œapplication logic,â€ having to do with
                        application responsibilities [Cockburn UC] (such as notifying contract administrators, and integrated applications, of revenue recognition calculations). Application logic is sometimes referred to as â€œworkflow logic,â€ although different
                        people have different interpretations of â€œworkflow.â€</p>
                <p>Domain Models (116) are preferable to Transaction Scripts (110) for avoiding domain logic duplication and for managing complexity using classical
                        design patterns. But putting application logic into pure domain object classes
                        has a couple of undesirable consequences. First, domain object classes are less
                        reusable across applications if they implement application-specific logic and
                        depend on application-specific packages. Second, commingling both kinds of
                        logic in the same classes makes it harder to reimplement the application logic
                        in, say, a workflow tool if that should ever become desirable. For these reasons
                        Service Layer factors each kind of business logic into a separate layer, yielding
                        the usual benefits of layering and rendering the pure domain object classes more
                        reusable from application to application.</p>
                <p><b>Implementation Variations</b> The two basic implementation variations are the
                        domain facade approach and the operation script approach. In the domain
                        facade approach a Service Layer is implemented as a set of thin facades over a
                        Domain Model (116). The classes implementing the facades donâ€™t implement
                        any business logic. Rather, the Domain Model (116) implements all of the business logic. The thin facades establish a boundary and set of operations through
                        which client layers interact with the application, exhibiting the defining characteristics of Service Layer. sIn the operation script approach a Service Layer is implemented as a set of
                        thicker classes that directly implement application logic but delegate to encapsulated domain object classes for domain logic. The operations available to clients
                        of a Service Layer are implemented as scripts, organized several to a class defining a subject area of related logic. Each such class forms an application â€œservice,â€ and itâ€™s common for service type names to end with â€œService.â€ A Service
                        Layer is comprised of these application service classes, which should extend a
                        Layer Supertype (475), abstracting their responsibilities and common behaviors.</p>
                <p><i>To Remote or Not to Remote</i> The interface of a Service Layer class is coarse
                        grained almost by definition, since it declares a set of application operations
                        available to interfacing client layers. Therefore, Service Layer classes are well
                        suited to remote invocation from an interface granularity perspective.
                        However, remote invocation comes at the cost of dealing with object distribution. It likely entails a lot of extra work to make your Service Layer method
                        signatures deal in Data Transfer Objects (401). Donâ€™t underestimate the cost of
                        this work, especially if you have a complex Domain Model (116) and rich editing UIs for complex update use cases! Itâ€™s significant, and itâ€™s painfulâ€”perhaps
                        second only to the cost and pain of object-relational mapping. Remember the
                        First Law of Distributed Object Design (page 89).</p>
                <p>My advice is to start with a locally invocable Service Layer whose method
                        signatures deal in domain objects. Add remotability when you need it (if ever)
                        by putting Remote Facades (388) on your Service Layer or having your Service
                        Layer objects implement remote interfaces. If your application has a Web-based
                        UI or a Web-services-based integration gateway, thereâ€™s no law that says your
                        business logic has to run in a separate process from your server pages and Web
                        services. In fact, you can save yourself some development effort and runtime
                        response time, without sacrificing scalability, by starting out with a colocated
                        approach.</p>
                <p><i>Identifying Services and Operations</i> Identifying the operations needed on a Service Layer boundary is pretty straightforward. Theyâ€™re determined by the needs
                        of Service Layer clients, the most significant (and first) of which is typically a
                        user interface. Since a user interface is designed to support the use cases that
                        actors want to perform with an application, the starting point for identifying
                        Service Layer operations is the use case model and the user interface design for
                        the application.
                        Disappointing as it is, many of the use cases in an enterprise application
                        are fairly boring â€œCRUDâ€ (create, read, update, delete) use cases on domain
                        objectsâ€”create one of these, read a collection of those, update this other
                        thing. My experience is that thereâ€™s almost always a one-to-one correspondence between CRUD use cases and Service Layer operations.
                        The applicationâ€™s responsibilities in carrying out these use cases, however,
                        may be anything but boring. Validation aside, the creation, update, or deletion
                        of a domain object in an application increasingly requires notification of other
                        people and other integrated applications. These responses must be coordinated,
                        and transacted atomically, by Service Layer operations.</p>
                <p>If only it were as straightforward to identify Service Layer abstractions to
                        group related operations. There are no hard-and-fast prescriptions in this area;
                        only vague heuristics. For a sufficiently small application, it may suffice to have
                        but one abstraction, named after the application itself. In my experience larger
                        applications are partitioned into several â€œsubsystems,â€ each of which includes a
                        complete vertical slice through the stack of architecture layers. In this case I prefer
                        one abstraction per subsystem, named after the subsystem. Other possibilities
                        include abstractions reflecting major partitions in a domain model, if these are
                        different from the subsystem partitions (e.g., ContractsService, ProductsService), and
                        abstractions named after thematic application behaviors (e.g., RecognitionService).</p>
                <h5>Java Implementation</h5>
                <p>In both the domain facade approach and the operation script approach, a
                        Service Layer class can be implemented as either a POJO (plain old Java
                        object) or a stateless session bean. The trade-off pits ease of testing against
                        ease of transaction control. POJOs might be easier to test, since they donâ€™t
                        have to be deployed in an EJB container to run, but itâ€™s harder for a POJO
                        Service Layer to hook into distributed container-managed transaction services, especially in interservice invocations. EJBs, on the other hand, come
                        with the potential for container-managed distributed transactions but have
                        to be deployed in a container before they can be tested and run. Choose
                        your poison.</p>
                <p>My preferred way of applying a Service Layer in J2EE is with EJB 2.0
                        stateless session beans, using local interfaces, and the operation script
                        approach, delegating to POJO domain object classes. Itâ€™s just so darned convenient to implement a Service Layer using stateless session bean, because of
                        the distributed container-managed transactions provided by EJB. Also, with
                        the local interfaces introduced in EJB 2.0, a Service Layer can exploit the
                        valuable transaction services while avoiding the thorny object distribution
                        issues.
                        On a related Java-specific note, let me differentiate Service Layer from
                        the Session Facade pattern documented in the J2EE patterns literature
                        [Alur et al.] and [Marinescu]. Session Facade was motivated by the desire
                        to avoid the performance penalty of too many remote invocations on entity
                        beans; it therefore prescribes facading entity beans with session beans. Service Layer is motivated instead by factoring responsibility to avoid duplication and promote reusability; itâ€™s an architecture pattern that transcends
                        technology. In fact, the application boundary pattern [Cockburn PloP] that
                        inspired Service Layer predates EJB by three years. Session Facade may be
                        in the spirit of Service Layer but, as currently named, scoped, and presented,
                        is not the same.</p>
                <h4 id="137">When to Use It</h4>
                <p>The benefit of Service Layer is that it defines a common set of application operations available to many kinds of clients and it coordinates an applicationâ€™s
                        response in each operation. The response may involve application logic that
                        needs to be transacted atomically across multiple transactional resources. Thus,
                        in an application with more than one kind of client of its business logic, and
                        complex responses in its use cases involving multiple transactional resources, it
                        makes a lot of sense to include a Service Layer with container-managed transactions, even in an undistributed architecture.
                        The easier question to answer is probably when not to use it. You probably
                        donâ€™t need a Service Layer if your applicationâ€™s business logic will only have one
                        kind of clientâ€”say, a user interfaceâ€”and its use case responses donâ€™t involve
                        multiple transactional resources. In this case your Page Controllers can manually control transactions and coordinate whatever response is required, perhaps
                        delegating directly to the Data Source layer.
                        But as soon as you envision a second kind of client, or a second transactional
                        resource in use case responses, it pays to design in a Service Layer from the
                        beginning.</p>
                <h4 id="137(2)">Further Reading</h4>
                <p>Thereâ€™s not a great deal of prior art on Service Layer, whose inspiration is
                        Alistair Cockburnâ€™s application boundary pattern [Cockburn PloP]. In the
                        remotable services vein [Alpert, et al.] discuss the role of facades in distributed
                        systems. Compare and contrast this with the various presentations of Session
                        Facade [Alur et al.] and [Marinescu]. On the topic of application responsibilities that must be coordinated within Service Layer operations, Cockburnâ€™s
                        description of use cases as a contract for behavior [Cockburn UC] is very helpful. An earlier background reference is the Fusion methodologyâ€™s recognition of
                        â€œsystem operationsâ€ [Coleman et al.].</p>
                <h4 id="138">Example: Revenue Recognition (Java)</h4>
                        This example continues the revenue recognition example of the Transaction
                        Script (110) and Domain Model (116) patterns, demonstrating how Service
                        Layer is used to script application logic and delegate for domain logic in a Service Layer operation. It uses the operation script approach to implement a Service Layer, first with POJOs and then with EJBs.
                        To make the demonstration we expand the scenario to include some application logic. Suppose the use cases for the application require that, when the revenue recognitions for a contract are calculated, the application must respond by
                        sending an e-mail notification of that event to a designated contract administrator and by publishing a message using message-oriented middleware to notify
                        other integrated applications.
                        We start by changing the RecognitionService class from the Transaction
                        Script (110) example to extend a Layer Supertype (475) and to use a couple of
                        Gateways (466) in carrying out application logic. This yields the class diagram
                        of Figure 9.7. RecognitionService becomes a POJO implementation of a Service
                        Layer application service, and its methods represent two of the operations
                        available at the applicationâ€™s boundary.</p>
                <p>The methods of the RecognitionService class script the application logic of
                        the operations, delegating to domain object classes (of the example from
                        Domain Model (116)) for domain logic.
                        <pre>public class ApplicationService {
                        protected EmailGateway getEmailGateway() {
                        //return an instance of EmailGateway
                        }
                        protected IntegrationGateway getIntegrationGateway() {
                        //return an instance of IntegrationGateway
                        }
                        }
                        public interface EmailGateway {
                        void sendEmailMessage(String toAddress, String subject, String body);
                        }
                        public interface IntegrationGateway {
                        void publishRevenueRecognitionCalculation(Contract contract);
                        }
                        public class RecognitionService
                        extends ApplicationService {
                        public void calculateRevenueRecognitions(long contractNumber) {
                        Contract contract = Contract.readForUpdate(contractNumber);
                        contract.calculateRecognitions();
                        getEmailGateway().sendEmailMessage(
                        contract.getAdministratorEmailAddress(),
                        "RE: Contract #" + contractNumber,
                        contract + " has had revenue recognitions calculated.");
                        getIntegrationGateway().publishRevenueRecognitionCalculation(contract);
                        }
                        Serv
                        ice
                        Layer
                        Figure 9.7 RecognitionService POJO class diagram.
                        +calculateRevenueRecognitions(in contractNumber : long) : void
                        +recognizedRevenue(in contractNumber : long, in asOf : Date) : Money
                        RecognitionService
                        +getEmailGateway() : EmailGateway
                        +getIntegrationGateway() : IntegrationGateway
                        ApplicationService
                        +sendEmailMessage(in toAddress : String, in subject : String, in body : String) : void
                        Â«interfaceÂ»
                        EmailGateway
                        +publishRevenueRecognitionCalculation(in contract : Contract) : void
                        Â«interfaceÂ»
                        IntegrationGateway
                        Â«usesÂ»
                        Â«usesÂ»
                        public Money recognizedRevenue(long contractNumber, Date asOf) {
                        return Contract.read(contractNumber).recognizedRevenue(asOf);
                        }
                        }</pre>
                        Persistence details are again left out of the example. Suffice it to say that the
                        Contract class implements static methods to read contracts from the Data Source
                        layer by their numbers. One of these methods has a name revealing an intention
                        to update the contract thatâ€™s read, which allows an underlying Data Mapper
                        (165) to register the read object(s) with for example, a Unit of Work (184).</p>
                <p>Transaction control details are also left out of the example. The calculateRevenueRecognitions() method is inherently transactional because, during its execution,
                        persistent contract objects are modified via addition of revenue recognitions;
                        messages are enqueued in message-oriented middleware; and e-mail messages
                        are sent. All of these responses must be transacted atomically because we donâ€™t
                        want to send e-mail and publish messages to other applications if the contract
                        changes fail to persist.
                        In the J2EE platform we can let the EJB container manage distributed transactions by implementing application services (and Gateways (466)) as stateless
                        session beans that use transactional resources. Figure 9.8 shows the class diagram of a RecognitionService implementation that uses EJB 2.0 local interfaces
                        and the â€œbusiness interfaceâ€ idiom. In this implementation a Layer Supertype
                        (475) is still used, providing default implementations of the bean implementation class methods required by EJB, in addition to the application-specific methods. If we assume that the EmailGateway and IntegrationGateway interfaces are also
                        â€œbusiness interfacesâ€ for their respective stateless session beans, then control of
                        the distributed transaction is achieved by declaring the calculateRevenueRecognitions, sendEmailMessage, and publishRevenueRecognitionCalculation methods to be
                        transactional. The RecognitionService methods from the POJO example move
                        unchanged to RecognitionServiceBeanImpl.</p>
                <p>The important point about the example is that the Service Layer uses both
                        operation scripting and domain object classes in coordinating the transactional
                        response of the operation. The calculateRevenueRecognitions method scripts the
                        application logic of the response required by the applicationâ€™s use cases, but it
                        delegates to the domain object classes for domain logic. It also presents a couple
                        of techniques for combating duplicated logic within operation scripts of a Service Layer. Responsibilities are factored into different objects (e.g., Gateways
                        (466)) that can be reused via delegation. A Layer Supertype (475) provides convenient access to these other objects.
                        Some might argue that a more elegant implementation of the operation
                        script would use the Observer pattern [Gang of Four], but Observer is difficult
                        ice
                        Layer
                        Figure 9.8 RecognitionService EJB class diagram.
                        Â«interfaceÂ»
                        javax.ejb.EJBLocalObject
                        +calculateRevenueRecognitions(in contractNumber : long) : void
                        +recognizedRevenue(in contractNumber : long, in asOf : Date) : Money
                        Â«interfaceÂ»
                        RecognitionService
                        Â«interfaceÂ»
                        RecognitionServiceBean
                        Â«interfaceÂ»
                        javax.ejb.SessionBean
                        +calculateRevenueRecognitions(in contractNumber : long) : void
                        +recognizedRevenue(in contractNumber : long, in asOf : Date) : Money
                        RecognitionServiceBeanImpl
                        +getEmailService() : EmailService
                        +getIntegrationService() : IntegrationService
                        ApplicationServiceBeanImpl
                        142 DOMAIN LOGIC PATTERNS
                        Service
                        Layer
                        to implement in a stateless, multithreaded Service Layer. In my opinion the
                        open code of the operation script is clearer and simpler.
                        Some might also argue that the application logic responsibilities could be
                        implemented in domain object methods, such as Contract.calculateRevenueRecognitions(), or even in the data source layer, thereby eliminating the need for a separate Service Layer. However, I find those allocations of responsibility
                        undesirable for a number of reasons. First, domain object classes are less reusable across applications if they implement application-specific logic (and
                        depend on application-specific Gateways (466), and the like). They should
                        model the parts of the problem domain that are of interest to the application,
                        which doesnâ€™t mean all of the applicationâ€™s use case responsibilities. Second,
                        encapsulating application logic in a â€œhigherâ€ layer dedicated to that purpose
                        (which the data source layer isnâ€™t) facilitates changing the implementation of
                        that layerâ€”perhaps to use a workflow engine.
                        As an organization pattern for the logic layer of an enterprise application,
                        Service Layer combines scripting and domain object classes, leveraging the best
                        aspects of both. Several variations are possible in a Service Layer implementationâ€”for example, domain facades or operation scripts, POJOs or session
                        beans, or a combination of both. Service Layer can be designed for local invocation, remote invocation, or both. Most important, regardless of these variations, this pattern lays the foundation for encapsulated implementation of an
                        applicationâ€™s business logic and consistent invocation of that logic by its various
                        clients.</p>
                <h3 id="143">Chapter 10</h3>
                <h1>Data Source Architectural Patterns</h1>
                <h3 id="144">Table Data Gateway</h3>
                <p>An object that acts as a Gateway (466) to a database table.
                        One instance handles all the rows in the table.
                        Mixing SQL in application logic can cause several problems. Many developers
                        arenâ€™t comfortable with SQL, and many who are comfortable may not write it
                        well. Database administrators need to be able to find SQL easily so they can figure out how to tune and evolve the database.
                        A Table Data Gateway holds all the SQL for accessing a single table or
                        view: selects, inserts, updates, and deletes. Other code calls its methods for all
                        interaction with the database.</p>
                <h3 id="144(2)">How It Works</h3>
                <p>A Table Data Gateway has a simple interface, usually consisting of several find
                        methods to get data from the database and update, insert, and delete methods.
                        Each method maps the input parameters into a SQL call and executes the SQL
                        against a database connection.The Table Data Gateway is usually stateless, as
                        its role is to push data back and forth.
                        The trickiest thing about a Table Data Gateway is how it returns information from a query. Even a simple find-by-ID query will return multiple data
                        items. In environments where you can return multiple items you can use that
                        for a single row, but many languages give you only a single return value and
                        many queries return multiple rows.
                        One alternative is to return some simple data structure, such as a map. A
                        map works, but it forces data to be copied out of the record set that comes from
                        the database into the map. I think that using maps to pass data around is bad
                        form because it defeats compile time checking and isnâ€™t a very explicit interface,
                        find (id) : RecordSet
                        findWithLastName(String) : RecordSet
                        update (id, lastname, firstname, numberOfDependents)
                        insert (lastname, firstname, numberOfDependents)
                        delete (id)
                        Person Gateway
                        TABLE DATA GATEWAY 145
                        Data Source
                        Architectural
                        Patterns
                        leading to bugs as people misspell whatâ€™s in the map. A better alternative is to
                        use a Data Transfer Object (401). Itâ€™s another object to create but one that may
                        well be used elsewhere.
                        To save all this you can return the Record Set (508) that comes from the SQL
                        query. This is conceptually messy, as ideally the in-memory object doesnâ€™t have to
                        know anything about the SQL interface. It may also make it difficult to substitute
                        the database for a file if you canâ€™t easily create record sets in your own code. Nevertheless, in many environments that use Record Set (508) widely, such as .NET,
                        itâ€™s a very effective approach. A Table Data Gateway thus goes very well with
                        Table Module (125). If all of your updates are done through the Table Data Gateway, the returned data can be based on views rather than on the actual tables,
                        which reduces the coupling between your code and the database.
                        If youâ€™re using a Domain Model (116), you can have the Table Data Gateway return the appropriate domain object. The problem with this is that you
                        then have bidirectional dependencies between the domain objects and the gateway. The two are closely connected, so that isnâ€™t necessarily a terrible thing, but
                        itâ€™s something Iâ€™m always reluctant to do.</p>
                <p>Most times when you use Table Data Gateway, youâ€™ll have one for each
                        table in the database. For very simple cases, however, you can have a single
                        Table Data Gateway that handles all methods for all tables. You can also have
                        one for views or even for interesting queries that arenâ€™t kept in the database as
                        views. Obviously, view-based Table Data Gateways often canâ€™t update and so
                        wonâ€™t have update behavior. However, if you can make updates to the underlying tables, then encapsulating the updates behind update operations on the
                        Table Data Gateway is a very good technique. </p>
                <h3 id="145">When to Use It</h3>
                <p>As with Row Data Gateway (152) the decision regarding Table Data Gateway
                        is first whether to use a Gateway (466) approach at all and then which one.
                        I find that Table Data Gateway is probably the simplest database interface
                        pattern to use, as it maps so nicely onto a database table or record type. It also
                        makes a natural point to encapsulate the precise access logic of the data source.
                        I use it least with Domain Model (116) because I find that Data Mapper (165)
                        gives a better isolation between the Domain Model (116) and the database.
                        Table Data Gateway works particularly well with Table Module (125),
                        where it produces a record set data structure for the Table Module (125) to
                        work on. Indeed, I canâ€™t really imagine any other database-mapping approach
                        for Table Module (125).
                        Just like Row Data Gateway (152), Table Data Gateway is very suitable for
                        Transaction Scripts (110). The choice between the two really boils down to
                        how they deal with multiple rows of data. Many people like using a Data
                        Transfer Object (401), but that seems to me like more work than is worthwhile,
                        unless the same Data Transfer Object (401) is used elsewhere. I prefer Table
                        Data Gateway when the result set representation is convenient for the Transaction Script (110) to work with.
                        Interestingly, it often makes sense to have the Data Mappers (165) talk to the
                        database via Table Data Gateways. Although this isnâ€™t useful when everything
                        is handcoded, it can be very effective if you want to use metadata for the Table
                        Data Gateways but prefer handcoding for the actual mapping to the domain
                        objects.</p>
                <p>One of the benefits of using a Table Data Gateway to encapsulate database
                        access is that the same interface can work both for using SQL to manipulate the
                        database and for using stored procedures. Indeed, stored procedures themselves
                        are often organized as Table Data Gateways. That way the insert and update
                        stored procedures encapsulate the actual table structure. The find procedures in
                        this case can return views, which helps to hide the underlying table structure.</p>
                <h3 id="146">Further Reading</h3>
                <p>[Alur et al.] discusses the Data Access Object pattern, which is a Table Data
                        Gateway. They show returning a collection of Data Transfer Objects (401) on
                        the query methods. Itâ€™s not clear whether they see this pattern as always being
                        table based; the intent and discussion seems to imply either Table Data Gateway or Row Data Gateway (152).
                        Iâ€™ve used a different name, partly because I see this pattern as a particular
                        usage of the more general Gateway (466) concept and I want the pattern name
                        to reflect that. Also, the term Data Access Object and its abbreviation DAO has
                        its own particular meaning within the Microsoft world.</p>
                <h3 id="146(2)">Example: Person Gateway (C#)</h3>
                <p>Table Data Gateway is the usual form of database access in the windows
                        world, so it makes sense to illustrate one with C#. I have to stress, however, that
                        this classic form of Table Data Gateway doesnâ€™t quite fit in the .NET environment since it doesnâ€™t take advantage of the ADO.NET data set; instead, it uses
                        the data reader, which is a cursor-like interface to database records. The data
                        TABLE DATA GATEWAY 147
                        Data Source
                        Architectural
                        Patterns
                        reader is the right choice for manipulating larger amounts of information when
                        you donâ€™t want to bring everything into memory in one go.</p>
                <p>For the example Iâ€™m using a Person Gateway class that connects to a person
                        table in a database. The Person Gateway contains the finder code, returning
                        ADO.NETâ€™s data reader to access the returned data.
                        <pre>class PersonGateway...
                        public IDataReader FindAll() {
                        String sql = "select * from person";
                        return new OleDbCommand(sql, DB.Connection).ExecuteReader();
                        }
                        public IDataReader FindWithLastName(String lastName) {
                        String sql = "SELECT * FROM person WHERE lastname = ?";
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter("lastname", lastName));
                        return comm.ExecuteReader();
                        }
                        public IDataReader FindWhere(String whereClause) {
                        String sql = String.Format("select * from person where {0}", whereClause);
                        return new OleDbCommand(sql, DB.Connection).ExecuteReader();
                        }</pre>
                        Almost always youâ€™ll want to pull back a bunch of rows with a reader. On a
                        rare occasion you might want to get hold of an individual row of data with a
                        method along these lines:
                        <pre>class PersonGateway...
                        public Object[] FindRow (long key) {
                        String sql = "SELECT * FROM person WHERE id = ?";
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter("key",key));
                        IDataReader reader = comm.ExecuteReader();
                        reader.Read();
                        Object [] result = new Object[reader.FieldCount];
                        reader.GetValues(result);
                        reader.Close();
                        return result;
                        }</pre>
                        The update and insert methods receive the necessary data in arguments and
                        invoke the appropriate SQL routines.
                        <pre>class PersonGateway...
                        public void Update (long key, String lastname, String firstname, long numberOfDependents){
                        String sql = @"
                        UPDATE person
                        SET lastname = ?, firstname = ?, numberOfDependents = ?
                        WHERE id = ?";
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter ("last", lastname));
                        comm.Parameters.Add(new OleDbParameter ("first", firstname));
                        comm.Parameters.Add(new OleDbParameter ("numDep", numberOfDependents));
                        comm.Parameters.Add(new OleDbParameter ("key", key));
                        comm.ExecuteNonQuery();
                        }
                        class PersonGateway...
                        public long Insert(String lastName, String firstName, long numberOfDependents) {
                        String sql = "INSERT INTO person VALUES (?,?,?,?)";
                        long key = GetNextID();
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter ("key", key));
                        comm.Parameters.Add(new OleDbParameter ("last", lastName));
                        comm.Parameters.Add(new OleDbParameter ("first", firstName));
                        comm.Parameters.Add(new OleDbParameter ("numDep", numberOfDependents));
                        comm.ExecuteNonQuery();
                        return key;
                        }</pre>
                        The deletion method just needs a key.
                        <pre>class PersonGateway...
                        public void Delete (long key) {
                        String sql = "DELETE FROM person WHERE id = ?";
                        IDbCommand comm = new OleDbCommand(sql, DB.Connection);
                        comm.Parameters.Add(new OleDbParameter ("key", key));
                        comm.ExecuteNonQuery();
                        }</pre></p>
                <h3 id="148">Example: Using ADO.NET Data Sets (C#)</h3>
                <p>The generic Table Data Gateway works with pretty much any kind of platform
                        since itâ€™s nothing but a wrapper for SQL statements. With .NET you use data
                        sets more often, but Table Data Gateway is still useful although it comes in a
                        different form.
                        A data set needs data adapters to load the data into it and update the data. In
                        find it useful to define a holder for the data set and the adapters. A gateway
                        then uses the holder to store them. Much of this behavior is generic and can be
                        done in a superclass.</p>
                <p>The holder indexes the data sets and adapters by the name of the table.
                        <pre>class DataSetHolder...
                        public DataSet Data = new DataSet();
                        private Hashtable DataAdapters = new Hashtable();</pre>
                        The gateway stores the holder and exposes the data set for its clients.
                        <pre>class DataGateway...
                        public DataSetHolder Holder;
                        public DataSet Data {
                        get {return Holder.Data;}
                        }</pre>
                        The gateway can act on an existing holder, or it can create a new one.
                        <pre>class DataGateway...
                        protected DataGateway() {
                        Holder = new DataSetHolder();
                        }
                        protected DataGateway(DataSetHolder holder) {
                        this.Holder = holder;
                        }</pre>
                        The find behavior can work a bit differently here. A data set is a container
                        for table-oriented data and can hold data from several tables. For that reason
                        itâ€™s better to load data into a data set.
                        <pre>class DataGateway...
                        public void LoadAll() {
                        String commandString = String.Format("select * from {0}", TableName);
                        Holder.FillData(commandString, TableName);
                        }
                        Figure 10.1 Class diagram of data-set-oriented gateway and the supporting data holder.
                        Data Gateway Data Set Holder
                        Person Gateway
                        1
                        Data Set
                        1
                        Data Adapter
                        tablename
                        1
                        *
                        150 DATA SOURCE ARCHITECTURAL PATTERNS
                        Table Data
                        Gateway
                        public void LoadWhere(String whereClause) {
                        String commandString =
                        String.Format("select * from {0} where {1}", TableName,whereClause);
                        Holder.FillData(commandString, TableName);
                        }
                        abstract public String TableName {get;}
                        class PersonGateway...
                        public override String TableName {
                        get {return "Person";}
                        }
                        class DataSetHolder...
                        public void FillData(String query, String tableName) {
                        if (DataAdapters.Contains(tableName)) throw new MutlipleLoadException();
                        OleDbDataAdapter da = new OleDbDataAdapter(query, DB.Connection);
                        OleDbCommandBuilder builder = new OleDbCommandBuilder(da);
                        da.Fill(Data, tableName);
                        DataAdapters.Add(tableName, da);
                        }</pre>
                        To update data you manipulate the data set directly in some client code.
                        <pre>person.LoadAll();
                        person[key]["lastname"] = "Odell";
                        person.Holder.Update();</pre>
                        The gateway can have an indexer to make it easier to get to specific rows.
                        <pre>class DataGateway...
                        public DataRow this[long key] {
                        get {
                        String filter = String.Format("id = {0}", key);
                        return Table.Select(filter)[0];
                        }
                        }
                        public override DataTable Table {
                        get { return Data.Tables[TableName];}
                        }
                        The update triggers update behavior on the holder.
                        class DataSetHolder...
                        public void Update() {
                        foreach (String table in DataAdapters.Keys)
                        ((OleDbDataAdapter)DataAdapters[table]).Update(Data, table);
                        }
                        public DataTable this[String tableName] {
                        get {return Data.Tables[tableName];}
                        }</pre>
                        Insertion can be done much the same way: Get a data set, insert a new row in
                        the data table, and fill in each column. However, an update method can do the
                        insertion in one call.
                        <pre>class DataGateway...
                        public long Insert(String lastName, String firstname, int numberOfDependents) {
                        long key = new PersonGatewayDS().GetNextID();
                        DataRow newRow = Table.NewRow();
                        newRow["id"] = key;
                        newRow["lastName"] = lastName;
                        newRow["firstName"] = firstname;
                        newRow["numberOfDependents"] = numberOfDependents;
                        Table.Rows.Add(newRow);
                        return key;
                        }</pre></p>
                <h3 id="152">Row Data Gateway</h3>
                <p>An object that acts as a Gateway (466) to a single record in a data
                        source. There is one instance per row.
                        Embedding database access code in in-memory objects can leave you with a few
                        disadvantages. For a start, if your in-memory objects have business logic of
                        their own, adding the database manipulation code increases complexity. Testing
                        is awkward too since, if your in-memory objects are tied to a database, tests are
                        slower to run because of all the database access. You may have to access multiple databases with all those annoying little variations on their SQL.
                        A Row Data Gateway gives you objects that look exactly like the record in
                        your record structure but can be accessed with the regular mechanisms of your
                        programming language. All details of data source access are hidden behind this
                        interface.</p>
                <h3 id="152(2)">How It Works</h3>
                <p>A Row Data Gateway acts as an object that exactly mimics a single record,
                        such as one database row. In it each column in the database becomes one field.
                        The Row Data Gateway will usually do any type conversion from the data
                        source types to the in-memory types, but this conversion is pretty simple. This
                        pattern holds the data about a row so that a client can then access the Row
                        Data Gateway directly. The gateway acts as a good interface for each row of
                        data. This approach works particularly well for Transaction Scripts (110).
                        With a Row Data Gateway youâ€™re faced with the questions of where to put
                        the find operations that generate this pattern. You can use static find methods,
                        but they preclude polymorphism should you want to substitute different finder
                        methods for different data sources. In this case it often makes sense to have separate finder objects so that each table in a relational database will have one
                        finder class and one gateway class for the results (Figure 10.2).
                        Itâ€™s often hard to tell the difference between a Row Data Gateway and an
                        Active Record (160). The crux of the matter is whether thereâ€™s any domain logic
                        present; if there is, you have an Active Record (160). A Row Data Gateway
                        should contain only database access logic and no domain logic.</p>
                <p>As with any other form of tabular encapsulation, you can use a Row Data
                        Gateway with a view or query as well as a table. Updates often turn out to be
                        more complicated this way, as you have to update the underlying tables. Also, if
                        you have two Row Data Gateways that operate on the same underlying tables,
                        you may find that the second Row Data Gateway you update undoes the
                        changes on the first. Thereâ€™s no general way to prevent this; developers just have
                        to be aware of how virtual Row Data Gateways are formed. After all, the same
                        thing can happen with updatable views. Of course, you can choose not to provide update operations.
                        Row Data Gateways tend to be somewhat tedious to write, but theyâ€™re a
                        very good candidate for code generation based on a Metadata Mapping (306).
                        This way all your database access code can be automatically built for you during your automated build process.</p>
                <h3 id="153">When to Use It</h3>
                <p>The choice of Row Data Gateway often takes two steps: first whether to use a
                        gateway at all and second whether to use Row Data Gateway or Table Data
                        Gateway (144).
                        I use Row Data Gateway most often when Iâ€™m using a Transaction Script
                        (110). In this case it nicely factors out the database access code and allows it to
                        be reused easily by different Transaction Scripts (110).
                        I donâ€™t use a Row Data Gateway when Iâ€™m using a Domain Model (116). If
                        the mapping is simple, Active Record (160) does the same job without an additional layer of code. If the mapping is complex, Data Mapper (165) works better, as itâ€™s better at decoupling the data structure from the domain objects
                        because the domain objects donâ€™t need to know the layout of the database. Of
                        course, you can use the Row Data Gateway to shield the domain objects from
                        the database structure. Thatâ€™s a good thing if youâ€™re changing the database
                        structure when using Row Data Gateway and you donâ€™t want to change the
                        domain logic. However, doing this on a large scale leads you to three data representations: one in the business logic, one in the Row Data Gateway, and one
                        in the databaseâ€”and thatâ€™s one too many. For that reason I usually have Row
                        Data Gateways that mirror the database structure.</p>
                <p>Interestingly, Iâ€™ve seen Row Data Gateway used very nicely with Data Mapper (165). Although this seems like extra work, it can be effective iff the Row
                        Data Gateways are automatically generated from metadata while the Data
                        Mappers (165) are done by hand.
                        If you use Transaction Script (110) with Row Data Gateway, you may notice
                        that you have business logic thatâ€™s repeated across multiple scripts; logic that
                        would make sense in the Row Data Gateway. Moving that logic will gradually
                        turn your Row Data Gateway into an Active Record (160), which is often good
                        as it reduces duplication in the business logic.</p>
                <h3 id="155">Example: A Person Record (Java)</h3>
                <p>Hereâ€™s an example for Row Data Gateway. Itâ€™s a simple person table.
                        <pre>create table people (ID int primary key, lastname varchar,
                        firstname varchar, number_of_dependents int)</pre>
                        PersonGateway is a gateway for the table. It starts with data fields and accessors.
                        <pre>class PersonGateway...
                        private String lastName;
                        private String firstName;
                        private int numberOfDependents;
                        public String getLastName() {
                        return lastName;
                        }
                        public void setLastName(String lastName) {
                        this.lastName = lastName;
                        }
                        public String getFirstName() {
                        return firstName;
                        }
                        public void setFirstName(String firstName) {
                        this.firstName = firstName;
                        }
                        public int getNumberOfDependents() {
                        return numberOfDependents;
                        }
                        public void setNumberOfDependents(int numberOfDependents) {
                        this.numberOfDependents = numberOfDependents;
                        }</pre>
                        The gateway class itself can handle updates and inserts.
                        <pre>class PersonGateway...
                        private static final String updateStatementString =
                        "UPDATE people " +
                        " set lastname = ?, firstname = ?, number_of_dependents = ? " +
                        " where id = ?";
                        public void update() {
                        PreparedStatement updateStatement = null;
                        try {
                        updateStatement = DB.prepare(updateStatementString);
                        updateStatement.setString(1, lastName);
                        updateStatement.setString(2, firstName);
                        updateStatement.setInt(3, numberOfDependents);
                        updateStatement.setInt(4, getID().intValue());
                        updateStatement.execute();
                        } catch (Exception e) {
                        throw new ApplicationException(e);
                        } finally {DB.cleanUp(updateStatement);
                        }
                        }
                        private static final String insertStatementString =
                        "INSERT INTO people VALUES (?, ?, ?, ?)";
                        public Long insert() {
                        PreparedStatement insertStatement = null;
                        try {
                        insertStatement = DB.prepare(insertStatementString);
                        setID(findNextDatabaseId());
                        insertStatement.setInt(1, getID().intValue());
                        insertStatement.setString(2, lastName);
                        insertStatement.setString(3, firstName);
                        insertStatement.setInt(4, numberOfDependents);
                        insertStatement.execute();
                        Registry.addPerson(this);
                        return getID();
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally { DB.cleanUp(insertStatement);
                        }
                        }</pre>
                        To pull people out of the database, we have a separate PersonFinder. This
                        works with the gateway to create new gateway objects.
                        <pre>class PersonFinder...
                        private final static String findStatementString =
                        "SELECT id, lastname, firstname, number_of_dependents " +
                        " from people " +
                        " WHERE id = ?";
                        ROW DATA GATEWAY 157
                        Row Data
                        Gateway
                        public PersonGateway find(Long id) {
                        PersonGateway result = (PersonGateway) Registry.getPerson(id);
                        if (result != null) return result;
                        PreparedStatement findStatement = null;
                        ResultSet rs = null;
                        try {
                        findStatement = DB.prepare(findStatementString);
                        findStatement.setLong(1, id.longValue());
                        rs = findStatement.executeQuery();
                        rs.next();
                        result = PersonGateway.load(rs);
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {DB.cleanUp(findStatement, rs);
                        }
                        }
                        public PersonGateway find(long id) {
                        return find(new Long(id));
                        }
                        class PersonGateway...
                        public static PersonGateway load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        PersonGateway result = (PersonGateway) Registry.getPerson(id);
                        if (result != null) return result;
                        String lastNameArg = rs.getString(2);
                        String firstNameArg = rs.getString(3);
                        int numDependentsArg = rs.getInt(4);
                        result = new PersonGateway(id, lastNameArg, firstNameArg, numDependentsArg);
                        Registry.addPerson(result);
                        return result;
                        }</pre>
                        To find more than one person according to some criteria we can provide a suitable finder method.
                        <pre>class PersonFinder...
                        private static final String findResponsibleStatement =
                        "SELECT id, lastname, firstname, number_of_dependents " +
                        " from people " +
                        " WHERE number_of_dependents > 0";
                        public List findResponsibles() {
                        List result = new ArrayList();
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        stmt = DB.prepare(findResponsibleStatement);
                        rs = stmt.executeQuery();
                        158 DATA SOURCE ARCHITECTURAL PATTERNS
                        Row Data
                        Gateway
                        while (rs.next()) {
                        result.add(PersonGateway.load(rs));
                        }
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {DB.cleanUp(stmt, rs);
                        }
                        }</pre>
                        The finder uses a Registry (480) to hold Identity Maps (195).
                        We can now use the gateways from a Transaction Script (110)
                        <pre>PersonFinder finder = new PersonFinder();
                        Iterator people = finder.findResponsibles().iterator();
                        StringBuffer result = new StringBuffer();
                        while (people.hasNext()) {
                        PersonGateway each = (PersonGateway) people.next();
                        result.append(each.getLastName());
                        result.append("");
                        result.append(each.getFirstName());
                        result.append("");
                        result.append(String.valueOf(each.getNumberOfDependents()));
                        result.append("\n");
                        }
                        return result.toString();</pre></p>
                <h3 id="158">Example: A Data Holder for a Domain Object (Java)</h3>
                <p>I use Row Data Gateway mostly with Transaction Script (110). If we want to
                        use the Row Data Gateway from a Domain Model (116), the domain objects
                        need to get at the data from the gateway. Instead of copying the data to the
                        domain object we can use the Row Data Gateway as a data holder for the
                        domain object.
                        <pre>class Person...
                        private PersonGateway data;
                        public Person(PersonGateway data) {
                        this.data = data;
                        }</pre>
                        Accessors on the domain logic can then delegate to the gateway for the data.
                        <pre>class Person...
                        public int getNumberOfDependents() {
                        return data.getNumberOfDependents();
                        }</pre>
                        The domain logic uses the getters to pull the data from the gateway.
                        <pre>class Person...
                        public Money getExemption() {
                        Money baseExemption = Money.dollars(1500);
                        Money dependentExemption = Money.dollars(750);
                        return baseExemption.add(dependentExemption.multiply(this.getNumberOfDependents()));
                        }</pre></p>
                <h3 id="160">Active Record</h3>
                <p>An object that wraps a row in a database table or view, encapsulates
                        the database access, and adds domain logic on that data.
                        An object carries both data and behavior. Much of this data is persistent and
                        needs to be stored in a database. Active Record uses the most obvious
                        approach, putting data access logic in the domain object. This way all people
                        know how to read and write their data to and from the database.</p>
                <h3 id="160(2)">How It Works</h3>
                <p>The essence of an Active Record is a Domain Model (116) in which the classes
                        match very closely the record structure of an underlying database. Each Active
                        Record is responsible for saving and loading to the database and also for any
                        domain logic that acts on the data. This may be all the domain logic in the
                        application, or you may find that some domain logic is held in Transaction
                        Scripts (110) with common and data-oriented code in the Active Record.
                        The data structure of the Active Record should exactly match that of the
                        database: one field in the class for each column in the table. Type the fields the
                        way the SQL interface gives you the dataâ€”donâ€™t do any conversion at this
                        stage. You may consider Foreign Key Mapping (236), but you may also leave
                        the foreign keys as they are. You can use views or tables with Active Record,
                        although updates through views are obviously harder. Views are particularly
                        useful for reporting purposes.</p>
                <p>The Active Record class typically has methods that do the following:
                <ul>
                        <li>Construct an instance of the Active Record from a SQL result set row</li>
                        <li>Construct a new instance for later insertion into the table</li>
                        <li>Static finder methods to wrap commonly used SQL queries and return
                        <i>Active Record objects</i></li>
                        <li>Update the database and insert into it the data in the Active Record</li>
                        <li>Get and set the fields</li>
                        <li>Implement some pieces of business logic</li>
                </ul>
                </p>
                <p>The getting and setting methods can do some other intelligent things, such as
                        convert from SQL-oriented types to better in-memory types. Also, if you ask for
                        a related table, the getting method can return the appropriate Active Record,
                        even if you arenâ€™t using Identity Field (216) on the data structure (by doing a
                        lookup).
                        In this pattern the classes are convenient, but they donâ€™t hide the fact that a
                        relational database is present. As a result you usually see fewer of the other
                        object-relational mapping patterns present when youâ€™re using Active Record.
                        Active Record is very similar to Row Data Gateway (152). The principal difference is that a Row Data Gateway (152) contains only database access while
                        an Active Record contains both data source and domain logic. Like most boundaries in software, the line between the two isnâ€™t terribly sharp, but itâ€™s useful.
                        Because of the close coupling between the Active Record and the database, I
                        more often see static find methods in this pattern. However, thereâ€™s no reason
                        that you canâ€™t separate out the find methods into a separate class, as I discussed
                        with Row Data Gateway (152), and that is better for testing.
                        As with the other tabular patterns, you can use Active Record with a view or
                        query as well as a table.</p>
                <h3 id="161">When to Use It</h3>
                <p>Active Record is a good choice for domain logic that isnâ€™t too complex, such as
                        creates, reads, updates, and deletes. Derivations and validations based on a single record work well in this structure.
                        In an initial design for a Domain Model (116) the main choice is between
                        Active Record and Data Mapper (165). Active Record has the primary advantage of simplicity. Itâ€™s easy to build Active Records, and they are easy to understand. Their primary problem is that they work well only if the Active Record
                        objects correspond directly to the database tables: an isomorphic schema. If
                        your business logic is complex, youâ€™ll soon want to use your objectâ€™s direct relationships, collections, inheritance, and so forth. These donâ€™t map easily onto
                        Active Record, and adding them piecemeal gets very messy. Thatâ€™s what will
                        lead you to use Data Mapper (165) instead.
                        Another argument against Active Record is the fact that it couples the object
                        design to the database design. This makes it more difficult to refactor either
                        design as a project goes forward.
                        Active Record is a good pattern to consider if youâ€™re using Transaction Script
                        (110) and are beginning to feel the pain of code duplication and the difficulty in
                        updating scripts and tables that Transaction Script (110) often brings. In this
                        case you can gradually start creating Active Records and then slowly refactor
                        behavior into them. It often helps to wrap the tables as a Gateway (466) first,
                        and then start moving behavior so that the tables evolve to a Active Record.</p>
                <h3 id="162">Example: A Simple Person (Java)</h3>
                <p>This is a simple, even simplistic, example to show how the bones of Active
                        Record work. We begin with a basic Person class.
                        <pre>class Person...
                        private String lastName;
                        private String firstName;
                        private int numberOfDependents;</pre>
                        Thereâ€™s also an ID field in the superclass.
                        The database is set up with the same structure.
                        <pre>create table people (ID int primary key, lastname varchar,
                        firstname varchar, number_of_dependents int)</pre>
                        To load an object, the person class acts as the finder and also performs the
                        load. It uses static methods on the person class.
                        <pre>class Person...
                        private final static String findStatementString =
                        "SELECT id, lastname, firstname, number_of_dependents" +
                        " FROM people" +
                        " WHERE id = ?";
                        public static Person find(Long id) {
                        Person result = (Person) Registry.getPerson(id);
                        if (result != null) return result;
                        PreparedStatement findStatement = null;
                        ResultSet rs = null;
                        ACTIVE RECORD 163
                        Active
                        Record
                        try {
                        findStatement = DB.prepare(findStatementString);
                        findStatement.setLong(1, id.longValue());
                        rs = findStatement.executeQuery();
                        rs.next();
                        result = load(rs);
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(findStatement, rs);
                        }
                        }
                        public static Person find(long id) {
                        return find(new Long(id));
                        }
                        public static Person load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        Person result = (Person) Registry.getPerson(id);
                        if (result != null) return result;
                        String lastNameArg = rs.getString(2);
                        String firstNameArg = rs.getString(3);
                        int numDependentsArg = rs.getInt(4);
                        result = new Person(id, lastNameArg, firstNameArg, numDependentsArg);
                        Registry.addPerson(result);
                        return result;
                        }</pre>
                        Updating an object takes a simple instance method.
                        <pre>class Person...
                        private final static String updateStatementString =
                        "UPDATE people" +
                        " set lastname = ?, firstname = ?, number_of_dependents = ?" +
                        " where id = ?";
                        public void update() {
                        PreparedStatement updateStatement = null;
                        try {
                        updateStatement = DB.prepare(updateStatementString);
                        updateStatement.setString(1, lastName);
                        updateStatement.setString(2, firstName);
                        updateStatement.setInt(3, numberOfDependents);
                        updateStatement.setInt(4, getID().intValue());
                        updateStatement.execute();
                        } catch (Exception e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(updateStatement);
                        }
                        }
                        164 DATA SOURCE ARCHITECTURAL PATTERNS
                        Active
                        Record</pre>
                        Insertions are also mostly pretty simple.
                        <pre>class Person...
                        private final static String insertStatementString =
                        "INSERT INTO people VALUES (?, ?, ?, ?)";
                        public Long insert() {
                        PreparedStatement insertStatement = null;
                        try {
                        insertStatement = DB.prepare(insertStatementString);
                        setID(findNextDatabaseId());
                        insertStatement.setInt(1, getID().intValue());
                        insertStatement.setString(2, lastName);
                        insertStatement.setString(3, firstName);
                        insertStatement.setInt(4, numberOfDependents);
                        insertStatement.execute();
                        Registry.addPerson(this);
                        return getID();
                        } catch (Exception e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(insertStatement);
                        }
                        }
                        Any business logic, such as calculating the exemption, sits directly in the Person class.
                        class Person...
                        public Money getExemption() {
                        Money baseExemption = Money.dollars(1500);
                        Money dependentExemption = Money.dollars(750);
                        return baseExemption.add(dependentExemption.multiply(this.getNumberOfDependents()));
                        }</pre></p>
                <h3 id="165">Data Mapper</h3>
                <p>A layer of Mappers (473) that moves data between objects
                        and a database while keeping them independent of
                        each other and the mapper itself.
                        Objects and relational databases have different mechanisms for structuring
                        data. Many parts of an object, such as collections and inheritance, arenâ€™t
                        present in relational databases. When you build an object model with a lot of
                        business logic itâ€™s valuable to use these mechanisms to better organize the data
                        and the behavior that goes with it. Doing so leads to variant schemas; that is,
                        the object schema and the relational schema donâ€™t match up.
                        You still need to transfer data between the two schemas, and this data transfer becomes a complexity in its own right. If the in-memory objects know
                        about the relational database structure, changes in one tend to ripple to the
                        other.</p>
                <p>The Data Mapper is a layer of software that separates the in-memory objects
                        from the database. Its responsibility is to transfer data between the two and
                        also to isolate them from each other. With Data Mapper the in-memory objects
                        neednâ€™t know even that thereâ€™s a database present; they need no SQL interface
                        code, and certainly no knowledge of the database schema. (The database
                        schema is always ignorant of the objects that use it.) Since itâ€™s a form of Mapper
                        (473), Data Mapper itself is even unknown to the domain layer.</p>
                <h3 id="165(2)">How It Works</h3>
                <p>The separation between domain and data source is the main function of a Data
                        Mapper, but there are plenty of details that have to be addressed to make this
                        happen. Thereâ€™s also a lot of variety in how mapping layers are built. Many of
                        the comments here are pretty broad, because I try to give a general overview of
                        what you need to separate the cat from its skin.
                        Weâ€™ll start with a very basic Data Mapper example. This is the simplest style of
                        this layer that you can have and might not seem worth doing. With simple database mapping examples other patterns usually are simpler and thus better. If you
                        are going to use Data Mapper at all you usually need more complicated cases.
                        However, itâ€™s easier to explain the ideas if we start simple at a very basic level.
                        A simple case would have a Person and Person Mapper class. To load a person
                        from the database, a client would call a find method on the mapper (Figure 10.3).
                        The mapper uses an Identity Map (195) to see if the person is already loaded; if
                        not, it loads it.
                        Updates are shown in Figure 10.4. A client asks the mapper to save a domain
                        object. The mapper pulls the data out of the domain object and shuttles it to the
                        database.</p>
                <p>The whole layer of Data Mapper can be substituted, either for testing purposes or to allow a single domain layer to work with different databases.
                        A simple Data Mapper would just map a database table to an equivalent inmemory class on a field-to-field basis. Of course, things arenâ€™t usually simple.
                        Mappers need a variety of strategies to handle classes that turn into multiple
                        fields, classes that have multiple tables, classes with inheritance, and the joys of
                        connecting together objects once theyâ€™ve been sorted out. The various objectrelational mapping patterns in this book are all about that. Itâ€™s usually easier to
                        deploy these patterns with a Data Mapper than it is with the other organizing
                        alternatives.
                        When it comes to inserts and updates, the database mapping layer needs to
                        understand what objects have changed, which new ones have been created, and
                        which ones have been destroyed. It also has to fit the whole workload into a
                        transactional framework. The Unit of Work (184) pattern is a good way to
                        organize this.</p>
                <p>Figure 10.3 suggests that a single request to a find method results in a single
                        SQL query. This isnâ€™t always true. Loading a typical order with multiple order
                        lines may involve loading the order lines as well. The request from the client will
                        usually lead to a graph of objects being loaded, with the mapper designer deciding exactly how much to pull back in one go. The point of this is to minimize
                        database queries, so the finders typically need to know a fair bit about how clients use the objects in order to make the best choices for pulling data back.
                        This example leads to cases where you load multiple classes of domain objects
                        from a single query. If you want to load orders and order lines, it will usually be
                        faster to do a single query that joins the orders and order line tables. You then use
                        the result set to load both the order and the order line instances (page 243).
                        Since objects are very interconnected, you usually have to stop pulling the
                        data back at some point. Otherwise, youâ€™re likely to pull back the entire database with a request. Again, mapping layers have techniques to deal with this
                        while minimizing the impact on the in-memory objects, using Lazy Load (200).
                        Hence, the in-memory objects canâ€™t be entirely ignorant of the mapping layer.
                        They may need to know about the finders and a few other mechanisms.</p>
                <p>An application can have one Data Mapper or several. If youâ€™re hardcoding
                        your mappers, itâ€™s best to use one for each domain class or root of a domain
                        hierarchy. If youâ€™re using Metadata Mapping (306), you can get away with a
                        single mapper class. In the latter case the limiting problem is your find methods.
                        With a large application it can be too much to have a single mapper with lots of
                        find methods, so it makes sense to split these methods up by each domain class
                        or head of the domain hierarchy. You get a lot of small finder classes, but itâ€™s
                        easy for a developer to locate the finder she needs.</p>
                <p>As with any database find behavior, the finders need to use an Identity Map
                        (195) in order to maintain the identity of the objects read from the database.
                        Either you can have a Registry (480) of Identity Maps (195), or you can have
                        each finder hold an Identity Map (195) (providing there is only one finder per
                        class per session).</p>
                <p><b>Handling Finders</b> In order to work with an object, you have to load it from the
                        database. Usually the presentation layer will initiate things by loading some initial objects. Then control moves into the domain layer, at which point the code
                        will mainly move from object to object using associations between them. This
                        will work effectively providing that the domain layer has all the objects it needs
                        loaded into memory or that you use Lazy Load (200) to load in additional
                        objects when needed.
                        On occasion you may need the domain objects to invoke find methods on the
                        Data Mapper. However, Iâ€™ve found that with a good Lazy Load (200) you can
                        completely avoid this. For simpler applications, though, may not be worth trying
                        to manage everything with associations and Lazy Load (200). Still, you donâ€™t
                        want to add a dependency from your domain objects to your Data Mapper.
                        You can solve this dilemma by using Separated Interface (476). Put any find
                        methods needed by the domain code into an interface class that you can place
                        in the domain package.</p>
                <p><b>Mapping Data to Domain Fields</b> Mappers need access to the fields in the
                        domain objects. Often this can be a problem because you need public methods
                        to support the mappers you donâ€™t want for domain logic. (Iâ€™m assuming that
                        you wonâ€™t commit the cardinal sin of making fields public.) Thereâ€™s no easy to
                        answer to this. You could use a lower level of visibility by packaging the mappers closer to the domain objects, such as in the same package in Java, but this
                        confuses the bigger dependency picture because you donâ€™t want other parts of
                        the system that know the domain objects to know about the mappers. You can
                        use reflection, which can often bypass the visibility rules of the language. Itâ€™s
                        slower, but the slower speed may end up as just a rounding error compared to
                        the time taken by the SQL call. Or you can use public methods, but guard them
                        with a status field so that they throw an exception if theyâ€™re used outside the
                        context of a database load. If so, name them in such a way that theyâ€™re not mistaken for regular getters and setters.
                        Tied to this is the issue of when you create the object. In essence you have
                        two options. One is to create the object with a rich constructor so that itâ€™s at
                        least created with all its mandatory data. The other is to create an empty object
                        and then populate it with the mandatory data. I usually prefer the former since
                        itâ€™s nice to have a well-formed object from the start. This also means that, if you
                        have an immutable field, you can enforce it by not providing any method to
                        change its value.</p>
                <p>The problem with a rich constructor is that you have to be aware of cyclic
                        references. If you have two objects that reference each other, each time you try
                        to load one it will try to load the other, which will in turn try to load the first
                        one, and so on, until you run out of stack space. Avoiding this requires special
                        case code, often using Lazy Load (200). Writing this special case code is messy,
                        so itâ€™s worth trying to do without it. You can do this by creating an empty
                        object. Use a no-arg constructor to create a blank object and insert that empty
                        object immediately into the Identity Map (195). That way, if you have a cycle,
                        the Identity Map (195) will return an object to stop the recursive loading.
                        Using an empty object like this means you may need some setters for values
                        that are truly immutable when the object is loaded. A combination of a naming
                        convention and perhaps some status-checking guards can fix this. You can also
                        use reflection for data loading.</p>
                <p><b>Metadata-Based Mappings</b> One of the decisions you need to make concerns
                        storing the information about how fields in domain objects are mapped to columns in the database. The simplest, and often best, way to do this is with
                        explicit code, which requires a mapper class for each domain object. The mapper does the mapping through assignments and has fields (usually constant
                        strings) to store the SQL for database access. An alternative is to use Metadata
                        Mapping (306), which stores the metadata as data, either in a class or in a separate file. The great advantage of metadata is that all the variation in the mappers can be handled through data without the need for more source code, either
                        by use of code generation or reflective programming.</p>
                <h3 id="170">When to Use It</h3>
                <p>The primary occasion for using Data Mapper is when you want the database
                        schema and the object model to evolve independently. The most common case
                        for this is with a Domain Model (116). Data Mapperâ€™s primary benefit is that
                        when working on the domain model you can ignore the database, both in
                        design and in the build and testing process. The domain objects have no idea
                        what the database structure is, because all the correspondence is done by the
                        mappers.
                        This helps you in the code because you can understand and work with the
                        domain objects without having to understand how theyâ€™re stored in the database. You can modify the Domain Model (116) or the database without having
                        to alter either. With complicated mappings, particularly those involving existing
                        databases, this is very valuable.</p>
                <p>The price, of course, is the extra layer that you donâ€™t get with Active Record
                        (160), so the test for using these patterns is the complexity of the business logic.
                        If you have fairly simple business logic, you probably wonâ€™t need a Domain
                        Model (116) or a Data Mapper. More complicated logic leads you to Domain
                        Model (116) and therefore to Data Mapper.
                        I wouldnâ€™t choose Data Mapper without Domain Model (116), but can I use
                        Domain Model (116) without Data Mapper? If the domain model is pretty sim-
                        ple, and the database is under the domain model developersâ€™ control, then itâ€™s
                        reasonable for the domain objects to access the database directly with Active
                        Record (160). Effectively this puts the mapper behavior discussed here into the
                        domain objects themselves. As things become more complicated, itâ€™s better to
                        refactor the database behavior out into a separate layer.
                        Remember that you donâ€™t have to build a full-featured database-mapping
                        layer. Itâ€™s a complicated beast to build, and there are products available that do
                        this for you. For most cases I recommend buying a database-mapping layer
                        rather than building one yourself.</p>
                <h3 id="171">Example: A Simple Database Mapper (Java)</h3>
                <p>Hereâ€™s an absurdly simple use of Data Mapper to give you a feel for the basic
                        structure. Our example is a person with an isomorphic people table.
                        <pre>class Person...
                        private String lastName;
                        private String firstName;
                        private int numberOfDependents;</pre>
                        The database schema looks like this:
                        <pre>create table people (ID int primary key, lastname varchar,
                        firstname varchar, number_of_dependents int)</pre>
                        Weâ€™ll use the simple case here, where the Person Mapper class also implements the finder and Identity Map (195). However, Iâ€™ve added an abstract mapper Layer Supertype (475) to indicate where I can pull out some common
                        behavior. Loading involves checking that the object isnâ€™t already in the Identity
                        Map (195) and then pulling the data from the database.
                        The find behavior starts in the Person Mapper, which wraps calls to an
                        abstract find method to find by ID.
                        <pre>class PersonMapper...
                        protected String findStatement() {
                        return "SELECT " + COLUMNS +
                        " FROM people" +
                        " WHERE id = ?";
                        }
                        public static final String COLUMNS = " id, lastname, firstname, number_of_dependents ";
                        public Person find(Long id) {
                        return (Person) abstractFind(id);
                        }
                        public Person find(long id) {
                        return find(new Long(id));
                        }
                        172 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        class AbstractMapper...
                        protected Map loadedMap = new HashMap();
                        abstract protected String findStatement();
                        protected DomainObject abstractFind(Long id) {
                        DomainObject result = (DomainObject) loadedMap.get(id);
                        if (result != null) return result;
                        PreparedStatement findStatement = null;
                        try {
                        findStatement = DB.prepare(findStatement());
                        findStatement.setLong(1, id.longValue());
                        ResultSet rs = findStatement.executeQuery();
                        rs.next();
                        result = load(rs);
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(findStatement);
                        }
                        }</pre>
                        The find method calls the load method, which is split between the abstract
                        and person mappers. The abstract mapper checks the ID, pulling it from the
                        data and registering the new object in the Identity Map (195).
                        <pre>class AbstractMapper...
                        protected DomainObject load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id);
                        DomainObject result = doLoad(id, rs);
                        loadedMap.put(id, result);
                        return result;
                        }
                        abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                        class PersonMapper...
                        protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                        String lastNameArg = rs.getString(2);
                        String firstNameArg = rs.getString(3);
                        int numDependentsArg = rs.getInt(4);
                        return new Person(id, lastNameArg, firstNameArg, numDependentsArg);
                        }</pre>
                        Notice that the Identity Map (195) is checked twice, once by abstractFind and
                        once by load. Thereâ€™s a reason for this madness.
                        I need to check the map in the finder because, if the object is already there, I
                        can save myself a trip to the databaseâ€”I always want to save myself that long
                        hike if I can. But I also need to check in the load because I may have queries
                        DATA MAPPER 173
                        Data Mapper
                        that I canâ€™t be sure of resolving in the Identity Map (195). Say I want to find
                        everyone whose last name matches some search pattern. I canâ€™t be sure that I
                        have all such people already loaded, so I have to go to the database and run a
                        query.
                        <pre>class PersonMapper...
                        private static String findLastNameStatement =
                        "SELECT " + COLUMNS +
                        " FROM people " +
                        " WHERE UPPER(lastname) like UPPER(?)" +
                        " ORDER BY lastname";
                        public List findByLastName(String name) {
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        stmt = DB.prepare(findLastNameStatement);
                        stmt.setString(1, name);
                        rs = stmt.executeQuery();
                        return loadAll(rs);
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(stmt, rs);
                        }
                        }
                        class AbstractMapper...
                        protected List loadAll(ResultSet rs) throws SQLException {
                        List result = new ArrayList();
                        while (rs.next())
                        result.add(load(rs));
                        return result;
                        }</pre>
                        When I do this I may pull back some rows in the result set that correspond to
                        people Iâ€™ve already loaded. I have to ensure that I donâ€™t make a duplicate, so I
                        have to check the Identity Map (195) again.
                        Writing a find method this way in each subclass that needs it involves some
                        basic, but repetitive, coding, which I can eliminate by providing a general
                        method.
                        <pre>class AbstractMapper...
                        public List findMany(StatementSource source) {
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        174 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        stmt = DB.prepare(source.sql());
                        for (int i = 0; i &lt; source.parameters().length; i++)
                        stmt.setObject(i+1, source.parameters()[i]);
                        rs = stmt.executeQuery();
                        return loadAll(rs);
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(stmt, rs);
                        }
                        }</pre>
                        For this to work I need an interface that wraps both the SQL string and the
                        loading of parameters into the prepared statement.
                        <pre>interface StatementSource...
                        String sql();
                        Object[] parameters();</pre>
                        I can then use this facility by providing a suitable implementation as an inner
                        class.
                        <pre>class PersonMapper...
                        public List findByLastName2(String pattern) {
                        return findMany(new FindByLastName(pattern));
                        }
                        static class FindByLastName implements StatementSource {
                        private String lastName;
                        public FindByLastName(String lastName) {
                        this.lastName = lastName;
                        }
                        public String sql() {
                        return
                        "SELECT " + COLUMNS +
                        " FROM people " +
                        " WHERE UPPER(lastname) like UPPER(?)" +
                        " ORDER BY lastname";
                        }
                        public Object[] parameters() {
                        Object[] result = {lastName};
                        return result;
                        }
                        }</pre>
                        This kind of work can be done in other places where thereâ€™s repetitive statement invocation code. On the whole Iâ€™ve made the examples here more straight
                        to make them easier to follow. If you find yourself writing a lot of repetitive
                        straight-ahead code you should consider doing something similar.
                        DATA MAPPER 175
                        Data Mapper
                        With the update the JDBC code is specific to the subtype.
                        <pre>class PersonMapper...
                        private static final String updateStatementString =
                        "UPDATE people " +
                        " SET lastname = ?, firstname = ?, number_of_dependents = ? " +
                        " WHERE id = ?";
                        public void update(Person subject) {
                        PreparedStatement updateStatement = null;
                        try {
                        updateStatement = DB.prepare(updateStatementString);
                        updateStatement.setString(1, subject.getLastName());
                        updateStatement.setString(2, subject.getFirstName());
                        updateStatement.setInt(3, subject.getNumberOfDependents());
                        updateStatement.setInt(4, subject.getID().intValue());
                        updateStatement.execute();
                        } catch (Exception e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(updateStatement);
                        }
                        }</pre>
                        For the insert some code can be factored into the Layer Supertype (475)
                        <pre>class AbstractMapper...
                        public Long insert(DomainObject subject) {
                        PreparedStatement insertStatement = null;
                        try {
                        insertStatement = DB.prepare(insertStatement());
                        subject.setID(findNextDatabaseId());
                        insertStatement.setInt(1, subject.getID().intValue());
                        doInsert(subject, insertStatement);
                        insertStatement.execute();
                        loadedMap.put(subject.getID(), subject);
                        return subject.getID();
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {
                        DB.cleanUp(insertStatement);
                        }
                        }
                        abstract protected String insertStatement();
                        abstract protected void doInsert(DomainObject subject, PreparedStatement insertStatement)
                        throws SQLException;
                        class PersonMapper...
                        protected String insertStatement() {
                        return "INSERT INTO people VALUES (?, ?, ?, ?)";
                        176 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        }
                        protected void doInsert(
                        DomainObject abstractSubject,
                        PreparedStatement stmt)
                        throws SQLException
                        {
                        Person subject = (Person) abstractSubject;
                        stmt.setString(2, subject.getLastName());
                        stmt.setString(3, subject.getFirstName());
                        stmt.setInt(4, subject.getNumberOfDependents());
                        }</pre></p>
                <h3 id="176">Example: Separating the Finders (Java)</h3>
                <p>To allow domain objects to invoke finder behavior I can use Separated Interface
                        (476) to separate the finder interfaces from the mappers (Figure 10.5). I can put
                        these finder interfaces in a separate package thatâ€™s visible to the domain layer,
                        or, as in this case, I can put them in the domain layer itself.
                        One of the most common finds is one that finds an object according to a particular surrogate ID. Much of this processing is quite generic, so it can be handled by a suitable Layer Supertype (475). All it needs is a Layer Supertype (475)
                        for domain objects that know about IDs.
                        The interface for finding lies in the finder interface. Itâ€™s usually best not made
                        generic because you need to know what the return type is.
                        <pre>interface ArtistFinder...
                        Artist find(Long id);
                        Artist find(long id);</pre>
                        The finder interface is best declared in the domain package with the finders
                        held in a Registry (480). In this case Iâ€™ve made the mapper class implement the
                        finder interface.
                        <pre>class ArtistMapper implements ArtistFinder...
                        public Artist find(Long id) {
                        return (Artist) abstractFind(id);
                        }
                        public Artist find(long id) {
                        return find(new Long(id));
                        }</pre>
                        The bulk of the find method is done by the mapperâ€™s Layer Supertype (475),
                        which checks the Identity Map (195) to see if the object is already in memory. If
                        DATA MAPPER 177
                        Data Mapper
                        not, it completes a prepared statement thatâ€™s loaded in by the artist mapper and
                        executes it.
                        <pre>class AbstractMapper...
                        abstract protected String findStatement();
                        protected Map loadedMap = new HashMap();
                        protected DomainObject abstractFind(Long id) {
                        DomainObject result = (DomainObject) loadedMap.get(id);
                        if (result != null) return result;
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        stmt = DB.prepare(findStatement());
                        stmt.setLong(1, id.longValue());
                        Figure 10.5 Defining a finder interface in the domain package.
                        domain
                        find (id)
                        Â«interfaceÂ»
                        Artist Finder
                        find (id)
                        # doLoad
                        Artist Mapper
                        + insert
                        + update
                        # abstractFind
                        # load
                        # doLoad
                        Abstract Mapper
                        Album
                        mapper
                        id: Long
                        Domain Object
                        Artist
                        178 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        rs = stmt.executeQuery();
                        rs.next();
                        result = load(rs);
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {cleanUp(stmt, rs);
                        }
                        }
                        class ArtistMapper...
                        protected String findStatement() {
                        return "select " + COLUMN_LIST + " from artists art where ID = ?";
                        }
                        public static String COLUMN_LIST = "art.ID, art.name";</pre>
                        The find part of the behavior is about getting either the existing object or a new
                        one. The load part is about putting the data from the database into a new object.
                        <pre>class AbstractMapper...
                        protected DomainObject load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong("id"));
                        if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id);
                        DomainObject result = doLoad(id, rs);
                        loadedMap.put(id, result);
                        return result;
                        }
                        abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                        class ArtistMapper...
                        protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                        String name = rs.getString("name");
                        Artist result = new Artist(id, name);
                        return result;
                        }</pre>
                        Notice that the load method also checks the Identity Map (195). Although
                        redundant in this case, the load can be called by other finders that havenâ€™t
                        already done this check. In this scheme all a subclass has to do is develop a
                        doLoad method to load the actual data needed, and return a suitable prepared
                        statement from the findStatement method.
                        You can also do a find based on a query. Say we have a database of tracks
                        and albums and we want a finder that will find all the tracks on a specified
                        album. Again the interface declares the finders.
                        <pre>interface TrackFinder...
                        Track find(Long id);
                        Track find(long id);
                        List findForAlbum(Long albumID);</pre>
                        Since this is a specific find method for this class, itâ€™s implemented in a specific
                        class, such as the track mapper class, rather than in a Layer Supertype (475). As
                        with any finder, there are two methods to the implementation. One sets up the
                        prepared statement; the other wraps the call to the prepared statement and
                        interprets the results.
                        <pre>class TrackMapper...
                        public static final String findForAlbumStatement =
                        "SELECT ID, seq, albumID, title " +
                        "FROM tracks " +
                        "WHERE albumID = ? ORDER BY seq";
                        public List findForAlbum(Long albumID) {
                        PreparedStatement stmt = null;
                        ResultSet rs = null;
                        try {
                        stmt = DB.prepare(findForAlbumStatement);
                        stmt.setLong(1, albumID.longValue());
                        rs = stmt.executeQuery();
                        List result = new ArrayList();
                        while (rs.next())
                        result.add(load(rs));
                        return result;
                        } catch (SQLException e) {
                        throw new ApplicationException(e);
                        } finally {cleanUp(stmt, rs);
                        }
                        }</pre>
                        The finder calls a load method for each row in the result set. This method
                        has the responsibility of creating the in-memory object and loading it with the
                        data. As in the previous example, some of this can be handled in a Layer Supertype (475), including checking the Identity Map (195) to see if something is
                        already loaded.</p>
                <h3 id="179">Example: Creating an Empty Object (Java)</h3>
                <p>There are two basic approaches for loading an object. One is to create a fully
                        valid object with a constructor, which is what Iâ€™ve done in the examples above.
                        This results in the following loading code:
                        <pre>class AbstractMapper...
                        protected DomainObject load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id);
                        DomainObject result = doLoad(id, rs);
                        loadedMap.put(id, result);
                        return result;
                        180 DATA SOURCE ARCHITECTURAL PATTERNS
                        Data Mapper
                        }
                        abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                        class PersonMapper...
                        protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                        String lastNameArg = rs.getString(2);
                        String firstNameArg = rs.getString(3);
                        int numDependentsArg = rs.getInt(4);
                        return new Person(id, lastNameArg, firstNameArg, numDependentsArg);
                        }</pre>
                        The alternative is to create an empty object and load it with the setters later.
                        <pre>class AbstractMapper...
                        protected DomainObjectEL load(ResultSet rs) throws SQLException {
                        Long id = new Long(rs.getLong(1));
                        if (loadedMap.containsKey(id)) return (DomainObjectEL) loadedMap.get(id);
                        DomainObjectEL result = createDomainObject();
                        result.setID(id);
                        loadedMap.put(id, result);
                        doLoad (result, rs);
                        return result;
                        }
                        abstract protected DomainObjectEL createDomainObject();
                        abstract protected void doLoad(DomainObjectEL obj, ResultSet rs) throws SQLException;
                        class PersonMapper...
                        protected DomainObjectEL createDomainObject() {
                        return new Person();
                        }
                        protected void doLoad(DomainObjectEL obj, ResultSet rs) throws SQLException {
                        Person person = (Person) obj;
                        person.dbLoadLastName(rs.getString(2));
                        person.setFirstName(rs.getString(3));
                        person.setNumberOfDependents(rs.getInt(4));
                        }</pre>
                        Notice that Iâ€™m using a different kind of domain object Layer Supertype
                        (475) here, because I want to control the use of the setters. Letâ€™s say that I want
                        the last name of a person to be an immutable field. In this case I donâ€™t want to
                        change the value of the field once itâ€™s loaded, so I add a status field to the
                        domain object.
                        <pre>class DomainObjectEL...
                        private int state = LOADING;
                        private static final int LOADING = 0;
                        private static final int ACTIVE = 1;
                        public void beActive() {
                        state = ACTIVE;
                        }</pre>
                        I can then check the value of this during a load.
                        <pre>class Person...
                        public void dbLoadLastName(String lastName) {
                        assertStateIsLoading();
                        this.lastName = lastName;
                        }
                        class DomainObjectEL...
                        void assertStateIsLoading() {
                        Assert.isTrue(state == LOADING);
                        }</pre>
                        What I donâ€™t like about this is that we now have a method in the interface
                        that most clients of the Person class canâ€™t use. This is an argument for the mapper using reflection to set the field, which will completely bypass Javaâ€™s protection mechanisms.
                        Is the status-based guard worth the trouble? Iâ€™m not entirely sure. On the
                        one hand it will catch bugs caused by people calling update methods at the
                        wrong time. On the other hand is the seriousness of the bugs worth the cost of
                        the mechanism? At the moment I donâ€™t have a strong opinion either way.
                        <i>This page intentionally left blank</i></p>
                <h3 id="183">Chapter 11</h3>
                <h2>Object-Relational Behavioral Patterns</h2>
                <h3 id="184">Unit of Work</h3>
                <p>Maintains a list of objects affected by a business transaction
                                and coordinates the writing out of changes and the
                                resolution of concurrency problems.
                                When youâ€™re pulling data in and out of a database, itâ€™s important to keep track
                                of what youâ€™ve changed; otherwise, that data wonâ€™t be written back into the
                                database. Similarly you have to insert new objects you create and remove any
                                objects you delete.
                                You can change the database with each change to your object model, but this
                                can lead to lots of very small database calls, which ends up being very slow.
                                Furthermore it requires you to have a transaction open for the whole interaction, which is impractical if you have a business transaction that spans multiple
                                requests. The situation is even worse if you need to keep track of the objects
                                youâ€™ve read so you can avoid inconsistent reads.
                                A Unit of Work keeps track of everything you do during a business transaction that can affect the database. When youâ€™re done, it figures out everything
                                that needs to be done to alter the database as a result of your work.</p>
                <h3 id="184(2)">How It Works</h3>
                <p>The obvious things that cause you to deal with the database are changes: new
                                object created and existing ones updated or deleted. Unit of Work is an object
                                that keeps track of these things. As soon as you start doing something that may
                                affect a database, you create a Unit of Work to keep track of the changes. Every
                                time you create, change, or delete an object you tell the Unit of Work. You can
                                also let it know about objects youâ€™ve read so that it can check for inconsistent
                                reads by verifying that none of the objects changed on the database during the
                                business transaction.
                                The key thing about Unit of Work is that, when it comes time to commit, the
                                Unit of Work decides what to do. It opens a transaction, does any concurrency
                                checking (using Pessimistic Offline Lock (426) or Optimistic Offline Lock
                                (416)), and writes changes out to the database. Application programmers never
                                explicitly call methods for database updates. This way they donâ€™t have to keep
                                track of whatâ€™s changed or worry about how referential integrity affects the
                                order in which they need to do things.</p>
                <p>Of course for this to work the Unit of Work needs to know what objects it
                                should keep track of. You can do this either by the caller doing it or by getting
                                the object to tell the Unit of Work.
                                With caller registration (Figure 11.1), the user of an object has to remember
                                to register the object with the Unit of Work for changes. Any objects that arenâ€™t
                                registered wonâ€™t be written out on commit. Although this allows forgetfulness
                                to cause trouble, it does give flexibility in allowing people to make in-memory
                                changes that they donâ€™t want written out. Still, I would argue that itâ€™s going to
                                cause far more confusion than would be worthwhile. Itâ€™s better to make an
                                explicit copy for that purpose.
                                With object registration (Figure 11.2), the onus is removed from the caller.
                                The usual trick here is to place registration methods in object methods. Loading
                                an object from the database registers the object as clean; the setting methods
                                register the object as dirty. For this scheme to work the Unit of Work needs
                                either to be passed to the object or to be in a well-known place. Passing the
                                Unit of Work around is tedious but usually no problem to have it present in
                                some kind of session object.</p>
                <p>Even object registration leaves something to remember; that is, the developer
                                of the object has to remember to add a registration call in the right places. The
                                consistency becomes habitual, but is still an awkward bug when missed.
                                This is a natural place for code generation to generate appropriate calls, but
                                that only works when you can clearly separate generated and nongenerated
                                code. This problem turns out to be particularly suited to aspect-oriented programming. Iâ€™ve also come across post-processing of the object files to pull this
                                off. In this example a post-processor examined all the Java .class files, looked
                                for the appropriate methods and inserted registration calls into the byte code.
                                Such finicking around feels dirty, but it separates the database code from the
                                regular code. Aspect-oriented programming will do this more cleanly with
                                source code, and as its tools become more commonplace I expect to see this
                                strategy being used.</p>
                <p>Another technique Iâ€™ve seen is unit of work controller (Figure 11.3), which
                                the TOPLink product uses. Here the Unit of Work handles all reads from the
                                database and registers clean objects whenever theyâ€™re read. Rather than marking objects as dirty the Unit of Work takes a copy at read time and then compares the object at commit time. Although this adds overhead to the commit
                                process, it allows a selective update of only those fields that were actually
                                changed; it also avoids registration calls in the domain objects. A hybrid
                                approach is to take copies only of changed objects. This requires registration,
                                but it supports selective update and greatly reduces the overhead of the copy if
                                there are many more reads than updates.
                                Object creation is often a special time to consider caller registration. Itâ€™s not
                                uncommon for people to create objects that are only supposed to be transient.
                                A good example of this is in testing domain objects, where the tests run much
                                faster without database writes. Caller registration can make this apparent.
                                However, there are other solutions, such as providing a transient constructor
                                that doesnâ€™t register with the Unit of Work or, better still, providing a Special
                                Case (496)Unit of Work that does nothing with a commit.</p>
                <p>Another area where a Unit of Work can be helpful is in update order when a
                                database uses referential integrity. Most of the time you can avoid this issue by
                                ensuring that the database only checks referential integrity when the transaction commits rather than with each SQL call. Most databases allow this, and if
                                available thereâ€™s no good reason not to do it. If not, the Unit of Work is the natural place to sort out the update order. In smaller systems this can be done with
                                explicit code that contains details about which tables to write first based on the
                                foreign key dependencies. In a larger application itâ€™s better to use metadata to
                                figure out which order to write to the database. How you do that is beyond the
                                scope of this book, and itâ€™s a common reason to use a commercial tool. If you
                                have to do it yourself, Iâ€™m told the key to the puzzle is a topological sort.
                                You can use a similar technique to minimize deadlocks. If every transaction
                                uses the same sequence of tables to edit, you greatly reduce the risk of deadlocks. The Unit of Work is an ideal place to hold a fixed sequence of table
                                writes so that you always touch the tables in the same order.
                                Objects need to be able to find their current Unit of Work. A good way to do
                                this is with a thread-scoped Registry (480). Another way is to pass the Unit of
                                Work to objects that need it, either in method calls or when you create an
                                object. In either case make sure that more than one thread canâ€™t get access to a
                                Unit of Workâ€”there lies the way to madness.</p>
                <p>Unit of Work makes an obvious point of handling batch updates. The idea
                                behind a batch update is to send multiple SQL commands as a single unit so
                                that they can be processed in a single remote call. This is particularly important
                                when many updates, inserts, and deletes are sent in rapid succession. Different
                                environments provide different levels of support for batch updates. JDBC has a
                                facility that allows you to batch individual statements. If you donâ€™t have this
                                feature, you can mimic it by building up a string that has multiple SQL statements and then submitting as one statement. [Nilsson] describes an example of
                                this for Microsoft platforms. However, if you do this check to see if it interferes
                                with statement precompilation.
                                Unit of Work works with any transactional resource, not just databases, so
                                you can also use it to coordinate with message queues and transaction monitors.
                                .NET Implementation</p>
                <p>In .NET the Unit of Work is done by the disconnected data set. This makes
                                it a slightly different pattern from the classical variety. Most Units of Work
                                Iâ€™ve come across register and track changes to objects. .NET reads data from
                                the database into a data set, which is a series of objects arranged like database tables, rows, and columns. The data set is essentially an in-memory mirror image of the result of one or more SQL queries. Each data row has the
                                concept of a version (current, original, proposed) and a state (unchanged,
                                added, deleted, modified), which, together with the fact that the data set
                                mimics the database structure, makes for straightforward writing of changes
                                to the database.</p>
                <h3 id="189">When to Use It</h3>
                <p>The fundamental problem that Unit of Work deals with is keeping track of the
                                various objects youâ€™ve manipulated so that you know which ones you need to
                                consider to synchronize your in-memory data with the database. If youâ€™re able
                                to do all your work within a system transaction, the only objects you need to
                                worry about are those you alter. Although Unit of Work is generally the best
                                way of doing this, there are alternatives.
                                Perhaps the simplest alternative is to explicitly save any object whenever you
                                alter it. The problem here is that you may get many more database calls than
                                you want since, if you alter one object at three different points in your work,
                                you get three calls rather than one call in its final state.
                                To avoid multiple database calls, you can leave all your updates to the end.
                                To do this you need to keep track of all the objects that have changed. You can
                                use variables in your code for this, but they soon become unmanageable once
                                you have more than a few. Variables often work fine with a Transaction Script
                                (110), but they can be very difficult with a Domain Model (116).</p>
                <p>Rather than keep objects in variables you can give each object a dirty flag
                                that you set when the object changes. Then you need to find all the dirty objects
                                at the end of your transaction and write them out. The value of this technique
                                hinges on how easy it is to find the dirty objects. If all of them are in a single
                                hierarchy, then you can traverse the hierarchy and write out any that have been
                                changed. However, a more general object network, such as a Domain Model
                                (116), is harder to traverse.
                                The great strength of Unit of Work is that it keeps all this information in one
                                place. Once you have it working for you, you donâ€™t have to remember to do
                                much in order to keep track of your changes. Also, Unit of Work is a firm platform for more complicated situations, such as handling business transactions
                                that span several system transactions using Optimistic Offline Lock (416) and
                                Pessimistic Offline Lock (426).</p>
                <h3 id="190">Example: Unit of Work with Object Registration (Java)</h3>
                <p>Hereâ€™s a Unit of Work that can track all changes for a given business transaction and then commit them to the database when instructed to do so. Our
                                domain layer has a Layer Supertype (475), DomainObject, with which the Unit of
                                Work will interact. To store the change set we use three lists: new, dirty, and
                                removed domain objects.
                                <pre>class UnitOfWork...
                                private List newObjects = new ArrayList();
                                private List dirtyObjects = new ArrayList();
                                private List removedObjects = new ArrayList();</pre>
                                The registration methods maintain the state of these lists. They must perform
                                basic assertions such as checking that an ID isnâ€™t null or that a dirty object isnâ€™t
                                being registered as new.
                                <pre>class UnitOfWork...
                                public void registerNew(DomainObject obj) {
                                Assert.notNull("id not null", obj.getId());
                                Assert.isTrue("object not dirty", !dirtyObjects.contains(obj));
                                Assert.isTrue("object not removed", !removedObjects.contains(obj));
                                Assert.isTrue("object not already registered new", !newObjects.contains(obj));
                                newObjects.add(obj);
                                }
                                UNIT OF WORK 191
                                Unit of Work
                                public void registerDirty(DomainObject obj) {
                                Assert.notNull("id not null", obj.getId());
                                Assert.isTrue("object not removed", !removedObjects.contains(obj));
                                if (!dirtyObjects.contains(obj) && !newObjects.contains(obj)) {
                                dirtyObjects.add(obj);
                                }
                                }
                                public void registerRemoved(DomainObject obj) {
                                Assert.notNull("id not null", obj.getId());
                                if (newObjects.remove(obj)) return;
                                dirtyObjects.remove(obj);
                                if (!removedObjects.contains(obj)) {
                                removedObjects.add(obj);
                                }
                                }
                                public void registerClean(DomainObject obj) {
                                Assert.notNull("id not null", obj.getId());
                                }</pre>
                                Notice that registerClean() doesnâ€™t do anything here. A common practice is to
                                place an Identity Map (195) within a Unit of Work. An Identity Map (195) is
                                necessary almost any time you store domain object state in memory because
                                multiple copies of the same object would result in undefined behavior. Were an
                                Identity Map (195) in place, registerClean() would put the registered object in it.
                                Likewise registerNew() would put a new object in the map and registerRemoved()
                                would remove a deleted object from the map. Without the Identity Map (195)
                                you have the option of not including registerClean() in your Unit of Work. Iâ€™ve
                                seen implementations of this method that remove changed objects from the
                                dirty list, but partially rolling back changes is always tricky. Be careful when
                                reversing any state in the change set.</p>
                <p>commit() will locate the Data Mapper (165) for each object and invoke the
                                appropriate mapping method. updateDirty() and deleteRemoved() arenâ€™t shown, but
                                they would behave like insertNew(), which is as expected.
                                <pre>class UnitOfWork...
                                public void commit() {
                                insertNew();
                                updateDirty();
                                deleteRemoved();
                                }
                                private void insertNew() {
                                for (Iterator objects = newObjects.iterator(); objects.hasNext();) {
                                DomainObject obj = (DomainObject) objects.next();
                                MapperRegistry.getMapper(obj.getClass()).insert(obj);
                                }
                                }</pre>
                                Not included in this Unit of Work is the tracking of any objects weâ€™ve read and
                                want to check for inconsistent read errors upon commit. This is addressed in
                                Optimistic Offline Lock (416).
                                Next we need to facilitate object registration. First each domain object needs
                                to find the Unit of Work serving the current business transaction. Since that
                                Unit of Work will be needed by the entire domain model, passing it around as a
                                parameter is probably unreasonable. As each business transaction executes
                                within a single thread we can associate the Unit of Work with the currently executing thread using the java.lang.ThreadLocal class. Keeping things simple, weâ€™ll
                                add this functionality by using static methods on our Unit of Work class. If we
                                already have some sort of session object associated with the business transaction execution thread we should place the current Unit of Work on that session
                                object rather than add the management overhead of another thread mapping.
                                Besides, the Unit of Work logically belongs to the session.
                                <pre>class UnitOfWork...
                                private static ThreadLocal current = new ThreadLocal();
                                public static void newCurrent() {
                                setCurrent(new UnitOfWork());
                                }
                                public static void setCurrent(UnitOfWork uow) {
                                current.set(uow);
                                }
                                public static UnitOfWork getCurrent() {
                                return (UnitOfWork) current.get();
                                }</pre>
                                Now we can now give our abstract domain object the marking methods to
                                register itself with the current Unit of Work.
                                <pre>class DomainObject...
                                protected void markNew() {
                                UnitOfWork.getCurrent().registerNew(this);
                                }
                                protected void markClean() {
                                UnitOfWork.getCurrent().registerClean(this);
                                }
                                protected void markDirty() {
                                UnitOfWork.getCurrent().registerDirty(this);
                                }
                                protected void markRemoved() {
                                UnitOfWork.getCurrent().registerRemoved(this);
                                }</pre>
                                Concrete domain objects need to remember to mark themselves new and dirty
                                where appropriate.
                                <pre>class Album...
                                public static Album create(String name) {
                                Album obj = new Album(IdGenerator.nextId(), name);
                                obj.markNew();
                                return obj;
                                }
                                public void setTitle(String title) {
                                this.title = title;
                                markDirty();
                                }</pre>
                                Not shown is that the registration of removed objects can be handled by a
                                remove() method on the abstract domain object. Also, and if youâ€™ve implemented
                                registerClean() your Data Mappers (165) will need to register any newly loaded
                                object as clean.
                                The final piece is to register and commit the Unit of Work where appropriate. This can be done either explicitly or implicitly. Hereâ€™s what explicit Unit of
                                Work management looks like:
                                <pre>class EditAlbumScript...
                                public static void updateTitle(Long albumId, String title) {
                                UnitOfWork.newCurrent();
                                Mapper mapper = MapperRegistry.getMapper(Album.class);
                                Album album = (Album) mapper.find(albumId);
                                album.setTitle(title);
                                UnitOfWork.getCurrent().commit();
                                }</pre>
                                Beyond the simplest of applications, implicit Unit of Work management is
                                more appropriate as it avoids repetitive, tedious coding. Hereâ€™s a servlet Layer
                                Supertype (475) that registers and commits the Unit of Work for its concrete
                                subtypes. Subtypes will implement handleGet() rather than override doGet(). Any
                                code executing within handleGet() will have a Unit of Work with which to work.
                                <pre>class UnitOfWorkServlet...
                                final protected void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws ServletException, IOException {
                                try {
                                UnitOfWork.newCurrent();
                                handleGet(request, response);
                                UnitOfWork.getCurrent().commit();
                                194 OBJECT-RELATIONAL BEHAVIORAL PATTERNS
                                Unit of Work
                                } finally {
                                UnitOfWork.setCurrent(null);
                                }
                                }
                                abstract void handleGet(HttpServletRequest request, HttpServletResponse response)
                                throws ServletException, IOException;</pre>
                                The above servlet example is obviously a bit simplistic, in that it skips system transaction control. If you were using Front Controller (344), you would
                                be more likely to wrap Unit of Work management around your commands
                                rather than doGet(). Similar wrapping can be done with just about any execution context.
                                Identity Map</p>
                <h3 id="195">Identity Map</h3>
                <p>Ensures that each object gets loaded only once by keeping
                                every loaded object in a map. Looks up objects using
                                the map when referring to them.
                                An old proverb says that a man with two watches never knows what time it is.
                                If two watches are confusing, you can get in an even bigger mess with loading
                                objects from a database. If you arenâ€™t careful you can load the data from the
                                same database record into two different objects. Then, when you update them
                                both youâ€™ll have an interesting time writing the changes out to the database
                                correctly.
                                Related to this is an obvious performance problem. If you load the same data
                                more than once youâ€™re incurring an expensive cost in remote calls. Thus, not
                                loading the same data twice doesnâ€™t just help correctness, but can also speed up
                                your application.
                                An Identity Map keeps a record of all objects that have been read from the
                                database in a single business transaction. Whenever you want an object, you
                                check the Identity Map first to see if you already have it.</p>
                <h3 id="195(2)">How It Works</h3>
                <p>The basic idea behind the Identity Map is to have a series of maps containing
                                objects that have been pulled from the database. In a simple case, with an isomorphic schema, youâ€™ll have one map per database table. When you load an
                                <pre>finder an identity map
                                find (1)
                                found = get (1)
                                [found not null] found
                                database
                                [found is null] found = select where id = 1</pre>
                                object from the database, you first check the map. If thereâ€™s an object in it that
                                corresponds to the one youâ€™re loading, you return it. If not, you go to the database, putting the objects into the map for future reference as you load them.
                                There are a number of implementation choices to worry about. Also, since
                                Identity Maps interact with concurrency management, so you should consider
                                Optimistic Offline Lock (416) as well.
                                Choice of Keys The first thing to consider is the key for the map. The obvious
                                choice is the primary key of the corresponding database table. This works well
                                if the key is a single column and immutable. A surrogate primary key fits in very
                                well with this approach because you can use it as the key in the map. The key
                                will usually be a simple data type so the comparison behavior will work nicely.
                                Explicit or Generic You have to choose whether to make the Identity Map
                                explicit or generic. An explicit Identity Map is accessed with distinct methods
                                for each kind of object you need: such as findPerson(1). A generic map uses a single method for all kinds of objects, with perhaps a parameter to indicate which
                                kind of object you need, such as find("Person", 1). The obvious advantage is that
                                you can support a generic map with a generic and reusable object. Itâ€™s easy to
                                construct a reusable Registry (480) that work for all kinds of objects and
                                doesnâ€™t need updating when you add a new map.</p>
                <p>However, I prefer an explicit Identity Map. For a start this gives you compiletime checking in a strongly typed language. But more than that, it has all the
                                other advantages of an explicit interface: itâ€™s easier to see what maps are available and what theyâ€™re called. It does mean adding a method each time you add
                                a new map, but that is a small overhead for the virtue of explicitness.
                                Your type of key affects the choice. You can only use a generic map if all
                                your objects have the same type of key. This is a good argument for encapsulating different kinds of database key behind a single key object. (See Identity
                                Field (216) for detail.)
                                How Many Here the decision varies between one map per class and one map
                                for the whole session. A single map for the session works only if you have database-unique keys (see the discussion in Identity Field (216) for the trade-offs on
                                that.) Once you have one Identity Map, the benefit is that you have only one
                                place to go and no awkward decisions about inheritance.
                                If you have multiple maps, the obvious route is one map per class or per
                                table, which works well if your database schema and object models are the
                                same. If they look different, itâ€™s usually easier to base the maps on your objects
                                rather than on your tables, as the objects shouldnâ€™t really know about the intricacies of the mapping.
                                Inheritance rears an ugly head here. If you have cars as a subtype of vehicle,
                                do you have one map or separate maps? Keeping them separate can make polymorphic references much more awkward, since any lookup needs to know to
                                look in all maps. As a result I prefer to use a single map for each inheritance
                                tree, but that means that you should also make your keys unique across inheritance trees, which can be awkward if you use Concrete Table Inheritance (293).
                                An advantage of a single map is that you donâ€™t have to add new ones when
                                you add database tables. However, tying your maps to your Data Mappers
                                (165) (see below) wonâ€™t be any extra burden.</p>
                <p>Where to Put Them Identity Maps need to be somewhere where theyâ€™re easy to
                                find. Theyâ€™re also tied to the process context youâ€™re working in. You need to
                                ensure that each session gets itâ€™s own instance thatâ€™s isolated from any other sessionâ€™s instance. Thus, you need to put the Identity Map on a session-specific
                                object. If youâ€™re using Unit of Work (184) thatâ€™s by far the best place for the
                                Identity Maps since the Unit of Work (184) is the main place for keeping track
                                of data coming in or out of the database. If you donâ€™t have a Unit of Work
                                (184), the best bet is a Registry (480) thatâ€™s tied to the session.
                                As Iâ€™ve implied here, you usually see a single Identity Map for a session; otherwise, you need to provide transactional protection for your map, which is
                                more work than any sane developer wants to do. However, there are a couple
                                of exceptions. The biggest one is to use an object database as a transactional
                                cache, even if you use a relational database for record data. While I havenâ€™t seen
                                any independent performance studies, the possibilities suggest that itâ€™s worth
                                taking a look at. Many people I respect are big fans of a transactional cache as
                                a way to improve performance.
                                The other exception is for objects that are read-only in all cases. If an object
                                can never be modified, thereâ€™s no need to worry about it being shared across sessions. In performance-intensive systems it can be very beneficial to load in all
                                read-only data once and have it available to the whole process. In this case you
                                have your read-only Identity Maps held in a process context and your updatable
                                Identity Maps in a session context. This also applies to objects that arenâ€™t completely read-only but are updated so rarely that you donâ€™t mind flushing the process-wide Identity Map and potentially bouncing the server when it happens.
                                Even if youâ€™re inclined to have only one Identity Map you can split it in two
                                along read-only and updatable lines. You can avoid clients having to know
                                which is which by providing an interface that checks both maps.</p>
                <h3 id="198">When to Use It</h3>
                <p>In general you use an Identity Map to manage any object brought from a database and modified. The key reason is that you donâ€™t want a situation where two
                                in-memory objects correspond to a single database recordâ€”you might modify
                                the two records inconsistently and thus confuse the database mapping.
                                Another value in Identity Map is that it acts as a cache for database reads,
                                which means that you can avoid going to the database each time you need some
                                data.
                                You may not need an Identity Map for immutable objects. If you canâ€™t
                                change an object, then you donâ€™t have to worry about modification anomalies.
                                Since Value Objects (486) are immutable, it follows that you donâ€™t need Identity Map for them. Still, Identity Map has advantages here, the most important
                                of which is the performance advantages of the cache, another is that it helps to
                                prevent the use of the wrong form of equality test, a problem prevalent in Java,
                                where you canâ€™t override ==.
                                You donâ€™t need an Identity Map for a Dependent Mapping (262). Since
                                dependent objects have their persistence controlled by their parent, thereâ€™s no
                                need for a map to maintain identity. However, although you donâ€™t need a map,
                                you may want to provide one if you need to access the object through a database key. In this case the map is merely an index, so itâ€™s arguable whether it
                                really counts as a map at all.
                                Identity Map helps avoid update conflicts within a single session, but it
                                doesnâ€™t do anything to handle conflicts that cross sessions. This is a complex
                                problem that we discuss further in Optimistic Offline Lock (416) and Pessimistic Offline Lock (426).</p>
                <h3 id="198(2)">Example: Methods for an Identity Map (Java)</h3>
                <p>For each Identity Map we have a map field and accessors.
                                <pre>private Map people = new HashMap();
                                public static void addPerson(Person arg) {
                                soleInstance.people.put(arg.getID(), arg);
                                }
                                public static Person getPerson(Long key) {
                                return (Person) soleInstance.people.get(key);
                                }
                                public static Person getPerson(long key) {
                                return getPerson(new Long(key));
                                }</pre>
                                One of the annoyances of Java is the fact that long isnâ€™t an object so you canâ€™t
                                use it as an index for a map. This isnâ€™t as annoying as it could have been since
                                we donâ€™t actually do any arithmetic on the index. The one place where it really
                                hurts, though, is when you want to retrieve an object with a literal. You hardly
                                ever need to do that in production code, but you often do in test code, so Iâ€™ve
                                included a getting method that takes a long to make testing easier.</p>
                <h3 id="200">Lazy Load</h3>
                <p>An object that doesnâ€™t contain all of the data you need
                                but knows how to get it.
                                For loading data from a database into memory itâ€™s handy to design things so
                                that as you load an object of interest you also load the objects that are related
                                to it. This makes loading easier on the developer using the object, who otherwise has to load all the objects he needs explicitly.
                                However, if you take this to its logical conclusion, you reach the point where
                                loading one object can have the effect of loading a huge number of related
                                objectsâ€”something that hurts performance when only a few of the objects are
                                actually needed.
                                A Lazy Load interrupts this loading process for the moment, leaving a
                                marker in the object structure so that if the data is needed it can be loaded only
                                when it is used. As many people know, if youâ€™re lazy about doing things youâ€™ll
                                win when it turns out you donâ€™t need to do them at all.</p>
                <h3 id="200(2)">How It Works</h3>
                <p>There are four main ways you can implement Lazy Load: lazy initialization,
                                virtual proxy, value holder, and ghost.
                                a customer the database
                                get orders
                                [orders not loaded]
                                load orders
                                return orders
                                Lazy initialization [Beck Patterns] is the simplest approach. The basic idea is
                                that every access to the field checks first to see if itâ€™s null. If so, it calculates the
                                value of the field before returning the field. To make this work you have to
                                ensure that the field is self-encapsulated, meaning that all access to the field,
                                even from within the class, is done through a getting method.
                                Using a null to signal a field that hasnâ€™t been loaded yet works well, unless
                                null is a legal field value. In this case you need something else to signal that
                                the field hasnâ€™t been loaded, or you need to use a Special Case (496) for the
                                null value.</p>
                <p>Using lazy initialization is simple, but it does tend to force a dependency
                                between the object and the database. For that reason it works best for Active
                                Record (160), Table Data Gateway (144), and Row Data Gateway (152). If
                                youâ€™re using Data Mapper (165), youâ€™ll need an additional layer of indirection,
                                which you can obtain by using a virtual proxy [Gang of Four]. A virtual proxy
                                is an object that looks like the object that should be in the field, but doesnâ€™t
                                actually contain anything. Only when one of its methods is called does it load
                                the correct object from the database.
                                The good thing about a virtual proxy is that it looks exactly like the object
                                thatâ€™s supposed to be there. The bad thing is that it isnâ€™t that object, so you can
                                easily run into a nasty identity problem. Furthermore you can have more than
                                one virtual proxy for the same real object. All of these proxies will have different object identities, yet they represent the same conceptual object. At the very
                                least you have to override the equality method and remember to use it instead
                                of an identity method. Without that, and discipline, youâ€™ll run into some very
                                hard-to-track bugs.<p>
                <p>In some environments another problem is that you end up having to create
                                lots of virtual proxies, one for each class youâ€™re proxying. You can usually
                                avoid this in dynamically typed languages, but in statically typed languages
                                things often get messy. Even when the platform provides handy facilities, such
                                as Javaâ€™s proxies, other inconveniences can come up.
                                These problems donâ€™t hit you if you only use virtual proxies for collections
                                classes, such as lists. Since collections are Value Objects (486), their identity
                                doesnâ€™t matter. Additionally you only have a few collection classes to write virtual collections for.
                                With domain classes you can get around these problems by using a value
                                holder. This concept, which I first came across in Smalltalk, is an object that
                                wraps some other object. To get the underlying object you ask the value holder
                                for its value, but only on the first access does it pull the data from the database.
                                The disadvantages of the value holder are that the class needs to know that itâ€™s
                                present and that you lose the explicitness of strong typing. You can avoid identity
                                problems by ensuring that the value holder is never passed out beyond its owning
                                class.</p>
                <p>A ghost is the real object in a partial state. When you load the object from
                                the database it contains just its ID. Whenever you try to access a field it loads its
                                full state. Think of a ghost as an object, where every field is lazy-initialized in
                                one fell swoop, or as a virtual proxy, where the object is its own virtual proxy.
                                Of course, thereâ€™s no need to load all the data in one go; you may group it in
                                groups that are commonly used together. If you use a ghost, you can put it
                                immediately in its Identity Map (195). This way you maintain identity and
                                avoid all problems due to cyclic references when reading in data.
                                A virtual proxy/ghost doesnâ€™t need to be completely devoid of data. If you
                                have some data thatâ€™s quick to get hold of and commonly used, it may make
                                sense to load it when you load the proxy or ghost. (This is sometimes referred
                                to as a â€œlight object.â€)
                                Inheritance often poses a problem with Lazy Load. If youâ€™re going to use
                                ghosts, youâ€™ll need to know what type of ghost to create, which you often canâ€™t
                                tell without loading the thing properly. Virtual proxies can suffer from the same
                                problem in statically typed languages.</p>
                <p>Another danger with Lazy Load is that it can easily cause more database
                                accesses than you need. A good example of this ripple loading is if you fill a collection with Lazy Loads and then look at them one at a time. This will cause
                                you to go to the database once for each object instead of reading them all in at
                                once. Iâ€™ve seen ripple loading cripple the performance of an application. One
                                way to avoid it is never to have a collection of Lazy Loads but, rather make the
                                collection itself a Lazy Load and, when you load it, load all the contents. The
                                limitation of this tactic is when the collection is very large, such as all the IP
                                addresses in the world. These arenâ€™t usually linked through associations in the
                                object model, so that doesnâ€™t happen very often, but when it does youâ€™ll need a
                                Value List Handler [Alur et al.].
                                Lazy Load is a good candidate for aspect-oriented programming. You can
                                put Lazy Load behavior into a separate aspect, which allows you to change the
                                lazy load strategy separately as well as freeing the domain developers from having to deal with lazy loading issues. Iâ€™ve also seen a project post-process Java
                                bytecode to implement Lazy Load in a transparent way.</p>
                <p>Often youâ€™ll run into situations where different use cases work best with different varieties of laziness. Some need one subset of the object graph; others
                                need another subset. For maximum efficiency you want to load the right subgraph for the right use case.
                                The way to deal with this is to have separate database interaction objects for
                                the different use cases. Thus, if you use Data Mapper (165), you may have two
                                order mapper objects: one that loads the line items immediately and one that
                                loads them lazily. The application code chooses the appropriate mapper depending on the use case. A variation on this is to have the same basic loader object
                                but defer to a strategy object to decide the loading pattern. This is a bit more
                                sophisticated, but it can be a better way to factor behavior.
                                In theory you might want a range of different degrees of laziness, but in practice you really need only two: a complete load and enough of a load for identification purposes in a list. Adding more usually adds more complexity than is
                                worthwhile.</p>
                <h3 id="203">When to Use It</h3>
                <p>Deciding when to use Lazy Load is all about deciding how much you want to
                                pull back from the database as you load an object, and how many database
                                calls that will require. Itâ€™s usually pointless to use Lazy Load on a field thatâ€™s
                                stored in the same row as the rest of the object, because most of the time it
                                doesnâ€™t cost any more to bring back extra data in a call, even if the data field is
                                quite largeâ€”such as a Serialized LOB (272). That means itâ€™s usually only worth
                                considering Lazy Load if the field requires an extra database call to access.
                                In performance terms itâ€™s about deciding when you want to take the hit of
                                bringing back the data. Often itâ€™s a good idea to bring everything youâ€™ll need in
                                one call so you have it in place, particularly if it corresponds to a single interaction with a UI. The best time to use Lazy Load is when it involves an extra call
                                and the data youâ€™re calling isnâ€™t used when the main object is used.
                                Adding Lazy Load does add a little complexity to the program, so my preference is not to use it unless I actively think Iâ€™ll need it.</p>
                <h3 id="203(2)">Example: Lazy Initialization (Java)</h3>
                <p>The essence of lazy initialization is code like this:
                                <pre>class Supplier...
                                public List getProducts() {
                                if (products == null) products = Product.findForSupplier(getID());
                                return products;
                                }</pre>
                                In this way the first access of the products field causes the data to be loaded
                                from the database.</p>
                <h3 id="203(3)">Example: Virtual Proxy (Java)</h3>
                <p>The key to the virtual proxy is providing a class that looks like the actual class
                                you normally use but that actually holds a simple wrapper around the real
                                204 OBJECT-RELATIONAL BEHAVIORAL PATTERNS
                                Lazy Load
                                <pre>class. Thus, a list of products for a supplier would be held with a regular list
                                field.
                                class SupplierVL...
                                private List products;
                                The most complicated thing about producing a list proxy like this is setting it
                                up so that you can provide an underlying list thatâ€™s created only when itâ€™s
                                accessed. To do this we have to pass the code thatâ€™s needed to create the list into
                                the virtual list when itâ€™s instantiated. The best way to do this in Java is to define
                                an interface for the loading behavior.
                                public interface VirtualListLoader {
                                List load();
                                }
                                Then we can instantiate the virtual list with a loader that calls the appropriate
                                mapper method.
                                class SupplierMapper...
                                public static class ProductLoader implements VirtualListLoader {
                                private Long id;
                                public ProductLoader(Long id) {
                                this.id = id;
                                }
                                public List load() {
                                return ProductMapper.create().findForSupplier(id);
                                }
                                }
                                During the load method we assign the product loader to the list field.
                                class SupplierMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String nameArg = rs.getString(2);
                                SupplierVL result = new SupplierVL(id, nameArg);
                                result.setProducts(new VirtualList(new ProductLoader(id)));
                                return result;
                                }
                                The virtual listâ€™s source list is self-encapsulated and evaluates the loader on
                                first reference.
                                class VirtualList...
                                private List source;
                                private VirtualListLoader loader;
                                public VirtualList(VirtualListLoader loader) {
                                this.loader = loader;
                                LAZY LOAD 205
                                Lazy Load
                                }
                                private List getSource() {
                                if (source == null) source = loader.load();
                                return source;
                                }
                                The regular list methods to delegate are then implemented to the source list.
                                class VirtualList...
                                public int size() {
                                return getSource().size();
                                }
                                public boolean isEmpty() {
                                return getSource().isEmpty();
                                }
                                // ... and so on for rest of list methods</pre>
                                This way the domain class knows nothing about how the mapper class does the
                                Lazy Load. Indeed, the domain class isnâ€™t even aware that there is a Lazy Load.</p>
                <h3 id="205">Example: Using a Value Holder (Java)</h3>
                <p>A value holder can be used as a generic Lazy Load. In this case the domain type is
                                aware that something is afoot, since the product field is typed as a value holder.
                                This fact can be hidden from clients of the supplier by the getting method.
                                <pre>class SupplierVH...
                                private ValueHolder products;
                                public List getProducts() {
                                return (List) products.getValue();
                                }</pre>
                                The value holder itself does the Lazy Load behavior. It needs to be passed the
                                necessary code to load its value when itâ€™s accessed. We can do this by defining a
                                loader interface.
                                <pre>class ValueHolder...
                                private Object value;
                                private ValueLoader loader;
                                public ValueHolder(ValueLoader loader) {
                                this.loader = loader;
                                }
                                public Object getValue() {
                                if (value == null) value = loader.load();
                                return value;
                                }
                                public interface ValueLoader {
                                Object load();
                                }
                                206 OBJECT-RELATIONAL BEHAVIORAL PATTERNS
                                Lazy Load
                                A mapper can set up the value holder by creating an implementation of the
                                loader and putting it into the supplier object.
                                class SupplierMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String nameArg = rs.getString(2);
                                SupplierVH result = new SupplierVH(id, nameArg);
                                result.setProducts(new ValueHolder(new ProductLoader(id)));
                                return result;
                                }
                                public static class ProductLoader implements ValueLoader {
                                private Long id;
                                public ProductLoader(Long id) {
                                this.id = id;
                                }
                                public Object load() {
                                return ProductMapper.create().findForSupplier(id);
                                }
                                }</pre></p>
                <h3 id="206">Example: Using Ghosts (C#)</h3>
                <p>Much of the logic for making objects ghosts can be built into Layer Supertypes
                                (475). As a consequence, if you use ghosts you tend to see them used everywhere. Iâ€™ll begin our exploration of ghosts by looking at the domain object
                                Layer Supertype (475). Each domain object knows if itâ€™s a ghost or not.
                                <pre>class DomainObject...
                                LoadStatus Status;
                                public DomainObject (long key) {
                                this.Key = key;
                                }
                                public Boolean IsGhost {
                                get {return Status == LoadStatus.GHOST;}
                                }
                                public Boolean IsLoaded {
                                get {return Status == LoadStatus.LOADED;}
                                }
                                public void MarkLoading() {
                                Debug.Assert(IsGhost);
                                Status = LoadStatus.LOADING;
                                }
                                public void MarkLoaded() {
                                Debug.Assert(Status == LoadStatus.LOADING);
                                Status = LoadStatus.LOADED;
                                }</pre>
                                Domain objects can be in three states: ghost, loading, and loaded. I like to wrap
                                status information with read-only properties and explicit status change methods.
                                The most intrusive element of ghosts is that every accessor needs to be modified so that it will trigger a load if the object actually is a ghost.
                                <pre>class Employee...
                                public String Name {
                                get {
                                Load();
                                return _name;
                                }
                                set {
                                Load();
                                _name = value;
                                }
                                }
                                String _name;
                                class Domain Object...
                                protected void Load() {
                                if (IsGhost)
                                DataSource.Load(this);
                                }</pre>
                                Such a need, which is annoying to remember, is an ideal target for aspect-oriented programming for post-processing the bytecode.
                                In order for the loading to work, the domain object needs to call the correct
                                mapper. However, my visibility rules dictate that the domain code may not see
                                the mapper code. To avoid the dependency, I need to use an interesting combination of Registry (480) and Separated Interface (476) (Figure 11.4). I define a
                                Registry (480) for the domain for data source operations.
                                <pre>class DataSource...
                                public static void Load (DomainObject obj) {
                                instance.Load(obj);
                                }</pre>
                                The instance of the data source is defined using an interface.
                                <pre>class DataSource...
                                public interface IDataSource {
                                void Load (DomainObject obj);
                                }</pre>
                                208
                                OBJECT-RELATIO
                                NAL BEHA
                                VIORAL
                                PATTER
                                N
                                S
                                Lazy Load
                                A registry of mappers, defined in the data source layer, implements the data
                                source interface. In this case Iâ€™ve put the mappers in a dictionary indexed by
                                domain type. The load method finds the correct mapper and tells it to load the
                                appropriate domain object.
                                <pre>class MapperRegistry : IDataSource...
                                public void Load (DomainObject obj) {
                                Mapper(obj.GetType()).Load (obj);
                                }
                                public static Mapper Mapper(Type type) {
                                return (Mapper) instance.mappers[type];
                                }
                                IDictionary mappers = new Hashtable();</pre>
                                The preceding code shows how the domain objects interact with the data
                                source. The data source logic uses Data Mappers (165). The update logic on the
                                mappers is the same as in the case with no ghostsâ€”the interesting behavior for
                                this example lies in the finding and loading behavior.
                                Concrete mapper classes have their own find methods that use an abstract
                                method and downcast the result.
                                <pre>class EmployeeMapper...
                                public Employee Find (long key) {
                                return (Employee) AbstractFind(key);
                                }
                                class Mapper...
                                public DomainObject AbstractFind (long key) {
                                DomainObject result;
                                result = (DomainObject) loadedMap[key];
                                if (result == null) {
                                result = CreateGhost(key);
                                loadedMap.Add(key, result);
                                }
                                return result;
                                }
                                IDictionary loadedMap = new Hashtable();
                                public abstract DomainObject CreateGhost(long key);
                                class EmployeeMapper...
                                public override DomainObject CreateGhost(long key) {
                                return new Employee(key);
                                }</pre>
                                As you can see, the find method returns an object in its ghost state. The actual
                                data does not come from the database until the load is triggered by accessing a
                                property on the domain object.
                                <pre>class Mapper...
                                public void Load (DomainObject obj) {
                                if (! obj.IsGhost) return;
                                IDbCommand comm = new OleDbCommand(findStatement(), DB.connection);
                                comm.Parameters.Add(new OleDbParameter("key",obj.Key));
                                IDataReader reader = comm.ExecuteReader();
                                reader.Read();
                                LoadLine (reader, obj);
                                reader.Close();
                                }
                                protected abstract String findStatement();
                                public void LoadLine (IDataReader reader, DomainObject obj) {
                                if (obj.IsGhost) {
                                obj.MarkLoading();
                                doLoadLine (reader, obj);
                                obj.MarkLoaded();
                                }
                                }
                                protected abstract void doLoadLine (IDataReader reader, DomainObject obj);</pre>
                                As is common with these examples, the Layer Supertype (475) handles all of
                                the abstract behavior and then calls an abstract method for a particular subclass to play its part. For this example Iâ€™ve used a data reader, a cursor-based
                                approach thatâ€™s the more common for the various platforms at the moment. Iâ€™ll
                                leave it to you to extend this to a data set, which would actually be more suitable for most cases in .NET.
                                For this employee object, Iâ€™ll show three kinds of property: a name thatâ€™s a
                                simple value, a department thatâ€™s a reference to another object, and a list of
                                timesheet records that shows the case of a collection. All are loaded together in
                                the subclassâ€™s implementation of the hook method.
                                <pre>class EmployeeMapper...
                                protected override void doLoadLine (IDataReader reader, DomainObject obj) {
                                Employee employee = (Employee) obj;
                                employee.Name = (String) reader["name"];
                                DepartmentMapper depMapper =
                                (DepartmentMapper) MapperRegistry.Mapper(typeof(Department));
                                employee.Department = depMapper.Find((int) reader["departmentID"]);
                                loadTimeRecords(employee);
                                }</pre>
                                The nameâ€™s value is loaded simply by reading the appropriate column from
                                the data readerâ€™s current cursor. The department is read by using the find
                                method on the departmentâ€™s mapper object. This will end up setting the property to a ghost of the department; the departmentâ€™s data will only be read when
                                the department object itself is accessed.
                                The collection is the most complicated case. To avoid ripple loading, itâ€™s
                                important to load all the time records in a single query. For this we need a special list implementation that acts as a ghost list. This list is just a thin wrapper
                                around a real list object, to which all the real behavior is just delegated. The
                                only thing the ghost does is ensure that any accesses to the real list triggers a
                                load.
                                <pre>class DomainList...
                                IList data {
                                get {
                                Load();
                                return _data;
                                }
                                set {_data = value;}
                                }
                                IList _data = new ArrayList();
                                public int Count {
                                get {return data.Count;}
                                }</pre>
                                The domain list class is used by domain objects and is part of the domain
                                layer. The actual loading needs access to SQL commands, so I use a delegate to
                                define a loading function that can be supplied by the mapping layer.
                                <pre>class DomainList...
                                public void Load () {
                                if (IsGhost) {
                                MarkLoading();
                                RunLoader(this);
                                MarkLoaded();
                                }
                                }
                                public delegate void Loader(DomainList list);
                                public Loader RunLoader;</pre>
                                Think of a delegate as a special variety of Separated Interface (476) for a single
                                function. Indeed, declaring an interface with a single function in it is a reasonable alternative way of doing this.
                                212
                                OBJECT-RELATIO
                                NAL BEHA
                                VIORAL
                                PATTER
                                N
                                S
                                Lazy Load
                                Figure 11.5 The load sequence for a ghost.
                                emp: Employee
                                Name
                                load
                                [isGhost] Load (emp)
                                Data Source a Mapper Registry
                                IDataSource
                                Load (emp)
                                Mapper(emp.GetType)
                                an Employee
                                Mapper
                                Load (emp) SELECT ... WHERE ID = emp.Key
                                -- load various properties
                                database
                                The loader itself has properties to specify the SQL for the load and mapper
                                to use for mapping the time records. The employeeâ€™s mapper sets up the loader
                                when it loads the employee object.
                                class EmployeeMapper...
                                void loadTimeRecords(Employee employee) {
                                ListLoader loader = new ListLoader();
                                loader.Sql = TimeRecordMapper.FIND_FOR_EMPLOYEE_SQL;
                                loader.SqlParams.Add(employee.Key);
                                loader.Mapper = MapperRegistry.Mapper(typeof(TimeRecord));
                                loader.Attach((DomainList) employee.TimeRecords);
                                }
                                Figure 11.6 Classes for a ghost list. As yet thereâ€™s no accepted standard for showing
                                delegates in UML models. This is my current approach.
                                Domain List
                                IList
                                1
                                + Load (DomainList)
                                + Attach (DomainList)
                                Sql : String
                                SqlParams : IList
                                List Loader
                                RunLoader Loader(DomainList)
                                Â«delegateÂ»
                                Mapper
                                Â«delegateÂ»
                                Load
                                1
                                1
                                data source
                                domain
                                class ListLoader...
                                public String Sql;
                                public IList SqlParams = new ArrayList();
                                public Mapper Mapper;
                                Since the syntax for the delegate assignment is a bit complicated, Iâ€™ve given the
                                loader an attach method.
                                class ListLoader...
                                public void Attach (DomainList list) {
                                list.RunLoader = new DomainList.Loader(Load);
                                }
                                When the employee is loaded, the time records collection stays in a ghost
                                state until one of the access methods fires to trigger the loader. At this point the
                                loader executes the query to fill the list.
                                class ListLoader...
                                public void Load (DomainList list) {
                                list.IsLoaded = true;
                                IDbCommand comm = new OleDbCommand(Sql, DB.connection);
                                foreach (Object param in SqlParams)
                                comm.Parameters.Add(new OleDbParameter(param.ToString(),param));
                                IDataReader reader = comm.ExecuteReader();
                                while (reader.Read()) {
                                DomainObject obj = GhostForLine(reader);
                                Mapper.LoadLine(reader, obj);
                                list.Add (obj);
                                }
                                reader.Close();
                                }
                                private DomainObject GhostForLine(IDataReader reader) {
                                return Mapper.AbstractFind((System.Int32)reader[Mapper.KeyColumnName]);
                                }
                                Using ghost lists like this is important to reduce ripple loading. It doesnâ€™t
                                completely eliminate it, as there are other cases where it appears. In this example, a more sophisticated mapping could load the departmentâ€™s data in a single
                                query with the employee. However, always loading all the elements in a collection together helps eliminate the worst cases.
                                ObjectRelational</p>
                <h3 id="215">Chapter 12</h3>
                <h2>Object-Relational Structural Patterns</h2>
                <h3 id="216">Identity Field</h3>
                <p>Saves a database ID field in an object to maintain identity between
                                an in-memory object and a database row.
                                Relational databases tell one row from another by using keyâ€”in particular, the
                                primary key. However, in-memory objects donâ€™t need such a key, as the object
                                system ensures the correct identity under the covers (or in C++â€™s case with raw
                                memory locations). Reading data from a database is all very well, but in order
                                to write data back you need to tie the database to the in-memory object system.
                                In essence, Identity Field is mind-numbingly simple. All you do is store the
                                primary key of the relational database table in the objectâ€™s fields.</p>
                <h3 id="216(2)">How It Works</h3>
                <p>Although the basic notion of Identity Field is very simple, there are oodles of
                                complicated issues that come up.
                                Choosing Your Key The first issue is what kind of key to choose in your database. Of course, this isnâ€™t always a choice, since youâ€™re often dealing with an
                                existing database that already has its key structures in place. Thereâ€™s a lot of discussion and material on this in the database community. Still, mapping to
                                objects does add some concerns to your decision.
                                The first concern is whether to use meaningful or meaningless keys. A meaningful key is something like the U.S. Social Security number for identifying a
                                person. A meaningless key is essentially a random number the database dreams
                                up thatâ€™s never intended for human use. The danger with a meaningful key is
                                that, while in theory they make good keys, in practice they donâ€™t. To work at
                                all, keys need to be unique; to work well, they need to be immutable. While
                                assigned numbers are supposed to be unique and immutable, human error often
                                makes them neither. If you mistype my SSN for my wifeâ€™s the resulting record is
                                neither unique nor immutable (assuming you would like to fix the mistake.)
                                The database should detect the uniqueness problem, but it can only do that
                                id : long
                                Person
                                after my record goes into the system, and of course that might not happen until
                                after the mistake. As a result, meaningful keys should be distrusted. For small
                                systems and/or very stable cases you may get away with it, but usually you
                                should take a rare stand on the side of meaninglessness.</p>
                <p>The next concern is simple versus compound keys. A simple key uses only
                                one database field; a compound key uses more than one. The advantage of a
                                compound key is that itâ€™s often easier to use when one table makes sense in the
                                context of another. A good example is orders and line items, where a good key
                                for the line item is a compound of the order number and a sequence number
                                makes a good key for a line item. While compound keys often make sense, there
                                is a lot to be said for the sheer uniformity of simple keys. If you use simple keys
                                everywhere, you can use the same code for all key manipulation. Compound
                                keys require special handling in concrete classes. (With code generation this
                                isnâ€™t a problem). Compound keys also carry a bit of meaning, so be careful
                                about the uniqueness and particularly the immutability rule with them.
                                You have to choose the type of the key. The most common operation youâ€™ll
                                do with a key is equality checking, so you want a type with a fast equality operation. The other important operation is getting the next key. Hence a long integer type is often the best bet. Strings can also work, but equality checking may
                                be slower and incrementing strings is a bit more painful. Your DBAâ€™s preferences may well decide the issue.
                                (Beware about using dates or times in keys. Not only are they meaningful,
                                they also lead to problems with portability and consistency. Dates in particular
                                are vulnerable to this because they are often stored to some fractional second
                                precision, which can easily get out of sync and lead to identity problems.)
                                You can have keys that are unique to the table or unique database-wide. A
                                table-unique key is unique across the table, which is what you need for a key in
                                any case. A database-unique key is unique across every row in every table in the
                                database. A table-unique key is usually fine, but a database-unique key is often
                                easier to do and allows you to use a single Identity Map (195). Modern values
                                being what they are, itâ€™s pretty unlikely that youâ€™ll run out of numbers for new
                                keys. If you really insist, you can reclaim keys from deleted objects with a simple database script that compacts the key spaceâ€”although running this script
                                will require that you take the application offline. However, if you use 64-bit
                                keys (and you might as well) youâ€™re unlikely to need this.</p>
                <p>Be wary of inheritance when you use table-unique keys. If youâ€™re using Concrete Table Inheritance (293) or Class Table Inheritance (285), life is much easier with keys that are unique to the hierarchy rather than unique to each table. I
                                still use the term â€œtable-unique,â€ even if it should strictly be something like
                                â€œinheritance graph unique.â€
                                The size of your key may effect performance, particularly with indexes. This
                                is dependent on your database system and/or how many rows you have, but itâ€™s
                                worth doing a crude check before you get fixed into your decision.
                                Representing the Identity Field in an Object The simplest form of Identity
                                Field is a field that matches the type of the key in the database. Thus, if you use
                                a simple integral key, an integral field will work very nicely.
                                Compound keys are more problematic. The best bet with them is to make a
                                key class. A generic key class can store a sequence of objects that act as the elements of the key. The key behavior for the key object (I have a quota of puns
                                per book to fill) is equality. Itâ€™s also useful to get parts of the key when youâ€™re
                                mapping to the database.
                                If you use the same basic structure for all keys, you can do all of the key handling in a Layer Supertype (475). You can put default behavior that will work
                                for most cases in the Layer Supertype (475) and extend it for the exceptional
                                cases in the particular subtypes.</p>
                <p>You can have either a single key class, which takes a generic list of key
                                objects, or key class for each domain class with explicit fields for each part of
                                the key. I usually prefer to be explicit, but in this case Iâ€™m not sure it buys very
                                much. You end up with lots of small classes that donâ€™t do anything interesting.
                                The main benefit is that you can avoid errors caused by users putting the elements of the key in the wrong order, but that doesnâ€™t seem to be a big problem
                                in practice.
                                If youâ€™re likely to import data between different database instances, you need
                                to remember that youâ€™ll get key collisions unless you come up with some
                                scheme to separate the keys between different databases. You can solve this
                                with some kind of key migration on the imports, but this can easily get very
                                messy.
                                Getting a New Key To create an object, youâ€™ll need a key. This sounds like a
                                simple matter, but it can often be quite a problem. You have three basic choices:
                                get the database to auto-generate, use a GUID, or generate your own.
                                The auto-generate route should be the easiest. Each time you insert data for
                                the database, the database generates a unique primary key without you having
                                to do anything. It sounds too good to be true, and sadly it often is. Not all databases do this the same way. Many that do, handle it in such a way that causes
                                problems for object-relational mapping.</p>
                <p>The most common auto-generation method is declaring one auto-generated
                                field, which, whenever you insert a row, is incremented to a new value. The
                                problem with this scheme is that you canâ€™t easily determine what value got gen-
                                erated as the key. If you want to insert an order and several line items, you need
                                the key of the new order so you can put the value in the line itemâ€™s foreign key.
                                Also, you need this key before the transaction commits so you can save everything within the transaction. Sadly, databases usually donâ€™t give you this information, so you usually canâ€™t use this kind of auto-generation on any table in
                                which you need to insert connected objects.
                                An alternative approach to auto-generation is a database counter, which
                                Oracle uses with its sequence. An Oracle sequence works by sending a select
                                statement that references a sequence; the database then returns an SQL record
                                set consisting of the next sequence value. You can set a sequence to increment
                                by any integer, which allows you to get multiple keys at once. The sequence
                                query is automatically carried out in a separate transaction, so that accessing
                                the sequence wonâ€™t lock out other transactions inserting at the same time. A
                                database counter like this is perfect for our needs, but itâ€™s nonstandard and not
                                available in all databases.</p>
                <p>A GUID (Globally Unique IDentifier) is a number generated on one
                                machine thatâ€™s guaranteed to be unique across all machines in space and time.
                                Often platforms give you the API to generate a GUID. The algorithm is an
                                interesting one involving ethernet card addresses, time of the day in nanoseconds, chip ID numbers, and probably the number of hairs on your left wrist.
                                All that matters is that the resulting number is completely unique and thus a
                                safe key. The only disadvantage to a GUID is that the resulting key string is
                                big, and that can be an equally big problem. There are always times when
                                someone needs to type in a key to a window or SQL expression, and long keys
                                are hard both to type and to read. They may also lead to performance problems, particularly with indexes.
                                The last option is rolling your own. A simple staple for small systems is to
                                use a table scan using the SQL max function to find the largest key in the table
                                and then add one to use it. Sadly, this read-locks the entire table while youâ€™re
                                doing it, which means that it works fine if inserts are rare, but your performance will be toasted if you have inserts running concurrently with updates on
                                the same table. You also have to ensure you have complete isolation between
                                transactions; otherwise, you can end up with multiple transactions getting the
                                same ID value.</p>
                <p>A better approach is to use a separate key table. This table is typically one
                                with two columns: name and next available value. If you use database-unique
                                keys, youâ€™ll have just one row in this table. If you use table-unique keys, youâ€™ll
                                have one row for each table in the database. To use the key table, all you need
                                to do is read that one row and note the number, the increment, the number and
                                write it back to the row. You can grab many keys at a time by adding a suitable
                                number when you update the key table. This cuts down on expensive database
                                calls and reduces contention on the key table.</p>
                <p>If you use a key table, itâ€™s a good idea to design it so that access to it is in a
                                separate transaction from the one that updates the table youâ€™re inserting into.
                                Say Iâ€™m inserting an order into the orders table. To do this Iâ€™ll need to lock the
                                orders row on the key table with a write lock (since Iâ€™m updating). That lock
                                will last for the entire transaction that Iâ€™m in, locking out anyone else who
                                wants a key. For table-unique keys, this means anyone inserting into the orders
                                table; for database-unique keys it means anyone inserting anywhere.
                                By putting access to the key table in a separate transaction, you only lock the
                                row for that, much shorter, transaction. The downside is that, if you roll back
                                on your insert to the orders, the key you got from the key table is lost to everyone. Fortunately, numbers are cheap, so thatâ€™s not a big issue. Using a separate
                                transaction also allows you to get the ID as soon as you create the in-memory
                                object, which is often some before you open the transaction to commit the business transaction.
                                Using a key table affects the choice of database-unique or table-unique keys.
                                If you use a table-unique key, you have to add a row to the key table every time
                                you add a table to the database. This is more effort, but it reduces contention
                                on the row. If you keep your key table accesses in a different transaction, contention is not so much of a problem, especially if you get multiple keys in a single call. But if you canâ€™t arrange for the key table update to be in a separate
                                transaction, you have a strong reason against database-unique keys.
                                Itâ€™s good to separate the code for getting a new key into its own class, as that
                                makes it easier to build a Service Stub (504) for testing purposes.</p>
                <h3 id="220">When to Use It</h3>
                <p>Use Identity Field when thereâ€™s a mapping between objects in memory and rows
                                in a database. This is usually when you use Domain Model (116) or Row Data
                                Gateway (152). You donâ€™t need this mapping if youâ€™re using Transaction Script
                                (110), Table Module (125), or Table Data Gateway (144).
                                For a small object with value semantics, such as a money or date range
                                object that wonâ€™t have its own table, itâ€™s better to use Embedded Value (268).
                                For a complex graph of objects that doesnâ€™t need to be queried within the relational database, Serialized LOB (272) is usually easier to write and gives faster
                                performance.
                                One alternative to Identity Field is to extend Identity Map (195) to maintain
                                the correspondence. This can be used for systems where you donâ€™t want to store
                                an Identity Field in the in-memory object. Identity Map (195) needs to look up
                                IDENTITY FIELD 221
                                Identity Field
                                both ways: give me a key for an object or an object for a key. I donâ€™t see this
                                very often because usually itâ€™s easier to store the key in the object.</p>
                <h3 id="221">Further Reading</h3>
                <p> [Marinescu] discusses several techniques for generating keys.</p>
                <h3 id="221(2)">Example: Integral Key (C#)</h3>
                <p>The simplest form of Identity Field is a integral field in the database that maps
                                to an integral field in an in-memory object.
                                <pre>class DomainObject...
                                public const long PLACEHOLDER_ID = -1;
                                public long Id = PLACEHOLDER_ID;
                                public Boolean isNew() {return Id == PLACEHOLDER_ID;}</pre>
                                An object thatâ€™s been created in memory but not saved to the database will not
                                have a value for its key. For a .NET value object this is a problem since .NET
                                values cannot be null. Hence, the placeholder value.
                                The key becomes important in two places: finding and inserting. For finding
                                you need to form a query using a key in a where clause. In .NET you can load
                                many rows into a data set and then select a particular one with a find operation.
                                <pre>class CricketerMapper...
                                public Cricketer Find(long id) {
                                return (Cricketer) AbstractFind(id);
                                }
                                class Mapper...
                                protected DomainObject AbstractFind(long id) {
                                DataRow row = FindRow(id);
                                return (row == null) ? null : Find(row);
                                }
                                protected DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                }
                                public DomainObject Find (DataRow row) {
                                DomainObject result = CreateDomainObject();
                                Load(result, row);
                                return result;
                                }
                                abstract protected DomainObject CreateDomainObject();
                                222 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                Most of this behavior can live on the Layer Supertype (475), but youâ€™ll often
                                need to define the find on the concrete class just to encapsulate the downcast.
                                Naturally, you can avoid this in a language that doesnâ€™t use compile-time typing.
                                With a simple integral Identity Field the insertion behavior can also be held
                                at the Layer Supertype (475).
                                class Mapper...
                                public virtual long Insert (DomainObject arg) {
                                DataRow row = table.NewRow();
                                arg.Id = GetNextID();
                                row["id"] = arg.Id;
                                Save (arg, row);
                                table.Rows.Add(row);
                                return arg.Id;
                                }</pre>
                                Essentially insertion involves creating the new row and using the next key for
                                it. Once you have it you can save the in-memory objectâ€™s data to this new row.</p>
                <h3 id="222">Example: Using a Key Table (Java)</h3>
                <p>If your database supports a database counter and youâ€™re not worried about
                                being dependent on database-specific SQL, you should use the counter. Even if
                                youâ€™re worried about being dependent on a database you should still consider
                                itâ€”as long as your key generation code is nicely encapsulated, you can always
                                change it to a portable algorithm later. You could even have a strategy [Gang of
                                Four] to use counters when you have them and roll your own when you donâ€™t.
                                For the moment letâ€™s assume that we have to do this the hard way. The first
                                thing we need is a key table in the database.
                                CREATE TABLE keys (name varchar primary key, nextID int)
                                INSERT INTO keys VALUES ('orders', 1)
                                This table contains one row for each counter thatâ€™s in the database. In this case
                                weâ€™ve initialized the key to 1. If youâ€™re preloading data in the database, youâ€™ll
                                need to set the counter to a suitable number. If you want database-unique keys,
                                youâ€™ll only need one row, if you want table-unique keys, youâ€™ll need one row
                                per table.</p>
                <p>You can wrap all of your key generation code into its own class. That way
                                itâ€™s easier to use it more widely around one or more applications and itâ€™s easier
                                to put key reservation into its own transaction.
                                We construct a key generator with its own database connection, together
                                with information on how many keys to take from the database at one time.
                                <pre>class KeyGenerator...
                                private Connection conn;
                                private String keyName;
                                private long nextId;
                                private long maxId;
                                private int incrementBy;
                                public KeyGenerator(Connection conn, String keyName, int incrementBy) {
                                this.conn = conn;
                                this.keyName = keyName;
                                this.incrementBy = incrementBy;
                                nextId = maxId = 0;
                                try {
                                conn.setAutoCommit(false);
                                } catch(SQLException exc) {
                                throw new ApplicationException("Unable to turn off autocommit", exc);
                                }
                                }</pre>
                                We need to ensure that no auto-commit is going on since we absolutely must
                                have the select and update operating in one transaction.
                                When we ask for a new key, the generator looks to see if it has one cached
                                rather than go to the database.
                                <pre>class KeyGenerator...
                                public synchronized Long nextKey() {
                                if (nextId == maxId) {
                                reserveIds();
                                }
                                return new Long(nextId++);
                                }
                                If the generator hasnâ€™t got one cached, it needs to go to the database.
                                class KeyGenerator...
                                private void reserveIds() {
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                long newNextId;
                                try {
                                stmt = conn.prepareStatement("SELECT nextID FROM keys WHERE name = ? FOR UPDATE");
                                stmt.setString(1, keyName);
                                rs = stmt.executeQuery();
                                rs.next();
                                newNextId = rs.getLong(1);
                                }
                                224 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                catch (SQLException exc) {
                                throw new ApplicationException("Unable to generate ids", exc);
                                }
                                finally {
                                DB.cleanUp(stmt, rs);
                                }
                                long newMaxId = newNextId + incrementBy;
                                stmt = null;
                                try {
                                stmt = conn.prepareStatement("UPDATE keys SET nextID = ? WHERE name = ?");
                                stmt.setLong(1, newMaxId);
                                stmt.setString(2, keyName);
                                stmt.executeUpdate();
                                conn.commit();
                                nextId = newNextId;
                                maxId = newMaxId;
                                }
                                catch (SQLException exc) {
                                throw new ApplicationException("Unable to generate ids", exc);
                                }
                                finally {
                                DB.cleanUp(stmt);
                                }
                                }</pre>
                                In this case we use SELECT... FOR UPDATE to tell the database to hold a write lock
                                on the key table. This is an Oracle-specific statement, so your mileage will vary
                                if youâ€™re using something else. If you canâ€™t write-lock on the select, you run the
                                risk of the transaction failing should another one get in there before you. In this
                                case, however, you can pretty safely just rerun reserveIds until you get a pristine
                                set of keys.</p>
                <h3 id="224">Example: Using a Compound Key (Java)</h3>
                <p>Using a simple integral key is a good, simple solution, but you often need other
                                types or compound keys.
                                A Key Class As soon as you need something else itâ€™s worth putting together a
                                key class. A key class needs to be able to store multiple elements of the key and
                                to be able to tell if two keys are equal.
                                <pre>class Key...
                                private Object[] fields;
                                public boolean equals(Object obj) {
                                if (!(obj instanceof Key)) return false;
                                Key otherKey = (Key) obj;
                                if (this.fields.length != otherKey.fields.length) return false;
                                IDENTITY FIELD 225
                                Identity Field
                                for (int i = 0; i < fields.length; i++)
                                if (!this.fields[i].equals(otherKey.fields[i])) return false;
                                return true;
                                }
                                The most elemental way to create a key is with an array parameter.
                                class Key...
                                public Key(Object[] fields) {
                                checkKeyNotNull(fields);
                                this.fields = fields;
                                }
                                private void checkKeyNotNull(Object[] fields) {
                                if (fields == null) throw new IllegalArgumentException("Cannot have a null key");
                                for (int i = 0; i < fields.length; i++)
                                if (fields[i] == null)
                                throw new IllegalArgumentException("Cannot have a null element of key");
                                }
                                If you find you commonly create keys with certain elements, you can add
                                convenience constructors. The exact ones will depend on what kinds of keys
                                your application has.
                                class Key...
                                public Key(long arg) {
                                this.fields = new Object[1];
                                this.fields[0] = new Long(arg);
                                }
                                public Key(Object field) {
                                if (field == null) throw new IllegalArgumentException("Cannot have a null key");
                                this.fields = new Object[1];
                                this.fields[0] = field;
                                }
                                public Key(Object arg1, Object arg2) {
                                this.fields = new Object[2];
                                this.fields[0] = arg1;
                                this.fields[1] = arg2;
                                checkKeyNotNull(fields);
                                }
                                Donâ€™t be afraid to add these convenience methods. After all, convenience is
                                important to everyone using the keys.
                                Similarly you can add accessor functions to get parts of keys. The application
                                will need to do this for the mappings.
                                class Key...
                                public Object value(int i) {
                                return fields[i];
                                }
                                226 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                public Object value() {
                                checkSingleKey();
                                return fields[0];
                                }
                                private void checkSingleKey() {
                                if (fields.length > 1)
                                throw new IllegalStateException("Cannot take value on composite key");
                                }
                                public long longValue() {
                                checkSingleKey();
                                return longValue(0);
                                }
                                public long longValue(int i) {
                                if (!(fields[i] instanceof Long))
                                throw new IllegalStateException("Cannot take longValue on non long key");
                                return ((Long) fields[i]).longValue();
                                }
                                In this example weâ€™ll map to an order and line item tables. The order table
                                has a simple integral primary key,
                                the line item tableâ€™s primary key is a compound of the orderâ€™s primary key and a sequence number.
                                CREATE TABLE orders (ID int primary key, customer varchar)
                                CREATE TABLE line_items (orderID int, seq int, amount int, product varchar,
                                primary key (orderID, seq))
                                The Layer Supertype (475) for domain objects needs to have a key field.
                                class DomainObjectWithKey...
                                private Key key;
                                protected DomainObjectWithKey(Key ID) {
                                this.key = ID;
                                }
                                protected DomainObjectWithKey() {
                                }
                                public Key getKey() {
                                return key;
                                }
                                public void setKey(Key key) {
                                this.key = key;
                                }</pre>
                                Reading As with other examples in this book Iâ€™ve split the behavior into find
                                (which gets to the right row in the database) and load (which loads data from
                                that row into the domain object). Both responsibilities are affected by the use of
                                a key object.</p>
                <p>The primary difference between these and the other examples in this book
                                (which use simple integral keys) is that we have to factor out certain pieces of
                                behavior that are overridden by classes that have more complex keys. For this
                                example Iâ€™m assuming that most tables use simple integral keys. However, some
                                use something else, so Iâ€™ve made the default case the simple integral and have
                                embedded the behavior for it the mapper Layer Supertype (475). The order
                                class is one of those simple cases. Hereâ€™s the code for the find behavior:
                                <pre>class OrderMapper...
                                public Order find(Key key) {
                                return (Order) abstractFind(key);
                                }
                                public Order find(Long id) {
                                return find(new Key(id));
                                }
                                protected String findStatementString() {
                                return "SELECT id, customer from orders WHERE id = ?";
                                }
                                class AbstractMapper...
                                abstract protected String findStatementString();
                                protected Map loadedMap = new HashMap();
                                public DomainObjectWithKey abstractFind(Key key) {
                                DomainObjectWithKey result = (DomainObjectWithKey) loadedMap.get(key);
                                if (result != null) return result;
                                ResultSet rs = null;
                                PreparedStatement findStatement = null;
                                try {
                                findStatement = DB.prepare(findStatementString());
                                loadFindStatement(key, findStatement);
                                rs = findStatement.executeQuery();
                                rs.next();
                                if (rs.isAfterLast()) return null;
                                result = load(rs);
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {
                                DB.cleanUp(findStatement, rs);
                                }
                                }
                                // hook method for keys that arenâ€™t simple integral
                                protected void loadFindStatement(Key key, PreparedStatement finder) throws SQLException {
                                finder.setLong(1, key.longValue());
                                }</pre>
                                Iâ€™ve extracted out the building of the find statement, since that requires different
                                parameters to be passed into the prepared statement. The line item is a compound key, so it needs to override that method.
                                <pre>class LineItemMapper...
                                public LineItem find(long orderID, long seq) {
                                Key key = new Key(new Long(orderID), new Long(seq));
                                return (LineItem) abstractFind(key);
                                }
                                public LineItem find(Key key) {
                                return (LineItem) abstractFind(key);
                                }
                                protected String findStatementString() {
                                return
                                "SELECT orderID, seq, amount, product " +
                                " FROM line_items " +
                                " WHERE (orderID = ?) AND (seq = ?)";
                                }
                                // hook methods overridden for the composite key
                                protected void loadFindStatement(Key key, PreparedStatement finder) throws SQLException {
                                finder.setLong(1, orderID(key));
                                finder.setLong(2, sequenceNumber(key));
                                }
                                //helpers to extract appropriate values from line itemâ€™s key
                                private static long orderID(Key key) {
                                return key.longValue(0);
                                }
                                private static long sequenceNumber(Key key) {
                                return key.longValue(1);
                                }</pre>
                                As well as defining the interface for the find methods and providing an SQL
                                string for the find statement, the subclass needs to override the hook method to
                                allow two parameters to go into the SQL statement. Iâ€™ve also written two helper
                                methods to extract the parts of the key information. This makes for clearer
                                code than I would get by just putting explicit accessors with numeric indices
                                from the key. Such literal indices are a bad smell.
                                The load behavior shows a similar structureâ€”default behavior in the Layer
                                Supertype (475) for simple integral keys, overridden for the more complex
                                cases. In this case the orderâ€™s load behavior looks like this:
                                <pre>class AbstractMapper...
                                protected DomainObjectWithKey load(ResultSet rs) throws SQLException {
                                Key key = createKey(rs);
                                if (loadedMap.containsKey(key)) return (DomainObjectWithKey) loadedMap.get(key);
                                DomainObjectWithKey result = doLoad(key, rs);
                                loadedMap.put(key, result);
                                return result;
                                }
                                abstract protected DomainObjectWithKey doLoad(Key id, ResultSet rs) throws SQLException;
                                // hook method for keys that arenâ€™t simple integral
                                protected Key createKey(ResultSet rs) throws SQLException {
                                return new Key(rs.getLong(1));
                                }
                                class OrderMapper...
                                protected DomainObjectWithKey doLoad(Key key, ResultSet rs) throws SQLException {
                                String customer = rs.getString("customer");
                                Order result = new Order(key, customer);
                                MapperRegistry.lineItem().loadAllLineItemsFor(result);
                                return result;
                                }
                                The line item needs to override the hook to create a key based on two fields.
                                class LineItemMapper...
                                protected DomainObjectWithKey doLoad(Key key, ResultSet rs) throws SQLException {
                                Order theOrder = MapperRegistry.order().find(orderID(key));
                                return doLoad(key, rs, theOrder);
                                }
                                protected DomainObjectWithKey doLoad(Key key, ResultSet rs, Order order)
                                throws SQLException
                                {
                                LineItem result;
                                int amount = rs.getInt("amount");
                                String product = rs.getString("product");
                                result = new LineItem(key, amount, product);
                                order.addLineItem(result);//links to the order
                                return result;
                                }
                                //overrides the default case
                                protected Key createKey(ResultSet rs) throws SQLException {
                                Key key = new Key(new Long(rs.getLong("orderID")), new Long(rs.getLong("seq")));
                                return key;
                                }
                                The line item also has a separate load method for use when loading all the
                                lines for the order.
                                class LineItemMapper...
                                public void loadAllLineItemsFor(Order arg) {
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                stmt = DB.prepare(findForOrderString);
                                stmt.setLong(1, arg.getKey().longValue());
                                rs = stmt.executeQuery();
                                while (rs.next())
                                load(rs, arg);
                                230 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally { DB.cleanUp(stmt, rs);
                                }
                                }
                                private final static String findForOrderString =
                                "SELECT orderID, seq, amount, product " +
                                "FROM line_items " +
                                "WHERE orderID = ?";
                                protected DomainObjectWithKey load(ResultSet rs, Order order) throws SQLException {
                                Key key = createKey(rs);
                                if (loadedMap.containsKey(key)) return (DomainObjectWithKey) loadedMap.get(key);
                                DomainObjectWithKey result = doLoad(key, rs, order);
                                loadedMap.put(key, result);
                                return result;
                                }</pre>
                                You need the special handling because the order object isnâ€™t put into the orderâ€™s
                                Identity Map (195) until after itâ€™s created. Creating an empty object and inserting it directly into the Identity Field would avoid the need for this (page 169).
                                Insertion Like reading, inserting has a default action for a simple integral key
                                and the hooks to override this for more interesting keys. In the mapper supertype Iâ€™ve provided an operation to act as the interface, together with a template
                                method to do the work of the insertion.
                                <pre>class AbstractMapper...
                                public Key insert(DomainObjectWithKey subject) {
                                try {
                                return performInsert(subject, findNextDatabaseKeyObject());
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                }
                                }
                                protected Key performInsert(DomainObjectWithKey subject, Key key) throws SQLException {
                                subject.setKey(key);
                                PreparedStatement stmt = DB.prepare(insertStatementString());
                                insertKey(subject, stmt);
                                insertData(subject, stmt);
                                stmt.execute();
                                loadedMap.put(subject.getKey(), subject);
                                return subject.getKey();
                                }
                                abstract protected String insertStatementString();
                                class OrderMapper...
                                protected String insertStatementString() {
                                return "INSERT INTO orders VALUES(?,?)";
                                }</pre>
                                The data from the object goes into the insert statement through two methods
                                that separate the data of the key from the basic data of the object. I do this
                                because I can provide a default implementation for the key that will work for
                                any class, like order, that uses the default simple integral key.
                                <pre>class AbstractMapper...
                                protected void insertKey(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(1, subject.getKey().longValue());
                                }
                                The rest of the data for the insert statement is dependent on the particular
                                subclass, so this behavior is abstract on the superclass.
                                class AbstractMapper...
                                abstract protected void insertData(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException;
                                class OrderMapper...
                                protected void insertData(DomainObjectWithKey abstractSubject, PreparedStatement stmt) {
                                try {
                                Order subject = (Order) abstractSubject;
                                stmt.setString(2, subject.getCustomer());
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                }
                                }
                                The line item overrides both of these methods. It pulls two values out for
                                key.
                                class LineItemMapper...
                                protected String insertStatementString() {
                                return "INSERT INTO line_items VALUES (?, ?, ?, ?)";
                                }
                                protected void insertKey(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(1, orderID(subject.getKey()));
                                stmt.setLong(2, sequenceNumber(subject.getKey()));
                                }
                                232 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Identity Field
                                It also provides its own implementation of the insert statement for the rest of
                                the data.
                                class LineItemMapper...
                                protected void insertData(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                LineItem item = (LineItem) subject;
                                stmt.setInt(3, item.getAmount());
                                stmt.setString(4, item.getProduct());
                                }</pre>
                                Putting the data loading into the insert statement like this is only worthwhile
                                if most classes use the same single field for the key. If thereâ€™s more variation for
                                the key handling, then having just one command to insert the information is
                                probably easier.
                                Coming up with the next database key is also something that I can separate
                                into a default and an overridden case. For the default case I can use the key
                                table scheme that I talked about earlier. But for the line item we run into a
                                problem. The line itemâ€™s key uses the key of the order as part of its composite
                                key. However, thereâ€™s no reference from the line item class to the order class, so
                                itâ€™s impossible to tell a line item to insert itself into the database without providing the correct order as well. This leads to the always messy approach of implementing the superclass method with an unsupported operation exception.
                                <pre>class LineItemMapper...
                                public Key insert(DomainObjectWithKey subject) {
                                throw new UnsupportedOperationException
                                ("Must supply an order when inserting a line item");
                                }
                                public Key insert(LineItem item, Order order) {
                                try {
                                Key key = new Key(order.getKey().value(), getNextSequenceNumber(order));
                                return performInsert(item, key);
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                }
                                }</pre>
                                Of course, we can avoid this by having a back link from the line item to the
                                order, effectively making the association between the two bidirectional. Iâ€™ve
                                chosen not to do it here to illustrate what to do when you donâ€™t have that
                                link.
                                By supplying the order, itâ€™s easy to get the orderâ€™s part of the key. The next
                                problem is to come up with a sequence number for the order line. To find that
                                number, we need to find out what the next available sequence number is for an
                                order, which we can do either with a max query in SQL or by looking at the line
                                items on the order in memory. For this example Iâ€™ll do the latter.
                                <pre>class LineItemMapper...
                                private Long getNextSequenceNumber(Order order) {
                                loadAllLineItemsFor(order);
                                Iterator it = order.getItems().iterator();
                                LineItem candidate = (LineItem) it.next();
                                while (it.hasNext()) {
                                LineItem thisItem = (LineItem) it.next();
                                if (thisItem.getKey() == null) continue;
                                if (sequenceNumber(thisItem) > sequenceNumber(candidate)) candidate = thisItem;
                                }
                                return new Long(sequenceNumber(candidate) + 1);
                                }
                                private static long sequenceNumber(LineItem li) {
                                return sequenceNumber(li.getKey());
                                }
                                //comparator doesn't work well here due to unsaved null keys
                                protected String keyTableRow() {
                                throw new UnsupportedOperationException();
                                }</pre>
                                This algorithm would be much nicer if I used the Collections.max method, but
                                since we may (and indeed will) have at least one null key, that method would
                                fail.
                                Updates and Deletes After all of that, updates and deletes are mostly harmless.
                                Again we have an abstract method for the assumed usual case and an override
                                for the special cases.
                                Updates work like this:
                                <pre>class AbstractMapper...
                                public void update(DomainObjectWithKey subject) {
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(updateStatementString());
                                loadUpdateStatement(subject, stmt);
                                stmt.execute();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {
                                DB.cleanUp(stmt);
                                }
                                }
                                abstract protected String updateStatementString();
                                abstract protected void loadUpdateStatement(DomainObjectWithKey subject,
                                PreparedStatement stmt)
                                throws SQLException;
                                class OrderMapper...
                                protected void loadUpdateStatement(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                Order order = (Order) subject;
                                stmt.setString(1, order.getCustomer());
                                stmt.setLong(2, order.getKey().longValue());
                                }
                                protected String updateStatementString() {
                                return "UPDATE orders SET customer = ? WHERE id = ?";
                                }
                                class LineItemMapper...
                                protected String updateStatementString() {
                                return
                                "UPDATE line_items " +
                                " SET amount = ?, product = ? " +
                                " WHERE orderId = ? AND seq = ?";
                                }
                                protected void loadUpdateStatement(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(3, orderID(subject.getKey()));
                                stmt.setLong(4, sequenceNumber(subject.getKey()));
                                LineItem li = (LineItem) subject;
                                stmt.setInt(1, li.getAmount());
                                stmt.setString(2, li.getProduct());
                                }
                                Deletes work like this:
                                class AbstractMapper...
                                public void delete(DomainObjectWithKey subject) {
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(deleteStatementString());
                                loadDeleteStatement(subject, stmt);
                                stmt.execute();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {
                                DB.cleanUp(stmt);
                                }
                                }
                                abstract protected String deleteStatementString();
                                protected void loadDeleteStatement(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(1, subject.getKey().longValue());
                                }
                                IDENTITY FIELD 235
                                Identity Field
                                class OrderMapper...
                                protected String deleteStatementString() {
                                return "DELETE FROM orders WHERE id = ?";
                                }
                                class LineItemMapper...
                                protected String deleteStatementString() {
                                return "DELETE FROM line_items WHERE orderid = ? AND seq = ?";
                                }
                                protected void loadDeleteStatement(DomainObjectWithKey subject, PreparedStatement stmt)
                                throws SQLException
                                {
                                stmt.setLong(1, orderID(subject.getKey()));
                                stmt.setLong(2, sequenceNumber(subject.getKey()));
                                }</pre></p>
                <h3 id="236">Foreign Key Mapping</h3>
                <p>Maps an association between objects to a foreign
                                key reference between tables.
                                Objects can refer to each other directly by object references. Even the simplest
                                object-oriented system will contain a bevy of objects connected to each other in
                                all sorts of interesting ways. To save these objects to a database, itâ€™s vital to save
                                these references. However, since the data in them is specific to the specific
                                instance of the running program, you canâ€™t just save raw data values. Further
                                complicating things is the fact that objects can easily hold collections of references to other objects. Such a structure violates the first normal form of relational databases.
                                A Foreign Key Mapping maps an object reference to a foreign key in the
                                database.</p>
                <h3 id="236(2)">How It Works</h3>
                <p>The obvious key to this problem is Identity Field (216). Each object contains
                                the database key from the appropriate database table. If two objects are
                                linked together with an association, this association can be replaced by a foreign key in the database. Put simply, when you save an album to the database,
                                you save the ID of the artist that the album is linked to in the album record,
                                as in Figure 12.1.
                                Thatâ€™s the simple case. A more complicated case turns up when you have a
                                collection of objects. You canâ€™t save a collection in the database, so you have
                                to reverse the direction of the reference. Thus, if you have a collection of tracks
                                in the album, you put the foreign key of the album in the track record, as in
                                Figures 12.2 and 12.3. The complication occurs when you have an update.
                                Updating implies that tracks can be added to and removed from the collection
                                within an album. How can you tell what alterations to put in the database?
                                Essentially you have three options: (1) delete and insert, (2) add a back pointer,
                                and (3) diff the collection.
                                With delete and insert you delete all the tracks in the database that link to
                                the album, and then insert all the ones currently on the album. At first glance
                                this sounds pretty appalling, especially if you havenâ€™t changed any tracks. But
                                the logic is easy to implement and as such it works pretty well compared to the
                                alternatives. The drawback is that you can only do this if tracks are Dependent
                                Mappings (262), which means they must be owned by the album and canâ€™t be
                                referred to outside it.</p>
                <p>Adding a back pointer puts a link from the track back to the album, effectively making the association bidirectional. This changes the object model, but
                                now you can handle the update using the simple technique for single-valued
                                fields on the other side.
                                If neither of those appeals, you can do a diff. There are two possibilities here:
                                diff with the current state of the database or diff with what you read the first
                                time. Diffing with the database involves rereading the collection back from the
                                database and then comparing the collection you read with the collection in the
                                album. Anything in the database that isnâ€™t in the album was clearly removed;
                                anything in the album that isnâ€™t on the disk is clearly a new item to be added.
                                Then look at the logic of the application to decide what to do with each item.
                                Diffing with what you read in the first place means that you have to keep
                                what you read. This is better as it avoids another database read. You may also
                                need to diff with the database if youâ€™re using Optimistic Offline Lock (416).
                                In the general case anything thatâ€™s added to the collection needs to be
                                checked first to see if itâ€™s a new object. You can do this by seeing if it has a key;
                                if it doesnâ€™t, one needs to be added to the database. This step is made a lot easFigure 12.3 Classes and tables for a multivalued reference.
                                ier with Unit of Work (184) because that way any new object will be automatically inserted first. In either case you then find the linked row in the database
                                and update its foreign key to point to the current album.</p>
                <p>For removal you have to know whether the track was moved to another
                                album, has no album, or has been deleted altogether. If itâ€™s been moved to
                                another album it should be updated when you update that other album. If it has
                                no album, you need to null the foreign key. If the track was deleted, then it
                                should be deleted when things get deleted. Handling deletes is much easier if the
                                back link is mandatory, as it is here, where every track must be on an album.
                                That way you donâ€™t have to worry about detecting items removed from the collection since they will be updated when you process the album theyâ€™ve been
                                added to.
                                If the link is immutable, meaning that you canâ€™t change a trackâ€™s album, then
                                adding always means insertion and removing always means deletion. This
                                makes things simpler still.
                                One thing to watch out for is cycles in your links. Say you need to load an
                                order, which has a link to a customer (which you load). The customer has a set
                                of payments (which you load), and each payment has orders that itâ€™s paying for,
                                which might include the original order youâ€™re trying to load. Therefore, you
                                load the order (now go back to the beginning of this paragraph.)</p>
                <p>To avoid getting lost in cycles you have two choices that boil down to how
                                you create your objects. Usually itâ€™s a good idea for a creation method to
                                include data that will give you a fully formed object. If you do that, youâ€™ll need
                                to place Lazy Load (200) at appropriate points to break the cycles. If you miss
                                one, youâ€™ll get a stack overflow, but if youâ€™re testing is good enough you can
                                manage that burden.
                                The other choice is to create empty objects and immediately put them in an
                                Identity Map (195). That way, when you cycle back around, the object is
                                already loaded and youâ€™ll end the cycle. The objects you create arenâ€™t fully
                                formed, but they should be by the end of the load procedure. This avoids having to make special case decisions about the use of Lazy Load (200) just to do a
                                correct load.</p>
                <h3 id="239">When to Use It</h3>
                <p>A Foreign Key Mapping can be used for almost all associations between classes.
                                The most common case where it isnâ€™t possible is with many-to-many associations. Foreign keys are single values, and first normal form means that you canâ€™t
                                store multiple foreign keys in a single field. Instead you need to use Association
                                Table Mapping (248).
                                If you have a collection field with no back pointer, you should consider
                                whether the many side should be a Dependent Mapping (262). If so, it can simplify your handling of the collection.
                                If the related object is a Value Object (486) then you should use Embedded
                                Value (268).</p>
                <h3 id="240">Example: Single-Valued Reference (Java)</h3>
                                This is the simplest case, where an album has a single reference to an artist.
                                <pre>class Artist...
                                private String name;
                                public Artist(Long ID, String name) {
                                super(ID);
                                this.name = name;
                                }
                                public String getName() {
                                return name;
                                }
                                public void setName(String name) {
                                this.name = name;
                                }
                                class Album...
                                private String title;
                                private Artist artist;
                                public Album(Long ID, String title, Artist artist) {
                                super(ID);
                                this.title = title;
                                this.artist = artist;
                                }
                                public String getTitle() {
                                return title;
                                }
                                public void setTitle(String title) {
                                this.title = title;
                                }
                                public Artist getArtist() {
                                return artist;
                                }
                                public void setArtist(Artist artist) {
                                this.artist = artist;
                                }</pre>
                                Figure 12.4 shows how you can load an album. When an album mapper is
                                told to load a particular album it queries the database and pulls back the result
                                set for it. It then queries the result set for each foreign key field and finds that
                                object. Now it can create the album with the appropriate found objects. If the
                                artist object was already in memory it would be fetched from the cache; otherwise, it would be loaded from the database in the same way.
                                The find operation uses abstract behavior to manipulate an Identity Map
                                (195).
                                <pre>class AlbumMapper...
                                public Album find(Long id) {
                                return (Album) abstractFind(id);
                                }
                                protected String findStatement() {
                                return "SELECT ID, title, artistID FROM albums WHERE ID = ?";
                                }
                                class AbstractMapper...
                                abstract protected String findStatement();
                                protected DomainObject abstractFind(Long id) {
                                DomainObject result = (DomainObject) loadedMap.get(id);
                                if (result != null) return result;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                Figure 12.4 Sequence for loading a single-valued field.
                                an Album Mapper
                                find (1)
                                database
                                select * from albums where ID = 1
                                a result set album result set
                                get artist id
                                an Album
                                new (anArtist)
                                an artist mapper
                                find('3')
                                '3'
                                an artist
                                242 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Foreign Key
                                Mapping
                                stmt = DB.prepare(findStatement());
                                stmt.setLong(1, id.longValue());
                                rs = stmt.executeQuery();
                                rs.next();
                                result = load(rs);
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {cleanUp(stmt, rs);}
                                }
                                private Map loadedMap = new HashMap();
                                The find operation calls a load operation to actually load the data into the
                                album.
                                class AbstractMapper...
                                protected DomainObject load(ResultSet rs) throws SQLException {
                                Long id = new Long(rs.getLong(1));
                                if (loadedMap.containsKey(id)) return (DomainObject) loadedMap.get(id);
                                DomainObject result = doLoad(id, rs);
                                doRegister(id, result);
                                return result;
                                }
                                protected void doRegister(Long id, DomainObject result) {
                                Assert.isFalse(loadedMap.containsKey(id));
                                loadedMap.put(id, result);
                                }
                                abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                                class AlbumMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String title = rs.getString(2);
                                long artistID = rs.getLong(3);
                                Artist artist = MapperRegistry.artist().find(artistID);
                                Album result = new Album(id, title, artist);
                                return result;
                                }
                                To update an album the foreign key value is taken from the linked artist
                                object.
                                class AbstractMapper...
                                abstract public void update(DomainObject arg);
                                class AlbumMapper...
                                public void update(DomainObject arg) {
                                PreparedStatement statement = null;
                                try {
                                FOREIGN KEY MAPPING 243
                                Foreign Key
                                Mapping
                                statement = DB.prepare(
                                "UPDATE albums SET title = ?, artistID = ? WHERE id = ?");
                                statement.setLong(3, arg.getID().longValue());
                                Album album = (Album) arg;
                                statement.setString(1, album.getTitle());
                                statement.setLong(2, album.getArtist().getID().longValue());
                                statement.execute();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {
                                cleanUp(statement);
                                }
                                }</pre></p>
                <h3 id="243">Example: Multitable Find (Java)</h3>
                <p>While itâ€™s conceptually clean to issue one query per table, itâ€™s often inefficient
                                since SQL consists of remote calls and remote calls are slow. Therefore, itâ€™s
                                often worth finding ways to gather information from multiple tables in a single
                                query. I can modify the above example to use a single query to get both the
                                album and the artist information with a single SQL call. The first alteration is
                                that of the SQL for the find statement.
                                <pre>class AlbumMapper...
                                public Album find(Long id) {
                                return (Album) abstractFind(id);
                                }
                                protected String findStatement() {
                                return "SELECT a.ID, a.title, a.artistID, r.name " +
                                " from albums a, artists r " +
                                " WHERE ID = ? and a.artistID = r.ID";
                                }
                                I then use a different load method that loads both the album and the artist
                                information together.
                                class AlbumMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String title = rs.getString(2);
                                long artistID = rs.getLong(3);
                                ArtistMapper artistMapper = MapperRegistry.artist();
                                Artist artist;
                                if (artistMapper.isLoaded(artistID))
                                artist = artistMapper.find(artistID);
                                else
                                artist = loadArtist(artistID, rs);
                                244 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Foreign Key
                                Mapping
                                Album result = new Album(id, title, artist);
                                return result;
                                }
                                private Artist loadArtist(long id, ResultSet rs) throws SQLException {
                                String name = rs.getString(4);
                                Artist result = new Artist(new Long(id), name);
                                MapperRegistry.artist().register(result.getID(), result);
                                return result;
                                }</pre>
                                Thereâ€™s tension surrounding where to put the method that maps the SQL
                                result into the artist object. On the one hand itâ€™s better to put it in the artistâ€™s
                                mapper since thatâ€™s the class that usually loads the artist. On the other hand, the
                                load method is closely coupled to the SQL and thus should stay with the SQL
                                query. In this case Iâ€™ve voted for the latter.</p>
                <h3 id="244">Example: Collection of References (C#)</h3>
                <p>The case for a collection of references occurs when you have a field that constitutes a collection. Here Iâ€™ll use an example of teams and players where weâ€™ll
                                assume that we canâ€™t make player a Dependent Mapping (262) (Figure 12.5).
                                <pre>class Team...
                                public String Name;
                                public IList Players {
                                get {return ArrayList.ReadOnly(playersData);}
                                set {playersData = new ArrayList(value);}
                                }
                                public void AddPlayer(Player arg) {
                                playersData.Add(arg);
                                }
                                private IList playersData = new ArrayList();
                                In the database this will be handled with the player record having a foreign key
                                to the team (Figure 12.6).
                                class TeamMapper...
                                public Team Find(long id) {
                                return (Team) AbstractFind(id);
                                }
                                Team Player
                                1 *
                                Figure 12.5 A team with multiple players.
                                class AbstractMapper...
                                protected DomainObject AbstractFind(long id) {
                                Assert.True (id != DomainObject.PLACEHOLDER_ID);
                                DataRow row = FindRow(id);
                                return (row == null) ? null : Load(row);
                                }
                                protected DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                }
                                protected DataTable table {
                                get {return dsh.Data.Tables[TableName];}
                                }
                                public DataSetHolder dsh;
                                abstract protected String TableName {get;}
                                class TeamMapper...
                                protected override String TableName {
                                get {return "Teams";}
                                }</pre>
                                The data set holder is a class that holds onto the data set in use, together
                                with the adapters needed to update it to the database.
                                class DataSetHolder...
                                public DataSet Data = new DataSet();
                                private Hashtable DataAdapters = new Hashtable();
                                For this example, weâ€™ll assume that it has already been populated by some
                                appropriate queries.
                                The find method calls a load to actually load the data into the new object.
                                <pre>class AbstractMapper...
                                protected DomainObject Load (DataRow row) {
                                long id = (int) row ["id"];
                                if (identityMap[id] != null) return (DomainObject) identityMap[id];
                                Figure 12.6 Database structure for a team with multiple players.
                                ID : long
                                Â«tableÂ»
                                Team
                                ID : long
                                teamID : long
                                Â«tableÂ»
                                Player
                                246 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Foreign Key
                                Mapping
                                else {
                                DomainObject result = CreateDomainObject();
                                result.Id = id;
                                identityMap.Add(result.Id, result);
                                doLoad(result,row);
                                return result;
                                }
                                }
                                abstract protected DomainObject CreateDomainObject();
                                private IDictionary identityMap = new Hashtable();
                                abstract protected void doLoad (DomainObject obj, DataRow row);
                                class TeamMapper...
                                protected override void doLoad (DomainObject obj, DataRow row) {
                                Team team = (Team) obj;
                                team.Name = (String) row["name"];
                                team.Players = MapperRegistry.Player.FindForTeam(team.Id);
                                }
                                To bring in the players, I execute a specialized finder on the player mapper.
                                class PlayerMapper...
                                public IList FindForTeam(long id) {
                                String filter = String.Format("teamID = {0}", id);
                                DataRow[] rows = table.Select(filter);
                                IList result = new ArrayList();
                                foreach (DataRow row in rows) {
                                result.Add(Load (row));
                                }
                                return result;
                                }
                                To update, the team saves its own data and delegates the player mapper to
                                save the data into the player table.
                                class AbstractMapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg, FindRow(arg.Id));
                                }
                                abstract protected void Save (DomainObject arg, DataRow row);
                                class TeamMapper...
                                protected override void Save (DomainObject obj, DataRow row){
                                Team team = (Team) obj;
                                row["name"] = team.Name;
                                savePlayers(team);
                                }
                                private void savePlayers(Team team){
                                foreach (Player p in team.Players) {
                                MapperRegistry.Player.LinkTeam(p, team.Id);
                                }
                                }
                                class PlayerMapper...
                                public void LinkTeam (Player player, long teamID) {
                                DataRow row = FindRow(player.Id);
                                row["teamID"] = teamID;
                                }</pre>
                                The update code is made much simpler by the fact that the association from
                                player to team is mandatory. If we move a player from one team to another, as
                                long as we update both team, we donâ€™t have to do a complicated diff to sort the
                                players out. Iâ€™ll leave that case as an exercise for the reader.</p>
                <h3 id="248">Association Table Mapping</h3>
                <p>Saves an association as a table with foreign keys to the tables
                                that are linked by the association.
                                Objects can handle multivalued fields quite easily by using collections as field
                                values. Relational databases donâ€™t have this feature and are constrained to single-valued fields only. When youâ€™re mapping a one-to-many association you can
                                handle this using Foreign Key Mapping (236), essentially using a foreign key for
                                the single-valued end of the association. But a many-to-many association canâ€™t
                                do this because there is no single-valued end to hold the foreign key.
                                The answer is the classic resolution thatâ€™s been used by relational data people
                                for decades: create an extra table to record the relationship. Then use Association Table Mapping to map the multivalued field to this link table.</p>
                <h3 id="248(2)">How It Works</h3>
                <p>The basic idea behind Association Table Mapping is using a link table to store
                                the association. This table has only the foreign key IDs for the two tables that
                                are linked together, it has one row for each pair of associated objects.
                                The link table has no corresponding in-memory object. As a result it has no
                                ID. Its primary key is the compound of the two primary keys of the tables that
                                are associated.
                                In simple terms, to load data from the link table you perform two queries.
                                Consider loading the skills for an employee. In this case, at least conceptually,
                                you do queries in two stages. The first stage queries the skillsEmployees table to
                                find all the rows that link to the employee you want. The second stage finds the
                                skill object for the related ID for each row in the link table.</p>
                <p>If all the information is already in memory, this scheme works fine. If it isnâ€™t,
                                this scheme can be horribly expensive in queries, since you do a query for each
                                skill thatâ€™s in the link table. You can avoid this cost by joining the skills table to
                                the link table, which allows you to get all the data in a single query, albeit at the
                                cost of making the mapping a bit more complicated.
                                Updating the link data involves many of the issues in updating a many-valued
                                field. Fortunately, the matter is made much easier since you can in many ways
                                treat the link table like a Dependent Mapping (262). No other table should
                                refer to the link table, so you can freely create and destroy links as you need
                                them.</p>
                <h3 id="249">When to Use It</h3>
                <p>The canonical case for Association Table Mapping is a many-to-many association, since there are really no any alternatives for that situation.
                                Association Table Mapping can also be used for any other form of association. However, because itâ€™s more complex than Foreign Key Mapping (236) and
                                involves an extra join, itâ€™s not usually the right choice. Even so, in a couple of
                                cases Association Table Mapping is appropriate for a simpler association; both
                                involve databases where you have less control over the schema. Sometimes you
                                may need to link two existing tables, but you arenâ€™t able to add columns to
                                those tables. In this case you can make a new table and use Association Table
                                Mapping. Other times an existing schema uses an associative table, even when
                                it isnâ€™t really necessary. In this case itâ€™s often easier to use Association Table
                                Mapping than to simplify the database schema.
                                In a relational database design you may often have association tables that
                                also carry information about the relationship. An example is a person/company
                                associative table that also contains information about a personâ€™s employment
                                with the company. In this case the person/company table really corresponds to a
                                true domain object.</p>
                <h3 id="250">Example: Employees and Skills (C#)</h3>
                <p>Hereâ€™s a simple example using the sketchâ€™s model. We have an employee class
                                with a collection of skills, each of which can appear for more than one
                                employee.
                                <pre>class Employee...
                                public IList Skills {
                                get {return ArrayList.ReadOnly(skillsData);}
                                set {skillsData = new ArrayList(value);}
                                }
                                public void AddSkill (Skill arg) {
                                skillsData.Add(arg);
                                }
                                public void RemoveSkill (Skill arg) {
                                skillsData.Remove(arg);
                                }
                                private IList skillsData = new ArrayList();</pre>
                                To load an employee from the database, we need to pull in the skills using an
                                employee mapper. Each employee mapper class has a find method that creates
                                an employee object. All mappers are subclasses of the abstract mapper class
                                that pulls together common services for the mappers.
                                <pre>class EmployeeMapper...
                                public Employee Find(long id) {
                                return (Employee) AbstractFind(id);
                                }
                                class AbstractMapper...
                                protected DomainObject AbstractFind(long id) {
                                Assert.True (id != DomainObject.PLACEHOLDER_ID);
                                DataRow row = FindRow(id);
                                return (row == null) ? null : Load(row);
                                }
                                protected DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                }
                                protected DataTable table {
                                get {return dsh.Data.Tables[TableName];}
                                }
                                public DataSetHolder dsh;
                                abstract protected String TableName {get;}
                                class EmployeeMapper...
                                protected override String TableName {
                                get {return "Employees";}
                                }</pre>
                                The data set holder is a simple object that contains an ADO.NET data set
                                and the relevant adapters to save it to the database.
                                <pre>class DataSetHolder...
                                public DataSet Data = new DataSet();
                                private Hashtable DataAdapters = new Hashtable();
                                To make this example simpleâ€”indeed, simplisticâ€”weâ€™ll assume that the data
                                set has already been loaded with all the data we need.
                                The find method calls load methods to load data for the employee.
                                class AbstractMapper...
                                protected DomainObject Load (DataRow row) {
                                long id = (int) row ["id"];
                                if (identityMap[id] != null) return (DomainObject) identityMap[id];
                                else {
                                DomainObject result = CreateDomainObject();
                                result.Id = id;
                                identityMap.Add(result.Id, result);
                                doLoad(result,row);
                                return result;
                                }
                                }
                                abstract protected DomainObject CreateDomainObject();
                                private IDictionary identityMap = new Hashtable();
                                abstract protected void doLoad (DomainObject obj, DataRow row);
                                class EmployeeMapper...
                                protected override void doLoad (DomainObject obj, DataRow row) {
                                Employee emp = (Employee) obj;
                                emp.Name = (String) row["name"];
                                loadSkills(emp);
                                }
                                Loading the skills is sufficiently awkward to demand a separate method to do
                                the work.
                                class EmployeeMapper...
                                private IList loadSkills (Employee emp) {
                                DataRow[] rows = skillLinkRows(emp);
                                IList result = new ArrayList();
                                foreach (DataRow row in rows) {
                                long skillID = (int)row["skillID"];
                                emp.AddSkill(MapperRegistry.Skill.Find(skillID));
                                }
                                return result;
                                }
                                private DataRow[] skillLinkRows(Employee emp) {
                                String filter = String.Format("employeeID = {0}", emp.Id);
                                return skillLinkTable.Select(filter);
                                }
                                private DataTable skillLinkTable {
                                get {return dsh.Data.Tables["skillEmployees"];}
                                }
                                To handle changes in skills information we use an update method on the
                                abstract mapper.
                                class AbstractMapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg, FindRow(arg.Id));
                                }
                                abstract protected void Save (DomainObject arg, DataRow row);
                                The update method calls a save method in the subclass.
                                class EmployeeMapper...
                                protected override void Save (DomainObject obj, DataRow row) {
                                Employee emp = (Employee) obj;
                                row["name"] = emp.Name;
                                saveSkills(emp);
                                }
                                Again, Iâ€™ve made a separate method for saving the skills.
                                class EmployeeMapper...
                                private void saveSkills(Employee emp) {
                                deleteSkills(emp);
                                foreach (Skill s in emp.Skills) {
                                DataRow row = skillLinkTable.NewRow();
                                row["employeeID"] = emp.Id;
                                row["skillID"] = s.Id;
                                skillLinkTable.Rows.Add(row);
                                }
                                }
                                private void deleteSkills(Employee emp) {
                                DataRow[] skillRows = skillLinkRows(emp);
                                foreach (DataRow r in skillRows) r.Delete();
                                }</pre>
                                The logic here does the simple thing of deleting all existing link table rows
                                and creating new ones. This saves me having to figure out which ones have been
                                added and deleted.</p>
                <h3 id="253">Example: Using Direct SQL (Java)</h3>
                <p>One of the nice things about ADO.NET is that it allows me to discuss the basics
                                of an object-relational mapping without getting into the sticky details of minimizing queries. With other relational mapping schemes youâ€™re closer to the SQL
                                and have to take much of that into account.
                                When youâ€™re going directly to the database itâ€™s important to minimize the
                                queries. For my first version of this Iâ€™ll pull back the employee and all her skills
                                in two queries. This is easy to follow but not quite optimal, so bear with me.</p>
                <p>Hereâ€™s the DDL for the tables:
                                create table employees (ID int primary key, firstname varchar, lastname varchar)
                                create table skills (ID int primary key, name varchar)
                                create table employeeSkills (employeeID int, skillID int, primary key (employeeID, skillID))
                                To load a single Employee Iâ€™ll follow a similar approach to what Iâ€™ve done
                                before. The employee mapper defines a simple wrapper for an abstract find
                                method on the Layer Supertype (475).
                                <pre>class EmployeeMapper...
                                public Employee find(long key) {
                                return find (new Long (key));
                                }
                                public Employee find (Long key) {
                                return (Employee) abstractFind(key);
                                }
                                protected String findStatement() {
                                return
                                "SELECT " + COLUMN_LIST +
                                " FROM employees" +
                                " WHERE ID = ?";
                                }
                                public static final String COLUMN_LIST = " ID, lastname, firstname ";
                                class AbstractMapper...
                                protected DomainObject abstractFind(Long id) {
                                DomainObject result = (DomainObject) loadedMap.get(id);
                                if (result != null) return result;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                254 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Association
                                Table
                                Mapping
                                try {
                                stmt = DB.prepare(findStatement());
                                stmt.setLong(1, id.longValue());
                                rs = stmt.executeQuery();
                                rs.next();
                                result = load(rs);
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }
                                abstract protected String findStatement();
                                protected Map loadedMap = new HashMap();</pre>
                                The find methods then call load methods. An abstract load method handles the
                                ID loading while the actual data for the employee is loaded on the employeeâ€™s
                                mapper.
                                <pre>class AbstractMapper...
                                protected DomainObject load(ResultSet rs) throws SQLException {
                                Long id = new Long(rs.getLong(1));
                                return load(id, rs);
                                }
                                public DomainObject load(Long id, ResultSet rs) throws SQLException {
                                if (hasLoaded(id)) return (DomainObject) loadedMap.get(id);
                                DomainObject result = doLoad(id, rs);
                                loadedMap.put(id, result);
                                return result;
                                }
                                abstract protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException;
                                class EmployeeMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                Employee result = new Employee(id);
                                result.setFirstName(rs.getString("firstname"));
                                result.setLastName(rs.getString("lastname"));
                                result.setSkills(loadSkills(id));
                                return result;
                                }
                                The employee needs to issue another query to load the skills, but it can easily
                                load all the skills in a single query. To do this it calls the skill mapper to load in
                                the data for a particular skill.
                                class EmployeeMapper...
                                protected List loadSkills(Long employeeID) {
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                List result = new ArrayList();
                                stmt = DB.prepare(findSkillsStatement);
                                stmt.setObject(1, employeeID);
                                rs = stmt.executeQuery();
                                while (rs.next()) {
                                Long skillId = new Long (rs.getLong(1));
                                result.add((Skill) MapperRegistry.skill().loadRow(skillId, rs));
                                }
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }
                                private static final String findSkillsStatement =
                                "SELECT skill.ID, " + SkillMapper.COLUMN_LIST +
                                " FROM skills skill, employeeSkills es " +
                                " WHERE es.employeeID = ? AND skill.ID = es.skillID";
                                class SkillMapper...
                                public static final String COLUMN_LIST = " skill.name skillName ";
                                class AbstractMapper...
                                protected DomainObject loadRow (Long id, ResultSet rs) throws SQLException {
                                return load (id, rs);
                                }
                                class SkillMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                Skill result = new Skill (id);
                                result.setName(rs.getString("skillName"));
                                return result;
                                }
                                The abstract mapper can also help find employees.
                                class EmployeeMapper...
                                public List findAll() {
                                return findAll(findAllStatement);
                                }
                                private static final String findAllStatement =
                                "SELECT " + COLUMN_LIST +
                                " FROM employees employee" +
                                " ORDER BY employee.lastname";
                                class AbstractMapper...
                                protected List findAll(String sql) {
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                256 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Association
                                Table
                                Mapping
                                try {
                                List result = new ArrayList();
                                stmt = DB.prepare(sql);
                                rs = stmt.executeQuery();
                                while (rs.next())
                                result.add(load(rs));
                                return result;
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }</pre>
                                All of this works quite well and is pretty simple to follow. Still, thereâ€™s a
                                problem in the number of queries, and that is that each employee takes two
                                SQL queries to load. Although we can load the basic employee data for many
                                employees in a single query, we still need one query per employee to load the
                                skills. Thus, loading a hundred employees takes 101 queries.</p>
                <h3 id="256">Example: Using a Single Query for Multiple Employees (Java)</h3>
                <p>Itâ€™s possible to bring back many employees, with their skills, in a single query.
                                This is a good example of multitable query optimization, which is certainly
                                more awkward. For that reason do this when you need to, rather than every
                                time. Itâ€™s better to put more energy into speeding up your slow queries than into
                                many queries that are less important.
                                The first case weâ€™ll look at is a simple one where we pull back all the skills
                                for an employee in the same query that holds the basic data. To do this Iâ€™ll use a
                                more complex SQL statement that joins across all three tables.
                                <pre>class EmployeeMapper...
                                protected String findStatement() {
                                return
                                "SELECT " + COLUMN_LIST +
                                " FROM employees employee, skills skill, employeeSkills es" +
                                " WHERE employee.ID = es.employeeID AND skill.ID = es.skillID AND employee.ID = ?";
                                }
                                public static final String COLUMN_LIST =
                                " employee.ID, employee.lastname, employee.firstname, " +
                                " es.skillID, es.employeeID, skill.ID skillID, " +
                                SkillMapper.COLUMN_LIST;</pre>
                                The abstractFind and load methods on the superclass are the same as in the
                                previous example, so I wonâ€™t repeat them here. The employee mapper loads its
                                data differently to take advantage of the multiple data rows.
                                <pre>class EmployeeMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                Employee result = (Employee) loadRow(id, rs);
                                loadSkillData(result, rs);
                                while (rs.next()){
                                Assert.isTrue(rowIsForSameEmployee(id, rs));
                                loadSkillData(result, rs);
                                }
                                return result;
                                }
                                protected DomainObject loadRow(Long id, ResultSet rs) throws SQLException {
                                Employee result = new Employee(id);
                                result.setFirstName(rs.getString("firstname"));
                                result.setLastName(rs.getString("lastname"));
                                return result;
                                }
                                private boolean rowIsForSameEmployee(Long id, ResultSet rs) throws SQLException {
                                return id.equals(new Long(rs.getLong(1)));
                                }
                                private void loadSkillData(Employee person, ResultSet rs) throws SQLException {
                                Long skillID = new Long(rs.getLong("skillID"));
                                person.addSkill ((Skill)MapperRegistry.skill().loadRow(skillID, rs));
                                }</pre>
                                In this case the load method for the employee mapper actually runs through the
                                rest of the result set to load in all the data.
                                All is simple when weâ€™re loading the data for a single employee. However,
                                the real benefit of this multitable query appears when we want to load lots of
                                employees. Getting the reading right can be tricky, particularly when we donâ€™t
                                want to force the result set to be grouped by employees. At this point itâ€™s handy
                                to introduce a helper class to go through the result set by focusing on the associative table itself, loading up the employees and skills as it goes along.
                                Iâ€™ll begin with the SQL and the call to the special loader class.
                                <pre>class EmployeeMapper...
                                public List findAll() {
                                return findAll(findAllStatement);
                                }
                                private static final String findAllStatement =
                                "SELECT " + COLUMN_LIST +
                                " FROM employees employee, skills skill, employeeSkills es" +
                                " WHERE employee.ID = es.employeeID AND skill.ID = es.skillID" +
                                " ORDER BY employee.lastname";
                                protected List findAll(String sql) {
                                AssociationTableLoader loader = new AssociationTableLoader(this, new SkillAdder());
                                return loader.run(findAllStatement);
                                }
                                class AssociationTableLoader...
                                private AbstractMapper sourceMapper;
                                private Adder targetAdder;
                                public AssociationTableLoader(AbstractMapper primaryMapper, Adder targetAdder) {
                                this.sourceMapper = primaryMapper;
                                this.targetAdder = targetAdder;
                                }</pre>
                                Donâ€™t worry about the skillAdderâ€”that will become a bit clearer later. For the
                                moment notice that we construct the loader with a reference to the mapper and
                                then tell it to perform a load with a suitable query. This is the typical structure
                                of a method object. A method object [Beck Patterns] is a way of turning a complicated method into an object on its own. The great advantage of this is that it
                                allows you to put values in fields instead of passing them around in parameters.
                                The usual way of using a method object is to create it, fire it up, and then let it
                                die once its duty is done.
                                The load behavior comes in three steps.
                                <pre>class AssociationTableLoader...
                                protected List run(String sql) {
                                loadData(sql);
                                addAllNewObjectsToIdentityMap();
                                return formResult();
                                }</pre>
                                The loadData method forms the SQL call, executes it, and loops through the
                                result set. Since this is a method object, Iâ€™ve put the result set in a field so I donâ€™t
                                have to pass it around.
                                <pre>class AssociationTableLoader...
                                private ResultSet rs = null;
                                private void loadData(String sql) {
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(sql);
                                rs = stmt.executeQuery();
                                while (rs.next())
                                loadRow();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }</pre>
                                The loadRow method loads the data from a single row in the result set. Itâ€™s a bit
                                complicated.
                                <pre>class AssociationTableLoader...
                                private List resultIds = new ArrayList();
                                private Map inProgress = new HashMap();
                                private void loadRow() throws SQLException {
                                Long ID = new Long(rs.getLong(1));
                                if (!resultIds.contains(ID)) resultIds.add(ID);
                                if (!sourceMapper.hasLoaded(ID)) {
                                if (!inProgress.keySet().contains(ID))
                                inProgress.put(ID, sourceMapper.loadRow(ID, rs));
                                targetAdder.add((DomainObject) inProgress.get(ID), rs);
                                }
                                }
                                class AbstractMapper...
                                boolean hasLoaded(Long id) {
                                return loadedMap.containsKey(id);
                                }</pre>
                                The loader preserves any order there is in the result set, so the output list of
                                employees will be in the same order in which it first appeared. So I keep a list of
                                IDs in the order I see them. Once Iâ€™ve got the ID I look to see if itâ€™s already fully
                                loaded in the mapperâ€”usually from a previous query. If not, I load what data I
                                have and keep it in an in-progress list. I need such a list since several rows will
                                combine to gather all the data from the employee and I may not hit those rows
                                consecutively.
                                The trickiest part to this code is ensuring that I can add the skill Iâ€™m loading
                                to the employeesâ€™ list of skills, but still keep the loader generic so it doesnâ€™t
                                depend on employees and skills. To achieve this I need to dig deep into my bag
                                of tricks to find an inner interfaceâ€”the Adder.
                                <pre>class AssociationTableLoader...
                                public static interface Adder {
                                void add(DomainObject host, ResultSet rs) throws SQLException ;
                                }
                                The original caller has to supply an implementation for the interface to bind
                                it to the particular needs of the employee and skill.
                                class EmployeeMapper...
                                private static class SkillAdder implements AssociationTableLoader.Adder {
                                public void add(DomainObject host, ResultSet rs) throws SQLException {
                                Employee emp = (Employee) host;
                                Long skillId = new Long (rs.getLong("skillId"));
                                emp.addSkill((Skill) MapperRegistry.skill().loadRow(skillId, rs));
                                }
                                }</pre>
                                This is the kind of thing that comes more naturally to languages that have
                                function pointers or closures, but at least the class and interface get the job
                                done. (They donâ€™t have to be inner in this case, but it helps bring out their narrow scope.)
                                You may have noticed that I have a load and a loadRow method defined on the
                                superclass and the implementation of the loadRow is to call load. I did this
                                because there are times when you want to be sure that a load action will not
                                move the result set forward. The load does whatever it needs to do to load an
                                object, but loadRow guarantees to load data from a row without altering the position of the cursor. Most of the time these two are the same thing, but in the case
                                of this employee mapper theyâ€™re different.
                                Now all the data is in from the result set. I have two collections: a list of all
                                the employee IDs that were in the result set in the order of first appearance and
                                a list of new objects that havenâ€™t yet made an appearance in the employee mapperâ€™s Identity Map (195).
                                The next step is to put all the new objects into the Identity Map (195).
                                <pre>class AssociationTableLoader...
                                private void addAllNewObjectsToIdentityMap() {
                                for (Iterator it = inProgress.values().iterator(); it.hasNext();)
                                sourceMapper.putAsLoaded((DomainObject)it.next());
                                }
                                class AbstractMapper...
                                void putAsLoaded (DomainObject obj) {
                                loadedMap.put (obj.getID(), obj);
                                }
                                The final step is to assemble the result list by looking up the IDs from the
                                mapper.
                                class AssociationTableLoader...
                                private List formResult() {
                                List result = new ArrayList();
                                for (Iterator it = resultIds.iterator(); it.hasNext();) {
                                Long id = (Long)it.next();
                                result.add(sourceMapper.lookUp(id));
                                }
                                return result;
                                }
                                class AbstractMapper...
                                protected DomainObject lookUp (Long id) {
                                return (DomainObject) loadedMap.get(id);
                                }</pre>
                                Such code is more complex than the average loading code, but this kind of
                                thing can help cut down the number of queries. Since itâ€™s complicated, this is
                                something to be used sparingly when you have laggardly bits of database interaction. However, itâ€™s an example of how Data Mapper (165) can provide good
                                queries without the domain layer being aware of the complexity involved.</p>
                <h3 id="262">Dependent Mapping</h3>
                <p>Has one class perform the database mapping for a child class.
                                Some objects naturally appear in the context of other objects. Tracks on an
                                album may be loaded or saved whenever the underlying album is loaded or
                                saved. If they arenâ€™t referenced to by any other table in the database, you can
                                simplify the mapping procedure by having the album mapper perform the mapping for the tracks as wellâ€”treating this mapping as a dependent mapping.</p>
                <h3 id="262(2)">How It Works</h3>
                <p>The basic idea behind Dependent Mapping is that one class (the dependent)
                                relies upon some other class (the owner) for its database persistence. Each
                                dependent can have only one owner and must have one owner.
                                This manifests itself in terms of the classes that do the mapping. For Active
                                Record (160) and Row Data Gateway (152), the dependent class wonâ€™t contain
                                any database mapping code; its mapping code sits in the owner. With Data
                                Mapper (165) thereâ€™s no mapper for the dependent, the mapping code sits in the
                                mapper for the owner. In a Table Data Gateway (144) there will typically be no
                                dependent class at all, all the handling of the dependent is done in the owner.
                                In most cases every time you load an owner, you load the dependents too. If
                                the dependents are expensive to load and infrequently used, you can use a Lazy
                                Load (200) to avoid loading the dependents until you need them.
                                An important property of a dependent is that it doesnâ€™t have an Identity
                                Field (216) and therefore isnâ€™t stored in a Identity Map (195). It therefore canAlbum
                                not be loaded by a find method that looks up an ID. Indeed, thereâ€™s no finder
                                for a dependent since all finds are done with the owner.</p>
                <p>A dependent may itself be the owner of another dependent. In this case the
                                owner of the first dependent is also responsible for the persistence of the second
                                dependent. You can have a whole hierarchy of dependents controlled by a single primary owner.
                                Itâ€™s usually easier for the primary key on the database to be a composite key
                                that includes the ownerâ€™s primary key. No other table should have a foreign key
                                into the dependentâ€™s table, unless that object has the same owner. As a result, no
                                in-memory object other than the owner or its dependents should have a reference to a dependent. Strictly speaking, you can relax that rule providing that
                                the reference isnâ€™t persisted to the database, but having a nonpersistent reference is itself a good source of confusion.
                                In a UML model, itâ€™s appropriate to use composition to show the relationship between an owner and its dependents.
                                Since the writing and saving of dependents is left to the owner, and there are
                                no outside references, updates to the dependents can be handled through deletion and insertion. Thus, if you want to update the collection of dependents you
                                can safely delete all rows that link to the owner and then reinsert all the dependents. This saves you from having to do an analysis of objects added or
                                removed from the ownerâ€™s collection.</p>
                <p>Dependents are in many ways like Value Objects (486), although they often
                                donâ€™t need the full mechanics that you use in making something a Value Object
                                (486) (such as overriding equals). The main difference is that thereâ€™s nothing
                                special about them from a purely in-memory point of view. The dependent
                                nature of the objects is only really due to the database mapping behavior.
                                Using Dependent Mapping complicates tracking whether the owner has
                                changed. Any change to a dependent needs to mark the owner as changed so
                                that the owner will write the changes out to the database. You can simplify this
                                considerably by making the dependent immutable, so that any change to it
                                needs to be done by removing it and adding a new one. This can make the inmemory model harder to work with, but it does simplify the database mapping.
                                While in theory the in-memory and database mapping should be independent
                                when youâ€™re using Data Mapper (165), in practice you have to make the occasional compromise.</p>
                <h3 id="263">When to Use It</h3>
                <p>You use Dependent Mapping when you have an object thatâ€™s only referred to by
                                one other object, which usually occurs when one object has a collection of
                                dependents. Dependent Mapping is a good way of dealing with the awkward
                                situation where the owner has a collection of references to its dependents but
                                thereâ€™s no back pointer. Providing that the many objects donâ€™t need their own
                                identity, using Dependent Mapping makes it easier to manage their persistence.
                                For Dependent Mapping to work there are a number of preconditions.
                                â€¢ A dependent must have exactly one owner.
                                â€¢ There must be no references from any object other than the owner to the
                                dependent.
                                There is a school of OO design that uses the notion of entity objects and
                                dependent objects when designing a Domain Model (116). I tend to think of
                                Dependent Mapping as a technique to simplify database mapping rather than
                                as a fundamental OO design medium. In particular, I avoid large graphs of
                                dependents. The problem with them is that itâ€™s impossible to refer to a dependent from outside the graph, which often leads to complex lookup schemes
                                based around the root owner.
                                I donâ€™t recommend Dependent Mapping if youâ€™re using Unit of Work (184).
                                The delete and reinsert strategy doesnâ€™t help at all if you have a Unit of Work
                                (184) keeping track of things. It can also lead to problems since the Unit of
                                Work (184) isnâ€™t controlling the dependents. Mike Rettig told me about an
                                application where a Unit of Work (184) would keep track of rows inserted for
                                testing and then delete them all when done. Because it didnâ€™t track dependents,
                                orphan rows appeared and caused failures in the test runs.</p>
                <h3 id="264">Example: Albums and Tracks (Java)</h3>
                <p>In this domain model (Figure 12.7) an album holds a collection of tracks. This
                                uselessly simple application doesnâ€™t need anything else to refer to a track, so itâ€™s
                                an obvious candidate for Dependent Mapping. (Indeed, anyone would think
                                the example is deliberately constructed for the pattern.)
                                This track just has a title. Iâ€™ve defined it as an immutable class.
                                <pre>class Track...
                                private final String title;
                                public Track(String title) {
                                this.title = title;
                                }
                                public String getTitle() {
                                return title;
                                }
                                The tracks are held in the album class.
                                class Album...
                                private List tracks = new ArrayList();
                                public void addTrack(Track arg) {
                                tracks.add(arg);
                                }
                                public void removeTrack(Track arg) {
                                tracks.remove(arg);
                                };
                                public void removeTrack(int i) {
                                tracks.remove(i);
                                }
                                public Track[] getTracks() {
                                return (Track[]) tracks.toArray(new Track[tracks.size()]);
                                }
                                The album mapper class handles all the SQL for tracks and thus defines the
                                SQL statements that access the tracks table.
                                class AlbumMapper...
                                protected String findStatement() {
                                return
                                "SELECT ID, a.title, t.title as trackTitle" +
                                " FROM albums a, tracks t" +
                                " WHERE a.ID = ? AND t.albumID = a.ID" +
                                " ORDER BY t.seq";
                                }
                                The tracks are loaded into the album whenever the album is loaded.
                                class AlbumMapper...
                                protected DomainObject doLoad(Long id, ResultSet rs) throws SQLException {
                                String title = rs.getString(2);
                                Album result = new Album(id, title);
                                loadTracks(result, rs);
                                return result;
                                266 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Dependent
                                Mapping
                                }
                                public void loadTracks(Album arg, ResultSet rs) throws SQLException {
                                arg.addTrack(newTrack(rs));
                                while (rs.next()) {
                                arg.addTrack(newTrack(rs));
                                }
                                }
                                private Track newTrack(ResultSet rs) throws SQLException {
                                String title = rs.getString(3);
                                Track newTrack = new Track (title);
                                return newTrack;
                                }</pre>
                                For clarity Iâ€™ve done the track load in a separate query. For performance, you
                                might want to consider loading them in the same query along the lines of the
                                example on page 243.
                                When the album is updated all the tracks are deleted and reinserted.
                                <pre>class AlbumMapper...
                                public void update(DomainObject arg) {
                                PreparedStatement updateStatement = null;
                                try {
                                updateStatement = DB.prepare("UPDATE albums SET title = ? WHERE id = ?");
                                updateStatement.setLong(2, arg.getID().longValue());
                                Album album = (Album) arg;
                                updateStatement.setString(1, album.getTitle());
                                updateStatement.execute();
                                updateTracks(album);
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(updateStatement);
                                }
                                }
                                public void updateTracks(Album arg) throws SQLException {
                                PreparedStatement deleteTracksStatement = null;
                                try {
                                deleteTracksStatement = DB.prepare("DELETE from tracks WHERE albumID = ?");
                                deleteTracksStatement.setLong(1, arg.getID().longValue());
                                deleteTracksStatement.execute();
                                for (int i = 0; i < arg.getTracks().length; i++) {
                                Track track = arg.getTracks()[i];
                                insertTrack(track, i + 1, arg);
                                }
                                } finally {DB.cleanUp(deleteTracksStatement);
                                }
                                }
                                public void insertTrack(Track track, int seq, Album album) throws SQLException {
                                PreparedStatement insertTracksStatement = null;
                                DEPENDENT MAPPING 267
                                Dependent
                                Mapping
                                try {
                                insertTracksStatement =
                                DB.prepare("INSERT INTO tracks (seq, albumID, title) VALUES (?, ?, ?)");
                                insertTracksStatement.setInt(1, seq);
                                insertTracksStatement.setLong(2, album.getID().longValue());
                                insertTracksStatement.setString(3, track.getTitle());
                                insertTracksStatement.execute();
                                } finally {DB.cleanUp(insertTracksStatement);
                                }
                                }</pre></p>
                <h3 id="268">Embedded Value</h3>
                <p>Maps an object into several fields of another objectâ€™s table.
                                Many small objects make sense in an OO system that donâ€™t make sense as
                                tables in a database. Examples include currency-aware money objects and date
                                ranges. Although the default thinking is to save an object as a table, no sane
                                person would want a table of money values.
                                An Embedded Value maps the values of an object to fields in the record of
                                the objectâ€™s owner. In the sketch we have an employment object with links to a
                                date range object and a money object. In the resulting table the fields in those
                                objects map to fields in the employment table rather than make new records
                                themselves.</p>
                <h3 id="268(2)">How It Works</h3>
                <p>This exercise is actually quite simple. When the owning object (employment) is
                                loaded or saved, the dependent objects (date range and money) are loaded and
                                saved at the same time. The dependent classes wonâ€™t have their own persistence
                                methods since all persistence is done by the owner. You can think of Embedded
                                Value as a special case of Dependent Mapping (262), where the value is a single
                                dependent object.</p>
                <h3 id="268(3)">When to Use It</h3>
                <p>This is one of those patterns where the doing of it is very straightforward, but
                                knowing when to use it a little more complicated.
                                The simplest cases for Embedded Value are the clear, simple Value Objects
                                (486) like money and date range. Since Value Objects (486) donâ€™t have identity,
                                you can create and destroy them easily without worrying about such things as
                                Identity Maps (195) to keep them all in sync. Indeed, all Value Objects (486)
                                should be persisted as Embedded Value, since you would never want a table for
                                them there.
                                The grey area is in whether itâ€™s worth storing reference objects, such as an
                                order and a shipping object, using Embedded Value. The principal question
                                here is whether the shipping data has any relevance outside the context of the
                                order. One issue is the loading and saving. If you only load the shipping data
                                into memory when you load the order, thatâ€™s an argument for saving both in the
                                same table. Another question is whether youâ€™ll want to access the shipping data
                                separately though SQL. This can be important if youâ€™re reporting through SQL
                                and donâ€™t have a separate database for reporting.</p>
                <p>If youâ€™re mapping to an existing schema, you can use Embedded Value when
                                a table contains data that you split into more than one object in memory. This
                                may occur because you want a separate object to factor out some behavior in the
                                object model, but itâ€™s all still one entity in the database. In this case you have to
                                be careful that any change to the dependent marks the owner as dirtyâ€”which
                                isnâ€™t an issue with Value Objects (486) that are replaced in the owner.
                                In most cases youâ€™ll only use Embedded Value on a reference object when the
                                association between them is single valued at both ends (a one-to-one association). Occasionally you may use it if there are multiple candidate dependents
                                and their number is small and fixed. Then youâ€™ll have numbered fields for each
                                value. This is messy table design, and horrible to query in SQL, but it may have
                                performance benefits. If this is the case, however, Serialized LOB (272) is usually the better choice.</p>
                <p>Since so much of the logic for deciding when to use Embedded Value is the
                                same as for Serialized LOB (272), thereâ€™s the obvious matter of choosing
                                between the two. The great advantage of Embedded Value is that it allows SQL
                                queries to be made against the values in the dependent object. Although using
                                XML as the serialization, together with XML-based query add-ons to SQL,
                                may alter that in the future, at the moment you really need Embedded Value if
                                you want to use dependent values in a query. This may be important for separate reporting mechanisms on the database
                                Embedded Value can only be used for fairly simple dependents. A solitary
                                dependent, or a few separated dependents, works well. Serialized LOB (272)
                                works with more complex structures, including potentially large object subgraphs.
                                270 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Embedded
                                Value</p>
                <h3 id="270">Further Reading</h3>
                <p>Embedded Value has been called a couple of different names in its history.
                                TOPLink refers to it as aggregate mapping. Visual Age refers to it as composer.</p>
                <h3 id="270(2)">Example: Simple Value Object (Java)</h3>
                <p>This is the classic example of a value object mapped with Embedded Value.
                                Weâ€™ll begin with a simple product offering class with the following fields.
                                <pre>class ProductOffering...
                                private Product product;
                                private Money baseCost;
                                private Integer ID;</pre>
                                In these fields the ID is an Identity Field (216) and the product is a regular
                                record mapping. Weâ€™ll map the base cost using Embedded Value. Weâ€™ll do the
                                overall mapping with Active Record (160) to keep things simple.
                                Since weâ€™re using Active Record (160) we need save and load routines. These
                                simple routines are in the product offering class because itâ€™s the owner. The
                                money class has no persistence behavior at all. Hereâ€™s the load method.
                                <pre>class ProductOffering...
                                public static ProductOffering load(ResultSet rs) {
                                try {
                                Integer id = (Integer) rs.getObject("ID");
                                BigDecimal baseCostAmount = rs.getBigDecimal("base_cost_amount");
                                Currency baseCostCurrency = Registry.getCurrency(rs.getString("base_cost_currency"));
                                Money baseCost = new Money(baseCostAmount, baseCostCurrency);
                                Integer productID = (Integer) rs.getObject("product");
                                Product product = Product.find((Integer) rs.getObject("product"));
                                return new ProductOffering(id, product, baseCost);
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                }
                                }
                                Hereâ€™s the update behavior. Again itâ€™s a simple variation on the updates.
                                class ProductOffering...
                                public void update() {
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(updateStatementString);
                                stmt.setBigDecimal(1, baseCost.amount());
                                stmt.setString(2, baseCost.currency().code());
                                stmt.setInt(3, ID.intValue());
                                stmt.execute();
                                } catch (Exception e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(stmt);}
                                }
                                private String updateStatementString =
                                "UPDATE product_offerings" +
                                " SET base_cost_amount = ?, base_cost_currency = ? " +
                                " WHERE id = ?";</pre></p>
                <h3 id="272">Serialized LOB</h3>
                <p>Saves a graph of objects by serializing them into a single large object
                                (LOB), which it stores in a database field.
                                Object models often contain complicated graphs of small objects. Much of the
                                information in these structures isnâ€™t in the objects but in the links between
                                them. Consider storing the organization hierarchy for all your customers. An
                                object model quite naturally shows the composition pattern to represent organizational hierarchies, and you can easily add methods that allow you to get
                                ancestors, siblings, descendents, and other common relationships.
                                Not so easy is putting all this into a relational schema. The basic schema is
                                simpleâ€”an organization table with a parent foreign key, however, its manipulation of the schema requires many joins, which are both slow and awkward.
                                Objects donâ€™t have to be persisted as table rows related to each other.
                                Another form of persistence is serialization, where a whole graph of objects is
                                written out as a single large object (LOB) in a table this Serialized LOB then
                                becomes a form of memento [Gang of Four].</p>
                <h3 id="272(2)">How It Works</h3>
                <p>There are two ways you can do the serialization: as a binary (BLOB) or as textual characters (CLOB). The BLOB is often the simplest to create since many
                                platforms include the ability to automatically serialize an object graph. Saving
                                the graph is a simple matter of applying the serialization in a buffer and saving
                                that buffer in the relevant field.
                                The advantages of the BLOB are that itâ€™s simple to program (if your platform supports it) and that it uses the minimum of space. The disadvantages
                                are that your database must support a binary data type for it and that you
                                canâ€™t reconstruct the graph without the object, so the field is utterly impenetrable to casual viewing. The most serious problem, however, is versioning. If
                                you change the department class, you may not be able to read all its previous
                                serializations; since data can live in the database for a long time, this is no
                                small thing.</p>
                <p>The alternative is a CLOB. In this case you serialize the department graph
                                into a text string that carries all the information you need. The text string can
                                be read easily by a human viewing the row, which helps in casual browsing of
                                the database. However the text approach will usually need more space, and you
                                may need to create your own parser for the textual format you use. Itâ€™s also
                                likely to be slower than a binary serialization.
                                Many of the disadvantages of CLOBs can be overcome with XML. XML
                                parsers are commonly available, so you donâ€™t have to write your own. Furthermore, XML is a widely supported standard so you can take advantage of tools
                                as they become available to do further manipulations. The disadvantage that
                                XML doesnâ€™t help with is the matter of space. Indeed, it makes the space issue
                                much worse because its a very verbose format. One way to deal with that is to
                                use a zipped XML format as your BLOBâ€”you lose the direct human readability, but itâ€™s an option if space is a real issue.</p>
                <p>When you use Serialized LOB beware of identity problems. Say you want to
                                use Serialized LOB for the customer details on an order. For this donâ€™t put the
                                customer LOB in the order table; otherwise, the customer data will be copied
                                on every order, which makes updates a problem. (This is actually a good thing,
                                however, if you want to store a snapshot of the customer data as it was at the
                                placing of the orderâ€”it avoids temporal relationships.) If you want your customer data to be updated for each order in the classical relational sense, you
                                need to put the LOB in a customer table so many orders can link to it. Thereâ€™s
                                nothing wrong with a table that just has an ID and a single LOB field for its
                                data.
                                In general, be careful of duplicating data when using this pattern. Often itâ€™s
                                not a whole Serialized LOB that gets duplicated but part of one that overlaps
                                with another one. The thing to do is to pay careful attention to the data thatâ€™s
                                stored in the Serialized LOB and be sure that it canâ€™t be reached from anywhere
                                but a single object that acts as the owner of the Serialized LOB.</p>
                <h3 id="274">When to Use It</h3>
                <p>Serialized LOB isnâ€™t considered as often as it might be. XML makes it much more
                                attractive since it yields a easy-to-implement textual approach. Its main disadvantage is that you canâ€™t query the structure using SQL. SQL extensions appear to
                                get at XML data within a field, but thatâ€™s still not the same (or portable).
                                This pattern works best when you can chop out a piece of the object model
                                and use it to represent the LOB. Think of a LOB as a way to take a bunch of
                                objects that arenâ€™t likely to be queried from any SQL route outside the application. This graph can then be hooked into the SQL schema.
                                Serialized LOB works poorly when you have objects outside the LOB reference objects buried in it. To handle this you have to come up with some form of
                                referencing scheme that can support references to objects inside a LOBâ€”itâ€™s by
                                no means impossible, but itâ€™s awkward, awkward enough usually not to be worth
                                doing. Again XML, or rather XPath, reduces this awkwardness somewhat.
                                If youâ€™re using a separate database for reporting and all other SQL goes
                                against that database, you can transform the LOB into a suitable table structure. The fact that a reporting database is usually denormalized means that
                                structures suitable for Serialized LOB are often also suitable for a separate
                                reporting database.</p>
                <h3 id="274(2)">Example: Serializing a Department Hierarchy in XML (Java)</h3>
                <p>For this example weâ€™ll take the notion of customers and departments from the
                                sketch and show how you might serialize all the departments into an XML
                                CLOB. As I write this, Javaâ€™s XML handling is somewhat primitive and volatile,
                                so the code may look different when you get to it (Iâ€™m also using an early version of JDOM).
                                The object model of the sketch turns into the following class structures:
                                <pre>class Customer...
                                private String name;
                                private List departments = new ArrayList();
                                class Department...
                                private String name;
                                private List subsidiaries = new ArrayList();</pre>
                                The database for this has only one table.
                                create table customers (ID int primary key, name varchar, departments varchar)
                                Weâ€™ll treat the customer as an Active Record (160) and illustrate writing the
                                data with the insert behavior.
                                <pre>class Customer...
                                public Long insert() {
                                PreparedStatement insertStatement = null;
                                try {
                                insertStatement = DB.prepare(insertStatementString);
                                setID(findNextDatabaseId());
                                insertStatement.setInt(1, getID().intValue());
                                insertStatement.setString(2, name);
                                insertStatement.setString(3, XmlStringer.write(departmentsToXmlElement()));
                                insertStatement.execute();
                                Registry.addCustomer(this);
                                return getID();
                                } catch (SQLException e) {
                                throw new ApplicationException(e);
                                } finally {DB.cleanUp(insertStatement);
                                }
                                }
                                public Element departmentsToXmlElement() {
                                Element root = new Element("departmentList");
                                Iterator i = departments.iterator();
                                while (i.hasNext()) {
                                Department dep = (Department) i.next();
                                root.addContent(dep.toXmlElement());
                                }
                                return root;
                                }
                                class Department...
                                Element toXmlElement() {
                                Element root = new Element("department");
                                root.setAttribute("name", name);
                                Iterator i = subsidiaries.iterator();
                                while (i.hasNext()) {
                                Department dep = (Department) i.next();
                                root.addContent(dep.toXmlElement());
                                }
                                return root;
                                }</pre>
                                The customer has a method for serializing its departments field into a single
                                XML DOM. Each department has a method for serializing itself (and its subsidiaries recursively) into a DOM as well. The insert method then takes the
                                DOM of the departments, converts it into a string (via a utility class) and puts it
                                in the database. We arenâ€™t particularly concerned with the structure of the
                                string. Itâ€™s human readable, but we arenâ€™t going to look at it on a regular basis.
                                <pre>&lt;?xml version="1.0" encoding="UTF-8"?>
                                &lt;departmentList&gt;
                                &lt;department name="US"&gt;
                                &lt;department name="New England"&gt;
                                &lt;department name="Boston" /&gt;
                                &lt;department name="Vermont" /&gt;
                                &lt;/department&gt;
                                &lt;department name="California" /&gt;
                                &lt;department name="Mid-West" /&gt;
                                &lt;/department&gt;
                                &lt;department name="Europe" /&gt;
                                &lt;/departmentList&gt;</pre>
                                Reading back is a fairly simple reversal of this process.
                                <pre>class Customer...
                                public static Customer load(ResultSet rs) throws SQLException {
                                Long id = new Long(rs.getLong("id"));
                                Customer result = (Customer) Registry.getCustomer(id);
                                if (result != null) return result;
                                String name = rs.getString("name");
                                String departmentLob = rs.getString("departments");
                                result = new Customer(name);
                                result.readDepartments(XmlStringer.read(departmentLob));
                                return result;
                                }
                                void readDepartments(Element source) {
                                List result = new ArrayList();
                                Iterator it = source.getChildren("department").iterator();
                                while (it.hasNext())
                                addDepartment(Department.readXml((Element) it.next()));
                                }
                                class Department...
                                static Department readXml(Element source) {
                                String name = source.getAttributeValue("name");
                                Department result = new Department(name);
                                Iterator it = source.getChildren("department").iterator();
                                while (it.hasNext())
                                result.addSubsidiary(readXml((Element) it.next()));
                                return result;
                                }</pre>
                                The load code is obviously a mirror image of the insert code. The department
                                knows how to create itself (and its subsidiaries) from an XML element, and the
                                customer knows how to take an XML element and create the list of depart-
                                ments from it. The load method uses a utility class to turn the string from the
                                database into a utility element.
                                An obvious danger here is that someone may try to edit the XML by hand in
                                the database and mess up the XML, making it unreadable by the load routine.
                                More sophisticated tools that would support adding a DTD or XML schema to
                                a field as validation will obviously help with that.</p>
                <h3 id="278">Single Table Inheritance</h3>
                <p>Represents an inheritance hierarchy of classes as a single table that
                                has columns for all the fields of the various classes.
                                Relational databases donâ€™t support inheritance, so when mapping from objects
                                to databases we have to consider how to represent our nice inheritance structures in relational tables. When mapping to a relational database, we try to
                                minimize the joins that can quickly mount up when processing an inheritance
                                structure in multiple tables. Single Table Inheritance maps all fields of all classes
                                of an inheritance structure into a single table.</p>
                <h3 id="278(2)">How It Works</h3>
                <p>In this inheritance mapping scheme we have one table that contains all the data
                                for all the classes in the inheritance hierarchy. Each class stores the data thatâ€™s
                                relevant to it in one table row. Any columns in the database that arenâ€™t relevant
                                are left empty. The basic mapping behavior follows the general scheme of
                                Inheritance Mappers (302).
                                When loading an object into memory you need to know which class to
                                instantiate. For this you have a field in the table that indicates which class
                                should be used. This can be the name of the class or a code field. A code field
                                needs to be interpreted by some code to map it to the relevant class. This code
                                needs to be extended when a class is added to the hierarchy. If you embed the
                                class name in the table you can just use it directly to instantiate an instance. The
                                class name, however, will take up more space and may be less easy to process by
                                those using the database table structure directly. As well it may more closely
                                couple the class structure to the database schema.
                                In loading data you read the code first to figure out which subclass to instantiate. On saving the data the code needs be written out by the superclass in the
                                hierarchy.</p>
                <h3 id="279">When to Use It</h3>
                <p>Single Table Inheritance is one of the options for mapping the fields in an inheritance hierarchy to a relational database. The alternatives are Class Table Inheritance (285) and Concrete Table Inheritance (293).
                                These are the strengths of Single Table Inheritance:
                <ul>
                        <li>Thereâ€™s only a single table to worry about on the database.</li>
                        <li>There are no joins in retrieving data.</li>
                        <li>Any refactoring that pushes fields up or down the hierarchy doesnâ€™t require you to change the database.</li>
                </ul>
                The weaknesses of Single Table Inheritance are
                <ul>
                        <li>Fields are sometimes relevant and sometimes not, which can be confusing to people using the tables directly.</li>
                        <li>Columns used only by some subclasses lead to wasted space in the database. How much this is actually a problem depends on the specific data characteristics and how well the database compresses empty columns. Oracle, for example, is very efficient in trimming wasted space, particularly if you keep your optional columns to the right side of the database table. Each database has its own tricks for this.</li>
                        <li>The single table may end up being too large, with many indexes and frequent locking, which may hurt performance. You can avoid this by having separate index tables that either list keys of rows that have a certain property or that copy a subset of fields relevant to an index.</li>
                        <li>You only have a single namespace for fields, so you have to be sure that you donâ€™t use the same name for different fields. Compound names with the name of the class as a prefix or suffix help here.</li>
                </ul>
                                Remember that you donâ€™t need to use one form of inheritance mapping for
                                your whole hierarchy. Itâ€™s perfectly fine to map half a dozen similar classes in a
                                single table, as long as you use Concrete Table Inheritance (293) for any classes
                                that have a lot of specific data.</p>
                <h3 id="280">Example: A Single Table for Players (C#)</h3>
                <p>Like the other inheritance examples, Iâ€™ve based this one on Inheritance Mappers
                                (302), using the classes in Figure 12.8. Each mapper needs to be linked to a data
                                table in an ADO.NET data set. This link can be made generically in the mapper
                                superclass. The gatewayâ€™s data property is a data set that can be loaded by a
                                query.
                                <pre>class Mapper...
                                protected DataTable table {
                                get {return Gateway.Data.Tables[TableName];}
                                }
                                protected Gateway Gateway;
                                abstract protected String TableName {get;}
                                Since there is only one table, this can be defined by the abstract player
                                mapper.
                                class AbstractPlayerMapper...
                                protected override String TableName {
                                get {return "Players";}
                                }</pre>
                                Each class needs a type code to help the mapper code figure out what kind of
                                player itâ€™s dealing with. The type code is defined on the superclass and implemented in the subclasses.
                                <pre>class AbstractPlayerMapper...
                                abstract public String TypeCode {get;}
                                class CricketerMapper...
                                public const String TYPE_CODE = "C";
                                public override String TypeCode {
                                get {return TYPE_CODE;}
                                }
                                The player mapper has fields for each of the three concrete mapper classes.
                                class PlayerMapper...
                                private BowlerMapper bmapper;
                                private CricketerMapper cmapper;
                                private FootballerMapper fmapper;
                                public PlayerMapper (Gateway gateway) : base (gateway) {
                                bmapper = new BowlerMapper(Gateway);
                                cmapper = new CricketerMapper(Gateway);
                                fmapper = new FootballerMapper(Gateway);
                                }</pre></p>
                <h3 id="281">Loading an Object from the Database</h3>
                <p>Each concrete mapper class has a find method to get an object from the data.
                                <pre>class CricketerMapper...
                                public Cricketer Find(long id) {
                                return (Cricketer) AbstractFind(id);
                                }</pre>
                                This calls generic behavior to find an object.
                                <pre>class Mapper...
                                protected DomainObject AbstractFind(long id) {
                                DataRow row = FindRow(id);
                                return (row == null) ? null : Find(row);
                                }
                                protected DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                }
                                public DomainObject Find (DataRow row) {
                                DomainObject result = CreateDomainObject();
                                Load(result, row);
                                return result;
                                }
                                abstract protected DomainObject CreateDomainObject();
                                class CricketerMapper...
                                protected override DomainObject CreateDomainObject() {
                                return new Cricketer();
                                }</pre>
                                I load the data into the new object with a series of load methods, one on each
                                class in the hierarchy.
                                <pre>class CricketerMapper...
                                protected override void Load(DomainObject obj, DataRow row) {
                                base.Load(obj,row);
                                Cricketer cricketer = (Cricketer) obj;
                                cricketer.battingAverage = (double)row["battingAverage"];
                                }
                                class AbstractPlayerMapper...
                                protected override void Load(DomainObject obj, DataRow row) {
                                base.Load(obj, row);
                                Player player = (Player) obj;
                                player.name = (String)row["name"];
                                }
                                class Mapper...
                                protected virtual void Load(DomainObject obj, DataRow row) {
                                obj.Id = (int) row ["id"];
                                }</pre>
                                I can also load a player through the player mapper. It needs to read the data and
                                use the type code to determine which concrete mapper to use.
                                <pre>class PlayerMapper...
                                public Player Find (long key) {
                                DataRow row = FindRow(key);
                                if (row == null) return null;
                                else {
                                String typecode = (String) row["type"];
                                switch (typecode){
                                case BowlerMapper.TYPE_CODE:
                                return (Player) bmapper.Find(row);
                                case CricketerMapper.TYPE_CODE:
                                return (Player) cmapper.Find(row);
                                case FootballerMapper.TYPE_CODE:
                                return (Player) fmapper.Find(row);
                                default:
                                throw new Exception("unknown type");
                                }
                                }
                                }</pre>
                                Updating an Object The basic operation for updating is the same for all
                                objects, so I can define the operation on the mapper superclass.
                                <pre>class Mapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg, FindRow(arg.Id));
                                }
                                The save method is similar to the load methodâ€”each class defines it to save
                                the data it contains.
                                class CricketerMapper...
                                protected override void Save(DomainObject obj, DataRow row) {
                                base.Save(obj, row);
                                Cricketer cricketer = (Cricketer) obj;
                                row["battingAverage"] = cricketer.battingAverage;
                                }
                                class AbstractPlayerMapper...
                                protected override void Save(DomainObject obj, DataRow row) {
                                Player player = (Player) obj;
                                row["name"] = player.name;
                                row["type"] = TypeCode;
                                }</pre>
                                The player mapper forwards to the appropriate concrete mapper.
                                <pre>class PlayerMapper...
                                public override void Update (DomainObject obj) {
                                MapperFor(obj).Update(obj);
                                }
                                private Mapper MapperFor(DomainObject obj) {
                                if (obj is Footballer)
                                return fmapper;
                                if (obj is Bowler)
                                return bmapper;
                                if (obj is Cricketer)
                                return cmapper;
                                throw new Exception("No mapper available");
                                }</pre>
                                Inserting an Object Insertions are similar to updates; the only real difference is
                                that a new row needs to be made in the table before saving.
                                <pre>class Mapper...
                                public virtual long Insert (DomainObject arg) {
                                DataRow row = table.NewRow();
                                arg.Id = GetNextID();
                                row["id"] = arg.Id;
                                Save (arg, row);
                                table.Rows.Add(row);
                                return arg.Id;
                                }
                                class PlayerMapper...
                                public override long Insert (DomainObject obj) {
                                return MapperFor(obj).Insert(obj);
                                }
                                Deleting an Object Deletes are pretty simple. Theyâ€™re defined at the abstract
                                mapper level or in the player wrapper.
                                class Mapper...
                                public virtual void Delete(DomainObject obj) {
                                DataRow row = FindRow(obj.Id);
                                row.Delete();
                                }
                                class PlayerMapper...
                                public override void Delete (DomainObject obj) {
                                MapperFor(obj).Delete(obj);
                                }</pre></p>
                <h3 id="285">Class Table Inheritance</h3>
                <p>Represents an inheritance hierarchy of classes
                                with one table for each class.
                                A very visible aspect of the object-relational mismatch is the fact that relational
                                databases donâ€™t support inheritance. You want database structures that map
                                clearly to the objects and allow links anywhere in the inheritance structure.
                                Class Table Inheritance supports this by using one database table per class in
                                the inheritance structure.</p>
                <h3 id="285(2)">How It Works</h3>
                <p>The straightforward thing about Class Table Inheritance is that it has one table
                                per class in the domain model. The fields in the domain class map directly to
                                fields in the corresponding tables. As with the other inheritance mappings the
                                fundamental approach of Inheritance Mappers (302) applies.
                                One issue is how to link the corresponding rows of the database tables. A
                                possible solution is to use a common primary key value so that, say, the row of
                                key 101 in the footballers table and the row of key 101 in the players table correspond to the same domain object. Since the superclass table has a row for
                                each row in the other tables, the primary keys are going to be unique across the
                                tables if you use this scheme. An alternative is to let each table have its own primary keys and use foreign keys into the superclass table to tie the rows together.
                                The biggest implementation issue with Class Table Inheritance is how to
                                bring the data back from multiple tables in an efficient manner. Obviously,
                                making a call for each table isnâ€™t good since you have multiple calls to the database. You can avoid this by doing a join across the various component tables;
                                however, joins for more than three or four tables tend to be slow because of the
                                way databases do their optimizations.</p>
                <p>On top of this is the problem that in any given query you often donâ€™t know
                                exactly which tables to join. If youâ€™re looking for a footballer, you know to use
                                the footballer table, but if youâ€™re looking for a group of players, which tables
                                do you use? To join effectively when some tables have no data, youâ€™ll need to
                                do an outer join, which is nonstandard and often slow. The alternative is to
                                read the root table first and then use a code to figure out what tables to read
                                next, but this involves multiple queries.</p>
                <h3 id="286">When to Use It</h3>
                <p>Class Table Inheritance, Single Table Inheritance (278) and Concrete Table
                                Inheritance (293) are the three alternatives to consider for inheritance mapping.
                                The strengths of Class Table Inheritance are
                <ul>
                        <li>All columns are relevant for every row so tables are easier to understand and donâ€™t waste space.</li>
                        <li>The relationship between the domain model and the database is very straightforward.</li>
                </ul>
                                The weaknesses of Class Table Inheritance are
                <ul>
                        <li>You need to touch multiple tables to load an object, which means a join or multiple queries and sewing in memory.</li>
                        <li>Any refactoring of fields up or down the hierarchy causes database changes.</li>
                        <li>The supertype tables may become a bottleneck because they have to be accessed frequently.</li>
                        <li>The high normalization may make it hard to understand for ad hoc queries.</li>
                                You donâ€™t have to choose just one inheritance mapping pattern for one class
                                hierarchy. You can use Class Table Inheritance for the classes at the top of the
                                hierarchy and a bunch of Concrete Table Inheritance (293) for those lower
                                down.</p>
                <h3 id="287">Further Reading</h3>
                <p>A number of IBM texts refer to this pattern as Root-Leaf Mapping [Brown et al.].</p>
                <h3 id="287(2)">Example: Players and Their Kin (C#)</h3>
                <p>Hereâ€™s an implementation for the sketch. Again Iâ€™ll follow the familiar (if perhaps
                                a little tedious) theme of players and the like, using Inheritance Mappers (302)
                                (Figure 12.9).
                                Each class needs to define the table that holds its data and a type code for it.
                                <pre>class AbstractPlayerMapper...
                                abstract public String TypeCode {get;}
                                protected static String TABLENAME = "Players";
                                class FootballerMapper...
                                public override String TypeCode {
                                get {return "F";}
                                }
                                protected new static String TABLENAME = "Footballers";</pre>
                                Unlike the other inheritance examples, this one doesnâ€™t have a overridden
                                table name because we have to have the table name for this class even when the
                                instance is an instance of the subclass.
                                Loading an Object If youâ€™ve been reading the other mappings, you know the
                                first step is the find method on the concrete mappers.
                                <pre>class FootballerMapper...
                                public Footballer Find(long id) {
                                return (Footballer) AbstractFind (id, TABLENAME);
                                }</pre>
                                The abstract find method looks for a row matching the key and, if successful,
                                creates a domain object and calls the load method on it.
                                <pre>class Mapper...
                                public DomainObject AbstractFind(long id, String tablename) {
                                DataRow row = FindRow (id, tableFor(tablename));
                                if (row == null) return null;
                                else {
                                DomainObject result = CreateDomainObject();
                                result.Id = id;
                                Load(result);
                                return result;
                                }
                                }
                                protected DataTable tableFor(String name) {
                                return Gateway.Data.Tables[name];
                                }
                                protected DataRow FindRow(long id, DataTable table) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                return (results.Length == 0) ? null : results[0];
                                Figure 12.9 The generic class diagram of Inheritance Mappers (302).
                                + find (key) : Player
                                + insert
                                + update
                                Player Mapper
                                + find (key) : Footballer
                                # save
                                # load
                                Footballer Mapper
                                # save
                                # load
                                Abstract Player
                                + insert (Domain Object) Mapper
                                + update (Domain Object)
                                + delete (Domain Object)
                                -- hook methods
                                # save (Domain Object, Row)
                                # load (Domain Object, Row)
                                Mapper
                                + find (key) : Cricketer
                                # save
                                # load
                                Cricketer Mapper
                                + find (key) : Bowler
                                # save
                                # load
                                Bowler Mapper
                                1
                                1
                                1
                                }
                                protected DataRow FindRow (long id, String tablename) {
                                return FindRow(id, tableFor(tablename));
                                }
                                protected abstract DomainObject CreateDomainObject();
                                class FootballerMapper...
                                protected override DomainObject CreateDomainObject(){
                                return new Footballer();
                                }
                                Thereâ€™s one load method for each class which loads the data defined by that
                                class.
                                class FootballerMapper...
                                protected override void Load(DomainObject obj) {
                                base.Load(obj);
                                DataRow row = FindRow (obj.Id, tableFor(TABLENAME));
                                Footballer footballer = (Footballer) obj;
                                footballer.club = (String)row["club"];
                                }
                                class AbstractPlayerMapper...
                                protected override void Load(DomainObject obj) {
                                DataRow row = FindRow (obj.Id, tableFor(TABLENAME));
                                Player player = (Player) obj;
                                player.name = (String)row["name"];
                                }</pre>
                                As with the other sample code, but more noticeably in this case, Iâ€™m relying
                                on the fact that the ADO.NET data set has brought the data from the database
                                and cached it into memory. This allows me to make several accesses to the
                                table-based data structure without a high performance cost. If youâ€™re going
                                directly to the database, youâ€™ll need to reduce that load. For this example you
                                might do this by creating a join across all the tables and manipulating it.
                                The player mapper determines which kind of player it has to find and then
                                delegates the correct concrete mapper.
                                <pre>class PlayerMapper...
                                public Player Find (long key) {
                                DataRow row = FindRow(key, tableFor(TABLENAME));
                                if (row == null) return null;
                                else {
                                String typecode = (String) row["type"];
                                if (typecode == bmapper.TypeCode)
                                return bmapper.Find(key);
                                if (typecode == cmapper.TypeCode)
                                return cmapper.Find(key);
                                if (typecode == fmapper.TypeCode)
                                return fmapper.Find(key);
                                throw new Exception("unknown type");
                                }
                                }
                                protected static String TABLENAME = "Players";
                                Updating an Object The update method appears on the mapper superclass
                                class Mapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg);
                                }
                                Itâ€™s implemented through a series of save methods, one for each class in the
                                hierarchy.
                                class FootballerMapper...
                                protected override void Save(DomainObject obj) {
                                base.Save(obj);
                                DataRow row = FindRow (obj.Id, tableFor(TABLENAME));
                                Footballer footballer = (Footballer) obj;
                                row["club"] = footballer.club;
                                }
                                class AbstractPlayerMapper...
                                protected override void Save(DomainObject obj) {
                                DataRow row = FindRow (obj.Id, tableFor(TABLENAME));
                                Player player = (Player) obj;
                                row["name"] = player.name;
                                row["type"] = TypeCode;
                                }
                                The player mapperâ€™s update method overrides the general method to forward to
                                the correct concrete mapper.
                                class PlayerMapper...
                                public override void Update (DomainObject obj) {
                                MapperFor(obj).Update(obj);
                                }
                                private Mapper MapperFor(DomainObject obj) {
                                if (obj is Footballer)
                                return fmapper;
                                if (obj is Bowler)
                                return bmapper;
                                if (obj is Cricketer)
                                return cmapper;
                                throw new Exception("No mapper available");
                                }</pre>
                                Inserting an Object The method for inserting an object is declared on the mapper superclass. It has two stages: creating new database rows and then using the
                                save methods to update these blank rows with the necessary data.
                                <pre>class Mapper...
                                public virtual long Insert (DomainObject obj) {
                                obj.Id = GetNextID();
                                AddRow(obj);
                                Save(obj);
                                return obj.Id;
                                }
                                Each class inserts a row into its table.
                                class FootballerMapper...
                                protected override void AddRow (DomainObject obj) {
                                base.AddRow(obj);
                                InsertRow (obj, tableFor(TABLENAME));
                                }
                                class AbstractPlayerMapper...
                                protected override void AddRow (DomainObject obj) {
                                InsertRow (obj, tableFor(TABLENAME));
                                }
                                class Mapper...
                                abstract protected void AddRow (DomainObject obj);
                                protected virtual void InsertRow (DomainObject arg, DataTable table) {
                                DataRow row = table.NewRow();
                                row["id"] = arg.Id;
                                table.Rows.Add(row);
                                }
                                The player mapper delegates to the appropriate concrete mapper.
                                class PlayerMapper...
                                public override long Insert (DomainObject obj) {
                                return MapperFor(obj).Insert(obj);
                                }
                                Deleting an Object To delete an object, each class deletes a row from the corresponding table in the database.
                                class FootballerMapper...
                                public override void Delete(DomainObject obj) {
                                base.Delete(obj);
                                DataRow row = FindRow(obj.Id, TABLENAME);
                                row.Delete();
                                }
                                292 OBJECT-RELATIONAL STRUCTURAL PATTERNS
                                Class Table
                                Inheritance
                                class AbstractPlayerMapper...
                                public override void Delete(DomainObject obj) {
                                DataRow row = FindRow(obj.Id, tableFor(TABLENAME));
                                row.Delete();
                                }
                                class Mapper...
                                public abstract void Delete(DomainObject obj);
                                The player mapper again wimps out of all the hard work and just delegates to
                                the concrete mapper.
                                class PlayerMapper...
                                override public void Delete(DomainObject obj) {
                                MapperFor(obj).Delete(obj);
                                }</pre></p>
                <h3 id="293">Concrete Table Inheritance</h3>
                <p>Represents an inheritance hierarchy of classes with
                                one table per concrete class in the hierarchy.
                                As any object purist will tell you, relational databases donâ€™t support inheritanceâ€”a fact that complicates object-relational mapping. Thinking of tables
                                from an object instance point of view, a sensible route is to take each object in
                                memory and map it to a single database row. This implies Concrete Table Inheritance, where thereâ€™s a table for each concrete class in the inheritance hierarchy.
                                Iâ€™ll confess to having had some difficulty naming this pattern. Most people
                                think of it as leaf oriented since you usually have one table per leaf class in a
                                hierarchy. Following that logic, I could call this pattern leaf table inheritance,
                                and the term â€œleafâ€ is often used for this pattern. Strictly, however, a concrete
                                class that isnâ€™t a leaf usually gets a table as well, so I decided to go with the
                                more correct, if less intuitive term.</p>
                <h3 id="293(2)">How It Works</h3>
                <p>Concrete Table Inheritance uses one database table for each concrete class in
                                the hierarchy. Each table contains columns for the concrete class and all its
                                ancestors, so any fields in a superclass are duplicated across the tables of the
                                subclasses. As with all of these inheritance schemes the basic behavior uses
                                Inheritance Mappers (302).
                                You need to pay attention to the keys with this pattern. Punningly, the key
                                thing is to ensure that keys are unique not just to a table but to all the tables
                                from a hierarchy. A classic example of where you need this is if you have a collection of players and youâ€™re using Identity Field (216) with table-wide keys. If
                                keys can be duplicated between the tables that map the concrete classes, youâ€™ll
                                get multiple rows for a particular key value. Thus, you need a key allocation
                                system that keeps track of key usage across tables; also, you canâ€™t rely on the
                                databaseâ€™s primary key uniqueness mechanism.</p>
                <p>This becomes particularly awkward if youâ€™re hooking up to databases used
                                by other systems. In many of these cases you canâ€™t guarantee key uniqueness
                                across tables. In this situation you either avoid using superclass fields or use a
                                compound key that involves a table identifier.
                                You can get around some of this by not having fields that are typed to the
                                superclass, but obviously that compromises the object model. As alternative is
                                to have accessors for the supertype in the interface but to use several private
                                fields for each concrete type in the implementation. The interface then combines
                                values from the private fields. If the public interface is a single value, it picks
                                whichever of the private values arenâ€™t null. If the public interface is a collection
                                value, it replies with the union of values from the implementation fields.
                                For compound keys you can use a special key object as your ID field for
                                Identity Field (216). This key uses both the primary key of the table and the
                                table name to determine uniqueness.</p>
                <p>Related to this are problems with referential integrity in the database. Consider an object model like Figure 12.10. To implement referential integrity you
                                need a link table that contains foreign key columns for the charity function and
                                for the player. The problem is that thereâ€™s no table for the player, so you canâ€™t
                                put together a referential integrity constraint for the foreign key field that takes
                                either footballers or cricketers. Your choice is to ignore referential integrity or
                                use multiple link tables, one for each of the actual tables in the database. On
                                top of this you have problems if you canâ€™t guarantee key uniqueness.
                                If youâ€™re searching for players with a select statement, you need to look at all
                                tables to see which ones contain the appropriate value. This means using multiple queries or using an outer join, both of which are bad for performance. You
                                donâ€™t suffer the performance hit when you know the class you need, but you do
                                have to use the concrete class to improve performance.
                                This pattern is often referred to as along the lines of leaf table inheritance.
                                Some people prefer a variation where you have one table per leaf class instead
                                of one table per concrete class. If you donâ€™t have any concrete superclasses in
                                the hierarchy, this ends up as the same thing. Even if you do have concrete
                                superclasses the difference is pretty minor.</p>
                <h3 id="295">When to Use It</h3>
                <p>When figuring out how to map inheritance, Concrete Table Inheritance, Class
                                Table Inheritance (285), and Single Table Inheritance (278) are the alternatives.
                                The strengths of Concrete Table Inheritance are:
                <ul>
                        <li>Each table is self-contained and has no irrelevant fields. As a result it makes good sense when used by other applications that arenâ€™t using the objects.</li>
                        <li>There are no joins to do when reading the data from the concrete mappers.</li>
                        <li>Each table is accessed only when that class is accessed, which can spread the access load.</li>
                </ul>
                                The weaknesses of Concrete Table Inheritance are:
                <ul>
                        <li>Primary keys can be difficult to handle.</li>
                        <li>You canâ€™t enforce database relationships to abstract classes.</li>
                        <li>If the fields on the domain classes are pushed up or down the hierarchy, you have to alter the table definitions. You donâ€™t have to do as much alteration as with Class Table Inheritance (285), but you canâ€™t ignore this as you can with Single Table Inheritance (278).</li>
                        <li>If a superclass field changes, you need to change each table that has this field because the superclass fields are duplicated across the tables.</li>
                        <li>A find on the superclass forces you to check all the tables, which leads to multiple database accesses (or a weird join).</li>
                </ul>
                                Remember that the trio of inheritance patterns can coexist in a single hierarchy. So you might use Concrete Table Inheritance for one or two subclasses and
                                Single Table Inheritance (278) for the rest.</p>
                <h3 id="296">Example: Concrete Players (C#)</h3>
                <p>Here Iâ€™ll show you an implementation for the sketch. As with all inheritance
                                examples in this chapter, Iâ€™m using the basic design of classes from Inheritance
                                Mappers (302), shown in Figure 12.11.
                                Each mapper is linked to the database table thatâ€™s the source of the data. In
                                ADO.NET a data set holds the data table.
                                <pre>class Mapper...
                                public Gateway Gateway;
                                private IDictionary identityMap = new Hashtable();
                                public Mapper (Gateway gateway) {
                                this.Gateway = gateway;
                                }
                                private DataTable table {
                                get {return Gateway.Data.Tables[TableName];}
                                }
                                abstract public String TableName {get;}</pre>
                                The gateway class holds the data set within its data property. The data can be
                                loaded up by supplying suitable queries.
                                <pre>class Gateway...
                                public DataSet Data = new DataSet();
                                Each concrete mapper needs to define the name of the table that holds its data.
                                class CricketerMapper...
                                public override String TableName {
                                get {return "Cricketers";}
                                }</pre>
                                The player mapper has fields for each concrete mapper.
                                <pre>class PlayerMapper...
                                private BowlerMapper bmapper;
                                private CricketerMapper cmapper;
                                private FootballerMapper fmapper;
                                public PlayerMapper (Gateway gateway) : base (gateway) {
                                bmapper = new BowlerMapper(Gateway);
                                cmapper = new CricketerMapper(Gateway);
                                fmapper = new FootballerMapper(Gateway);
                                }</pre>
                                Loading an Object from the Database Each concrete mapper class has a find
                                method that returns an object given a key value.
                                <pre>class CricketerMapper...
                                public Cricketer Find(long id) {
                                return (Cricketer) AbstractFind(id);
                                }</pre>
                                The abstract behavior on the superclass finds the right database row for the ID,
                                creates a new domain object of the correct type, and uses the load method to
                                load it up (Iâ€™ll describe the load in a moment).
                                <pre>class Mapper...
                                public DomainObject AbstractFind(long id) {
                                DataRow row = FindRow(id);
                                if (row == null) return null;
                                else {
                                DomainObject result = CreateDomainObject();
                                Load(result, row);
                                return result;
                                }
                                }
                                private DataRow FindRow(long id) {
                                String filter = String.Format("id = {0}", id);
                                DataRow[] results = table.Select(filter);
                                if (results.Length == 0) return null;
                                else return results[0];
                                }
                                protected abstract DomainObject CreateDomainObject();
                                class CricketerMapper...
                                protected override DomainObject CreateDomainObject(){
                                return new Cricketer();
                                }</pre>
                                The actual loading of data from the database is done by the load method, or
                                rather by several load methods: one each for the mapper class and for all its
                                superclasses.
                                <pre>class CricketerMapper...
                                protected override void Load(DomainObject obj, DataRow row) {
                                base.Load(obj,row);
                                Cricketer cricketer = (Cricketer) obj;
                                cricketer.battingAverage = (double)row["battingAverage"];
                                }
                                class AbstractPlayerMapper...
                                protected override void Load(DomainObject obj, DataRow row) {
                                base.Load(obj, row);
                                Player player = (Player) obj;
                                player.name = (String)row["name"];
                                class Mapper...
                                protected virtual void Load(DomainObject obj, DataRow row) {
                                obj.Id = (int) row ["id"];
                                }</pre>
                                This is the logic for finding an object using a mapper for a concrete class. You
                                can also use a mapper for the superclass: the player mapper, which it needs to
                                find an object from whatever table itâ€™s living in. Since all the data is already in
                                memory in the data set, I can do this like so:
                                <pre>class PlayerMapper...
                                public Player Find (long key) {
                                Player result;
                                result = fmapper.Find(key);
                                if (result != null) return result;
                                result = bmapper.Find(key);
                                if (result != null) return result;
                                result = cmapper.Find(key);
                                if (result != null) return result;
                                return null;
                                }</pre>
                                Remember, this is reasonable only because the data is already in memory. If
                                you need to go to the database three times (or more for more subclasses) this
                                will be slow. It may help to do a join across all the concrete tables, which will
                                allow you to access the data in one database call. However, large joins are often
                                slow in their own right, so youâ€™ll need to do some benchmarks with your own
                                application to find out what works and what doesnâ€™t. Also, this will be an outer
                                join, and as well as slowing the syntax itâ€™s nonportable and often cryptic.
                                Updating an Object The update method can be defined on the mapper
                                superclass.
                                <pre>class Mapper...
                                public virtual void Update (DomainObject arg) {
                                Save (arg, FindRow(arg.Id));
                                }</pre>
                                Similar to loading, we use a sequence of save methods for each mapper class.
                                <pre>class CricketerMapper...
                                protected override void Save(DomainObject obj, DataRow row) {
                                base.Save(obj, row);
                                Cricketer cricketer = (Cricketer) obj;
                                row["battingAverage"] = cricketer.battingAverage;
                                }
                                class AbstractPlayerMapper...
                                protected override void Save(DomainObject obj, DataRow row) {
                                Player player = (Player) obj;
                                row["name"] = player.name;
                                }
                                The player mapper needs to find the correct concrete mapper to use and then
                                delegate the update call.
                                class PlayerMapper...
                                public override void Update (DomainObject obj) {
                                MapperFor(obj).Update(obj);
                                }
                                private Mapper MapperFor(DomainObject obj) {
                                if (obj is Footballer)
                                return fmapper;
                                if (obj is Bowler)
                                return bmapper;
                                if (obj is Cricketer)
                                return cmapper;
                                throw new Exception("No mapper available");
                                }</pre>
                                Inserting an Object Insertion is a variation on updating. The extra behavior is
                                creating the new row, which can be done on the superclass.
                                <pre>class Mapper...
                                public virtual long Insert (DomainObject arg) {
                                DataRow row = table.NewRow();
                                arg.Id = GetNextID();
                                row["id"] = arg.Id;
                                Save (arg, row);
                                table.Rows.Add(row);
                                return arg.Id;
                                }</pre>
                                Again, the player class delegates to the appropriate mapper.
                                <pre>class PlayerMapper...
                                public override long Insert (DomainObject obj) {
                                return MapperFor(obj).Insert(obj);
                                }</pre>
                                Deleting an Object Deletion is very straightforward. As before, we have a
                                method defined on the superclass:
                                <pre>class Mapper...
                                public virtual void Delete(DomainObject obj) {
                                DataRow row = FindRow(obj.Id);
                                row.Delete();
                                }</pre>
                                and a delegating method on the player mapper.
                                <pre>class PlayerMapper...
                                public override void Delete (DomainObject obj) {
                                MapperFor(obj).Delete(obj);
                                }</pre></p>
                <h3 id="302">Inheritance Mappers</h3>
                <p>A structure to organize database mappers
                                that handle inheritance hierarchies.
                                When you map from an object-oriented inheritance hierarchy in memory to a
                                relational database you have to minimize the amount of code needed to save
                                and load the data to the database. You also want to provide both abstract and
                                concrete mapping behavior that allows you to save or load a superclass or a
                                subclass.
                                Although the details of this behavior vary with your inheritance mapping
                                scheme (Single Table Inheritance (278), Class Table Inheritance (285), and
                                Concrete Table Inheritance (293)) the general structure works the same for all
                                of them.</p>
                <h3 id="303">How It Works</h3>
                <p>You can organize the mappers with a hierarchy so that each domain class has a
                                mapper that saves and loads the data for that domain class. This way you have
                                one point where you can change the mapping. This approach works well for
                                concrete mappers that know how to map the concrete objects in the hierarchy.
                                There are times, however, where you also need mappers for the abstract classes.
                                These can be implemented with mappers that are actually outside of the basic
                                hierarchy but delegate to the appropriate concrete mappers.
                                To best explain how this works, Iâ€™ll start with the concrete mappers. In the
                                sketch the concrete mappers are the mappers for footballer, cricketer, and bowler.
                                Their basic behavior includes the find, insert, update, and delete operations.
                                The find methods are declared on the concrete subclasses because they will
                                return a concrete class. Thus, the find method on BowlerMapper should return
                                a bowler, not an abstract class. Common OO languages canâ€™t let you change the
                                declared return type of a method, so itâ€™s not possible to inherit the find operation and still declare a specific return type. You can, of course, return an
                                abstract type, but that forces the user of the class to downcastâ€”which is best to
                                avoid. (A language with dynamic typing doesnâ€™t have this problem.)</p>
                <p>The basic behavior of the find method is to find the appropriate row in the
                                database, instantiate an object of the correct type (a decision thatâ€™s made by the
                                subclass), and then load the object with data from the database. The load
                                method is implemented by each mapper in the hierarchy which loads the behavior for its corresponding domain object. This means that the bowler mapperâ€™s
                                load method loads the data specific to the bowler class and calls the superclass
                                method to load the data specific to the cricketer, which calls its superclass
                                method, and so on.
                                The insert and update methods operate in a similar way using a save method.
                                Here you can define the interface on the superclassâ€”indeed, on a Layer Supertype (475). The insert method creates a new row and then saves the data from
                                the domain object using the save hook methods. The update method just saves
                                the data, also using the save hook methods. These methods operate similarly to
                                the load hook methods, with each class storing its specific data and calling the
                                superclass save method.</p>
                <p>This scheme makes it easy to write the appropriate mappers to save the
                                information needed for a particular part of the hierarchy. The next step is to
                                support loading and saving an abstract classâ€”in this example, a player. While a
                                first thought is to put appropriate methods on the superclass mapper, that actually gets awkward. While concrete mapper classes can just use the abstract
                                mapperâ€™s insert and update methods, the player mapperâ€™s insert and update
                                need to override these to call a concrete mapper instead. The result is one of
                                those combinations of generalization and composition that twist your brain
                                cells into a knot.
                                I prefer to separate the mappers into two classes. The abstract player mapper
                                is responsible for loading and saving the specific player data to the database.
                                This is an abstract class whose behavior is just used only by the concrete mapper objects. A separate player mapper class is used for the interface for operations at the player level. The player mapper provides a find method and
                                overrides the insert and update methods. For all of these its responsibility is to
                                figure out which concrete mapper should handle the task and delegate to it.
                                Although a broad scheme like this makes sense for each type of inheritance
                                mapping, the details do vary. Therefore, itâ€™s not possible to show a code example for this case. You can find good examples in each of the inheritance mapping pattern sections: Single Table Inheritance (278), Class Table Inheritance
                                (285), and Concrete Table Inheritance (293).</p>
                <h3 id="304">When to Use It</h3>
                <p>This general scheme makes sense for any inheritance-based database mapping.
                                The alternatives involve such things as duplicating superclass mapping code
                                among the concrete mappers and folding the playerâ€™s interface into the abstract
                                player mapper class. The former is a heinous crime, and the latter is possible
                                but leads to a player mapper class thatâ€™s messy and confusing. On the whole,
                                then, its hard to think of a good alternative to this pattern.
                                ObjectRelational
                                Metadata Mapping Patterns</p>
                <h3 id="305">Chapter 13</h3>
                <h2>Object-Relational Metadata Mapping Patterns</h2>
                <h3 id="306">Metadata Mapping</h3>
                <p>Holds details of object-relational mapping in metadata.
                                Much of the code that deals with object-relational mapping describes how fields
                                in the database correspond to fields in in-memory objects. The resulting code
                                tends to be tedious and repetitive to write. A Metadata Mapping allows developers to define the mappings in a simple tabular form, which can then be processed by generic code to carry out the details of reading, inserting, and
                                updating the data.</p>
                <h3 id="306(2)">How It Works</h3>
                <p>The biggest decision in using Metadata Mapping is how the information in the
                                metadata manifests itself in terms of running code. There are two main routes
                                to take: code generation and reflective programming.
                                With code generation you write a program whose input is the metadata and
                                whose output is the source code of classes that do the mapping. These classes
                                look as though theyâ€™re hand-written, but theyâ€™re entirely generated during the
                                build process, usually just prior to compilation. The resulting mapper classes
                                are deployed with the server code.
                                If you use code generation, you should make sure that itâ€™s fully integrated
                                into your build process with whatever build scripts youâ€™re using. The generated
                                classes should never be edited by hand and thus shouldnâ€™t need to be held in
                                source code control.</p>
                <p>A reflective program may ask an object for a method named setName, and then
                                run an invoke method on the setName method passing in the appropriate argument. By treating methods (and fields) as data the reflective program can read in
                                field and method names from a metadata file and use them to carry out the
                                mapping. I usually counsel against reflection, partly because itâ€™s slow but
                                mainly because it often causes code thatâ€™s hard to debug. Even so, reflection is
                                actually quite appropriate for database mapping. Since youâ€™re reading in the
                                names of fields and methods from a file, youâ€™re taking full advantage of reflectionâ€™s flexibility.
                                Code generation is a less dynamic approach since any changes to the mapping require recompiling and redeploying at least that part of the software.
                                With a reflective approach, you can just change the mapping data file and the
                                existing classes will use the new metadata. You can even do this during runtime, rereading the metadata when you get a particular kind of interrupt. As it
                                turns out, mapping changes should be pretty rare, since they imply database
                                or code changes. Modern environments also make it easy to redeploy part of
                                an application.</p>
                <p>Reflective programming often suffers in speed, although the problem here
                                depends very much on the actual environment youâ€™re usingâ€”in some a reflective call can be an order of magnitude slower. Remember, though, that the
                                reflection is being done in the context of an SQL call, so its slower speed may
                                not make that much difference considering the slow speed of the remote call. As
                                with any performance issue, you need to measure within your environment to
                                find out how much of a factor this is.
                                Both approaches can be a little awkward to debug. The comparison
                                between them depends very much on how used to generated and reflective
                                code developers are. Generated code is more explicit so you can see whatâ€™s
                                going on in the debugger; as a result I usually prefer generation to reflection,
                                and I think itâ€™s usually easier for less sophisticated developers (which I guess
                                makes me unsophisticated).</p>
                <p>On most occasions you keep the metadata in a separate file format. These
                                days XML is a popular choice as it provides hierarchic structuring while freeing
                                you from writing your own parsers and other tools. A loading step takes this
                                metadata and turns it into programming language structure, which then drive
                                either the code generation output or the reflective mapping.
                                In simpler cases you can skip the external file format and create the metadata
                                representation directly in source code. This saves you from having to parse, but
                                it makes editing the metadata somewhat harder.
                                Another alternative is to hold the mapping information in the database itself,
                                which keeps it together with the data. If the database schema changes, the mapping information is right there.
                                When youâ€™re deciding which way to hold the metadata information, you can
                                mostly neglect the performance of access and parsing. If you use code generation, access and parsing take place only during the build and not during execution. If you use reflective programming, youâ€™ll typically access and parse during
                                execution but only once during system startup; then you can keep the in-memory representation.</p>
                <p>How complex to make your metadata is one of your biggest decisions. When
                                youâ€™re faced with a general relational mapping problem, there are a lot of different factors to keep in metadata, but many projects can manage with much
                                less than a fully general scheme and so their metadata can be much simpler. On
                                the whole itâ€™s worth evolving your design as your needs grow, as it isnâ€™t hard to
                                add new capabilities to metadata-driven software.
                                One of the challenges of metadata is that although a simple metadata scheme
                                often works well 90 percent of the time, there are often special cases that make
                                life much more tricky. To handle these minority cases you often have to add a
                                lot of complexity to metadata. A useful alternative is to override the generic
                                code with subclasses where the special code is handwritten. Such special-case
                                subclasses would be subclasses of either the generated code or the reflective routines. Since these special cases are . . . well . . . special, it isnâ€™t easy to describe in
                                general terms how you arrange things to support the overriding. My advice is to
                                handle them on a case-by-case basis. As you need the overriding, alter the generated/reflective code to isolate a single method that should be overridden and
                                then override it in your special case.</p>
                <h3 id="308">When to Use It</h3>
                <p>Metadata Mapping can greatly reduce the amount of work needed to handle
                                database mapping. However, some setup work is required to prepare the Metadata Mapping framework. Also, while itâ€™s often easy to handle most cases with
                                Metadata Mapping, you can find exceptions that really tangle the metadata.
                                Itâ€™s no surprise that the commercial object-relational mapping tools use
                                Metadata Mappingâ€”when selling a product producing a sophisticated Metadata Mapping is always worth the effort.
                                If youâ€™re building your own system, you should evaluate the trade-offs yourself. Compare adding new mappings using handwritten code with using Metadata Mapping. If you use reflection, look into its consequences for performance;
                                sometimes it causes slowdowns, but sometimes it doesnâ€™t. Your own measurements will reveal whether this is an issue for you.
                                The extra work of hand-coding can be greatly reduced by creating a good
                                Layer Supertype (475) that handles all the common behavior. That way you
                                should only have a few hook routines to add in for each mapping. Usually
                                Metadata Mapping can further reduce the number.</p>
                <p>Metadata Mapping can interfere with refactoring, particularly if youâ€™re using
                                automated tools. If you change the name of a private field, it can break an
                                application unexpectedly. Even automated refactoring tools wonâ€™t be able to
                                find the field name hidden in a XML data file of a map. Using code generation
                                is a little easier, since search mechanisms can find the usage. Still, any automated update will get lost when you regenerate the code. A tool can warn you
                                of a problem, but itâ€™s up to you to change the metadata yourself. If you use
                                reflection, you wonâ€™t even get the warning.
                                On the other hand, Metadata Mapping can make refactoring the database
                                easier, since the metadata represents a statement of the interface of your database schema. Thus, alterations to the database can be contained by changes in
                                the Metadata Mapping.</p>
                <h3 id="309">Example: Using Metadata and Reflection (Java)</h3>
                <p>Most examples in this book use explicit code because itâ€™s the easiest to understand. However, it does lead to pretty tedious programming, and tedious programming is a sign that something is wrong. You can remove a lot of tedious
                                programming by using metadata.
                                Holding the Metadata The first question to ask about metadata is how itâ€™s
                                going to be kept. Here Iâ€™m keeping it in two classes. The data map corresponds
                                to the mapping of one class to one table. This is a simple mapping, but it will do
                                for illustration.
                                <pre>class DataMap...
                                private Class domainClass;
                                private String tableName;
                                private List columnMaps = new ArrayList();</pre>
                                The data map contains a collection of column maps that map columns in the
                                table to fields.
                                <pre>class ColumnMap...
                                private String columnName;
                                private String fieldName;
                                private Field field;
                                private DataMap dataMap;</pre>
                                This isnâ€™t a terribly sophisticated mapping. Iâ€™m just using the default Java type
                                mappings, which means thereâ€™s no type conversion between fields and columns.
                                Iâ€™m also forcing a one-to-one relationship between tables and classes.
                                These structures hold the mappings. The next question is how theyâ€™re populated. For this example Iâ€™m going to populate them with Java code in specific
                                mapper classes. That may seem a little odd, but it buys most of the benefit of
                                metadataâ€”avoiding repetitive code.
                                <pre>class PersonMapper...
                                protected void loadDataMap(){
                                dataMap = new DataMap (Person.class, "people");
                                dataMap.addColumn ("lastname", "varchar", "lastName");
                                dataMap.addColumn ("firstname", "varchar", "firstName");
                                dataMap.addColumn ("number_of_dependents", "int", "numberOfDependents");
                                }</pre>
                                During construction of the column mapper, I build the link to the field.
                                Strictly speaking, this is an optimization so you may not have to calculate the
                                fields. However, doing so reduces the subsequent accesses by an order of magnitude on my little laptop.
                                <pre>class ColumnMap...
                                public ColumnMap(String columnName, String fieldName, DataMap dataMap) {
                                this.columnName = columnName;
                                this.fieldName = fieldName;
                                this.dataMap = dataMap;
                                initField();
                                }
                                private void initField() {
                                try {
                                field = dataMap.getDomainClass().getDeclaredField(getFieldName());
                                field.setAccessible(true);
                                } catch (Exception e) {
                                throw new ApplicationException ("unable to set up field: " + fieldName, e);
                                }
                                }</pre>
                                Itâ€™s not much of a challenge to see how I can write a routine to load the map
                                from an XML file or from a metadata database. Paltry that challenge may be,
                                but Iâ€™ll decline it and leave it to you.
                                Now that the mappings are defined, I can make use of them. The strength of
                                the metadata approach is that all of the code that actually manipulates things is
                                in a superclass, so I donâ€™t have to write the mapping code that I wrote in the
                                explicit cases.
                                Find by ID Iâ€™ll begin with the find by ID method.
                                <pre>class Mapper...
                                public Object findObject (Long key) {
                                if (uow.isLoaded(key)) return uow.getObject(key);
                                String sql = "SELECT" + dataMap.columnList() + " FROM " + dataMap.getTableName() + " WHERE
                                ID = ?";
                                PreparedStatement stmt = null;
                                METADATA MAPPING 311
                                Metadata
                                Mapping
                                ResultSet rs = null;
                                DomainObject result = null;
                                try {
                                stmt = DB.prepare(sql);
                                stmt.setLong(1, key.longValue());
                                rs = stmt.executeQuery();
                                rs.next();
                                result = load(rs);
                                } catch (Exception e) {throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                return result;
                                }
                                private UnitOfWork uow;
                                protected DataMap dataMap;
                                class DataMap...
                                public String columnList() {
                                StringBuffer result = new StringBuffer(" ID");
                                for (Iterator it = columnMaps.iterator(); it.hasNext();) {
                                result.append(",");
                                ColumnMap columnMap = (ColumnMap)it.next();
                                result.append(columnMap.getColumnName());
                                }
                                return result.toString();
                                }
                                public String getTableName() {
                                return tableName;
                                }</pre>
                                The select is built more dynamically than the other examples, but itâ€™s still worth
                                preparing in a way that allows the database session to cache it properly. If itâ€™s
                                an issue, the column list can be calculated during construction and cached,
                                since thereâ€™s no call for updating the columns during the life of the data map.
                                For this example Iâ€™m using a Unit of Work (184) to handle the database session.
                                As is common with the examples in this book Iâ€™ve separated the load from
                                the find, so that we can use the same load method from other find methods.
                                <pre>class Mapper...
                                public DomainObject load(ResultSet rs)
                                throwsInstantiationException, IllegalAccessException, SQLException
                                {
                                Long key = new Long(rs.getLong("ID"));
                                if (uow.isLoaded(key)) return uow.getObject(key);
                                DomainObject result = (DomainObject) dataMap.getDomainClass().newInstance();
                                result.setID(key);
                                uow.registerClean(result);
                                loadFields(rs, result);
                                return result;
                                }
                                private void loadFields(ResultSet rs, DomainObject result) throws SQLException {
                                for (Iterator it = dataMap.getColumns(); it.hasNext();) {
                                ColumnMap columnMap = (ColumnMap)it.next();
                                Object columnValue = rs.getObject(columnMap.getColumnName());
                                columnMap.setField(result, columnValue);
                                }
                                }
                                class ColumnMap...
                                public void setField(Object result, Object columnValue) {
                                try {
                                field.set(result, columnValue);
                                } catch (Exception e) { throw new ApplicationException ("Error in setting " + fieldName, e);
                                }
                                }</pre>
                                This is a classic reflected program. We go through each of the column maps
                                and use them to load the field in the domain object. I separated the loadFields
                                method to show how we might extend this for more complicated cases. If we
                                have a class and a table where the simple assumptions of the metadata donâ€™t
                                hold, I can just override loadFields in a subclass mapper to put in arbitrarily
                                complex code. This is a common technique with metadataâ€”providing a hook
                                to override for more wacky cases. Itâ€™s usually a lot easier to override the wacky
                                cases with subclasses than it is to build metadata sophisticated enough to hold a
                                few rare special cases.
                                Of course, if we have a subclass, we might as well use it to avoid downcasting.
                                <pre>class PersonMapper...
                                public Person find(Long key) {
                                return (Person) findObject(key);
                                }
                                Writing to the Database For updates I have a single update routine.
                                class Mapper...
                                public void update (DomainObject obj) {
                                String sql = "UPDATE " + dataMap.getTableName() + dataMap.updateList() + " WHERE ID = ?";
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(sql);
                                int argCount = 1;
                                for (Iterator it = dataMap.getColumns(); it.hasNext();) {
                                ColumnMap col = (ColumnMap) it.next();
                                stmt.setObject(argCount++, col.getValue(obj));
                                }
                                stmt.setLong(argCount, obj.getID().longValue());
                                stmt.executeUpdate();
                                } catch (SQLException e) {throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt);
                                }
                                }
                                class DataMap...
                                public String updateList() {
                                StringBuffer result = new StringBuffer(" SET ");
                                for (Iterator it = columnMaps.iterator(); it.hasNext();) {
                                ColumnMap columnMap = (ColumnMap)it.next();
                                result.append(columnMap.getColumnName());
                                result.append("=?,");
                                }
                                result.setLength(result.length() - 1);
                                return result.toString();
                                }
                                public Iterator getColumns() {
                                return Collections.unmodifiableCollection(columnMaps).iterator();
                                }
                                class ColumnMap...
                                public Object getValue (Object subject) {
                                try {
                                return field.get(subject);
                                } catch (Exception e) {
                                throw new ApplicationException (e);
                                }
                                }
                                Inserts use a similar scheme.
                                class Mapper...
                                public Long insert (DomainObject obj) {
                                String sql = "INSERT INTO " + dataMap.getTableName() + " VALUES (?" + dataMap.insertList()
                                + ")";
                                PreparedStatement stmt = null;
                                try {
                                stmt = DB.prepare(sql);
                                stmt.setObject(1, obj.getID());
                                int argCount = 2;
                                for (Iterator it = dataMap.getColumns(); it.hasNext();) {
                                ColumnMap col = (ColumnMap) it.next();
                                stmt.setObject(argCount++, col.getValue(obj));
                                }
                                stmt.executeUpdate();
                                } catch (SQLException e) {throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt);
                                }
                                return obj.getID();
                                }
                                314 OBJECT-RELATIONAL METADATA MAPPING PATTERNS
                                Metadata
                                Mapping
                                class DataMap...
                                public String insertList() {
                                StringBuffer result = new StringBuffer();
                                for (int i = 0; i < columnMaps.size(); i++) {
                                result.append(",");
                                result.append("?");
                                }
                                return result.toString();
                                }
                                Multi-Object Finds There are a couple of routes you can take to get multiple
                                objects with a query. If you want a generic query capability on the generic mapper,
                                you can have a query that takes a SQL where clause as an argument.
                                class Mapper...
                                public Set findObjectsWhere (String whereClause) {
                                String sql = "SELECT" + dataMap.columnList() + " FROM " + dataMap.getTableName() + " WHERE "
                                + whereClause;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                Set result = new HashSet();
                                try {
                                stmt = DB.prepare(sql);
                                rs = stmt.executeQuery();
                                result = loadAll(rs);
                                } catch (Exception e) {
                                throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                return result;
                                }
                                public Set loadAll(ResultSet rs) throws SQLException, InstantiationException,
                                IllegalAccessException {
                                Set result = new HashSet();
                                while (rs.next()) {
                                DomainObject newObj = (DomainObject) dataMap.getDomainClass().newInstance();
                                newObj = load (rs);
                                result.add(newObj);
                                }
                                return result;
                                }
                                An alternative is to provide special case finders on the mapper subtypes.
                                class PersonMapper...
                                public Set findLastNamesLike (String pattern) {
                                String sql =
                                "SELECT" + dataMap.columnList() +
                                " FROM " + dataMap.getTableName() +
                                " WHERE UPPER(lastName) like UPPER(?)";
                                METADATA MAPPING 315
                                Metadata
                                Mapping
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                stmt = DB.prepare(sql);
                                stmt.setString(1, pattern);
                                rs = stmt.executeQuery();
                                return loadAll(rs);
                                } catch (Exception e) {throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                }</pre>
                                A further alternative for general selects is a Query Object (316).
                                On the whole, the great advantage of the metadata approach is that I can
                                now add new tables and classes to my data mapping and all I have to do is to
                                provide a loadMap method and any specialized finders that I may fancy.</p>
                <h3 id="316">Query Object</h3>
                <p>An object that represents a database query.
                                SQL can be an involved language, and many developers arenâ€™t particularly
                                familiar with it. Furthermore, you need to know what the database schema
                                looks like to form queries. You can avoid this by creating specialized finder
                                methods that hide the SQL inside parameterized methods, but that makes it difficult to form more ad hoc queries. It also leads to duplication in the SQL statements should the database schema change.
                                A Query Object is an interpreter [Gang of Four], that is, a structure of
                                objects that can form itself into a SQL query. You can create this query by referring to classes and fields rather than tables and columns. In this way those who
                                write the queries can do so independently of the database schema and changes
                                to the schema can be localized in a single place.</p>
                <h3 id="316(2)">How It Works</h3>
                <p>A Query Object is an application of the Interpreter pattern geared to represent
                                a SQL query. Its primary roles are to allow a client to form queries of various
                                kinds and to turn those object structures into the appropriate SQL string.
                                In order to represent any query, you need a flexible Query Object. Often,
                                however, applications can make do with a lot less than the full power of SQL,
                                in which case your Query Object can be simpler. It wonâ€™t be able to represent
                                anything, but it can satisfy your particular needs. Moreover, itâ€™s usually no
                                more work to enhance it when you need more capability than it is to create a
                                fully capable Query Object right from the beginning. As a result you should
                                create a minimally functional Query Object for your current needs and evolve
                                it as those needs grow.
                                A common feature of Query Object is that it can represent queries in the language of the in-memory objects rather than the database schema. That means
                                that, instead of using table and column names, you can use object and field
                                names. While this isnâ€™t important if your objects and database have the same
                                structure, it can be very useful if you get variations between the two. In order to
                                perform this change of view, the Query Object needs to know how the database
                                structure maps to the object structure, a capability that really needs Metadata
                                Mapping (306).</p>
                <p>For multiple databases you can design your Query Object so that it produces
                                different SQL depending on which database the query is running against. At itâ€™s
                                simplest level it can take into account the annoying differences in SQL syntax
                                that keep cropping up; at a more ambitious level it can use different mappings
                                to cope with the same classes being stored in different database schemas.
                                A particularly sophisticated use of Query Object is to eliminate redundant
                                queries against a database. If you see that youâ€™ve run the same query earlier in a
                                session, you can use it to select objects from the Identity Map (195) and avoid a
                                trip to the database. A more sophisticated approach can detect whether one
                                query is a particular case of an earlier query, such as a query that is the same as
                                an earlier one but with an additional clause linked with an AND.
                                Exactly how to achieve these more sophisticated features is beyond the
                                scope of this book, but theyâ€™re the kind of features that O/R mapping tools
                                may provide.
                                A variation on the Query Object is to allow a query to be specified by an
                                example domain object. Thus, you might have a person object whose last name
                                is set to Fowler but all of those other attributes are set to null. You can treat it
                                as a query by example thatâ€™s processed like the Interpreter-style Query Object.
                                That returns all people in the database whose last name is Fowler, and itâ€™s very
                                simple and convenient to use. However, it breaks down for complex queries.</p>
                <h3 id="317">When to Use It</h3>
                <p>Query Objects are a pretty sophisticated pattern to put together, so most
                                projects donâ€™t use them if they have a handbuilt data source layer. You only
                                really need them when youâ€™re using Domain Model (116) and Data Mapper
                                (165); you also really need Metadata Mapping (306) to make serious use of
                                them.
                                318 OBJECT-RELATIONAL METADATA MAPPING PATTERNS
                                Query Object
                                Even then Query Objects arenâ€™t always necessary, as many developers are
                                comfortable with SQL. You can hide many of the details of the database
                                schema behind specific finder methods.
                                The advantages of Query Object come with more sophisticated needs: keeping database schemas encapsulated, supporting multiple databases, supporting
                                multiple schemas, and optimizing to avoid multiple queries. Some projects with
                                a particularly sophisticated data source team might want to build these capabilities themselves, but most people who use Query Object do so with a commercial tool. My inclination is that youâ€™re almost always better off buying a tool.
                                All that said, you may find that a limited Query Object fulfills your needs
                                without being difficult to build on a project that doesnâ€™t justify a fully featured
                                version. The trick is to pare down the functionality to no more than you actually use.</p>
                <h3 id="318">Further Reading</h3>
                <p>You can find an example of Query Object in [Alpert et al.] in the discussion of
                                interpreters. Query Object is also closely linked to the Specification pattern in
                                [Evans and Fowler] and [Evans].</p>
                <h3 id="318(2)">Example: A Simple Query Object (Java)</h3>
                <p>This is a simple example of a Query Objectâ€”rather less than would be useful
                                for most situations but enough to give you an idea of what a Query Object is
                                about. It can query a single table based on set of criteria â€œANDâ€™edâ€ together (in
                                slightly more technical language, it can handle a conjunction of elementary
                                predicates).
                                The Query Object is set up using the language of domain objects rather than
                                that of the table structure. Thus, a query knows the class that itâ€™s for and a collection of criteria that correspond to the clauses of a where clause.
                                <pre>class QueryObject...
                                private Class klass;
                                private List criteria = new ArrayList();
                                A simple criterion is one that takes a field and a value and an SQL operator
                                to compare them.
                                class Criteria...
                                private String sqlOperator;
                                protected String field;
                                protected Object value;</pre>
                                To make it easier to create the right criteria, I can provide an appropriate creation method.
                                <pre>class Criteria...
                                public static Criteria greaterThan(String fieldName, int value) {
                                return Criteria.greaterThan(fieldName, new Integer(value));
                                }
                                public static Criteria greaterThan(String fieldName, Object value) {
                                return new Criteria(" > ", fieldName, value);
                                }
                                private Criteria(String sql, String field, Object value) {
                                this.sqlOperator = sql;
                                this.field = field;
                                this.value = value;
                                }
                                This allows me to find everyone with dependents by forming a query such as
                                class Criteria...
                                QueryObject query = new QueryObject(Person.class);
                                query.addCriteria(Criteria.greaterThan("numberOfDependents", 0));
                                Thus, if I have a person object such as this:
                                class Person...
                                private String lastName;
                                private String firstName;
                                private int numberOfDependents;</pre>
                                I can ask for all people with dependents by creating a query for person and adding a criterion.
                                <pre>QueryObject query = new QueryObject(Person.class);
                                query.addCriteria(Criteria.greaterThan("numberOfDependents", 0));</pre>
                                Thatâ€™s enough to describe the query. Now the query needs to execute by
                                turning itself into a SQL select. In this case I assume that my mapper class supports a method that finds objects based on a string thatâ€™s a where clause.
                                <pre>class QueryObject...
                                public Set execute(UnitOfWork uow) {
                                this.uow = uow;
                                return uow.getMapper(klass).findObjectsWhere(generateWhereClause());
                                }
                                class Mapper...
                                public Set findObjectsWhere (String whereClause) {
                                String sql = "SELECT" + dataMap.columnList() + " FROM " + dataMap.getTableName() + " WHERE "
                                + whereClause;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                Set result = new HashSet();
                                try {
                                stmt = DB.prepare(sql);
                                rs = stmt.executeQuery();
                                result = loadAll(rs);
                                } catch (Exception e) {
                                throw new ApplicationException (e);
                                } finally {DB.cleanUp(stmt, rs);
                                }
                                return result;
                                }</pre>
                                Here Iâ€™m using a Unit of Work (184) that holds mappers indexed by the class
                                and a mapper that uses Metadata Mapping (306). The code is the same as that
                                in the example in Metadata Mapping (306) to save repeating the code in this
                                section.
                                To generate the where clause, the query iterates through the criteria and has
                                each one print itself out, tying them together with ANDs.
                                <pre>class QueryObject...
                                private String generateWhereClause() {
                                StringBuffer result = new StringBuffer();
                                for (Iterator it = criteria.iterator(); it.hasNext();) {
                                Criteria c = (Criteria)it.next();
                                if (result.length() != 0)
                                result.append(" AND ");
                                result.append(c.generateSql(uow.getMapper(klass).getDataMap()));
                                }
                                return result.toString();
                                }
                                class Criteria...
                                public String generateSql(DataMap dataMap) {
                                return dataMap.getColumnForField(field) + sqlOperator + value;
                                }
                                class DataMap...
                                public String getColumnForField (String fieldName) {
                                for (Iterator it = getColumns(); it.hasNext();) {
                                ColumnMap columnMap = (ColumnMap)it.next();
                                if (columnMap.getFieldName().equals(fieldName))
                                return columnMap.getColumnName();
                                }
                                throw new ApplicationException ("Unable to find column for " + fieldName);
                                }</pre>
                                As well as criteria with simple SQL operators, we can create more complex
                                criteria classes that do a little more. Consider a case-insensitive pattern match
                                query, like one that finds all people whose last names start with F. We can form
                                a query object for all people with such dependents.
                                <pre>QueryObject query = new QueryObject(Person.class);
                                query.addCriteria(Criteria.greaterThan("numberOfDependents", 0));
                                query.addCriteria(Criteria.matches("lastName", "f%"));</pre>
                                This uses a different criteria class that forms a more complex clause in the
                                where statement.
                                <pre>class Criteria...
                                public static Criteria matches(String fieldName, String pattern){
                                return new MatchCriteria(fieldName, pattern);
                                }
                                class MatchCriteria extends Criteria...
                                public String generateSql(DataMap dataMap) {
                                return "UPPER(" + dataMap.getColumnForField(field) + ") LIKE UPPER(â€™" + value + "â€™)";
                                }</pre></p>
                <h3 id="322">Repository</h3>
                <p>Mediates between the domain and data mapping layers using a
                                collection-like interface for accessing domain objects.
                                A system with a complex domain model often benefits from a layer, such as the
                                one provided by Data Mapper (165), that isolates domain objects from details
                                of the database access code. In such systems it can be worthwhile to build
                                another layer of abstraction over the mapping layer where query construction
                                code is concentrated. This becomes more important when there are a large
                                number of domain classes or heavy querying. In these cases particularly, adding
                                this layer helps minimize duplicate query logic.
                                A Repository mediates between the domain and data mapping layers, acting
                                like an in-memory domain object collection. Client objects construct query
                                specifications declaratively and submit them to Repository for satisfaction.
                                Objects can be added to and removed from the Repository, as they can from a
                                simple collection of objects, and the mapping code encapsulated by the Reposiclient
                                tory will carry out the appropriate operations behind the scenes. Conceptually,
                                a Repository encapsulates the set of objects persisted in a data store and the
                                operations performed over them, providing a more object-oriented view of the
                                persistence layer. Repository also supports the objective of achieving a clean
                                separation and one-way dependency between the domain and data mapping
                                layers.</p>
                <h3 id="323">How It Works</h3>
                <p>Repository is a sophisticated pattern that makes use of a fair number of the
                                other patterns described in this book. In fact, it looks like a small piece of an
                                object-oriented database and in that way itâ€™s similar to Query Object (316),
                                which development teams may be more likely to encounter in an object-relational mapping tool than to build themselves. However, if a team has taken the
                                leap and built Query Object (316), it isnâ€™t a huge step to add a Repository
                                capability. When used in conjunction with Query Object (316), Repository
                                adds a large measure of usability to the object-relational mapping layer without
                                a lot of effort.
                                In spite of all the machinery behind the scenes, Repository presents a simple
                                interface. Clients create a criteria object specifying the characteristics of the
                                objects they want returned from a query. For example, to find person objects
                                by name we first create a criteria object, setting each individual criterion like
                                so: criteria.equals(Person.LAST_NAME, "Fowler"), and criteria.like(Person.FIRST_NAME,
                                "M"). Then we invoke repository.matching(criteria) to return a list of domain
                                objects representing people with the last name Fowler and a first name starting
                                with M. Various convenience methods similar to matching (criteria) can be
                                defined on an abstract repository; for example, when only one match is
                                expected soleMatch(criteria) might return the found object rather than a collection. Other common methods include byObjectId(id), which can be trivially
                                implemented using soleMatch.</p>
                <p>To code that uses a Repository, it appears as a simple in-memory collection
                                of domain objects. The fact that the domain objects themselves typically arenâ€™t
                                stored directly in the Repository is not exposed to the client code. Of course,
                                code that uses Repository should be aware that this apparent collection of
                                objects might very well map to a product table with hundreds of thousands of
                                records. Invoking all() on a catalog systemâ€™s ProductRepository might not be such
                                a good idea.
                                Repository replaces specialized finder methods on Data Mapper (165)
                                classes with a specification-based approach to object selection [Evans and
                                Fowler]. Compare this with the direct use of Query Object (316), in which
                                client code may construct a criteria object (a simple example of the specification pattern), add() that directly to the Query Object (316), and execute the
                                query. With a Repository, client code constructs the criteria and then passes
                                them to the Repository, asking it to select those of its objects that match.
                                From the client codeâ€™s perspective, thereâ€™s no notion of query â€œexecutionâ€;
                                rather thereâ€™s the selection of appropriate objects through the â€œsatisfactionâ€
                                of the queryâ€™s specification. This may seem an academic distinction, but it
                                illustrates the declarative flavor of object interaction with Repository, which
                                is a large part of its conceptual power.</p>
                <p>Under the covers, Repository combines Metadata Mapping (329) with a
                                Query Object (316) to automatically generate SQL code from the criteria.
                                Whether the criteria know how to add themselves to a query, the Query Object
                                (316) knows how to incorporate criteria objects, or the Metadata Mapping
                                (306) itself controls the interaction is an implementation detail.
                                The object source for the Repository may not be a relational database at all,
                                which is fine as Repository lends itself quite readily to the replacement of the
                                data-mapping component via specialized strategy objects. For this reason it can
                                be especially useful in systems with multiple database schemas or sources for
                                domain objects, as well as during testing when use of exclusively in-memory
                                objects is desirable for speed.
                                Repository can be a good mechanism for improving readability and clarity in
                                code that uses querying extensively. For example, a browser-based system featuring a lot of query pages needs a clean mechanism to process HttpRequest
                                objects into query results. The handler code for the request can usually convert
                                the HttpRequest into a criteria object without much fuss, if not automatically;
                                submitting the criteria to the appropriate Repository should require only an
                                additional line or two of code.</p>
                <h3 id="324">When to Use It</h3>
                <p>In a large system with many domain object types and many possible queries,
                                Repository reduces the amount of code needed to deal with all the querying
                                that goes on. Repository promotes the Specification pattern (in the form of the
                                criteria object in the examples here), which encapsulates the query to be performed in a pure object-oriented way. Therefore, all the code for setting up a
                                query object in specific cases can be removed. Clients need never think in SQL
                                and can write code purely in terms of objects.
                                However, situations with multiple data sources are where we really see
                                Repository coming into its own. Suppose, for example, that weâ€™re sometimes
                                interested in using a simple in-memory data store, commonly when we wants to
                                run a suite of unit tests entirely in memory for better performance. With no
                                database access, many lengthy test suites run significantly faster. Creating fixture for unit tests can also be more straightforward if all we have to do is construct some domain objects and throw them in a collection rather than having
                                to save them to the database in setup and delete them at teardown.</p>
                <p>Itâ€™s also conceivable, when the application is running normally, that certain
                                types of domain objects should always be stored in memory. One such example
                                is immutable domain objects (those that canâ€™t be changed by the user), which
                                once in memory, should remain there and never be queried for again. As weâ€™ll
                                see later in this chapter, a simple extension to the Repository pattern allows different querying strategies to be employed depending on the situation.
                                Another example where Repository might be useful is when a data feed is
                                used as a source of domain objectsâ€”say, an XML stream over the Internet, perhaps using SOAP, might be available as a source. An XMLFeedRepositoryStrategy
                                might be implemented that reads from the feed and creates domain objects
                                from the XML.</p>
                <h3 id="325">Further Reading</h3>
                <p>The specification pattern hasnâ€™t made it into a really good reference source yet.
                                The best published description so far is [Evans and Fowler]. A better description is currently in the works in [Evans].</p>
                <h3 id="325(2)">Example: Finding a Personâ€™s Dependents (Java)</h3>
                <p>From the client objectâ€™s perspective, using a Repository is simple. To retrieve its
                                dependents from the database a person object creates a criteria object representing the search criteria to be matched and sends it to the appropriate Repository.
                                <pre>public class Person {
                                public List dependents() {
                                Repository repository = Registry.personRepository();
                                Criteria criteria = new Criteria();
                                criteria.equal(Person.BENEFACTOR, this);
                                return repository.matching(criteria);
                                }
                                }</pre>
                                Common queries can be accommodated with specialized subclasses of
                                Repository. In the previous example we might make a PersonRepository subclass
                                of Repository and move the creation of the search criteria into the Repository
                                itself.
                                <pre>public class PersonRepository extends Repository {
                                public List list dependentsOf(Person aPerson) {
                                Criteria criteria = new Criteria();
                                criteria.equal(Person.BENEFACTOR, aPerson);
                                return matching(criteria);
                                }
                                }
                                The person object then calls the dependents() method directly on its Repository.
                                public class Person {
                                public List dependents() {
                                return Registry.personRepository().dependentsOf(this);
                                }
                                }</pre></p>
                <h3 id="326">Example: Swapping Repository Strategies (Java)</h3>
                <p>Because Repositoryâ€™s interface shields the domain layer from awareness of the
                                data source, we can refactor the implementation of the querying code inside the
                                Repository without changing any calls from clients. Indeed, the domain code
                                neednâ€™t care about the source or destination of domain objects. In the case of
                                the in-memory store, we want to change the matching() method to select from a
                                collection of domain objects the ones satisfy the criteria. However, weâ€™re not
                                interested in permanently changing the data store used but rather in being able
                                to switch between data stores at will. From this comes the need to change the
                                implementation of the matching() method to delegate to a strategy object that
                                does the querying. The power of this, of course, is that we can have multiple
                                strategies and we can set the strategy as desired. In our case, itâ€™s appropriate to
                                have two: RelationalStrategy, which queries the database, and InMemoryStrategy,
                                which queries the in-memory collection of domain objects. Each strategy implements the RepositoryStrategy interface, which exposes the matching() method, so
                                we get the following implementation of the Repository class:
                                <pre>abstract class Repository {
                                private RepositoryStrategy strategy;
                                protected List matching(Criteria aCriteria) {
                                return strategy.matching(aCriteria);
                                }
                                }</pre>
                                A RelationalStrategy implements matching() by creating a Query Object from
                                the criteria and then querying the database using it. We can set it up with the
                                appropriate fields and values as defined by the criteria, assuming here that the
                                Query Object knows how to populate itself from criteria:
                                <pre>public class RelationalStrategy implements RepositoryStrategy {
                                protected List matching(Criteria criteria) {
                                Query query = new Query(myDomainObjectClass())
                                query.addCriteria(criteria);
                                return query.execute(unitOfWork());
                                }
                                }</pre>
                                An InMemoryStrategy implements matching() by iterating over a collection of
                                domain objects and asking the criteria at each domain object if itâ€™s satisfied by
                                it. The criteria can implement the satisfaction code using reflection to interrogate the domain objects for the values of specific fields. The code to do the
                                selection looks like this:
                                <pre>public class InMemoryStrategy implements RepositoryStrategy {
                                private Set domainObjects;
                                protected List matching(Criteria criteria) {
                                List results = new ArrayList();
                                Iterator it = domainObjects.iterator();
                                while (it.hasNext()) {
                                DomainObject each = (DomainObject) it.next();
                                if (criteria.isSatisfiedBy(each))
                                results.add(each);
                                }
                                return results;
                                }
                                }</pre></p>
                <h3 id="329">Chapter 14</h3>
                <h2>Web Presentation Patterns</h2>
                <h3 id="330">Model View Controller</h3>
                <p>Splits user interface interaction into three distinct roles.
                                Model View Controller (MVC) is one of the most quoted (and most misquoted)
                                patterns around. It started as a framework developed by Trygve Reenskaug for
                                the Smalltalk platform in the late 1970s. Since then it has played an influential
                                role in most UI frameworks and in the thinking about UI design.</p>
                <h3 id="330(2)">How It Works</h3>
                <p>MVC considers three roles. The model is an object that represents some
                                information about the domain. Itâ€™s a nonvisual object containing all the data
                                and behavior other than that used for the UI. In its most pure OO form the
                                model is an object within a Domain Model (116). You might also think of a
                                Transaction Script (110) as the model providing that it contains no UI
                                machinery. Such a definition stretches the notion of model, but fits the role
                                breakdown of MVC.</p>
                <p>The view represents the display of the model in the UI. Thus, if our model is
                                a customer object our view might be a frame full of UI widgets or an HTML
                                page rendered with information from the model. The view is only about display
                                of information; any changes to the information are handled by the third member of the MVC trinity: the controller. The controller takes user input, manipulates the model, and causes the view to update appropriately. In this way UI is a
                                combination of the view and the controller.
                                As I think about MVC I see two principal separations: separating the presentation from the model and separating the controller from the view.
                                Of these the separation of presentation from model is one of the most fundamental heuristics of good software design. This separation is important for several reasons.
                <ul>
                        <li>Fundamentally presentation and model are about different concerns. When youâ€™re developing a view youâ€™re thinking about the mechanisms of UI and how to lay out a good user interface. When youâ€™re working with a model you are thinking about business policies, perhaps database interactions. Certainly you will use different very different libraries when working with one or he other. Often people prefer one area to another and they specialize in one side of the line.</li>
                        <li>Depending on context, users want to see the same basic model information in different ways. Separating presentation and view allows you to develop multiple presentationsâ€”indeed, entirely different interfacesâ€”and yet use the same model code. Most noticeably this could be providing the same model with a rich client, a Web browser, a remote API, and a command-line interface. Even within a single Web interface you might have different customer pages at different points in an application.</li>
                        <li>Nonvisual objects are usually easier to test than visual ones. Separating presentation and model allows you to test all the domain logic easily without resorting to things like awkward GUI scripting tools.</li>
                </ul>
                                A key point in this separation is the direction of the dependencies: the presentation depends on the model but the model doesnâ€™t depend on the presentation. People programming in the model should be entirely unaware of what
                                presentation is being used, which both simplifies their task and makes it easier
                                to add new presentations later on. It also means that presentation changes can
                                be made freely without altering the model.</p>
                <p>This principle introduces a common issue. With a rich-client interface of
                                multiple windows itâ€™s likely that there will be several presentations of a model
                                on a screen at once. If a user makes a change to the model from one presentation, the others need to change as well. To do this without creating a dependency you usually need an implementation of the Observer pattern [Gang of
                                Four], such as event propagation or a listener. The presentation acts as the
                                observer of the model: whenever the model changes it sends out an event and
                                the presentations refresh the information.</p>
                <p>The second division, the separation of view and controller, is less important.
                                Indeed, the irony is that almost every version of Smalltalk didnâ€™t actually make
                                a view/controller separation. The classic example of why youâ€™d want to separate them is to support editable and noneditable behavior, which you can do
                                with one view and two controllers for the two cases, where the controllers are
                                strategies [Gang of Four] for the view. In practice most systems have only one
                                controller per view, however, so this separation is usually not done. It has come
                                back into vogue with Web interfaces where it becomes useful for separating the
                                controller and view again.
                                The fact that most GUI frameworks combine view and controller has led to
                                many misquotations of MVC. The model and the view are obvious, but whereâ€™s
                                the controller? The common idea is that it sits between the model and the view,
                                as in the Application Controller (379)â€”it doesnâ€™t help that the word â€œcontrollerâ€ is used in both contexts. Whatever the merits of a Application Controller
                                (379), itâ€™s a very different beast from an MVC controller.
                                For the purposes of this set of patterns these principles are really all you need
                                to know. If you want to dig deeper into MVC the best available reference is
                                [POSA].</p>
                <h3 id="332">When to Use It</h3>
                <p>As I said, the value of MVC lies in its two separations. Of these the separation
                                of presentation and model is one of the most important design principles in
                                software, and the only time you shouldnâ€™t follow it is in very simple systems
                                where the model has no real behavior in it anyway. As soon as you get some
                                nonvisual logic you should apply the separation. Unfortunately, a lot of UI
                                frameworks make it difficult, and those that donâ€™t are often taught without a
                                separation.
                                The separation of view and controller is less important, so Iâ€™d only recommend doing it when it is really helpful. For rich-client systems, that ends up
                                being hardly ever, although itâ€™s common in Web front ends where the controller
                                is separated out. Most of the patterns on Web design here are based on that
                                principle.</p>
                <h3 id="333">Page Controller</h3>
                <p>An object that handles a request for a specific
                                page or action on a Web site.
                                Most peopleâ€™s basic Web experience is with static HTML pages. When you
                                request static HTML you pass to the Web server the name and path for a
                                HTML document stored on it. The key notion is that each page on the Web site
                                is a separate document on the server. With dynamic pages things can get much
                                more interesting since thereâ€™s a much more complex relationship between path
                                names and the file that responds. However, the approach of one path leading to
                                one file that handles the request is a simple model to understand.
                                As a result, Page Controller has one input controller for each logical page of
                                the Web site. That controller may be the page itself, as it often is in server page
                                environments, or it may be a separate object that corresponds to that page.</p>
                <h3 id="333(2)">How It Works</h3>
                <p>The basic idea behind a Page Controller is to have one module on the Web
                                server act as the controller for each page on the Web site. In practice, it doesnâ€™t
                                work out to exactly one module per page, since you may hit a link sometimes
                                and get a different page depending on dynamic information. More strictly, the
                                controllers tie in to each action, which may be clicking a link or a button.
                                The Page Controller can be structured either as a script (CGI script, servlet,
                                etc.) or as a server page (ASP, PHP, JSP, etc.). Using a server page usually combines the Page Controller and a Template View (350) in the same file. This
                                works well for the Template View (350) but less well for the Page Controller
                                because itâ€™s more awkward to properly structure the module. If the page is a
                                simple display, this isnâ€™t a problem. However, if thereâ€™s logic involved in either
                                pulling data out of the request or deciding which actual view to display, then
                                you can end up with awkward scriptlet code in the server page.</p>
                <p>One way of dealing with scriptlet code is to use a helper object. In this case
                                the first thing the server page does is call the helper object to handle all the
                                logic. The helper may return control to the original server page, or it may forward to a different server page to act as the view, in which case the server page
                                is the request handler but most of the controller logic lies in the helper.
                                Another approach is to make a script the handler and controller. The Web
                                server passes control to the script; the script carries out the controllerâ€™s responsibilities and finally forwards to an appropriate view to display any results.
                                The basic responsibilities of a Page Controller are:
                <ul>
                        <li>Decode the URL and extract any form data to figure out all the data for the action.</li>
                        <li>Create and invoke any model objects to process the data. All relevant data from the HTML request should be passed to the model so that the model objects donâ€™t need any connection to the HTML request.</li>
                        <li>Determine which view should display the result page and forward the model information to it.</li>
                </ul>
                                The Page Controller neednâ€™t be a single class but can invoke helper objects.
                                This is particularly useful if several handlers have to do similar tasks. A helper
                                class can then be a good spot to put any code that would otherwise be duplicated.
                                Thereâ€™s no reason that you canâ€™t have some URLs handled by server pages
                                and some by scripts. Any URLs that have little or no controller logic are best
                                handled with a server page, since that provides a simple mechanism thatâ€™s easy
                                to understand and modify. Any URLs with more complicated logic go to a
                                script. Iâ€™ve come across teams who want to handle everything the same way: all
                                server page or everything is a script. Any advantages of consistency in such an
                                application are usually offset by the problems of either scriptlet-laden server
                                pages or lots of simple pass-through scripts.</p>
                <h3 id="334">When to Use It</h3>
                                The main decision point is whether to use Page Controller or Front Controller
                                (344). Of the two, Page Controller is the most familiar to work with and leads
                                to a natural structuring mechanism where particular actions are handled by
                                particular server pages or script classes. Your trade-off is thus the greater complexity of Front Controller (344) against the various advantages of Front Con
                                troller, most of which make a difference in Web sites that have more navigational
                                complexity.
                                Page Controller works particularly well in a site where most of the controller
                                logic is pretty simple. In this case most URLs can be handled with a server page
                                and the more complicated cases with helpers. When your controller logic is simple, Front Controller (344) adds a lot of overhead.
                                Itâ€™s not uncommon to have a site where some requests are dealt with by Page
                                Controllers and others are dealt with by Front Controllers (344), particularly
                                when a team is refactoring from one to another. Actually, the two patterns mix
                                without too much trouble.</p>
                <h3 id="335">Example: Simple Display with a Servlet Controller and a JSP View (Java)</h3>
                <p>A simple example of an Page Controller displays some information about
                                something. Here weâ€™ll show it displaying some information about a recording artist. The URL runs along the lines of http://www.thingy.com/recordingApp/
                                artist?name=danielaMercury.
                                Figure 14.1 Classes involved in a simple display with a Page Controller servlet and a
                                The Web server needs to be configured to recognize /artist as a call to ArtistController. In Tomcat you do this with the following code in the web.xml file:
                                <pre><servlet>
                                <servlet-name>artist</servlet-name>
                                <servlet-class>actionController.ArtistController</servlet-class>
                                </servlet>
                                <servlet-mapping>
                                <servlet-name>artist</servlet-name>
                                <url-pattern>/artist</url-pattern>
                                </servlet-mapping></pre>
                                The artist controller needs to implement a method to handle the request.
                                <pre>class ArtistController...
                                public void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException {
                                Artist artist = Artist.findNamed(request.getParameter("name"));
                                if (artist == null)
                                forward("/MissingArtistError.jsp", request, response);
                                else {
                                request.setAttribute("helper", new ArtistHelper(artist));
                                forward("/artist.jsp", request, response);
                                }
                                }</pre>
                                Although this is a very simple case, it covers the salient points. First the controller needs to create the necessary model objects to do their thing, here just
                                finding the correct model object to display. Second it puts the right information
                                in the HTTP request so that the JSP can display it properly. In this case it creates a helper and puts it into the request. Finally it forwards to the Template
                                View (350) to handle the display. Forwarding is a common behavior, so it sits
                                naturally on a superclass for all Page Controllers.
                                <pre>class ActionServlet...
                                protected void forward(String target,
                                HttpServletRequest request,
                                HttpServletResponse response)
                                throws IOException, ServletException
                                {
                                RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(target);
                                dispatcher.forward(request, response);
                                }</pre>
                                The main point of coupling between the Template View (350) and the Page
                                Controller is the parameter names in the request to pass on any objects that the
                                JSP needs.
                                The controller logic here is really very simple, but as it gets more complex we
                                can continue to use the servlet as a controller. We can have a similar behavior
                                for albums, with the twist that classical albums both have a different model
                                object and are rendered with a different JSP. To do this behavior we can again
                                use a controller class.
                                <pre>class AlbumController...
                                public void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException
                                {
                                Album album = Album.find(request.getParameter("id"));
                                if (album == null) {
                                forward("/missingAlbumError.jsp", request, response);
                                return;
                                }
                                request.setAttribute("helper", album);
                                if (album instanceof ClassicalAlbum)
                                forward("/classicalAlbum.jsp", request, response);
                                else
                                forward("/album.jsp", request, response);
                                }</pre>
                                Notice that in this case Iâ€™m using the model objects as helpers rather than creating a separate helper class. This is worth doing if a helper class is just a dumb
                                forwarder to the model class. If you do it, though, make sure that the model
                                class doesnâ€™t contain any servlet-dependent code. Any servlet-dependent code
                                should be in a separate helper class.</p>
                <h3 id="337">Example: Using a JSP as a Handler (Java)</h3>
                <p>Using a servlet as a controller is one route to take, but the most common route
                                is to make the server page itself the controller. The problem with this approach
                                is that it results in scriptlet code at the beginning of the server page and, as you
                                may have gathered, I think that scriptlet code has the same relationship to welldesigned software that professional wrestling has to sport.
                                Despite this you can make a server page as the request handler while delegating control to the helper to actually carry out the controller function. This preserves the simple property of having your URLs denoted by server pages. Iâ€™ll do
                                this for the album display, using the URL of the form http://localhost:8080/isa/
                                album.jsp?id=zero. Most albums are displayed directly with the album JSP, but
                                classical recordings require a different display, a classical album JSP.
                                This controller behavior appears in a helper class to the JSP. The helper is set
                                up in the album JSP itself.
                                <pre>album.jsp...
                                <jsp:useBean id="helper" class="actionController.AlbumConHelper"/>
                                <%helper.init(request, response);%>
                                The call to init sets the helper up to carry out the controller behavior.
                                class AlbumConHelper extends HelperController...
                                public void init(HttpServletRequest request, HttpServletResponse response) {
                                super.init(request, response);
                                if (getAlbum() == null) forward("missingAlbumError.jsp", request, response);
                                if (getAlbum() instanceof ClassicalAlbum) {
                                request.setAttribute("helper", getAlbum());
                                forward("/classicalAlbum.jsp", request, response);
                                }
                                }
                                Common helper behavior naturally sits on a helper superclass.
                                class HelperController...
                                public void init(HttpServletRequest request, HttpServletResponse response) {
                                this.request = request;
                                this.response = response;
                                }
                                protected void forward(String target,
                                HttpServletRequest request,
                                HttpServletResponse response)
                                {
                                try {
                                RequestDispatcher dispatcher = request.getRequestDispatcher(target);
                                if (dispatcher == null) response.sendError(response.SC_NO_CONTENT);
                                else dispatcher.forward(request, response);
                                } catch (IOException e) {
                                throw new ApplicationException(e);
                                } catch (ServletException e) {
                                throw new ApplicationException(e);
                                }
                                }</pre>
                                The key difference between the controller behavior here and that when using
                                a servlet is that the handler JSP is also the default view and, unless the controller forwards to a different JSP, control reverts to the original handler. This is an
                                advantage when you have pages where the JSP directly acts as the view most of
                                the time and so thereâ€™s no forwarding to be done. The initialization of the
                                helper acts to kick off any model behavior and set things up for the view later
                                on. Itâ€™s a simple model to follow, since people generally associate a Web page
                                with the server page that acts as its view. Often this also fits naturally with Web
                                server configuration.
                                The call to initialize the handler is a little clumsy. In a JSP environment this
                                awkwardness can be much better handled with a custom tag. Such a tag can
                                automatically create an appropriate object, put it in the request, and initialize
                                it. With that all you need is a simple tag in the JSP page.
                                <pre><helper:init name = "actionController.AlbumConHelper"/>
                                The custom tagâ€™s implementation then does the work.
                                class HelperInitTag extends HelperTag...
                                private String helperClassName;
                                public void setName(String helperClassName) {
                                this.helperClassName = helperClassName;
                                }
                                public int doStartTag() throws JspException {
                                HelperController helper = null;
                                try {
                                helper = (HelperController) Class.forName(helperClassName).newInstance();
                                } catch (Exception e) {
                                throw new ApplicationException("Unable to instantiate " + helperClassName, e);
                                }
                                initHelper(helper);
                                pageContext.setAttribute(HELPER, helper);
                                return SKIP_BODY;
                                }
                                private void initHelper(HelperController helper) {
                                HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();
                                HttpServletResponse response = (HttpServletResponse) pageContext.getResponse();
                                helper.init(request, response);
                                }
                                class HelperTag...
                                public static final String HELPER = "helper";
                                If Iâ€™m going to use custom tags like this, I might as well make them for property access too.
                                class HelperGetTag extends HelperTag...
                                private String propertyName;
                                public void setProperty(String propertyName) {
                                this.propertyName = propertyName;
                                }
                                public int doStartTag() throws JspException {
                                try {
                                pageContext.getOut().print(getProperty(propertyName));
                                } catch (IOException e) {
                                throw new JspException("unable to print to writer");
                                }
                                return SKIP_BODY;
                                }
                                class HelperTag...
                                protected Object getProperty(String property) throws JspException {
                                Object helper = getHelper();
                                try {
                                final Method getter = helper.getClass().getMethod(gettingMethod(property), null);
                                return getter.invoke(helper, null);
                                } catch (Exception e) {
                                throw new JspException
                                ("Unable to invoke " + gettingMethod(property) + " - " + e.getMessage());
                                }
                                }
                                private Object getHelper() throws JspException {
                                Object helper = pageContext.getAttribute(HELPER);
                                if (helper == null) throw new JspException("Helper not found.");
                                return helper;
                                }
                                private String gettingMethod(String property) {
                                String methodName = "get" + property.substring(0, 1).toUpperCase() +
                                property.substring(1);
                                return methodName;
                                }</pre>
                                (You may think itâ€™s better to use the Java Beans mechanism than to just
                                invoke a getter using reflection. If so, youâ€™re probably right . . . and also probably intelligent enough to figure out how to change the method to do that.)
                                With the getting tag defined, I can use it to pull information out of the helper.
                                The tag is shorter and eliminates any chance of my mizpelling â€œhelper.â€</p>
                                <B><helper:get property = "title"/></B>
                <h3 id="340">Example: Page Handler with a Code Behind (C#)</h3>
                <p>The Web system in .NET is designed to work with the Page Controller and
                                Template View (350) patterns, although you can certainly decide to handle Web
                                events with a different approach. In this next example, Iâ€™ll use the preferred
                                style of .NET, building the presentation layer on top of a domain using Table
                                Module (125) and using data sets as the main carrier of information between
                                layers.
                                This time weâ€™ll have a page that displays runs scored and the run rate for one
                                innings of a cricket match. As I know Iâ€™ll have many readers who are afflicted
                                with no material experience of this art form, let me summarize by saying that
                                the runs scored are the score of the batsman and the run rate is how many runs
                                he scores divided by the number of balls he faces. The runs scored and balls
                                faced are in the database; the run rate needs to be calculated by the applicationâ€”a tiny but pedagogically useful piece of domain logic.
                                The handler in this design is an ASP.NET Web page, captured in a .aspx file.
                                As with other server page constructs, this file allows you to embed programming logic directly into the page as scriptlets. Since you know Iâ€™d rather drink
                                bad beer than write scriptlets, you know thereâ€™s little chance that Iâ€™d do that.
                                My savior in this case is ASP.NETâ€™s code behind mechanism that allows you to
                                associate a regular file and class with the aspx page, signaled in the header of
                                the aspx page.
                                <%@ Page language="c#" Codebehind="bat.aspx.cs" AutoEventWireup="false" trace="False"
                                Inherits="batsmen.BattingPage" %></p>
                <p>The page is set up as a subclass of the code behind class, and as such can use
                                all its protected properties and methods. The page object is the handler of the
                                request, and the code behind can define the handling by defining a Page_Load
                                method. If most pages follow a common flow, I can define a Layer Supertype
                                (475) that has a template method [Gang of Four] for this.
                                <pre>class CricketPage...
                                protected void Page_Load(object sender, System.EventArgs e) {
                                db = new OleDbConnection(DB.ConnectionString);
                                if (hasMissingParameters())
                                errorTransfer (missingParameterMessage);
                                DataSet ds = getData();
                                if (hasNoData (ds))
                                errorTransfer ("No data matches your request");
                                applyDomainLogic (ds);
                                DataBind();
                                prepareUI(ds);
                                }</pre>
                                The template method breaks down the request handling into a number of common steps. This way we can define a single common flow for handling Web
                                requests, while allowing each Page Controller to supply implementations for the
                                specific steps. If you do this, once youâ€™ve written a few Page Controllers, youâ€™ll
                                know what common flow to use for the template method. If any page needs to do
                                something completely different, it can always override the page load method.
                                The first task is to do validation on the parameters coming into the page. In a
                                more realistic example this might entail initial sanity checking of various form
                                values, but in this case weâ€™re just decoding a URL of the form http://localhost/
                                batsmen/bat.aspx?team=England&innings=2&match=905. The only validation in this example
                                is that the various parameters required for the database query are present. As
                                usual Iâ€™ve been overly simplistic in the error handling until somebody writes a
                                good set of patterns on validationâ€”so here the particular page defines a set of
                                mandatory parameters and the Layer Supertype (475) has the logic for checking
                                them.
                                <pre>class CricketPage...
                                abstract protected String[] mandatoryParameters();
                                private Boolean hasMissingParameters() {
                                foreach (String param in mandatoryParameters())
                                if (Request.Params[param] == null) return true;
                                return false;
                                }
                                private String missingParameterMessage {
                                get {
                                String result = "<P>This page is missing mandatory parameters:</P>";
                                result += "<UL>";
                                foreach (String param in mandatoryParameters())
                                if (Request.Params[param] == null)
                                result += String.Format("<LI>{0}</LI>", param);
                                result += "</UL>";
                                return result;
                                }
                                }
                                protected void errorTransfer (String message) {
                                Context.Items.Add("errorMessage", message);
                                Context.Server.Transfer("Error.aspx");
                                }
                                class BattingPage...
                                override protected String[] mandatoryParameters() {
                                String[] result = {"team", "innings", "match"};
                                return result;
                                }</pre>
                                The next stage is to pull the data out of the database and put it in an
                                ADO.NET disconnected data set object. Here this is a single query to the batting table.
                                <pre>class CricketPage...
                                abstract protected DataSet getData();
                                protected Boolean hasNoData(DataSet ds) {
                                foreach (DataTable table in ds.Tables)
                                if (table.Rows.Count != 0) return false;
                                return true;
                                }
                                class BattingPage...
                                override protected DataSet getData() {
                                OleDbCommand command = new OleDbCommand(SQL, db);
                                command.Parameters.Add(new OleDbParameter("team", team));
                                command.Parameters.Add(new OleDbParameter("innings", innings));
                                command.Parameters.Add(new OleDbParameter("match", match));
                                OleDbDataAdapter da = new OleDbDataAdapter(command);
                                DataSet result = new DataSet();
                                da.Fill(result, Batting.TABLE_NAME);
                                return result;
                                }
                                private const String SQL =
                                @"SELECT * from batting
                                WHERE team = ? AND innings = ? AND matchID = ?
                                ORDER BY battingOrder";</pre>
                                Now the domain logic gets its turn to play, organized as a Table Module
                                (125). The controller passes the retrieved data set to the Table Module (125) for
                                processing.
                                <pre>class CricketPage...
                                protected virtual void applyDomainLogic (DataSet ds) {}
                                class BattingPage...
                                override protected void applyDomainLogic (DataSet dataSet) {
                                batting = new Batting(dataSet);
                                batting.CalculateRates();
                                }</pre>
                                At this point the controller part of the page handler is done. By this I mean,
                                in classic Model View Controller (330) terms, that the controller should now
                                hand over to the view to do display. In this design the BattingPage acts as both
                                the controller and the view and the last call to prepareUI is part of the view
                                behavior. I can now say farewell to this example in this pattern. However, I suspect youâ€™ll find this to lack a certain dramatic closure, so you can find the example continued later (page 350).</p>
                <h3 id="344">Front Controller</h3>
                <p>A controller that handles all requests for a Web site.
                                In a complex Web site there are many similar things you need to do when handling a request. These things include security, internationalization, and providing particular views for certain users. If the input controller behavior is
                                scattered across multiple objects, much of this behavior can end up duplicated.
                                Also, itâ€™s difficult to change behavior at runtime.
                                The Front Controller consolidates all request handling by channeling
                                requests through a single handler object. This object can carry out common
                                behavior, which can be modified at runtime with decorators. The handler then
                                dispatches to command objects for behavior particular to a request.</p>
                <h3 id="344(2)">How It Works</h3>
                <p>A Front Controller handles all calls for a Web site, and is usually structured in
                                two parts: a Web handler and a command hierarchy. The Web handler is the
                                object that actually receives post or get requests from the Web server. It pulls
                                just enough information from the URL and the request to decide what kind of
                                action to initiate and then delegates to a command to carry out the action (see
                                The Web handler is almost always implemented as a class rather than as a
                                server page, as it doesnâ€™t produce any response. The commands are also classes
                                rather than server pages and in fact donâ€™t need any knowledge of the Web environment, although theyâ€™re often passed the HTTP information. The Web handler itself is usually a fairly simple program that does nothing other than decide
                                which command to run.
                                The Web handler can decide which command to run either statically or
                                dynamically. The static version involves parsing the URL and using conditional
                                logic; the dynamic version usually involves taking a standard piece of the URL
                                and using dynamic instantiation to create a command class.
                                The static case has the advantage of explicit logic, compile time error checking on the dispatch, and lots of flexibility in the look of your URLs. The
                                dynamic case allows you to add new commands without changing the Web
                                handler.</p>
                <p>With dynamic invocation you can put the name of the command class into
                                the URL or you can use a properties file that binds URLs to command class
                                names. The properties file is another file to edit, but it does make it easier to
                                change your class names without a lot of searching through your Web pages.
                                A particularly useful pattern to use in conjunction with Front Controller is
                                Intercepting Filter, described in [Alur et al.]. This is essentially a decorator that
                                wraps the handler of the front controller allowing you to build a filter chain (or
                                pipeline of filters) to handle issues such as authentication, logging, and locale
                                identification. Using filters allows you to dynamically set up the filters to use at
                                configuration time.
                                Rob Mee showed me an interesting variation of Front Controller using a
                                two stage Web handler separated into a degenerate Web handler and a dispatcher. The degenerate Web handler pulls the basic data out of the http
                                parameters and hands it to the dispatcher in such a way that the dispatcher is
                                completely independent of the Web server framework. This makes testing easier because test code can drive the dispatcher directly without having to run in
                                a Web server.
                                Remember that both the handler and the commands are part of the controller. As a result the commands can (and should) choose which view to use for the
                                response. The only responsibility of the handler is in choosing which command
                                to execute. Once thatâ€™s done, it plays no further part in that request.</p>
                <h3 id="346">When to Use It</h3>
                <p>The Front Controller is a more complicated design than its obvious counterpart,
                                Page Controller (333). It therefore needs a few advantages to be worth the effort.
                                Only one Front Controller has to be configured into the Web server; the Web
                                handler does the rest of the dispatching. This simplifies the configuration of the
                                Web server, which is an advantage if the Web server is awkward to configure.
                                With dynamic commands you can add new commands without changing anything. They also ease porting since you only have to register the handler in a
                                Web-server-specific way.
                                Because you create new command objects with each request, you donâ€™t
                                have to worry about making the command classes thread-safe. In this way
                                you avoid the headaches of multi-threaded programming; however, you do
                                have to make sure that you donâ€™t share any other objects, such as the model
                                objects.</p>
                <p>A commonly stated advantage of a Front Controller is that it allows you to
                                factor out code thatâ€™s otherwise duplicated in Page Controller (333). To be fair,
                                however, you can also do much of this with a superclass Page Controller (333).
                                Thereâ€™s just one controller, so you can easily enhance its behavior at runtime
                                with decorators [Gang of Four]. You can have decorators for authentication,
                                character encoding, internationalization, and so forth, and add them using a
                                configuration file or even while the server is running. ([Alur et al.] describe this
                                approach in detail under the name Intercepting Filter.)</p>
                <h3 id="347">Further Reading</h3>
                <p>[Alur et al.] give a detailed description of how to implement Front Controller in
                                Java. They also describe Intercepting Filter, which goes very well with Front
                                Controller.
                                A number of Java Web frameworks use this pattern. An excellent example
                                appears in [Struts].</p>
                <h3 id="347(2)">Example: Simple Display (Java)</h3>
                <p>Hereâ€™s a simple case of using Front Controller for the original and innovative task
                                of displaying information about a recording artist. Weâ€™ll use dynamic commands
                                with a URL of the form http://localhost:8080/isa/music?name=barelyWorks&command=
                                Artist. The command parameter tells the Web handler which command to use.
                                Figure 14.3 The classes that implement Front Controller.
                                Weâ€™ll begin with the handler, which Iâ€™ve implemented as a servlet.
                                <pre>class FrontServlet...
                                public void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException {
                                FrontCommand command = getCommand(request);
                                command.init(getServletContext(), request, response);
                                command.process();
                                }
                                private FrontCommand getCommand(HttpServletRequest request) {
                                try {
                                return (FrontCommand) getCommandClass(request).newInstance();
                                } catch (Exception e) {
                                throw new ApplicationException(e);
                                }
                                }
                                private Class getCommandClass(HttpServletRequest request) {
                                Class result;
                                final String commandClassName =
                                "frontController." + (String) request.getParameter("command") + "Command";
                                try {
                                result = Class.forName(commandClassName);
                                } catch (ClassNotFoundException e) {
                                result = UnknownCommand.class;
                                }
                                return result;
                                }</pre>
                                The logic is straightforward. The handler tries to instantiate a class named by
                                concatenating the command name and â€œCommand.â€ Once it has the new command it initializes it with the necessary information from the HTTP server. Iâ€™ve
                                passed in what I need for this simple example. You may well need more, such as
                                the HTTP session. If you canâ€™t find a command, Iâ€™ve used the Special Case (496)
                                pattern and returned an unknown command. As is often the case, Special Case
                                (496) allows you to avoid a lot of extra error checking.
                                Commands share a fair bit of data and behavior. They all need to be initialized with information from the Web server.
                                <pre>class FrontCommand...
                                protected ServletContext context;
                                protected HttpServletRequest request;
                                protected HttpServletResponse response;
                                public void init(ServletContext context,
                                HttpServletRequest request,
                                HttpServletResponse response)
                                {
                                this.context = context;
                                this.request = request;
                                this.response = response;
                                }</pre>
                                They can also provide common behavior, such as a forward method, and define
                                an abstract process command for the actual commands to override.
                                <pre>class FrontCommand...
                                abstract public void process()throws ServletException, IOException ;
                                protected void forward(String target) throws ServletException, IOException
                                {
                                RequestDispatcher dispatcher = context.getRequestDispatcher(target);
                                dispatcher.forward(request, response);
                                }
                                The command object is very simple, at least in this case. It just implements
                                the process method, which involves invoking the appropriate behavior on the
                                model objects, putting the information needed for the view into the request,
                                and forwarding to a Template View (350).
                                class ArtistCommand...
                                public void process() throws ServletException, IOException {
                                Artist artist = Artist.findNamed(request.getParameter("name"));
                                request.setAttribute("helper", new ArtistHelper(artist));
                                forward("/artist.jsp");
                                }
                                The unknown command just brings up a boring error page.
                                class UnknownCommand...
                                public void process() throws ServletException, IOException {
                                forward("/unknown.jsp");
                                }</pre></p>
                <h3 id="350">Template View</h3>
                <p>Renders information into HTML by
                                embedding markers in an HTML page.
                                Writing a program that spits out HTML is often more difficult than you might
                                imagine. Although programming languages are better at creating text than
                                they used to be (some of us remember character handling in Fortran and standard Pascal), creating and concatenating string constructs is still painful. If
                                there isnâ€™t much to do, it isnâ€™t too bad, but a whole HTML page is a lot of text
                                manipulation.
                                With static HTML pagesâ€”those that donâ€™t change from request to requestâ€”
                                you can use nice WYSIWG editors. Even those of us who like raw text editors
                                find it easier to just type in the text and tags rather than fiddle with string concatenation in a programming language.
                                Of course the issue is with dynamic Web pagesâ€”those that take the results
                                of something like database queries and embed them into the HTML. The page
                                looks different with each result, and as a result regular HTML editors arenâ€™t up
                                to the job.</p>
                <p>The best way to work is to compose the dynamic Web page as you do a static
                                page but put in markers that can be resolved into calls to gather dynamic information. Since the static part of the page acts as a template for the particular
                                response, I call this a Template View.
                                <pre>Book
                                Author
                                Model
                                <HTML><P><B>
                                <jsp:getProperty
                                name="bookHelper"
                                property="title"/></B>
                                <BR/>
                                Author:
                                <jsp:getProperty
                                name="bookHelper"
                                property="author"/>
                                </P>
                                </HTML>
                                getTitle
                                getAuthor
                                Book Helper</pre></p>
                <h3 id="351">How It Works</h3>
                <p>The basic idea of Template View is to embed markers into a static HTML page
                                when itâ€™s written. When the page is used to service a request, the markers are
                                replaced by the results of some computation, such as a database query. This
                                way the page can be laid out in the usual manner, often with WYSIWYG editors, often by people who arenâ€™t programmers. The markers then communicate
                                with real programs to put in the results.
                                A lot of tools use Template View. As a result this pattern isnâ€™t about how to
                                build one yourself, but about how to use one effectively and what the alternative is.
                                Embedding the Markers There are a number of ways markers can be placed in
                                the HTML. One is to use HTML-like tags. This works well with WYSIWYG
                                editors because they realize that anything between the angled brackets (<>) is
                                special and so either ignore it or treat it differently. If the tags follow the rules
                                for well-formed XML you can also use XML tools on the resulting document
                                (providing your HTML is XHMTL, of course).
                                Another way to do this is to use special text markers in the body text. WYSIWYG editors treat that as regular text, still ignoring it but probably doing
                                annoying things to it like spell checking. The advantage is that the syntax can
                                be easier than the clunky syntax of HTML/XML.</p>
                <p>Many environments provide the set of tags you use but more and more platforms now give you the ability to define your own tags and markers so you can
                                design them to fit in with your particular needs.
                                One of the most popular forms of Template View is a server page such as
                                ASP, JSP, or PHP. These actually go a step further than the basic form of a Template View in that they allow you to embed arbitrary programming logic,
                                referred to as scriptlets, into the page. In my view, however, this feature is actually a big problem and youâ€™re better off limiting yourself to basic Template
                                View behavior when you use server page technology.
                                The most obvious disadvantage of putting a lot of scriptlets into a page is
                                that it eliminates the possibility of nonprogrammers editing the page. This is
                                particularly important when youâ€™re using graphic designers for the page design.
                                However, the biggest problems of embedding scriptlets into the page come from
                                the fact that a page is poor module for a program. Even with an object-oriented
                                language the page construct loses you most of the structural features that make
                                it possible to do a modular design either in OO or in procedural style.
                                Even worse, putting a lot of scriptlets into the page makes it too easy to mingle the different layers of an enterprise application. When domain logic starts
                                turning up on server pages it becomes far too difficult to structure it well and
                                far too easy to duplicate it across different server pages. All in all, the worst
                                code Iâ€™ve seen in the last few years has been server page code.</p>
                <p>Helper Object The key to avoiding scriptlets is to provide a regular object as a
                                helper to each page. This helper has all the real programming logic. The page
                                only has calls into it, which simplifies the page and makes it a more pure Template View. The resulting simplicity allows nonprogrammers to edit the page
                                and programmers to concentrate on the helper. Depending on the actual tool
                                youâ€™re using, you can often reduce all the templates in a page to HTML/XML
                                tags, which keeps the page more consistent and more amenable to tool support.
                                This sounds like a simple and commendable principle, but as ever quite a few
                                dirty issues make things more complicated. The simplest markers are those that
                                get some information from the rest of the system and put in the correct place on
                                the page. They are easily translated into calls to the helper that result in text, (or
                                something thatâ€™s trivially turned into text), and the engine places the text on the
                                page.</p>
                <p>Conditional Display A more knotty issue is conditional page behavior. The
                                simplest case is the situation where something is displayed only if a condition is
                                true. That might be some kind of conditional tag along the lines of <IF condition
                                = "$pricedrop > 0.1"> ...show some stuff </IF>. The trouble with this is that when
                                you start having conditional tags like this, you start going down the path of
                                turning the templates into a programming language in and of themselves. This
                                leads you into all the same problems you face when you embed scriptlets in the
                                page. If you need a full programming language, you might as well use scriptlets,
                                but you know what I think of that idea!</p>
                <p>As a result, I see purely conditional tags as a bad smell, something you
                                should try to avoid. You canâ€™t always avoid them, but you should try to come
                                up with something more focused than a general purpose <IF> tag.
                                If youâ€™re displaying some text conditionally, one option is to move the condition into the helper. The page will then always insert the result of the call into
                                helper. Itâ€™s just that if the condition isnâ€™t true the helper will send back an empty
                                string, but this way the helper holds all the logic. This approach works best if
                                thereâ€™s no markup for the returned text or itâ€™s enough to return empty markup
                                that gets ignored by the browser.</p>
                <p>This doesnâ€™t work if, say, you want to highlight good-selling items in a list by
                                putting their names in bold. In such a situation you always need the names displayed but sometimes you want the special markup. One way to get it is to have
                                the helper generate the markup. This keeps all the logic out of the page, at the
                                cost of moving the choice of highlighting mechanism away from the page
                                designer and giving it to the programming code.
                                In order to keep the choice of HTML in the hands of the page design, you
                                need some form of conditional tag. However itâ€™s important to look beyond a
                                simple <IF>. A good route to go is a focused tag, so rather than a tag that looks
                                like this:
                                <pre><IF expression = "isHighSelling()"><B></IF>
                                <property name = "price"/>
                                <IF expression = "isHighSelling()"></B></IF>
                                you have one like
                                <highlight condition = "isHighSelling" style = "bold">
                                <property name = "price"/>
                                </highlight></pre>
                                In either case itâ€™s important that the condition be done based on a single Boolean property of the helper. Putting any more complex expression into the page
                                is actually putting the logic into the page itself.
                                Another example would be putting information on a page that depends on
                                the locale on which the system is running. Consider some text that should only
                                be shown in the United States or Canada, which, rather than
                                <pre><IF expression = "locale = 'US' || 'CA'"> ...special text </IF>
                                Would be something like
                                <locale includes = "US, CA"> ...special text </locale></pre>
                                Iteration Iterating over a collection presents similar issues. If you want a table
                                where each line corresponds to a line item on an order, you need a construct
                                that allows easy display of information for each line. Here itâ€™s hard to avoid a
                                general iteration over a collection tag, but it usually works simply enough to fit
                                in quite well.
                                Of course the kinds of tag you have to work with are often limited by the
                                environment youâ€™re in. Some environments give you a fixed set of templates,
                                in which case you may be more limited than you would like in following these
                                kinds of guidelines. In other environments, however, you may have more
                                choice in the tags to use; many of them even allow you to define your own tag
                                libraries.</p>
                <p>When to Process The name Template View brings out the fact that the primary
                                function of this pattern is to play the view in Model View Controller (330). For
                                many systems the Template View should only play the view. In simpler systems
                                it may be reasonable for it to play the controller, and possibly even the model,
                                although I would strive to separate model processing as much as possible.
                                Where Template View is taking on responsibilities beyond the view, itâ€™s important to ensure that these responsibilities are handled by the helper, not by the
                                page. Controller and model responsibilities involve program logic, which program logic everywhere, should sit in the helper.
                                Any template system needs extra processing by the Web server. This can
                                either be done by compiling the page after itâ€™s created, compiling the page or on
                                its first request, or by interpreting the page on each request. Obviously the latter
                                isnâ€™t a good idea if the interpretation takes a while to do.
                                One thing to watch with Template View is exceptions. If an exception works
                                its way up to the Web container, you may find yourself with a half-handled
                                page that provides some decidedly odd output to the calling browser instead of
                                a redirect. You need to look into how your Web server handles exceptions; if it
                                does something strange, catch all exceptions yourself in the helper class (yet
                                another reason to disdain scriptlets.)
                                Using Scripts Although server pages are one of the most common forms of
                                Template View these days, you can write scripts in a Template View style. Iâ€™ve
                                seen a fair bit of Perl done this way. Most noticeably demonstrated by perlâ€™s
                                CGI.pm, the trick is to avoid concatenating strings by having function calls that
                                output the appropriate tags to the response. This way you can write the script
                                in your programming language and avoid the mess of interspersing print strings
                                with programming logic.</p>
                <h3 id="354">When to Use It</h3>
                <p>For implementing the view in Model View Controller (330) the main choice is
                                between Template View and Transform View (361). The strength of Template
                                View is that it allows you to compose the content of the page by looking at the
                                page structure. This seems to be easier for most people to do and to learn. In
                                particular it nicely supports the idea of a graphic designer laying out a page
                                with a programmer working on the helper.
                                Template View has two significant weaknesses. First, the common implementations make it too easy to put complicated logic in the page, thus making it
                                hard to maintain, particularly by nonprogrammers. You need good discipline to
                                keep the page simple and display oriented, putting logic in the helper. The second weakness is that Template View is harder to test than Transform View
                                (361). Most implementations of Template View are designed to work within a
                                Web server and are very difficult or impossible to test otherwise. Transform
                                View (361) implementations are much easier to hook into a testing harness and
                                test without a running Web server.</p>
                <p>In thinking about a view you also need to consider Two Step View (365).
                                Depending on your template scheme you may be able to implement this pattern
                                using specialized tags. However, you may find it easier to implement it based on
                                a Transform View (361). If youâ€™re going to need Two Step View (365) you need
                                to take that into account in your choice.</p>
                <h3 id="355">Example: Using a JSP as a View with a Separate Controller (Java)</h3>
                <p>When using a JSP as a view only, itâ€™s always be invoked from a controller rather
                                than directly from the servlet container. Thus, itâ€™s important to pass to the JSP
                                any information it will need to figure out what to display. A good way to do
                                this is to have the controller create a helper object and pass it to the JSP using
                                the HTTP request. Weâ€™ll show this with the simple display example from Page
                                Controller (333). The Web-handling method for the servlet looks like this:
                                <pre>class ArtistController...
                                public void doGet(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException {
                                Artist artist = Artist.findNamed(request.getParameter("name"));
                                if (artist == null)
                                forward("/MissingArtistError.jsp", request, response);
                                else {
                                request.setAttribute("helper", new ArtistHelper(artist));
                                forward("/artist.jsp", request, response);
                                }
                                }</pre>
                                As far as the Template View is concerned the important behavior is creating
                                the helper and placing it in the request. The server page can now reach the
                                helper with the useBean tag.
                                <jsp:useBean id="helper" type="actionController.ArtistHelper" scope="request"/>
                                With the helper in place we can use it to access the information we need to
                                display. The model information the helper needs was passed to it when it was
                                created.
                                <pre>class ArtistHelper...
                                private Artist artist;
                                public ArtistHelper(Artist artist) {
                                this.artist = artist;
                                }</pre>
                                We can use the helper to get appropriate information from the model. In the
                                simplest case we provide a method to get some simple data, such as the artistâ€™s
                                name.
                                <pre>class ArtistHelper...
                                public String getName() {
                                return artist.getName();
                                }</pre>
                                Then we access this information by a Java expression.
                                <pre><B> <%=helper.getName()%></B></pre>
                                or a property
                                <pre><B><jsp:getProperty name="helper" property="name"/></B></pre>
                                The choice between properties or expressions depends on who is editing the
                                JSP. Programmers find expressions easy to read and more compact, but HTML
                                editors may not be able to handle them. Nonprogrammers will probably prefer
                                tags, since they fits in the general form of HTML and leave less room for confusing errors.
                                Using a helper is one way to remove awkward scriptlet code. If you want to
                                show a list of albums for an artist, you need to run a loop, which you can do
                                with a scriptlet in the server page.
                                <pre><UL>
                                <%
                                for (Iterator it = helper.getAlbums().iterator(); it.hasNext();) {
                                Album album = (Album) it.next();%>
                                <LI><%=album.getTitle()%></LI>
                                <% } %>
                                </UL></pre>
                                Frankly, this mix of Java and HTML is really horrible to read. An alternative is
                                to move the for loop to the helper.
                                <pre>class ArtistHelper...
                                public String getAlbumList() {
                                StringBuffer result = new StringBuffer();
                                result.append("<UL>");
                                for (Iterator it = getAlbums().iterator(); it.hasNext();) {
                                Album album = (Album) it.next();
                                result.append("<LI>");
                                result.append(album.getTitle());
                                result.append("</LI>");
                                }
                                result.append("</UL>");
                                return result.toString();
                                }
                                public List getAlbums() {
                                return artist.getAlbums();
                                }</pre>
                                I find this easier to follow because the amount of HTML is quite small. It also
                                allows you to use a property to get the list. Many people donâ€™t like putting
                                HTML code in helpers. While I prefer not to, given the choice between this and
                                scriptlets Iâ€™d choose HTML in helpers any day or night.
                                The best route to go is a specialized tag for iteration.
                                <pre><UL><tag:forEach host = "helper" collection = "albums" id = "each">
                                <LI><jsp:getProperty name="each" property="title"/></LI>
                                </tag:forEach></UL></pre>
                                This is a much nicer alternative as it keeps scriptlets out of the JSP and HTML
                                out of the helper.</p>
                <h3 id="357">Example: ASP.NET Server Page (C#)</h3>
                <p>This example continues the one I started in Page Controller (333) (page 340).
                                To remind you, it shows the scores made by batsmen in a single innings of a
                                cricket match. For those who think that cricket is a small noisy insect, Iâ€™ll pass
                                over the long rhapsodies about the worldâ€™s most immortal sport and boil it all
                                down to the fact that the page displays three essential pieces of information:
                <ul>
                        <li>An ID number to reference the match</li>
                        <li>Which teamâ€™s scores are shown and which innings the scores are for</li>
                        <li>A table showing each batsmanâ€™s name, score, and run rate (the runs he scored divided by the number of balls he faced)</li>
                </ul>
                                If you donâ€™t understand what these statistics mean, donâ€™t worry about it.
                                Cricket is full of statisticsâ€”perhaps its greatest contribution to humanity is providing odd statistics for eccentric papers.
                                The Page Controller (333) discussion covered how a Web request is handled.
                                To sum up, the object that acts as both the controller and the view is the aspx
                                ASP.NET page. To keep the controller code out of a scriptlet, you define a separate code behind class.
                                <pre><%@ Page language="c#" Codebehind="bat.aspx.cs" AutoEventWireup="false" trace="False"
                                Inherits="batsmen.BattingPage" %></pre>
                                The page can access the methods and properties of the code behind class
                                directly. Furthermore, the code behind can define a Page_Load method to handle
                                the request. In this case Iâ€™ve defined the Page_Load as a template method [Gang of
                                Four] on a Layer Supertype (475).
                                <pre>class CricketPage...
                                protected void Page_Load(object sender, System.EventArgs e) {
                                db = new OleDbConnection(DB.ConnectionString);
                                if (hasMissingParameters())
                                errorTransfer (missingParameterMessage);
                                DataSet ds = getData();
                                if (hasNoData (ds))
                                errorTransfer ("No data matches your request");
                                applyDomainLogic (ds);
                                DataBind();
                                prepareUI(ds);
                                }</pre>
                                For the purposes of Template View I can ignore all but the last couple of
                                lines of the page load. The call to DataBind allows various page variables to be
                                properly bound to their underlying data sources. That will do for the simpler
                                cases, but for more complicated cases the last line calls a method in the particular pageâ€™s code behind to prepare any objects for its use.
                                The match ID number, team, and innings are single values for the page, all of
                                which came into the page as parameters in the HTTP request. I can provide
                                these values by using properties on the code behind class.
                                <pre>class BattingPage...
                                protected String team {
                                get {return Request.Params["team"];}
                                }
                                protected String match {
                                get {return Request.Params["match"];}
                                }
                                protected String innings {
                                get {return Request.Params["innings"];}
                                }
                                protected String ordinalInnings{
                                get {return (innings == "1") ? "1st" : "2nd";}
                                }</pre>
                                With the properties defined, I can use them in the text of the page.
                                <pre><P>
                                Match id:
                                <asp:label id="matchLabel" Text="<%# match %>" runat="server" font-bold="True">
                                </asp:label>&nbsp;
                                </P>
                                <P>
                                <asp:label id=teamLabel Text="<%# team %>" runat="server" font-bold="True">
                                </asp:label>&nbsp;
                                <asp:Label id=inningsLabel Text="<%# ordinalInnings %>" runat="server">
                                </asp:Label>&nbsp;innings</P>
                                <P></P></pre>
                                The table is a little more complicated, but actually works easily in practice
                                because of the graphical design facilities in Visual Studio. Visual Studio provides a data grid control that can be bound to a single table from a data set. I
                                can do this binding in the prepareUI method thatâ€™s called by the Page_Load method.
                                <pre>class BattingPage...
                                override protected void prepareUI(DataSet ds) {
                                DataGrid1.DataSource = ds;
                                DataGrid1.DataBind();
                                }</pre>
                                The batting class is a Table Module (125) that provides domain logic for the
                                batting table in the database. Its data property is the data from that table
                                enriched by domain logic from Table Module (125). Here the enrichment is the
                                run rate, which is calculated rather than stored in the database.
                                With the ASP.NET data grid you can select which table columns you wish to
                                display in the Web page, together with information about the tableâ€™s appearance. In this case we can select name, runs, and rate columns.
                                <pre><asp:DataGrid id="DataGrid1" runat="server" Width="480px" Height="171px"
                                BorderColor="#336666" BorderStyle="Double" BorderWidth="3px" BackColor="White"
                                CellPadding="4" GridLines="Horizontal" AutoGenerateColumns="False">
                                <SelectedItemStyle Font-Bold="True" ForeColor="White" BackColor="#339966"></
                                SelectedItemStyle>
                                <ItemStyle ForeColor="#333333" BackColor="White"></ItemStyle>
                                <HeaderStyle Font-Bold="True" ForeColor="White" BackColor="#336666"></HeaderStyle>
                                <FooterStyle ForeColor="#333333" BackColor="White"></FooterStyle>
                                <Columns>
                                <asp:BoundColumn DataField="name" HeaderText="Batsman">
                                <HeaderStyle Width="70px"></HeaderStyle>
                                </asp:BoundColumn>
                                <asp:BoundColumn DataField="runs" HeaderText="Runs">
                                <HeaderStyle Width="30px"></HeaderStyle>
                                </asp:BoundColumn>
                                <asp:BoundColumn DataField="rateString" HeaderText="Rate">
                                <HeaderStyle Width="30px"></HeaderStyle>
                                </asp:BoundColumn>
                                </Columns>
                                <PagerStyle HorizontalAlign="Center" ForeColor="White" BackColor="#336666"
                                Mode="NumericPages"></PagerStyle>
                                </asp:DataGrid></P></pre>
                                The HTML for this data grid looks intimidating, but in Visual Studio you
                                donâ€™t manipulate it directly but through property sheets in the development
                                environment, as you do for much of the rest of the page.
                                This ability to have Web form controls on the Web page that understand the
                                ADO.NET abstractions of data sets and data tables is the strength, and limitation, of this scheme. The strength is that you transfer information through data
                                sets, thanks to the kind of tools that Visual Studio provides. The limitation is
                                that it only works seamlessly when you use patterns such as Table Module
                                (125). If you have very complex domain logic, then a Domain Model (116)
                                becomes helpful; to take advantage of the tools, the Domain Model (116) needs
                                to create its own data set.</p>
                <h3 id="361">Transform View</h3>
                <p>A view that processes domain data element by
                                element and transforms it into HTML.
                                When you issue requests for data to the domain and data source layers, you get
                                back all the data you need to satisfy them, but without the formatting you need
                                to make a proper Web page. The role of the view in Model View Controller
                                (330) is to render this data into a Web page. Using Transform View means
                                thinking of this as a transformation where you have the modelâ€™s data as input
                                and its HTML as output.</p>
                <h3 id="361(2)">How It Works</h3>
                <p>The basic notion of Transform View is writing a program that looks at domainoriented data and converts it to HTML. The program walks the structure of the
                                domain data and, as it recognizes each form of domain data, it writes out the
                                particular piece of HTML for it. If you think about this in an imperative way,
                                you might have a method called renderCustomer that takes a customer object and
                                renders it into HTML. If the customer contains a lot of orders, this method
                                loops over the orders calling renderOrder.
                                The key difference between Transform View and Template View (350) is the
                                way in which the view is organized. A Template View (350) is organized around
                                the output. A Transform View is organized around separate transforms for each
                                kind of input element. The transform is controlled by something like a simple
                                loop that looks at each input element, finds the appropriate transform for that
                                element, and then calls the transform on it. A typical Transform Viewâ€™s rules
                                can be arranged in any order without affecting the resulting output.
                                You can write a Transform View in any language; at the moment, however, the
                                dominant choice is XSLT. The interesting thing about this is that XSLT is a functional programming language, similar to Lisp, Haskell, and other languages that
                                never quite made it into the IS mainstream. As such it has a different kind of
                                structure to it. For example, rather than explicitly calling routines, XSLT recognizes elements in the domain data and then invokes the appropriate rendering
                                transformations.</p>
                <p>To carry out an XSLT transform we need to begin with some XML data. The
                                simplest way this can happen is if the natural return type of the domain logic is
                                either XML or something automatically transformable to itâ€”for example, a
                                .NET. Failing that, we need to produce the XML ourselves, perhaps by populating a Data Transfer Object (401) that can serialize itself into XML. That way
                                the data can be assembled using a convenient API. In simpler cases a Transaction Script (110) can return XML directly.
                                The XML thatâ€™s fed into the transform donâ€™t have to be a string, unless a
                                string form is needed to cross a communication line. Itâ€™s usually quicker and
                                easier to produce a DOM and hand that to the transform.
                                Once we have the XML we pass it to an XSLT engine, which is becoming
                                increasingly available commercially. The logic for the transform is captured in
                                an XSLT style sheet, which we also pass to the transformer. The transformer
                                then applies the stylesheet to the input XML to yield the output HTML, which
                                we can write directly to the HTTP response.</p>
                <h3 id="362">When to Use It</h3>
                <p>The choice between a Transform View and a Template View (350) mostly
                                comes down to which environment the team working on the view software prefers. The presence of tools is a key factor here. There are more and more
                                HTML editors that you can use to write Template Views (350). Tools for XSLT
                                are, at least so far, much less sophisticated. Also, XSLT can be an awkward language to master because of its functional programming style coupled with its
                                awkward XML syntax.
                                One of the strengths of XSLT is its portability to almost any Web platform.
                                You can use the same XSLT to transform XML created from J2EE or .NET,
                                which can help in putting a common HTML view on data from different sources.
                                XSLT is also often easier if youâ€™re building a view on an XML document.
                                Other environments usually require you to transform such a document into an
                                object or to indulge in walking the XML DOM, which can be complicated.
                                XSLT fits naturally in an XML world.</p>
                <p>Transform View avoids two of the biggest problems with Template View
                                (350). Itâ€™s easier to keep the transform focused only on rendering HTML, thus
                                avoiding having too much other logic in the view. Itâ€™s also easy to run the Transform View and capture the output for testing. This makes it easier to test the
                                view and you donâ€™t need a Web server to run the tests.
                                TRANSFORM VIEW 363
                                Transform
                                View
                                Transform View transforms directly from domain-oriented XML into
                                HTML. If you need to change the overall appearance of a Web site, this can
                                force you to change multiple transform programs. Using common transforms,
                                such as with XSLT includes, helps reduce this problem. Indeed itâ€™s much easier
                                to call common transformations using Transform View than it is using Template View (350). If you need to make global changes easily or support multiple
                                appearances for the same data, you might consider Two Step View (365), which
                                uses a two-stage process.</p>
                <h3 id="363">Example: Simple Transform (Java)</h3>
                <p>Setting up a simple transform involves preparing Java code for invoking the
                                right style sheet to form the response. It also involves preparing the style sheet
                                to format the response. Most of the response to a page is pretty generic, so it
                                makes sense to use Front Controller (344). Iâ€™ll describe only the command here,
                                and you should look at Front Controller (344) to see how the command object
                                fits in with the rest of the request-response handling.
                                All the command object does is invoke the methods on the model to obtain
                                an XML input document, and then pass that XML document through the XML
                                processor.
                                <pre>class AlbumCommand...
                                public void process() {
                                try {
                                Album album = Album.findNamed(request.getParameter("name"));
                                Assert.notNull(album);
                                PrintWriter out = response.getWriter();
                                XsltProcessor processor = new SingleStepXsltProcessor("album.xsl");
                                out.print(processor.getTransformation(album.toXmlDocument()));
                                } catch (Exception e) {
                                throw new ApplicationException(e);
                                }
                                }
                                The XML document may look something like this:
                                <album>
                                <title>Stormcock</title>
                                <artist>Roy Harper</artist>
                                <trackList>
                                <track><title>Hors dâ€™Oeuvres</title><time>8:37</time></track>
                                <track><title>The Same Old Rock</title><time>12:24</time></track>
                                <track><title>One Man Rock and Roll Band</title><time>7:23</time></track>
                                <track><title>Me and My Woman</title><time>13:01</time></track>
                                </trackList>
                                </album></pre>
                                The translation of the XML document is done by an XSLT program. Each
                                template matches a particular part of the XML and produces the appropriate
                                HTML output for the page. In this case Iâ€™ve kept the formatting to a excessively
                                simple level to show just the essentials. The following template clauses match
                                the basic elements of the XML file.
                                <pre></pre>
                                <pre><xsl:template match="album">
                                <HTML><BODY bgcolor="white">
                                <xsl:apply-templates/>
                                </BODY></HTML>
                                </xsl:template>
                                <xsl:template match="album/title">
                                <h1><xsl:apply-templates/></h1>
                                </xsl:template>
                                <xsl:template match="artist">
                                <P><B>Artist: </B><xsl:apply-templates/></P>
                                </xsl:template>
                                These template matches handle the table,
                                which here has alternating rows highlighted in different colors.
                                This is a good example of something that isnâ€™t possible with cascading
                                style sheets but is reasonable with XML.
                                <xsl:template match="trackList">
                                <table><xsl:apply-templates/></table>
                                </xsl:template>
                                <xsl:template match="track">
                                <xsl:variable name="bgcolor">
                                <xsl:choose>
                                <xsl:when test="(position() mod 2) = 1">linen</xsl:when>
                                <xsl:otherwise>white</xsl:otherwise>
                                </xsl:choose>
                                </xsl:variable>
                                <tr bgcolor="{$bgcolor}"><xsl:apply-templates/></tr>
                                </xsl:template>
                                <xsl:template match="track/title">
                                <td><xsl:apply-templates/></td>
                                </xsl:template>
                                <xsl:template match="track/time">
                                <td><xsl:apply-templates/></td>
                                </xsl:template></pre>
                <h3 id="365">Two Step View</h3>
                <p>Turns domain data into HTML in two steps: first by forming some
                                kind of logical page, then rendering the logical page into HTML.
                                If you have a Web application with many pages, you often want a consistent
                                look and organization to the site. If every page looks different, you end up with
                                a site that users find confusing. You may also want to make global changes to
                                the appearance of the site easily, but common approaches using Template View
                                (350) or Transform View (361) make this difficult because presentation decisions are often duplicated across multiple pages or transform modules. A global
                                change can force you to change several files.
                                Two Step View deals with this problem by splitting the transformation into
                                two stages. The first transforms the model data into a logical presentation without any specific formatting; the second converts that logical presentation with
                                the actual formatting needed. This way you can make a global change by altering the second stage, or you can support multiple output looks and feels with
                                one second stage each.</p>
                <h3 id="365(2)">How It Works</h3>
                <p>The key to this pattern is in making the transformation to HTML a two-stage
                                process. The first stage assembles the information in a logical screen structure
                                that is suggestive of the display elements yet contains no HTML. The second
                                stage takes that presentation-oriented structure and renders it into HTML
                                This intermediate form is a kind of logical screen. Its elements might include
                                things like fields, headers, footers, tables, choices, and the like. As such itâ€™s certainly presentation-oriented and certainly forces the screens to follow a definite
                                style. You can think of the presentation-oriented model as one that defines the
                                various widgets you can have and the data they contain but doesnâ€™t specify the
                                HTML appearance.</p>
                <p>This presentation-oriented structure is assembled by specific code written for
                                each screen. The first stageâ€™s responsibility is to access a domain-oriented
                                model, either a database, an actual domain model, or a domain-oriented Data
                                Transfer Object (401); to extract the relevant information for that screen; and
                                then to put that information into the presentation-oriented structure.
                                The second stage turns this presentation-oriented structure into HTML. It
                                knows about each element in the presentation-oriented structure and how to
                                show it as HTML. Thus, a system with many screens can be rendered as HTML
                                by a single second stage so that all the HTML formatting decisions are made in
                                one place. Of course, the constraint is that the resulting screen must be derivable from the presentation-oriented structure.
                                There are several ways to build a Two Step View. Perhaps the easiest is with
                                two-step XSLT. Single-step XSLT follows the approach in Transform View
                                (361), in which each page has a single XSLT style sheet that transforms the
                                domain-oriented XML into HTML. In the two-step approach there are two
                                XSLT style sheets. The first-stage style sheet transforms the domain-oriented
                                XML into presentation-oriented XML, the second-stage style sheet renders that
                                XML into HTML.</p>
                <p>Another way is to use classes. Here you define the presentation-oriented
                                structure as a set of classes: with a table class, a row class, and so forth. The
                                first stage takes domain information and instantiates these classes into a structure that models a logical screen. The second stage renders the classes into
                                HTML, either by getting each presentation-oriented class to generate HTML
                                for itself or by having a separate HTML renderer class to do the job.
                                Both approaches are based on Transform View (361). You can also use a
                                Template View (350) based approach, in which you pick templates based on the
                                idea of a logical screenâ€”for example:
                                <pre>&lt;field label = "Name" value = "getName" /&gt;</pre>
                                The template system then converts these logical tags into HTML. In such a
                                scheme the page definition includes no HTML but only these logical screen
                                tags. As a result it will probably be an XML document, which of course means
                                that you lose the ability to use WYSIWYG HTML editors.
                                TWO STEP VIEW 367
                                Two Step
                                View</p>
                <h3 id="367">When to Use It</h3>
                <p>Two Step Viewâ€™s key value comes from the separation of first and second stages,
                                allowing you to make global changes more easily. It helps to think of two situations: multiappearance Web applications and single-appearance Web applications. Multiappearance apps are the rarer breed but a growing one. In them the
                                same basic functionality is provided through multiple organizations and each
                                organization has its own distinct look. A current example of this is airline travel
                                sites, where as you look at them you can tell from the page layout and design
                                that theyâ€™re all variations on one base site. I suspect many airlines want that
                                same functionality but with a distinctly individual appearance.
                                Single-appearance apps are more common. Only one organization fronts
                                them, and they want a consistent look throughout the site. This makes them the
                                easiest case to consider first.</p>
                <p>With a single-stage view (either Template View (350) or Transform View
                                (361), you build one view module per Web page (see Figure 14.6). With a Two
                                View Step View you have two stages: one first-stage module per page and one secondstage module for the entire application (Figure 14.7). Your pay-off in using Two
                                Step View is that any change to the appearance of the site in the second stage is
                                much easier to make, since one second-stage change affects the site as a whole.
                                With a multiappearance app this advantage is compounded because you
                                have a single-stage view for each combination of screen and appearance
                                (Figure 14.8). Thus, ten screens and three appearances require thirty single
                                stage view modules. Using Two Step View, however (see Figure 14.9), you can
                                get away with ten first stages and three second stages. The more screens and
                                appearances you have, the bigger the saving.</p>
                <p>Nevertheless, your ability to pull this off is entirely dependent on how well
                                you can make the presentation-oriented structure to really serve the needs of the
                                appearance. A design-heavy site, where each page is supposed to look different,
                                wonâ€™t work well with Two Step View because itâ€™s hard to find enough commonality between the screens to get a simple enough presentation-oriented structure.
                                Essentially the site design is constrained by the presentation-oriented structure,
                                and for many sites thatâ€™s too much of a limitation.
                                Another drawback of Two Step View is the tools required to use it. There are
                                a lot of tools for designers with no programming skills to lay out HTML pages
                                using Template View (350), but Two Step View forces programmers to write the
                                renderer and controller objects. Thus programmers have to be involved in any
                                design change.</p>
                <p>Itâ€™s also true that Two Step View, with its multiple layers, presents a harder
                                programming model to learn, although once youâ€™re used to it itâ€™s not that difficult, and may help reduce repetitive boilerplate code.
                                A variation on the theme of multiple appearances is providing different second stages for different devices, so you can have one second stage for a browser
                                and another for a PDA. The usual limitation here is that both appearances must
                                follow the same logical screen, and for very different devices this may be too
                                much to ask.</p>
                <h3 id="371">Example: Two Stage XSLT (XSLT)</h3>
                <p>This approach to a Two Step View uses a two-stage XLST transformation. The
                                first stage transforms domain-specific XML into logical screen XML; the second transforms the logical screen XML into HTML.
                                The initial domain oriented XML looks like this:
                                <pre>&lt;album&gt;
                                &lt;title&gt;Zero Hour&lt;/title&gt;
                                &lt;artist&gt;Astor Piazzola&lt;/artist&gt;
                                &lt;trackList&gt;
                                &lt;track&gt;&lt;title&gt;Tanguedia III&lt;/title&gt;&lt;time&gt;4:39&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Milonga del Angel&lt;/title&gt;&lt;time&gt;6:30&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Concierto Para Quinteto&lt;/title&gt;&lt;time&gt;9:00&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Milonga Loca&lt;/title&gt;&lt;time&gt;3:05&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Michelangelo '70&lt;/title&gt;&lt;time&gt;2:50&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Contrabajisimo&lt;/title&gt;&lt;time&gt;10:18&lt;/time&gt;&lt;/track&gt;
                                &lt;track&gt;&lt;title&gt;Mumuki&lt;/title&gt;&lt;time&gt;9:32&lt;/time&gt;&lt;/track&gt;
                                &lt;/trackList&gt;
                                &lt;/album&gt;</pre>
                                The first stage XSLT processor transforms it into this screen-oriented XML:
                                <pre>&lt;screen&gt;
                                &lt;title&gt;Zero Hour&lt;/title&gt;
                                &lt;field label="Artist"&gt;Astor Piazzola&lt;/field&gt;
                                &lt;table&gt;
                                &lt;row&gt;&lt;cell&gt;Tanguedia III&lt;/cell&gt;&lt;cell&gt;4:39&lt;/cell&gt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Milonga del Angel&lt;/cell&gt;&lt;cell&gt;6:30&lt;/cell&gt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Concierto Para Quinteto&lt;/cell&gt;&lt;cell&gt;9:00&lt;/cell&gt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Milonga Loca&lt;/cell&gt;&lt;cell&gt;3:05&lt;/cell&gt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Michelangelo '70&lt;/cell&gt;&lt;cell&gt;2:50&lt;/cell&lt;&lt;/row&gt;
                                &lt;row&gt;&lt;cell&gt;Contrabajisimo&lt;/cell&gt;&lt;cell&gt;10:18&lt;/cell&gt;&lt;/row&gt;
                                &lt;row>&lt;cell&gt;Mumuki&lt;/cell&gt;&lt;cell&gt;9:32&lt;/cell&gt;&lt;/row&gt;
                                &lt;/table&gt;
                                &lt;/screen&gt;</pre>
                                To do this we need the following XSLT program:
                                <pre>&lt;xsl:template match="album"&gt;
                                &lt;screen>&lt;xsl:apply-templates/&gt;&lt;/screen&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="album/title"&gt;
                                &lt;title&gt;&lt;xsl:apply-templates/&gt;&lt;/title&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="artist"&gt;
                                &lt;field label="Artist"&gt;&lt;xsl:apply-templates/&gt;&lt;/field&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="trackList"&gt;
                                &lt;table>&lt;xsl:apply-templates/&gt;&lt;/table&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="track"&gt;
                                &lt;row>&lt;xsl:apply-templates/&gt;&lt;/row&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="track/title"&gt;
                                &lt;cell&gt;&lt;xsl:apply-templates/&gt;&lt;/cell&gt;
                                &lt;/xsl:template&gt;
                                &lt;xsl:template match="track/time"&gt;
                                &lt;cell&gt;&lt;xsl:apply-templates/&gt;&lt;/cell&gt;
                                &lt;/xsl:template&gt;&lt;/p&gt;</pre>
                <p>The screen-oriented XML is very plain. To turn it into HTML we use a
                                second-stage XSLT program.
                                <pre><xsl:template match="screen">
                                <HTML><BODY bgcolor="white">
                                <xsl:apply-templates/>
                                </BODY></HTML>
                                </xsl:template>
                                <xsl:template match="title">
                                <h1><xsl:apply-templates/></h1>
                                </xsl:template><xsl:template match="field">
                                <P><B><xsl:value-of select = "@label"/>: </B><xsl:apply-templates/></P>
                                </xsl:template>
                                <xsl:template match="table">
                                <table><xsl:apply-templates/></table>
                                </xsl:template>
                                <xsl:template match="table/row">
                                <xsl:variable name="bgcolor">
                                <xsl:choose>
                                <xsl:when test="(position() mod 2) = 1">linen</xsl:when>
                                <xsl:otherwise>white</xsl:otherwise>
                                </xsl:choose>
                                </xsl:variable>
                                <tr bgcolor="{$bgcolor}"><xsl:apply-templates/></tr>
                                </xsl:template>
                                <xsl:template match="table/row/cell">
                                <td><xsl:apply-templates/></td>
                                </xsl:template></pre>
                                In assembling the two stages, I used Front Controller (344) to help separate
                                the code that does the work.
                                <pre>class AlbumCommand...
                                public void process() {
                                try {
                                Album album = Album.findNamed(request.getParameter("name"));
                                Assert.notNull(album);
                                PrintWriter out = response.getWriter();
                                XsltProcessor processor = new TwoStepXsltProcessor("album2.xsl", "second.xsl");
                                out.print(processor.getTransformation(album.toXmlDocument()));
                                } catch (Exception e) {
                                throw new ApplicationException(e);
                                }
                                }</pre>
                                Itâ€™s useful to compare this to the single-stage approach in Transform View
                                (361). If you want to change the colors of the alternating rows, Transform View
                                (361) requires editing every XSLT program, but with Two Step View only the
                                single second-stage XSLT program needs to be changed. It might be possible to
                                use callable templates to do something similar, but this needs a fair bit of XSLT
                                gymnastics to pull off. The down side of Two Step View is that the final HTML
                                is very much constrained by the screen-oriented XML.</p>
                <h3 id="374">Example: JSP and Custom Tags (Java)</h3>
                <p>Although the XSLT route is conceptually the easiest way to think about implementing Two Step View, plenty of other ways exist. For this example Iâ€™ll use
                                JSPs and custom tags. Although theyâ€™re both more awkward and less powerful
                                than XSLT, they do show how the pattern can manifest itself in different ways.
                                Iâ€™m being a bit cheeky with this example, for I havenâ€™t seen this done in the
                                field. But I feel a somewhat speculative example will give you an idea of what
                                might be possible.
                                The key rule of Two Step View is that choosing what to display and choosing
                                the HTML that displays it are totally separate. For this example my first stage is
                                handled by a JSP page and its helper; my second stage, by a set of custom tags.
                                The interesting part of the first stage is the JSP page.
                                <pre>&lt;%@ taglib uri="2step.tld" prefix = "2step" %&gt;
                                &lt;%@ page session="false"%&gt;
                                &lt;jsp:useBean id="helper" class="actionController.AlbumConHelper"/&gt;
                                &lt;%helper.init(request, response);%&gt;
                                &lt;2step:screen&gt;
                                &lt;2step:title&gt;&lt;jsp:getProperty name = "helper" property = "title"/&gt;&lt;/2step:title&gt;
                                &lt;2step:field label = "Artist"&gt;&lt;jsp:getProperty name = "helper" property = "artist"/&gt;&lt;/2step:field&gt;
                                &lt;2step:table host = "helper" collection = "trackList" columns = "title, time"/&gt;
                                &lt;/2step:screen&gt;</pre>
                                Iâ€™m using Page Controller (333) for the JSP page with a helper object you can
                                flick over to Page Controller (333) to read more about that. The important
                                thing here is to look at the tags that are part of the 2step namespace. They are
                                the ones Iâ€™m using to invoke the second stage. Also notice that there is no
                                HTML on the JSP page; the only tags present are either second-stage tags or
                                bean manipulation tags to get values out of the helper.
                                Each second-stage tag has an implementation to pump out the necessary
                                HTML for that logical screen element. The simplest of these is the title.
                                <pre>class TitleTag...
                                public int doStartTag() throws JspException {
                                try {
                                pageContext.getOut().print("&lt;H1&gt;");
                                } catch (IOException e) {
                                throw new JspException("unable to print start");
                                }
                                return EVAL_BODY_INCLUDE;
                                }
                                public int doEndTag() throws JspException {
                                try {
                                pageContext.getOut().print("&lt;/H1&gt;");
                                } catch (IOException e) {
                                throw new JspException("unable to print end");
                                }
                                return EVAL_PAGE;
                                }</pre>
                                For those that havenâ€™t indulged, a custom tag works by implementing hook
                                methods called at the beginning and the end of the tagged text. This tag simply
                                wraps its body content with an &lt;H1&gt; tag. A more complex tag, such as the field,
                                can take an attribute. The attribute is tied into the tag class using a setting
                                method.<pre>
                                class FieldTag...
                                private String label;
                                public void setLabel(String label) {
                                this.label = label;
                                }
                                Once the value is set, you can use it in the output.
                                class FieldTag...
                                public int doStartTag() throws JspException {
                                try {
                                pageContext.getOut().print("&lt;P&gt;" + label + ": &lt;B&gt;");
                                } catch (IOException e) {
                                throw new JspException("unable to print start");
                                }
                                return EVAL_BODY_INCLUDE;
                                }
                                public int doEndTag() throws JspException {
                                try {
                                pageContext.getOut().print("&lt;/B&gt;&lt;/P&gt;");
                                } catch (IOException e) {
                                throw new JspException("how are checked exceptions helping me here?");
                                }
                                return EVAL_PAGE;
                                }</pre>
                                The Table is the most sophisticated of the tags. As well as allowing the JSP
                                writer to choose which columns to put in the table, it highlights alternate rows.
                                The tag implementation acts as the second stage, so the highlighting is done
                                there so that a system-wide change can be made globally.
                                The Table tag takes attributes for the name of the collection property, the
                                object on which the collection property sits, and a comma-separated list of column names.
                                <pre>class TableTag...
                                private String collectionName;
                                private String hostName;
                                private String columns;
                                public void setCollection(String collectionName) {
                                this.collectionName = collectionName;
                                }
                                public void setHost(String hostName) {
                                this.hostName = hostName;
                                TWO STEP VIEW 377
                                Two Step
                                View
                                }
                                public void setColumns(String columns) {
                                this.columns = columns;
                                }</pre>
                                I made a helper method to get a property out of an object. Thereâ€™s a good
                                argument for using the various classes that support Java beans, rather than just
                                invoking a â€œgetsomethingâ€ method, but this will do for the example.
                                <pre>class TableTag...
                                private Object getProperty(Object obj, String property) throws JspException {
                                try {
                                String methodName = "get" + property.substring(0, 1).toUpperCase() +
                                property.substring(1);
                                Object result = obj.getClass().getMethod(methodName, null).invoke(obj, null);
                                return result;
                                } catch (Exception e) {
                                throw new JspException("Unable to get property " + property + " from " + obj);
                                }
                                }</pre>
                                This tag doesnâ€™t have a body. When itâ€™s called it pulls the named collection out
                                of the request property and iterates through the collection to generate the rows
                                of the table.
                                <pre>class TableTag...
                                public int doStartTag() throws JspException {
                                try {
                                JspWriter out = pageContext.getOut();
                                out.print("&lt;table&gt;");
                                Collection coll = (Collection) getPropertyFromAttribute(hostName, collectionName);
                                Iterator rows = coll.iterator();
                                int rowNumber = 0;
                                while (rows.hasNext()) {
                                out.print("&lt;tr");
                                if ((rowNumber++ % 2) == 0) out.print(" bgcolor = " + HIGHLIGHT_COLOR);
                                out.print("&gt;");
                                printCells(rows.next());
                                out.print("&lt;/tr&gt;");
                                }
                                out.print("&lt;/table&gt;");
                                } catch (IOException e) {
                                throw new JspException("unable to print out");
                                }
                                return SKIP_BODY;
                                }
                                private Object getPropertyFromAttribute(String attribute, String property)
                                throws JspException
                                {
                                Object hostObject = pageContext.findAttribute(attribute);
                                if (hostObject == null)
                                throw new JspException("Attribute " + attribute + " not found.");
                                return getProperty(hostObject, property);
                                }
                                public static final String HIGHLIGHT_COLOR = "'linen'";
                                During the iteration it sets every other row to the linen background to highlight
                                them.
                                To print the cells for each row, I use the column names as property values on
                                the objects in the collection.
                                class TableTag...
                                private void printCells(Object obj) throws IOException, JspException {
                                JspWriter out = pageContext.getOut();
                                for (int i = 0; i &lt; getColumnList().length; i++) {
                                out.print("&lt;td&gt;");
                                out.print(getProperty(obj, getColumnList()[i]));
                                out.print("&lt;/td&gt;");
                                }
                                }
                                private String[] getColumnList() {
                                StringTokenizer tk = new StringTokenizer(columns, ", ");
                                String[] result = new String[tk.countTokens()];
                                for (int i = 0; tk.hasMoreTokens(); i++)
                                result[i] = tk.nextToken();
                                return result;
                                }</pre>
                                Compared to the XSLT implementation, this solution is rather less constraining on the uniformity of the siteâ€™s layout. An author of one page wanting to slip
                                some individual HTML into it will find that easier to do. Of course, while this
                                allows tweaking of design-intensive pages, itâ€™s also open to inappropriate use by
                                people who are unfamiliar with how things work. Sometimes constraints help
                                prevent mistakes. Thatâ€™s a trade-off a team has to decide for themselves.
                                APPLICATION CONTROLLER 379
                                Application
                                Controller</p>
                <h3 id="379">Application Controller</h3>
                <p>A centralized point for handling screen navigation
                                and the flow of an application.
                                Some applications contain a significant amount of logic about the screens to use
                                at different points, which may involve invoking certain screens at certain times
                                in an application. This is the wizard style of interaction, where the user is led
                                through a series of screens in a certain order. In other cases we may see screens
                                that are only brought in under certain conditions, or choices between different
                                screens that depend on earlier input.
                                To some degree the various Model View Controller (330) input controllers
                                can make some of these decisions, but as an application gets more complex this
                                can lead to duplicated code as several controllers for different screens need to
                                know what to do in a certain situation.
                                You can remove this duplication by placing all the flow logic in an Application Controller. Input controllers then ask the Application Controller for the
                                appropriate commands for execution against a model and the correct view to
                                use depending on the application context.</p>
                <h3 id="380">How It Works</h3>
                <p>An Application Controller has two main responsibilities: deciding which
                                domain logic to run and deciding the view with which to display the response.
                                To do this it typically holds two structured collections of class references, one
                                for domain commands to execute against in the domain layer and one of views
                                (Figure 14.10).
                                For both the domain commands and the view, the application controller
                                needs a way to store something it can invoke. A Command [Gang of Four] is a
                                good choice, since it allows it to easily get hold of and run a block of code. Languages that can manipulate functions can hold references to them. Another
                                option is to hold a string that can be used to invoke a method by reflection.
                                The domain commands can be command objects that are part of the Application Controller layer, or they can be references to a Transaction Script (110)
                                or domain object methods in the domain layer.
                                If youâ€™re using server pages as your views, you can use the server page name.
                                If youâ€™re using a class, a command or a string for a reflective call makes sense.
                                You might also use an XSLT transform, to which the Application Controller
                                can hold a string as a reference.</p>
                <p>One decision youâ€™ll need to make is how much to separate the Application
                                Controller from the rest of the presentation. At the first level this decision manifests itself in whether the Application Controller has dependencies to the UI
                                machinery. Perhaps it directly accesses the HTTP session data, forwards to a
                                server page, or invokes methods on a rich-client class.
                                Although Iâ€™ve seen direct Application Controllers, my preference is for the
                                Application Controller to have no links to the UI machinery. For a start this
                                makes it possible to test the Application Controller independently of the UI,
                                which is a major benefit. Itâ€™s also important to do this if youâ€™re going to use the
                                same Application Controller with multiple presentations. For these reasons
                                many people like to think of the Application Controller as an intermediate layer
                                between the presentation and the domain.</p>
                <p>An application can have multiple Application Controllers to handle each of
                                its different parts. This allows you to split up complex logic into several classes.
                                In this case I usually see the work divided up into broad areas of the user interface and build separate Application Controllers for each area. On a simpler
                                application I might need only a single Application Controller.
                                If you have multiple presentations, such as a Web front end, a rich client, and
                                a PDA, you may be able to use the same Application Controller for each presentation, but donâ€™t be too eager. Often different UIs need a different screen
                                flow to achieve a really usable user interface. However, reusing a single Application Controller may reduce the development effort, and that decreased effort
                                may be worth the cost of a more awkward UI.</p>
                <p>A common way of thinking about a UI is as a state machine, where certain
                                events trigger different responses depending on the state of certain key objects
                                in the application. In this case the Application Controller is particularly amenable to using metadata to represent the state machineâ€™s control flow. The metadata can either be set up by programming language calls (the simplest way) or it
                                can be stored in a separate configuration file.
                                You may find domain logic particular to one request placed in an Application Controller (379). As you might suspect, I come down pretty hard against
                                that notion. However, the boundary between domain and application logic
                                does get very murky. Say Iâ€™m handling insurance applications and I need to
                                show a separate screen of questions only if the applicant is a smoker. Is this
                                application logic or domain logic? If I have only a few such cases I can probably
                                put that kind of logic in the Application Controller (379), but if it occurs in lots
                                of places I need to design the Domain Model (116) in such a way to drive this.</p>
                <h3 id="381">When to Use It</h3>
                <p>If the flow and navigation of your application are simple enough so that anyone
                                can visit any screen in pretty much any order, thereâ€™s little value in a Application
                                Controller. The strength of an Application Controller comes from definite rules
                                about the order in which pages should be visited and different views depending
                                on the state of objects.
                                A good signal to use an Application Controller is if you find yourself having
                                to make similar changes in lots of different places when your applicationâ€™s flow
                                changes.</p>
                <h3 id="382">Further Reading</h3>
                <p>Most of the ideas that underlie the writing of this pattern came from [Knight
                                and Dai]. Although their ideas arenâ€™t exactly new, I found their explanations
                                remarkably clear and compelling.</p>
                <h3 id="382(2)">Example: State Model Application Controller (Java)</h3>
                <p>State models are a common way of thinking about user interfaces. Theyâ€™re particularly appropriate when you need to react differently to events depending on
                                the state of some object. In this example I have a simple state model for a couple of commands on an asset (Figure 14.11). ThoughtWorkâ€™s leasing experts
                                would faint at the virulent oversimplification of this model, but it will do as an
                                example of a state-based Application Controller.
                                As far as the code is concerned our rules are these:
                <ul>
                        <li>When we receive a return command and weâ€™re in the On lease state, we display a page to capture information about the return of the asset.</li>
                        <li>A return event in the in Inventory state is an error, so we show an illegal action page.</li>
                        <li>When we receive a damage command we show different pages depending on whether the asset is in the Inventory or the On lease state.</li>
                </ul>
                                The input controller is a Front Controller (344). It services the request like
                                this:
                                <pre>class FrontServlet...
                                public void service(HttpServletRequest request, HttpServletResponse response)
                                throws IOException, ServletException
                                {
                                ApplicationController appController = getApplicationController(request);
                                String commandString = (String) request.getParameter("command");
                                DomainCommand comm =
                                appController.getDomainCommand(commandString, getParameterMap(request));
                                comm.run(getParameterMap(request));
                                String viewPage =
                                "/" + appController.getView(commandString, getParameterMap(request)) + ".jsp";
                                forward(viewPage, request, response);
                                }</pre>
                                The flow of the service method is pretty straightforward: We find the right
                                application controller for a given request, ask the application controller for the
                                domain command, execute the domain command, ask the application controller for a view, and, finally, forward to the view.
                                In this scheme Iâ€™m assuming a number of Application Controllers, all of
                                which implement the same interface.
                                <pre>interface ApplicationController...
                                DomainCommand getDomainCommand (String commandString, Map params);
                                String getView (String commandString, Map params);</pre>
                                For our commands the appropriate Application Controller is an asset application controller. It uses a response class to hold the domain commands and view
                                references. For the domain command I use a reference to a class; for the view I
                                use a string, which the front controller will turn into a URL for a JSP.
                                <pre>class Response...
                                private Class domainCommand;
                                private String viewUrl;
                                public Response(Class domainCommand, String viewUrl) {
                                this.domainCommand = domainCommand;
                                this.viewUrl = viewUrl;
                                }
                                public DomainCommand getDomainCommand() {
                                try {
                                return (DomainCommand) domainCommand.newInstance();
                                } catch (Exception e) {throw new ApplicationException (e);
                                }
                                }
                                public String getViewUrl() {
                                return viewUrl;
                                }</pre>
                                The application controller holds on to the responses using a map of maps
                                indexed by the command string and an asset status (Figure 14.12).
                                <pre>class AssetApplicationController...
                                private Response getResponse(String commandString, AssetStatus state) {
                                return (Response) getResponseMap(commandString).get(state);
                                }
                                private Map getResponseMap (String key) {
                                return (Map) events.get(key);
                                }
                                private Map events = new HashMap();</pre>
                                When asked for a domain command, the controller looks at the request to
                                figure out the asset ID, goes to the domain to determine the status of that asset,
                                looks up the appropriate domain command class, instantiates that class, and
                                returns the new object.
                                <pre>class AssetApplicationController...
                                public DomainCommand getDomainCommand (String commandString, Map params) {
                                Response reponse = getResponse(commandString, getAssetStatus(params));
                                return reponse.getDomainCommand();
                                }
                                private AssetStatus getAssetStatus(Map params) {
                                String id = getParam("assetID", params);
                                Asset asset = Asset.find(id);
                                return asset.getStatus();
                                }
                                private String getParam(String key, Map params) {
                                return ((String[]) params.get(key))[0];
                                }</pre>
                                All the domain commands follow a simple interface that allows the front
                                controller to run them.
                                <pre>interface DomainCommand...
                                abstract public void run(Map params);</pre>
                                Once the domain command has done what it needs to do, the Application Controller comes into play again when itâ€™s asked for the view.
                                <pre>class AssetApplicationController...
                                public String getView (String commandString, Map params) {
                                return getResponse(commandString, getAssetStatus(params)).getViewUrl();
                                }</pre>
                                In this case the Application Controller doesnâ€™t return the full URL to the JSP. It
                                returns a string that the front controller turns into an URL. I do this to avoid
                                duplicating the URL paths in the responses. It also makes it easy to add further
                                indirection later should I need it.
                                The Application Controller can be loaded for use with code.
                                <pre>class AssetApplicationController...
                                public void addResponse(String event, Object state, Class domainCommand, String view) {
                                Response newResponse = new Response (domainCommand, view);
                                if ( ! events.containsKey(event))
                                events.put(event, new HashMap());
                                getResponseMap(event).put(state, newResponse);
                                }
                                private static void loadApplicationController(AssetApplicationController appController) {
                                appController = AssetApplicationController.getDefault();
                                appController.addResponse("return", AssetStatus.ON_LEASE,
                                GatherReturnDetailsCommand.class, "return");
                                appController.addResponse("return", AssetStatus.IN_INVENTORY,
                                NullAssetCommand.class, "illegalAction");
                                appController.addResponse("damage", AssetStatus.ON_LEASE,
                                InventoryDamageCommand.class, "leaseDamage");
                                appController.addResponse("damage", AssetStatus.IN_INVENTORY,
                                LeaseDamageCommand.class, "inventoryDamage");
                                }</pre>
                                Doing this from a file instead isnâ€™t rocket science, but even so Iâ€™ll leave it to you.</p>
                <h3 id="387">Chapter 15</h3>
                <h2>Distribution Patterns</h2>
                <h3 id="388">Remote Facade</h3>
                <p>Provides a coarse-grained facade on fine-grained
                                objects to improve efficiency over a network.
                                In an object-oriented model, you do best with small objects that have small
                                methods. This gives you lots of opportunity for control and substitution of
                                behavior, and to use good intention revealing naming to make an application
                                easier to understand. One of the consequences of such fine-grained behavior is
                                that thereâ€™s usually a great deal of interaction between objects, and that interaction usually requires lots of method invocations.
                                Within a single address space fine-grained interaction works well, but this
                                happy state does not exist when you make calls between processes. Remote
                                calls are much more expensive because thereâ€™s a lot more to do: Data may have
                                to be marshaled, security may need to be checked, packets may need to be
                                routed through switches. If the two processes are running on machines on
                                opposite sides of the globe, the speed of light may be a factor. The brutal truth
                                is that any inter-process call is orders of magnitude more expensive than an inprocess callâ€”even if both processes are on the same machine. Such a performance effect cannot be ignored, even for believers in lazy optimization.</p>
                <p>As a result any object thatâ€™s intended to be used as a remote objects needs a
                                coarse-grained interface that minimizes the number of calls needed to get something done. Not only does this affect your method calls, it also affects your
                                objects. Rather than ask for an order and its order lines individually, you need
                                to access and update the order and order lines in a single call. This affects your
                                entire object structure. You give up the clear intention and fine-grained control
                                you get with small objects and small methods. Programming becomes more difficult and your productivity slows.
                                A Remote Facade is a coarse-grained facade [Gang of Four] over a web of
                                fine-grained objects. None of the fine-grained objects have a remote interface,
                                and the Remote Facade contains no domain logic. All the Remote Facade does
                                is translate coarse-grained methods onto the underlying fine-grained objects.</p>
                <h3 id="389">How It Works</h3>
                <p>Remote Facade tackles the distribution problem which the standard OO
                                approach of separating distinct responsibilities into different objects; and as a
                                result it has become the standard pattern for this problem. I recognize that finegrained objects are the right answer for complex logic, so I ensure that any
                                complex logic is placed in fine-grained objects that are designed to collaborate
                                within a single process. To allow efficient remote access to them, I make a separate facade object that acts as a remote interface. As the name implies, the
                                facade is merely a thin skin that switches from a coarse-grained to a finegrained interface.
                                In a simple case, like an address object, a Remote Facade replaces all the getting and setting methods of the regular address object with one getter and one
                                setter, often referred to as bulk accessors. When a client calls a bulk setter, the
                                address facade reads the data from the setting method and calls the individual
                                accessors on the real address object (see Figure 15.1) and does nothing more.
                                This way all the logic of validation and computation stays on the address object
                                where it can be factored cleanly and can be used by other fine-grained objects.
                                In a more complex case a single Remote Facade may act as a remote gateway
                                for many fine-grained objects. For example, an order facade may be used to get
                                and update information for an order, all its order lines, and maybe some customer data as well.
                                In transferring information in bulk like this, you need it to be in a form that
                                can easily move over the wire. If your fine-grained classes are present on both
                                sides of the connection and theyâ€™re serializable, you can transfer them directly
                                by making a copy. In this case a getAddressData method creates a copy of the original address object. The setAddressData receives an address object and uses it to
                                update the actual address objectâ€™s data. (This assumes that the original address
                                object needs to preserve its identity and thus canâ€™t be simply replaced with the
                                new address.)</p>
                <p>Often you canâ€™t do this, however. You may not want to duplicate your domain
                                classes on multiple processes, or it may be difficult to serialize a segment of a
                                domain model due to its complicated relationship structure. The client may not
                                want the whole model but just a simplified subset of it. In these cases it makes
                                sense to use a Data Transfer Object (401) as the basis of the transfer.
                                In the sketch Iâ€™ve shown a Remote Facade that corresponds to a single
                                domain object. This isnâ€™t uncommon and itâ€™s easy to understand, but it isnâ€™t the
                                most usual case. A single Remote Facade would have a number of methods,
                                each designed to pass on information from several objects. Thus, getAddressData
                                and setAddressData would be methods defined on a class like CustomerService,
                                which would also have methods along the lines of getPurchasingHistory and
                                updateCreditData.</p>
                <p>Granularity is one of the most tricky issues with Remote Facade. Some people like to make fairly small Remote Facades, such as one per use case. I prefer
                                a coarser grained structure with much fewer Remote Facades. For even a moderate-sized application I might have just one and even for a large application I
                                may have only half a dozen. This means that each Remote Facade has a lot of
                                methods, but since these methods are small I donâ€™t see this as a problem.
                                You design a Remote Facade based on the needs of a particular clientâ€™s
                                usageâ€”most commonly the need to view and update information through a
                                user interface. In this case you might have a single Remote Facade for a family
                                of screens, for each of which one bulk accessor method loads and saves the
                                data. Pressing buttons on a screen, say to change an orderâ€™s status, invokes
                                command methods on the facade. Quite often youâ€™ll have different methods on
                                the Remote Facade that do pretty much the same thing on the underlying
                                objects. This is common and reasonable. The facade is designed to make life
                                simpler for external users, not for the internal system, so if the client process
                                thinks of it as a different command, it is a different command, even if it all goes
                                to the same internal command.</p>
                <p>Remote Facade can be stateful or stateless. A stateless Remote Facade can be
                                pooled, which can improve resource usage and efficiency, especially in a B2C
                                situation. However, if the interaction involves state across a session, then it
                                needs to store session state somewhere using Client Session State (456) or Database Session State (462), or an implementation of Server Session State (458). As
                                stateful a Remote Facade can hold on to its own state, which makes for an easy
                                implementation of Server Session State (458), but this may lead to performance
                                issues when you have thousands of simultaneous users.
                                As well as providing a coarse-grained interface, several other responsibilities
                                can be added to a Remote Facade. For example, its methods are a natural point
                                at which to apply security. An access control list can say which users can invoke
                                calls on which methods. The Remote Facade methods also are a natural point
                                at which to apply transactional control. A Remote Facade method can start a
                                transaction, do all the internal work, and then commit the transaction at the
                                end. Each call makes a good transaction because you donâ€™t want a transaction
                                open when return goes back to the client, since transactions arenâ€™t built to be
                                efficient for such long running cases.</p>
                <p>One of the biggest mistakes I see in a Remote Facade is putting domain logic
                                in it. Repeat after me three times; â€œRemote Facade has no domain logic.â€ Any
                                facade should be a thin skin that has only minimal responsibilities. If you need
                                domain logic for workflow or coordination either put it in your fine-grained
                                objects or create a separate nonremotable Transaction Script (110) to contain
                                it. You should be able to run the entire application locally without using the
                                Remote Facades or having to duplicate any code.
                                Remote Facade and Session Facade Over the last couple of years the Session
                                Facade [Alur et al.] pattern has been appearing in the J2EE community. In my
                                earlier drafts I considered Remote Facade to be the same pattern as Session
                                Facade and used the Session Facade name. In practice, however, thereâ€™s a crucial
                                difference. Remote Facade is all about having a thin remote skinâ€”hence my
                                diatribe against domain logic in it. In contrast, most descriptions of Session
                                Facade involve putting logic in it, usually of a workflow kind. A large part of
                                this is due to the common approach of using J2EE session beans to wrap entity
                                beans. Any coordination of entity beans has to be done by another object since
                                they canâ€™t be re-entrant.</p>
                <p>As a result, I see a Session Facade as putting several Transaction Scripts
                                (110) in a remote interface. Thatâ€™s a reasonable approach, but it isnâ€™t the same
                                thing as a Remote Facade. Indeed, I would argue that, since the Session Facade
                                contains domain logic, it shouldnâ€™t be called a facade at all!
                                Service Layer A concept familiar to facades is a Service Layer (133). The main
                                difference is that a service layer doesnâ€™t have to be remote and thus doesnâ€™t need to
                                have only fine-grained methods. In simplifying the Domain Model (116), you
                                often end up with coarser-grained methods, but thatâ€™s for clarity, not for network
                                efficiency. Furthermore, thereâ€™s no need for a service layer to use Data Transfer
                                Objects (401). Usually it can happily return real domain objects to the client.
                                If a Domain Model (116) is going to be used both within a process and
                                remotely, you can have a Service Layer (133) and layer a separate Remote
                                Facade on top of it. If the process is only used remotely, itâ€™s probably easier to
                                fold the Service Layer (133) into the Remote Facade, providing the Service
                                Layer (133) has no application logic. If thereâ€™s any application logic in it, then I
                                would make the Remote Facade a separate object.</p>
                <h3 id="392">When to Use It</h3>
                <p>Use Remote Facade whenever you need remote access to a fine-grained object
                                model. You gain the advantages of a coarse-grained interface while still keeping
                                the advantage of fine-grained objects, giving you the best of both worlds.
                                The most common use of this pattern is between a presentation and a
                                Domain Model (116), where the two may run on different processes. Youâ€™ll get
                                this between a swing UI and server domain model or with a servlet and a server
                                object model if the application and Web servers are different processes.
                                Most often you run into this with different processes on different machines,
                                but it turns out that the cost of an inter-process call on the same box is sufficiently large that you need a coarse-grained interface for any inter-process communication regardless of where the processes live.
                                If all your access is within a single process, you donâ€™t need this kind of conversion. Thus, I wouldnâ€™t use this pattern to communicate between a client
                                Domain Model (116) and its presentation or between a CGI script and Domain
                                Model (116) running in one Web server. You donâ€™t see Remote Facade used
                                with a Transaction Script (110) as a rule, since a Transaction Script (110) is
                                inherently coarser grained.
                                Remote Facades imply a synchronousâ€”that is, a remote procedure callâ€”
                                style of distribution. Often you can greatly improve the responsiveness of an
                                application by going with asynchronous, message-based remote communication. Indeed, an asynchronous approach has many compelling advantages.
                                Sadly, discussion of asynchronous patterns is outside the scope of this book.</p>
                <h3 id="392(2)">Example: Using a Java Session Bean as a Remote Facade (Java)</h3>
                <p>If youâ€™re working with the Enterprise Java platform, a good choice for a distributed facade is a session bean because its a remote object and may be stateful or
                                stateless. In this example Iâ€™ll run a bunch of POJOs (plain old Java objects) inside
                                an EJB container and access them remotely through a session bean thatâ€™s designed
                                as a Remote Facade. Session beans arenâ€™t particularly complicated, so everything
                                should make sense even if you havenâ€™t done any work with them before.
                                I feel the need for a couple of side notes here. First, Iâ€™ve been surprised by
                                how many people seem to believe that you canâ€™t run plain objects inside an EJB
                                container in Java. I hear the question, â€œAre the domain objects entity beans?â€
                                The answer is, they can be but they donâ€™t have to be. Simple Java objects work
                                just fine, as in this example.</p>
                <p>My second side note is just to point out that this isnâ€™t the only way to use session beans. They can also be used to host Transaction Scripts (110).
                                In this example Iâ€™ll look at remote interfaces for accessing information about
                                music albums. The Domain Model (116) consists of fine-grained objects that
                                represent an artist, and album, and tracks. Surrounding this are several other
                                packages that provide the data sources for the application (see Figure 15.2).
                                In the figure, the dto package contains Data Transfer Objects (401) that help
                                move data over the wire to the client. They have simple accessor behavior and
                                also the ability to serialize themselves in binary or XML textual formats. In the
                                remote package are assembler objects that move data between the domain
                                objects and the Data Transfer Objects (401). If youâ€™re interested in how this
                                works see the Data Transfer Object (401) discussion.</p>
                <p>To explain the facade Iâ€™ll assume that I can move data into and out of Data
                                Transfer Objects (401) and concentrate on the remote interfaces. A single logical Java session bean has three actual classes. Two of them make up the remote
                                API (and in fact are Java interfaces); the other is the class that implements the
                                API. The two interfaces are the AlbumService itself and the home object, AlbumHome.
                                The home object is used by the naming service to get access to the distributed
                                facade, but thatâ€™s an EJB detail that Iâ€™ll skip over here. Our interest is in the
                                Remote Facade itself; AlbumService. Its interface is declared in the API package to
                                be used by the client and is just a list of methods.
                                <pre>class AlbumService...
                                String play(String id) throws RemoteException;
                                String getAlbumXml(String id) throws RemoteException;
                                AlbumDTO getAlbum(String id) throws RemoteException;
                                void createAlbum(String id, String xml) throws RemoteException;
                                void createAlbum(String id, AlbumDTO dto) throws RemoteException;
                                void updateAlbum(String id, String xml) throws RemoteException;
                                void updateAlbum(String id, AlbumDTO dto) throws RemoteException;
                                void addArtistNamed(String id, String name) throws RemoteException;
                                void addArtist(String id, String xml) throws RemoteException;
                                void addArtist(String id, ArtistDTO dto) throws RemoteException;
                                ArtistDTO getArtist(String id) throws RemoteException;</pre>
                                Notice that even in this short example I see methods for two different classes
                                in the Domain Model (116): artist and album. I also see minor variations on the
                                same method. Methods have variants that use either the Data Transfer Object
                                (401) or an XML string to move data into the remote service. This allows the
                                client to choose which form to use depending on the nature of the client and of
                                the connection. As you can see, for even a small application this can lead to
                                many methods on AlbumService.
                                Fortunately, the methods themselves are very simple. Here are the ones for
                                manipulating albums:
                                <pre>class AlbumServiceBean...
                                public AlbumDTO getAlbum(String id) throws RemoteException {
                                return new AlbumAssembler().writeDTO(Registry.findAlbum(id));
                                }
                                public String getAlbumXml(String id) throws RemoteException {
                                AlbumDTO dto = new AlbumAssembler().writeDTO(Registry.findAlbum(id));
                                return dto.toXmlString();
                                }
                                public void createAlbum(String id, AlbumDTO dto) throws RemoteException {
                                new AlbumAssembler().createAlbum(id, dto);
                                }
                                public void createAlbum(String id, String xml) throws RemoteException {
                                AlbumDTO dto = AlbumDTO.readXmlString(xml);
                                new AlbumAssembler().createAlbum(id, dto);
                                }
                                public void updateAlbum(String id, AlbumDTO dto) throws RemoteException {
                                new AlbumAssembler().updateAlbum(id, dto);
                                }
                                public void updateAlbum(String id, String xml) throws RemoteException {
                                AlbumDTO dto = AlbumDTO.readXmlString(xml);
                                new AlbumAssembler().updateAlbum(id, dto);
                                }</pre>
                                As you can see, each method really does nothing more than delegate to another
                                object, so itâ€™s only a line or two in length. This snippet illustrates nicely what a
                                distributed facade should look like: a long list of very short methods with very
                                little logic in them. The facade then is nothing more than a packaging mechanism, which is as it should be.
                                Weâ€™ll just finish with a few words on testing. Itâ€™s very useful to be able to do
                                as much testing as possible in a single process. In this case I can write tests for
                                the session bean implementation directly: these can be run without deploying to
                                the EJB container.
                                <pre>class XmlTester...
                                private AlbumDTO kob;
                                private AlbumDTO newkob;
                                private AlbumServiceBean facade = new AlbumServiceBean();
                                protected void setUp() throws Exception {
                                facade.initializeForTesting();
                                kob = facade.getAlbum("kob");
                                Writer buffer = new StringWriter();
                                kob.toXmlString(buffer);
                                newkob = AlbumDTO.readXmlString(new StringReader(buffer.toString()));
                                }
                                public void testArtist() {
                                assertEquals(kob.getArtist(), newkob.getArtist());
                                }</pre>
                                That was one of the JUnit tests to be run in memory. It showed how I can create
                                an instance of the session bean outside the container and run tests on it, allowing a faster testing turnaround.</p>
                <h3 id="395">Example: Web Service (C#)</h3>
                <p>I was talking over this book with Mike Hendrickson, my editor at AddisonWesley. Ever alert to the latest buzzwords, he asked me if I had anything
                                about Web services in it. Iâ€™m actually loathe to rush to every fashionâ€”after
                                all, given the languid pace of book publishing any â€œlatest fashionâ€ that I write
                                about will seem quaint by the time you read about it. Still, itâ€™s a good example
                                of how core patterns so often keep their value even with the latest technological flip-flops.
                                At its heart a Web service is nothing more than an interface for remote usage
                                (with a slow string-parsing step thrown in for good measure). As such the basic
                                advice of Remote Facade holds: Build your functionality in a fine-grained manner and then layer a Remote Facade over the fine-grained model in order to
                                handle Web services.</p>
                <p>For the example, Iâ€™ll use the same basic problem I described previously, but
                                concentrate just on the request for information about a single album.
                                Figure 15.3 shows the various classes that take part. They fall into the familiar
                                groups: album service, the Remote Facade; two Data Transfer Objects (401);
                                three objects in a Domain Model (116); and an assembler to pull data from the
                                Domain Model (116) into the Data Transfer Objects (401).
                                The Domain Model (116) is absurdly simple; indeed, for this kind of problem youâ€™re better off using a Table Data Gateway (144) to create the Data
                                Transfer Objects (401) directly. However, that would rather spoil the example
                                of a Remote Facade layered over a domain model.
                                <pre>class Album...
                                public String Title;
                                public Artist Artist;
                                public IList Tracks {
                                get {return ArrayList.ReadOnly(tracksData);}
                                }
                                public void AddTrack (Track arg) {
                                tracksData.Add(arg);
                                }
                                public void RemoveTrack (Track arg) {
                                tracksData.Remove(arg);
                                }
                                private IList tracksData = new ArrayList();
                                class Artist...
                                public String Name;
                                class Track...
                                public String Title;
                                public IList Performers {
                                get {return ArrayList.ReadOnly(performersData);}
                                }
                                public void AddPerformer (Artist arg) {
                                performersData.Add(arg);
                                }
                                public void RemovePerformer (Artist arg) {
                                performersData.Remove(arg);
                                }</pre>
                                private IList performersData = new ArrayList();
                                I use Data Transfer Objects (401) for passing the data over the wire. These are
                                just data holders that flatten the structure for the purposes of the Web service.
                                <pre>class AlbumDTO...
                                public String Title;
                                public String Artist;
                                public TrackDTO[] Tracks;
                                class TrackDTO...
                                public String Title;
                                public String[] Performers;</pre>
                                Since this is .NET, I donâ€™t need to write any code to serialize and restore into
                                XML. The .NET framework comes with the appropriate serializer class to do
                                the job.
                                This is a Web service, so I also need to declare the structure of the Data
                                Transfer Objects (401) in WSDL. The Visual Studio tools will generate the
                                WSDL for me, and Iâ€™m a lazy kind of guy, so Iâ€™ll let it do that. Hereâ€™s the XML
                                Schema definition that corresponds to the Data Transfer Objects (401):
                                <pre><s:complexType name="AlbumDTO">
                                <s:sequence>
                                <s:element minOccurs="1" maxOccurs="1" name="Title" nillable="true" type="s:string" />
                                <s:element minOccurs="1" maxOccurs="1" name="Artist" nillable="true" type="s:string" />
                                <s:element minOccurs="1" maxOccurs="1" name="Tracks"
                                nillable="true" type="s0:ArrayOfTrackDTO" />
                                </s:sequence>
                                </s:complexType>
                                <s:complexType name="ArrayOfTrackDTO">
                                <s:sequence>
                                <s:element minOccurs="0" maxOccurs="unbounded" name="TrackDTO"
                                nillable="true" type="s0:TrackDTO" />
                                </s:sequence>
                                </s:complexType>
                                <s:complexType name="TrackDTO">
                                <s:sequence>
                                <s:element minOccurs="1" maxOccurs="1" name="Title" nillable="true" type="s:string" />
                                <s:element minOccurs="1" maxOccurs="1" name="Performers"
                                nillable="true" type="s0:ArrayOfString" />
                                </s:sequence>
                                </s:complexType>
                                <s:complexType name="ArrayOfString">
                                <s:sequence>
                                <s:element minOccurs="0" maxOccurs="unbounded" name="string"
                                nillable="true" type="s:string" />
                                </s:sequence>
                                </s:complexType></pre>
                                Being XML, itâ€™s a particularly verbose data structure definition, but it does the
                                job.
                                To get the data from the Domain Model (116) to the Data Transfer Object
                                (401) I need an assembler.
                                <pre>class AlbumAssembler...
                                public AlbumDTO WriteDTO (Album subject) {
                                AlbumDTO result = new AlbumDTO();
                                result.Artist = subject.Artist.Name;
                                result.Title = subject.Title;
                                ArrayList trackList = new ArrayList();
                                foreach (Track t in subject.Tracks)
                                trackList.Add (WriteTrack(t));
                                result.Tracks = (TrackDTO[]) trackList.ToArray(typeof(TrackDTO));
                                return result;
                                }
                                public TrackDTO WriteTrack (Track subject) {
                                TrackDTO result = new TrackDTO();
                                result.Title = subject.Title;
                                result.Performers = new String[subject.Performers.Count];
                                ArrayList performerList = new ArrayList();
                                foreach (Artist a in subject.Performers)
                                performerList.Add (a.Name);
                                result.Performers = (String[]) performerList.ToArray(typeof (String));
                                return result;
                                }
                                The last piece we need is the service definition itself. This comes first from the
                                C# class.
                                class AlbumService...
                                [ WebMethod ]
                                public AlbumDTO GetAlbum(String key) {
                                Album result = new AlbumFinder()[key];
                                if (result == null)
                                throw new SoapException ("unable to find album with key: " +
                                key, SoapException.ClientFaultCode);
                                else return new AlbumAssembler().WriteDTO(result);
                                }</pre>
                                Of course, this isnâ€™t the real interface definitionâ€”that comes from the WSDL
                                file. Here are the relevant bits:
                                <pre><portType name="AlbumServiceSoap">
                                <operation name="GetAlbum">
                                <input message="s0:GetAlbumSoapIn" />
                                <output message="s0:GetAlbumSoapOut" />
                                </operation>
                                </portType>
                                <message name="GetAlbumSoapIn">
                                <part name="parameters" element="s0:GetAlbum" />
                                </message>
                                <message name="GetAlbumSoapOut">
                                <part name="parameters" element="s0:GetAlbumResponse" />
                                </message>
                                <s:element name="GetAlbum">
                                <s:complexType>
                                <s:sequence>
                                <s:element minOccurs="1" maxOccurs="1" name="key" nillable="true" type="s:string" />
                                </s:sequence>
                                </s:complexType>
                                </s:element>
                                <s:element name="GetAlbumResponse">
                                <s:complexType>
                                <s:sequence>
                                <s:element minOccurs="1" maxOccurs="1" name="GetAlbumResult"
                                nillable="true" type="s0:AlbumDTO" />
                                </s:sequence>
                                </s:complexType>
                                </s:element></pre>
                                As expected, WSDL is rather more garrulous than your average politician,
                                but unlike so many of them, it does get the job done. I can now invoke the service by sending a SOAP message of the form
                                <pre><?xml version="1.0" encoding="utf-8"?>
                                <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                                xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                                xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
                                <soap:Body>
                                <GetAlbum xmlns="http://martinfowler.com">
                                <key>aKeyString</key>
                                </GetAlbum>
                                </soap:Body>
                                </soap:Envelope></pre>
                                The important thing to remember about this example isnâ€™t the cool gyrations
                                with SOAP and .NET but the fundamental layering approach. Design an application without distribution, then layer the distribution ability on top of it with
                                Remote Facades and Data Transfer Objects (401).</p>
                <h3 id="401">Data Transfer Object</h3>
                <p>An object that carries data between processes in order
                                to reduce the number of method calls.
                                When youâ€™re working with a remote interface, such as Remote Facade (388),
                                each call to it is expensive. As a result you need to reduce the number of calls,
                                and that means that you need to transfer more data with each call. One way to
                                do this is to use lots of parameters. However, this is often awkward to programâ€”indeed, itâ€™s often impossible with languages such as Java that return
                                only a single value.
                                The solution is to create a Data Transfer Object that can hold all the data for
                                the call. It needs to be serializable to go across the connection. Usually an
                                assembler is used on the server side to transfer data between the DTO and any
                                domain objects.
                                Many people in the Sun community use the term â€œValue Objectâ€ for this pattern. I use it to mean something else. See the discussion on page 487.</p>
                <h3 id="401(2)">How It Works</h3>
                <p>In many ways, a Data Transfer Object is one of those objects our mothers told
                                us never to write. Itâ€™s often little more than a bunch of fields and the getters and
                                setters for them. The value of this usually hateful beast is that it allows you to
                                move several pieces of information over a network in a single callâ€”a trick
                                thatâ€™s essential for distributed systems.
                                Whenever a remote object needs some data, it asks for a suitable Data Transfer Object. The Data Transfer Object will usually carries much more data than
                                what the remote object requested, but it should carry all the data the remote
                                object will need for a while. Due to the latency costs of remote calls, its better
                                to err on the side of sending too much data than have to make multiple calls.
                                A single Data Transfer Object usually contains more than just a single server
                                object. It aggregates data from all the server objects that the remote object is
                                likely to want data from. Thus, if a remote object requests data about an order
                                object, the returned Data Transfer Object will contain data from the order, the
                                customer, the line items, the products on the line items, the delivery informationâ€”all sorts of stuff.
                                You canâ€™t usually transfer objects from a Domain Model (116). This is
                                because the objects are usually connected in a complex web thatâ€™s difficult, if
                                not impossible, to serialize. Also you usually donâ€™t want the domain object
                                classes on the client, which is tantamount to copying the whole Domain Model
                                (116) there. Instead you have to transfer a simplified form of the data from the
                                domain objects.</p>
                <p>The fields in a Data Transfer Object are fairly simple, being primitives, simple classes like strings and dates, or other Data Transfer Objects. Any structure
                                between data transfer objects should be a simple graph structureâ€”normally a
                                hierarchyâ€”as opposed to the more complicated graph structures that you see in
                                a Domain Model (116). Keep these simple attributes because they have to be
                                serializable and they need to be understood by both sides of the wire. As a
                                result the Data Transfer Object classes and any classes they reference must be
                                present on both sides.
                                It makes sense to design the Data Transfer Object around the needs of a particular client. Thatâ€™s why you often see them corresponding to Web pages or
                                GUI screens. You may also see multiple Data Transfer Objects for an order,
                                depending on the particular screen. Of course, if different presentations require
                                similar data, then it makes sense to use a single Data Transfer Object to handle
                                them all.</p>
                <p>A related question to consider is using a single Data Transfer Object for a
                                whole interaction versus different ones for each request. Different Data Transfer Objects make it easier to see what data is transferred in each call, but leads
                                to a lot of Data Transfer Objects. One is less work to write, but makes it harder
                                to see how each call transfers information. Iâ€™m inclined to use just one if thereâ€™s
                                a lot of commonality over the data, but I donâ€™t hesitate to use different Data
                                Transfer Objects if a particular request suggests it. Itâ€™s one of those things you
                                canâ€™t make a blanket rule about, so I might use one Data Transfer Object for
                                most of the interaction and use different ones for a couple of requests and
                                responses.</p>
                <p>A similar question is whether to have a single Data Transfer Object for both
                                request and response or separate ones for each. Again, thereâ€™s no blanket rule. If
                                the data in each case is pretty similar, use one. If theyâ€™re very different, I use two.
                                Some people like to make Data Transfer Objects immutable. In this scheme
                                you receive one Data Transfer Object from the client and create and send back
                                a different one, even if itâ€™s the same class. Other people alter the request Data
                                Transfer Object. I donâ€™t have any strong opinions either way, but on the whole
                                I prefer a mutable Data Transfer Object because itâ€™s easier to put the data in
                                gradually, even if you make a new object for the response. Some arguments in
                                favor of immutable Data Transfer Object have to do with the naming confusion with Value Object (486).
                                A common form for Data Transfer Object is that of a Record Set (508), that
                                is, a set of tabular recordsâ€”exactly what you get back from a SQL query.
                                Indeed, a Record Set (508) is the Data Transfer Object for a SQL database.
                                Architectures often use it throughout the design. A domain model can generate
                                a Record Set (508) of data to transfer to a client, which the client treats as if it
                                was coming directly from SQL. This is useful if the client has tools that bind to
                                Record Set (508) structures. The Record Set (508) can be entirely created by the
                                domain logic, but more likely itâ€™s generated from a SQL query and modified by
                                the domain logic before itâ€™s passed on to the presentation. This style lends itself
                                to Table Module (125).</p>
                <p>Another form of Data Transfer Object is as a generic collection data structure. Iâ€™ve seen arrays used for this, but I discourage that because the array indices obscure the code. The best collection is a dictionary because you can use
                                meaningful strings as keys. The problem is that you lose the advantage of an
                                explicit interface and strong typing. A dictionary can be worth using for ad hoc
                                cases when you donâ€™t have a generator at hand, as itâ€™s easier to manipulate one
                                than to write an explicit object by hand. However, with a generator I think
                                youâ€™re better off with an explicit interface, especially when you consider that it
                                is being used as communication protocol between different components.
                                Serializing the Data Transfer Object Other than simple getters and setters, the
                                Data Transfer Object is also usually responsible for serializing itself into some
                                format that will go over the wire. Which format depends on whatâ€™s on either
                                side of the connection, what can run over the connection itself, and how easy
                                the serialization is. A number of platforms provide built in serialization for simple objects. For example, Java has a built-in binary serialization and .NET has
                                built-in binary and XML serializations. If thereâ€™s a built-in serialization, it usually works right out of the box because Data Transfer Objects are simple structures that donâ€™t deal with the complexities you run into with objects in a
                                domain model. As a result I always use the automatic mechanism if I can.
                                If you donâ€™t have an automatic mechanism, you can usually create one yourself. Iâ€™ve seen several code generators that take a simple record descriptions and
                                generate appropriate classes to hold the data, provide accessors, and read and
                                write the data serializations. The important thing is to make the generator only
                                as complicated as you actually need it to be, and donâ€™t try to put in features you
                                only think youâ€™ll need. It can be a good idea to write the first classes by hand
                                and then use them to help you write the generator.</p>
                <p>You can also use reflective programming to handle the serialization. That
                                way you only have to write the serialization and deserialization routines once
                                and put them in a superclass. There may be a performance cost to this; youâ€™ll
                                have to measure it to find out if the cost is significant.
                                You have to choose a mechanism that both ends of the connection will work
                                with. If you control both ends, you pick the easiest one; if you donâ€™t, you may
                                be able to provide a connector at the end you donâ€™t own. Then you can use a
                                simple Data Transfer Object on both sides of the connection and use the connector to adapt to the foreign component.
                                One of the most common issues you face with Data Transfer Object is
                                whether to use a text or a binary serialization form. Text serializations are easy
                                to read to learn whatâ€™s being communicated. XML is popular because you can
                                easily get tools to create and parse XML documents. The big disadvantages
                                with text are that it needs more bandwidth to send the same data (something
                                particularly true of XML) and thereâ€™s often a performance penalty, which can
                                be quite significant.</p>
                <p>An important factor for serialization is the synchronization of the Data
                                Transfer Object on each side of the wire. In theory, whenever the server changes
                                the definition of the Data Transfer Object, the client updates as well but in
                                practice this may not happen. Accessing a server with an out-of-date client
                                always leads to problems, but the serialization mechanism can make the problems more or less painful. With a pure binary serialization of a Data Transfer
                                Object the result will be that its communication is entirely lost, since any
                                change to its structure usually causes an error on deserialization. Even an
                                innocuous change, such as adding an optional field, will have this effect. As a
                                result direct binary serialization can introduce a lot of fragility into the communication lines.
                                Other serialization schemes can avoid this. One is XML serialization, which
                                can usually be written in a way that makes the classes more tolerant of changes.
                                Another is a more tolerant binary approach, such as serializing the data using a
                                dictionary. Although I donâ€™t like using a dictionary as the Data Transfer Object,
                                it can be a useful way of doing a binary serialization of the data, since that
                                introduces some tolerance into the synchronization.</p>
                <p>Assembling a Data Transfer Object from Domain Objects A Data Transfer Object doesnâ€™t know about how to connect with domain objects. This is because
                                it should be deployed on both sides of the connection. For that reason I donâ€™t
                                want the Data Transfer Object to be dependent on the domain object. Nor do
                                I want the domain objects to be dependent of the Data Transfer Object since
                                the Data Transfer Object structure will change when I alter interface formats.
                                As a general rule, I want to keep the domain model independent of the external interfaces.
                                As a result I like to make a separate assembler object responsible for creating
                                a Data Transfer Object from the domain model and updating the model from it
                                (Figure 15.4). The assembler is an example of a Mapper (473) in that it maps
                                between the Data Transfer Object and the domain objects.
                                I may also have multiple assemblers share the same Data Transfer Object. A
                                common case for this is different update semantics in different scenarios using
                                Figure 15.4 An assembler object can keep the domain model and the data transfer
                                objects independent of each other.
                                <pre>Domain Object
                                serialize
                                deserialize
                                Data Transfer Object
                                createDataTransferObject (DomainObject)
                                updateDomainObject (DataTransferObject)
                                createDomainObject (DataTransferObject)
                                Assembler</pre>
                                the same data. Another reason to separate the assembler is that the Data Transfer Object can easily be generated automatically from a simple data description.
                                Generating the assembler is more difficult and indeed often impossible.</p>
                <h3 id="406">When to Use It</h3>
                <p>Use a Data Transfer Object whenever you need to transfer multiple items of
                                data between two processes in a single method call.
                                There are some alternatives to Data Transfer Object, although Iâ€™m not a fan
                                of them. One is to not use an object at all but simply to use a setting method
                                with many arguments or a getting method with several pass-by reference arguments. The problem is that many languages, such as Java, allow only one object
                                as a return value, so, although this can be used for updates, it canâ€™t be used for
                                retrieving information without playing games with callbacks.
                                Another alternative is to use a some form of string representation directly,
                                without an object acting as the interface to it. Here the problem is that everything
                                else is coupled to the string representation. Itâ€™s good to hide the precise representation behind an explicit interface; that way, if you want to change the string or
                                replace it with a binary structure, you donâ€™t have to change anything else.
                                In particular, itâ€™s worth creating a Data Transfer Object when you want to
                                communicate between components using XML. The XML DOM is a pain in
                                the neck to manipulate, and itâ€™s much better to use a Data Transfer Object that
                                encapsulates it, especially since the Data Transfer Object is so easy to generate.
                                Another common purpose for a Data Transfer Object is to act as a common
                                source of data for various components in different layers. Each component
                                makes some changes to the Data Transfer Object and then passes it on to the
                                next layer. The use of Record Set (508) in COM and .NET is a good example of
                                this, where each layer knows how to manipulate record set based data, whether
                                it comes directly from a SQL database or has been modified by other layers.
                                .NET expands on this by providing a built-in mechanism to serialize record sets
                                into XML.</p>
                <p>Although this book focuses on synchronous systems, thereâ€™s an interesting
                                asynchronous use for Data Transfer Object. This is where you want to use an
                                interface both synchronously and asynchronously. Return a Data Transfer
                                Object as usual for the synchronous case; for the asynchronous case create a
                                Lazy Load (200) of the Data Transfer Object and return that. Connect the
                                Lazy Load (200) to wherever the results from the asynchronous call should
                                appear. The user of the Data Transfer Object will block only when it tries to
                                access the results of the call.</p>
                <h3 id="407">Further Reading</h3>
                <p>[Alur et al.] discuss this pattern under the name Value Object, which I said earlier is equivalent to my Data Transfer Object; my Value Object (486) is a different pattern entirely. This is a name collision; many people have used â€œValue
                                Objectâ€ in the sense that I use it. As far as I can tell, its use to mean what I call
                                Data Transfer Object occurs only within the J2EE community. As a result, Iâ€™ve
                                followed the more general usage.
                                The Value Object Assembler [Alur et al.] is a discussion of the assembler. I
                                chose not to make it a separate pattern, although I use the â€œassemblerâ€ name
                                rather than a name based on Mapper (473).
                                [Marinescu] discusses Data Transfer Object and several implementation
                                variants. [Riehle et al.] discuss flexible ways to serialize, including switching
                                between different forms of serialization.</p>
                <h3 id="407(2)">Example: Transferring Information About Albums (Java)</h3>
                <p>For this example Iâ€™ll use the domain model in Figure 15.5. The data I want to
                                transfer is the data about these linked objects, and the structure for the data
                                transfer objects is the one in Figure 15.6.
                                The data transfer objects simplify this structure a good bit. The relevant data
                                from the artist class is collapsed into the album DTO, and the performers for a
                                track are represented as an array of strings. This is typical of the collapsing of
                                structure you see for a data transfer object. There are two data transfer objects
                                present, one for the album and one for each track. In this case I donâ€™t need one
                                for the artist, as all the data is present on one of the other two. I only have the
                                track as a transfer object because there are several tracks in the album and each
                                one can contain more than one data item.
                                Hereâ€™s the code to write a Data Transfer Object from the domain model. The
                                assembler is called by whatever object is handling the remote interface, such as
                                a Remote Facade (388).
                                <pre>class AlbumAssembler...
                                public AlbumDTO writeDTO(Album subject) {
                                AlbumDTO result = new AlbumDTO();
                                result.setTitle(subject.getTitle());
                                result.setArtist(subject.getArtist().getName());
                                writeTracks(result, subject);
                                return result;
                                }
                                private void writeTracks(AlbumDTO result, Album subject) {
                                List newTracks = new ArrayList();
                                Iterator it = subject.getTracks().iterator();
                                while (it.hasNext()) {
                                TrackDTO newDTO = new TrackDTO();
                                Track thisTrack = (Track) it.next();
                                newDTO.setTitle(thisTrack.getTitle());
                                writePerformers(newDTO, thisTrack);
                                newTracks.add(newDTO);
                                }
                                result.setTracks((TrackDTO[]) newTracks.toArray(new TrackDTO[0]));
                                }
                                private void writePerformers(TrackDTO dto, Track subject) {
                                List result = new ArrayList();
                                Iterator it = subject.getPerformers().iterator();
                                while (it.hasNext()) {
                                Artist each = (Artist) it.next();
                                result.add(each.getName());
                                }
                                dto.setPerformers((String[]) result.toArray(new String[0]));
                                }
                                Figure 15.6 A class diagram of data transfer objects.
                                title: String
                                artist: String
                                Album DTO
                                title: String
                                performers: Array of String
                                Track DTO
                                1 *</pre>
                                Updating the model from the Data Transfer Object is usually more involved.
                                For this example thereâ€™s a difference between creating a new album and updating an existing one. Hereâ€™s the creation code:
                                <pre>class AlbumAssembler...
                                public void createAlbum(String id, AlbumDTO source) {
                                Artist artist = Registry.findArtistNamed(source.getArtist());
                                if (artist == null)
                                throw new RuntimeException("No artist named " + source.getArtist());
                                Album album = new Album(source.getTitle(), artist);
                                createTracks(source.getTracks(), album);
                                Registry.addAlbum(id, album);
                                }
                                private void createTracks(TrackDTO[] tracks, Album album) {
                                for (int i = 0; i < tracks.length; i++) {
                                Track newTrack = new Track(tracks[i].getTitle());
                                album.addTrack(newTrack);
                                createPerformers(newTrack, tracks[i].getPerformers());
                                }
                                }
                                private void createPerformers(Track newTrack, String[] performerArray) {
                                for (int i = 0; i < performerArray.length; i++) {
                                Artist performer = Registry.findArtistNamed(performerArray[i]);
                                if (performer == null)
                                throw new RuntimeException("No artist named " + performerArray[i]);
                                newTrack.addPerformer(performer);
                                }
                                }</pre>
                                Reading the DTO involves quite a few decisions. Noticeable here is how to
                                deal with the artist names as they come in. My requirements are that artists
                                should already be in a Registry (480) when I create the album, so if I canâ€™t find
                                an artist this is an error. A different create method might decide to create artists
                                when theyâ€™re mentioned in the Data Transfer Object.
                                For this example I have a different method for updating an existing album.
                                <pre>class AlbumAssembler...
                                public void updateAlbum(String id, AlbumDTO source) {
                                Album current = Registry.findAlbum(id);
                                if (current == null)
                                throw new RuntimeException("Album does not exist: " + source.getTitle());
                                if (source.getTitle() != current.getTitle()) current.setTitle(source.getTitle());
                                if (source.getArtist() != current.getArtist().getName()) {
                                Artist artist = Registry.findArtistNamed(source.getArtist());
                                if (artist == null)
                                throw new RuntimeException("No artist named " + source.getArtist());
                                current.setArtist(artist);
                                }
                                updateTracks(source, current);
                                }
                                private void updateTracks(AlbumDTO source, Album current) {
                                for (int i = 0; i < source.getTracks().length; i++) {
                                current.getTrack(i).setTitle(source.getTrackDTO(i).getTitle());
                                current.getTrack(i).clearPerformers();
                                createPerformers(current.getTrack(i), source.getTrackDTO(i).getPerformers());
                                }
                                }</pre>
                                As for updates you can decide to either update the existing domain object or
                                destroy it and replace it with a new one. The question here is whether you have
                                other objects referring to the object you want to update. In this code Iâ€™m updating the album since I have other objects referring to it and its tracks. However,
                                for the title and performers of a track I just replace the objects that are there.
                                Another question concerns an artist changing. Is this changing the name of
                                the existing artist or changing the artist the album is linked to? Again, these
                                questions have to be settled on a case-by-use case basis, and Iâ€™m handling it by
                                linking to a new artist.
                                In this example Iâ€™ve used native binary serialization, which means I have to
                                be careful that the Data Transfer Object classes on both sides of the wire are
                                kept in sync. If I make a change to the data structure of the server Data Transfer Object and donâ€™t change the client, Iâ€™ll get errors in the transfer. I can make
                                the transfer more tolerant by using a map as my serialization.
                                <pre>class TrackDTO...
                                public Map writeMap() {
                                Map result = new HashMap();
                                result.put("title", title);
                                result.put("performers", performers);
                                return result;
                                }
                                public static TrackDTO readMap(Map arg) {
                                TrackDTO result = new TrackDTO();
                                result.title = (String) arg.get("title");
                                result.performers = (String[]) arg.get("performers");
                                return result;
                                }</pre>
                                Now, if I add a field to the server and use the old client, although the new field
                                wonâ€™t be picked up by the client, the rest of the data will transfer correctly.
                                Of course, writing the serialization and deserialization routines like this is
                                tedious. I can avoid much of this tedium by using a reflective routine such as
                                this on the Layer Supertype (475):
                                <pre>class DataTransferObject...
                                public Map writeMapReflect() {
                                Map result = null;
                                try {
                                Field[] fields = this.getClass().getDeclaredFields();
                                result = new HashMap();
                                for (int i = 0; i < fields.length; i++)
                                result.put(fields[i].getName(), fields[i].get(this));
                                } catch (Exception e) {throw new ApplicationException (e);
                                }
                                return result;
                                }
                                public static TrackDTO readMapReflect(Map arg) {
                                TrackDTO result = new TrackDTO();
                                try {
                                Field[] fields = result.getClass().getDeclaredFields();
                                for (int i = 0; i  fields.length; i++)
                                fields[i].set(result, arg.get(fields[i].getName()));
                                } catch (Exception e) {throw new ApplicationException (e);
                                }
                                return result;
                                }</pre>
                                Such a routine will handle most cases pretty well (although youâ€™ll have to add
                                extra code to handle primitives).</p>
                <h3 id="411">Example: Serializing Using XML (Java)</h3>
                <p>As I write this, Javaâ€™s XML handling is very much in flux and APIs, still volatile,
                                are generally getting better. By the time you read it this section may be out of
                                date or completely irrelevant, but the basic concept of converting to XML is
                                pretty much the same.
                                First I get the data structure for the Data Transfer Object; then I need to
                                decide how to serialize it. In Java you get free binary serialization simply by
                                using a marker interface. This works completely automatically for a Data
                                Transfer Object so itâ€™s my first choice. However, text-based serialization is often
                                necessary. For this example then, Iâ€™ll use XML.
                                For this example, Iâ€™m using JDOM since that makes working with XML
                                much easier than using the W3C standard interfaces. I write methods to read
                                and write an XML element to represent each Data Transfer Object class.
                                <pre>class AlbumDTO...
                                Element toXmlElement() {
                                Element root = new Element("album");
                                root.setAttribute("title", title);
                                root.setAttribute("artist", artist);
                                for (int i = 0; i < tracks.length; i++)
                                root.addContent(tracks[i].toXmlElement());
                                return root;
                                }
                                static AlbumDTO readXml(Element source) {
                                AlbumDTO result = new AlbumDTO();
                                result.setTitle(source.getAttributeValue("title"));
                                result.setArtist(source.getAttributeValue("artist"));
                                List trackList = new ArrayList();
                                Iterator it = source.getChildren("track").iterator();
                                while (it.hasNext())
                                trackList.add(TrackDTO.readXml((Element) it.next()));
                                result.setTracks((TrackDTO[]) trackList.toArray(new TrackDTO[0]));
                                return result;
                                }
                                class TrackDTO...
                                Element toXmlElement() {
                                Element result = new Element("track");
                                result.setAttribute("title", title);
                                for (int i = 0; i < performers.length; i++) {
                                Element performerElement = new Element("performer");
                                performerElement.setAttribute("name", performers[i]);
                                result.addContent(performerElement);
                                }
                                return result;
                                }
                                static TrackDTO readXml(Element arg) {
                                TrackDTO result = new TrackDTO();
                                result.setTitle(arg.getAttributeValue("title"));
                                Iterator it = arg.getChildren("performer").iterator();
                                List buffer = new ArrayList();
                                while (it.hasNext()) {
                                Element eachElement = (Element) it.next();
                                buffer.add(eachElement.getAttributeValue("name"));
                                }
                                result.setPerformers((String[]) buffer.toArray(new String[0]));
                                return result;
                                }</pre>
                                Of course, these methods only create the elements in the XML DOM. To perform the serialization I need to read and write text. Since the track is transferred only in the context of the album, I just need to write this album code.
                                <pre>class AlbumDTO...
                                public void toXmlString(Writer output) {
                                Element root = toXmlElement();
                                Document doc = new Document(root);
                                XMLOutputter writer = new XMLOutputter();
                                try {
                                writer.output(doc, output);
                                } catch (IOException e) {
                                e.printStackTrace();
                                }
                                }
                                public static AlbumDTO readXmlString(Reader input) {
                                try {
                                SAXBuilder builder = new SAXBuilder();
                                Document doc = builder.build(input);
                                Element root = doc.getRootElement();
                                AlbumDTO result = readXml(root);
                                return result;
                                } catch (Exception e) {
                                e.printStackTrace();
                                throw new RuntimeException();
                                }
                                }</pre>
                                Although it isnâ€™t rocket science, Iâ€™ll be glad when JAXB makes this kind of stuff
                                unnecessary.</p>
                <h3 id="415">Chapter 16</h3>
                <h2>Offline Concurrency Patterns</h2>
                <h3 id="416">Optimistic Offline Lock</h3>
                <p>Prevents conflicts between concurrent business transactions
                                by detecting a conflict and rolling back the transaction.
                                Often a business transaction executes across a series of system transactions.
                                Once outside the confines of a single system transaction, we canâ€™t depend on
                                our database manager alone to ensure that the business transaction will leave
                                the record data in a consistent state. Data integrity is at risk once two sessions
                                begin to work on the same records and lost updates are quite possible. Also,
                                with one session editing data that another is reading an inconsistent read
                                becomes likely.
                                Optimistic Offline Lock solves this problem by validating that the changes
                                about to be committed by one session donâ€™t conflict with the changes of another
                                session. A successful pre-commit validation is, in a sense, obtaining a lock indicating itâ€™s okay to go ahead with the changes to the record data. So long as the
                                validation and the updates occur within a single system transaction the business
                                transaction will display consistency.
                                Whereas Pessimistic Offline Lock (426) assumes that the chance of session
                                conflict is high and therefore limits the systemâ€™s concurrency, Optimistic Offline
                                Lock assumes that the chance of conflict is low. The expectation that session conflict isnâ€™t likely allows multiple users to work with the same data at the same time.</p>
                <h3 id="417">How It Works</h3>
                <p>An Optimistic Offline Lock is obtained by validating that, in the time since a
                                session loaded a record, another session hasnâ€™t altered it. It can be acquired at
                                any time but is valid only during the system transaction in which it is obtained.
                                Thus, in order that a business transaction not corrupt record data it must
                                acquire an Optimistic Offline Lock for each member of its change set during
                                the system transaction in which it applies changes to the database.
                                The most common implementation is to associate a version number with
                                each record in your system. When a record is loaded that number is maintained
                                by the session along with all other session state. Getting the Optimistic Offline
                                Lock is a matter of comparing the version stored in your session data to the
                                current version in the record data. Once the verification succeeds, all changes,
                                including an increment of the version, can be committed. The version increment
                                is what prevents inconsistent record data, as a session with an old version canâ€™t
                                acquire the lock.</p>
                <p>With an RDBMS data store the verification is a matter of adding the version
                                number to the criteria of any SQL statements used to update or delete a record.
                                A single SQL statement can both acquire the lock and update the record data.
                                The final step is for the business transaction to inspect the row count returned
                                by the SQL execution. A row count of 1 indicates success; 0 indicates that the
                                record has been changed or deleted. With a row count of 0 the business transaction must rollback the system transaction to prevent any changes from entering
                                the record data. At this point the business transaction must either abort or
                                attempt to resolve the conflict and retry.
                                In addition to a version number for each record, storing information as to
                                who last modified a record and when can be quite useful when managing concurrency conflicts. When informing a user of a failed update due to a concurrency violation a proper application will tell when the record was altered and
                                by whom. Itâ€™s a bad idea to use the modification timestamp rather than a version count for your optimistic checks because system clocks are simply too
                                unreliable, especially if youâ€™re coordinating across multiple servers.
                                In an alternative implementation the where clause in the update includes
                                every field in the row. The advantage here is that you can use the where clause
                                without using some form of version field, which can be handy if you canâ€™t add a
                                version field by altering the database tables. The problem is that this complicates the UPDATE statement with a potentially large where clause, which may
                                also be a performance impact depending on how clever the database is about
                                using the primary key index.</p>
                <p>Often implementing Optimistic Offline Lock is left at including the version
                                in UPDATE and DELETE statements, but this fails to address the problem of an
                                inconsistent read. Think of a billing system that creates charges and calculates
                                appropriate sales tax. A session creates the charge and then looks up the customerâ€™s address to calculate the tax on it, but during the charge generation session a separate customer maintenance session edits the customerâ€™s address. As
                                tax rates depend on location, the rate calculated by the charge generation session might be invalid, but since the charge generation session didnâ€™t make any
                                changes to the address the conflict wonâ€™t be detected.
                                Thereâ€™s no reason why Optimistic Offline Lock canâ€™t be used to detect an
                                inconsistent read. In the example above the charge generation session needs to
                                recognize that its correctness depends on the value of the customerâ€™s address. It
                                therefore should perform a version check on the address as well, perhaps by
                                adding the address to the change set or maintaining a separate list of items to be
                                version-checked. The latter requires a bit more work to set up, but results in
                                code that more clearly states its intent. If youâ€™re checking for a consistent read
                                simply by rereading the version rather than an artificial update, be especially
                                aware of your system transaction isolation level. The version reread will only
                                work with repeatable read or stronger isolation. Anything weaker requires an
                                increment of the version.</p>
                <p>A version check might be overkill for certain inconsistent read problems.
                                Often a transaction depends only on the presence of a record or maybe the value
                                of only one of its fields. In such a case you might improve your systemâ€™s liveliness
                                by checking conditions rather than the version, as fewer concurrent updates will
                                result in the failure of competing business transactions. The better you understand your concurrency issues, the better you can manage them in your code.
                                The Coarse-Grained Lock (438) can help with certain inconsistent read
                                conundrums by treating a group of objects as a single lockable item. Another
                                option is to simply execute all of the steps of the problematic business transaction within a long-running transaction. The ease of implementation might
                                prove worth the resource hit of using a few long transactions here and there.
                                Detection of an inconsistent read gets a bit difficult when your transaction is
                                dependent on the results of a dynamic query rather than the reading of specific
                                records. Itâ€™s possible for you to save the initial results and compare them to the
                                results of the same query at commit time as a means of obtaining an Optimistic
                                Offline Lock.
                                As with all locking schemes, Optimistic Offline Lock by itself doesnâ€™t provide adequate solutions to some of the trickier concurrency and temporal issues
                                in a business application. I canâ€™t stress enough that in a business application
                                concurrency management is as much a domain issue as it is a technical one. Is
                                the customer address scenario above really a conflict? It might be okay that I
                                calculated the sales tax with an older version of the customer, but which version
                                should I actually be using? This is a business issue. Or consider a collection.
                                What if two sessions simultaneously add items to a collection? The typical
                                Optimistic Offline Lock scheme wonâ€™t prevent this even though it might very
                                well be a violation of business rules.</p>
                <p>Thereâ€™s one system using Optimistic Offline Locks that we all should be familiar with: source code management (SCM). When an SCM system detects a conflict between programmers it usually can figure out the correct merge and retry the
                                commit. A quality merge strategy makes Optimistic Offline Lock very powerful
                                not only because the systemâ€™s concurrency is quite high but because users rarely
                                have to redo any work. Of course, the big difference between an SCM system and
                                an enterprise business application is that the SCM must implement only one type
                                of merge while the business system might implement hundreds. Some might be of
                                such complexity that theyâ€™re not worth the cost of coding. Others might be of
                                such value to the business that the merge should be coded by all means. Despite
                                rarely being done, the merging of business objects is possible. In fact, merging
                                business data is a pattern unto its own. Iâ€™ll leave it at that rather than butcher the
                                topic, but do understand the power that merging adds to Optimistic Offline Lock.
                                Optimistic Offline Lock only lets us know during the last system transaction
                                if a business transaction will commit. But itâ€™s occasionally useful to know earlier if a conflict has occurred. For this you can provide a checkCurrent method
                                that checks if anyone else has updated the data. It canâ€™t guarantee that you
                                wonâ€™t get a conflict, but it may be worthwhile to stop a complicated process if
                                you can tell in advance that it wonâ€™t commit. Use this checkCurrent at any time
                                that failing early may be useful, but remember that it never guarantees that you
                                wonâ€™t fail at commit time.</p>
                <h3 id="420">When to Use It</h3>
                <p>Optimistic concurrency management is appropriate when the chance of conflict
                                between any two business transactions is low. If conflicts are likely itâ€™s not user
                                friendly to announce one only when the user has finished his work and is ready
                                to commit. Eventually heâ€™ll assume the failure of business transactions and stop
                                using the system. Pessimistic Offline Lock (426) is more appropriate when the
                                chance of conflict is high or the expense of a conflict is unacceptable.
                                As optimistic locking is much easier to implement and not prone to the same
                                defects and runtime errors as a Pessimistic Offline Lock (426), consider using it
                                as the default approach to business transaction conflict management in any system you build. The pessimistic version works well as a complement to its optimistic counterpart, so rather than asking when to use an optimistic approach to
                                conflict avoidance, ask when the optimistic approach alone isnâ€™t good enough.
                                The correct approach to concurrency management will maximize concurrent
                                access to data while minimizing conflicts.</p>
                <h3 id="421">Example: Domain Layer with Data Mappers (165) (Java)</h3>
                <p>The shortest example of Optimistic Offline Lock would involve only a database
                                table with a version column and UPDATE and DELETE statements that use
                                that version as part of their update criteria. Of course, youâ€™ll be building more
                                sophisticated applications so I present an implementation using a Domain
                                Model (116) and Data Mappers (165). This will reveal more of the issues that
                                commonly arise when implementing Optimistic Offline Lock.
                                One of the first things to do is to make sure that your domain Layer Supertype (475) is capable of storing any information required to implement Optimistic Offline Lockâ€”namely, modification and version data.
                                <pre>class DomainObject...
                                private Timestamp modified;
                                private String modifiedBy;
                                private int version;</pre>
                                Our data is stored in a relational database, so each table must also store version
                                and modification data. Hereâ€™s the schema for a customer table as well as the
                                standard CRUD SQL necessary to support the Optimistic Offline Lock:
                                <pre>table customer...
                                create table customer(id bigint primary key, name varchar, createdby varchar,
                                created datetime, modifiedby varchar, modified datetime, version int)
                                SQL customer CRUD...
                                INSERT INTO customer VALUES (?, ?, ?, ?, ?, ?, ?)
                                SELECT * FROM customer WHERE id = ?
                                UPDATE customer SET name = ?, modifiedBy = ?, modified = ?, version = ?
                                WHERE id = ? and version = ?
                                DELETE FROM customer WHERE id = ? and version = ?</pre>
                                Once you have more than a few tables and domain objects, youâ€™ll want to
                                introduce a Layer Supertype (475) for your Data Mappers (165) that handles
                                the tedious, repetitive segments of O/R mapping. This not only saves a lot of
                                work when writing Data Mappers (165) but also allows the use of an Implicit
                                Lock (449) to prevent a developer from subverting a locking strategy by forgetting to code a bit of locking mechanics.
                                The first piece to move into your abstract mapper is SQL construction. This
                                requires that you provide mappers with a bit of metadata about your tables. An
                                alternative to having your mapper build SQL at runtime is to code-generate it.
                                However, Iâ€™ll leave the construction of SQL statements as an exercise for the
                                reader. In the abstract mapper below youâ€™ll see that Iâ€™ve made a number of
                                assumptions about the column names and positions for our modification data.
                                This becomes less feasible with legacy data. The abstract mapper will likely
                                require a bit of column metadata to be supplied by each concrete mapper.
                                Once the abstract mapper has SQL statements it can manage the CRUD
                                operations. Hereâ€™s how a find executes:
                                <pre>class AbstractMapper...
                                public AbstractMapper(String table, String[] columns) {
                                this.table = table;
                                this.columns = columns;
                                buildStatements();
                                }
                                public DomainObject find(Long id) {
                                DomainObject obj = AppSessionManager.getSession().getIdentityMap().get(id);
                                if (obj == null) {
                                Connection conn = null;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                stmt = conn.prepareStatement(loadSQL);
                                stmt.setLong(1, id.longValue());
                                rs = stmt.executeQuery();
                                if (rs.next()) {
                                obj = load(id, rs);
                                String modifiedBy = rs.getString(columns.length + 2);
                                Timestamp modified = rs.getTimestamp(columns.length + 3);
                                int version = rs.getInt(columns.length + 4);
                                obj.setSystemFields(modified, modifiedBy, version);
                                AppSessionManager.getSession().getIdentityMap().put(obj);
                                } else {
                                throw new SystemException(table + " " + id + " does not exist");
                                }
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected error finding " + table + " " + id);
                                } finally {
                                cleanupDBResources(rs, conn, stmt);
                                }
                                }
                                return obj;
                                }</pre>
                                protected abstract DomainObject load(Long id, ResultSet rs) throws SQLException;
                                There are a few items of note here. First, the mapper checks an Identity Map
                                (195) to make sure that the object isnâ€™t loaded already. Not using an Identity
                                Map (195) could result in different versions of an object being loaded at different times in a business transaction, leading to undefined behavior in your application as well as make a mess of any version checks. Once a result set is
                                obtained the mapper defers to an abstract load method that each concrete mapper must implement to extract its fields and return an activated object. The
                                mapper calls setSystemFields() to set the version and modification data on the
                                abstract domain object. While a constructor might seem the more appropriate
                                means of passing this data, doing so would push part of the version storage
                                responsibility down to each concrete mapper and domain object and thus
                                weaken the Implicit Lock (449).
                                Hereâ€™s what a concrete load() method looks like:
                                <pre>class CustomerMapper extends AbstractMapper...
                                protected DomainObject load(Long id, ResultSet rs) throws SQLException {
                                String name = rs.getString(2);
                                return Customer.activate(id, name, addresses);
                                }</pre>
                                The abstract mapper will similarly manage execution of update and delete
                                operations. The job here is to check that the database operation returns a row
                                count of 1. If no rows have been updated, the optimistic lock canâ€™t be obtained
                                and the mapper must then throw a concurrency exception. Here is the delete
                                operation:
                                <pre>class class AbstractMapper...
                                public void delete(DomainObject object) {
                                AppSessionManager.getSession().getIdentityMap().remove(object.getId());
                                Connection conn = null;
                                PreparedStatement stmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                stmt = conn.prepareStatement(deleteSQL);
                                stmt.setLong(1, object.getId().longValue());
                                int rowCount = stmt.executeUpdate();
                                if (rowCount == 0) {
                                throwConcurrencyException(object);
                                }
                                } catch (SQLException e) {
                                throw new SystemException("unexpected error deleting");
                                } finally {
                                cleanupDBResources(conn, stmt);
                                }
                                }
                                protected void throwConcurrencyException(DomainObject object) throws SQLException {
                                Connection conn = null;
                                PreparedStatement stmt = null;
                                ResultSet rs = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                stmt = conn.prepareStatement(checkVersionSQL);
                                stmt.setInt(1, (int) object.getId().longValue());
                                rs = stmt.executeQuery();
                                if (rs.next()) {
                                int version = rs.getInt(1);
                                String modifiedBy = rs.getString(2);
                                Timestamp modified = rs.getTimestamp(3);
                                if (version > object.getVersion()) {
                                String when = DateFormat.getDateTimeInstance().format(modified);
                                throw new ConcurrencyException(table + " " + object.getId() +
                                " modified by " + modifiedBy + " at " + when);
                                } else {
                                throw new SystemException("unexpected error checking timestamp");
                                }
                                } else {
                                throw new ConcurrencyException(table + " " + object.getId() +
                                " has been deleted");
                                }
                                } finally {
                                cleanupDBResources(rs, conn, stmt);
                                }
                                }</pre>
                                The SQL used to check the version in a concurrency exception also needs to
                                be known by the abstract mapper. Your mapper should construct it when it
                                constructs the CRUD SQL. It will look something like this:
                                checkVersionSQL...
                                SELECT version, modifiedBy, modified FROM customer WHERE id = ?
                                This code doesnâ€™t give much of a feel for the various pieces executing across
                                multiple system transactions within a single business transaction. The most
                                important thing to remember is that acquisition of Optimistic Offline Locks
                                must occur within the same system transaction that holds the commit of your
                                changes in order to maintain record data consistency. With the check bundled
                                into UPDATE and DELETE statements this wonâ€™t be a problem.</p>
                <p>Take a look at the use of a version object in the Coarse-Grained Lock (438)
                                sample code. While Coarse-Grained Lock (438) can solve some inconsistent
                                read problems, a simple nonshared version object can help detect inconsistent
                                reads because itâ€™s a convenient place to add optimistic check behavior such as
                                increment() or checkVersionIsLatest(). Hereâ€™s a Unit of Work (184) where we add
                                consistent read checks to our commit process via the more drastic measure of
                                incrementing the version because we donâ€™t know the isolation level:
                                <pre>class UnitOfWork...
                                private List reads = new ArrayList();
                                public void registerRead(DomainObject object) {
                                reads.add(object);
                                }
                                public void commit() {
                                try {
                                checkConsistentReads();
                                insertNew();
                                deleteRemoved();
                                updateDirty();
                                } catch (ConcurrencyException e) {
                                rollbackSystemTransaction();
                                throw e;
                                }
                                }
                                public void checkConsistentReads() {
                                for (Iterator iterator = reads.iterator(); iterator.hasNext();) {
                                DomainObject dependent = (DomainObject) iterator.next();
                                dependent.getVersion().increment();
                                }
                                }</pre>
                                Notice that the Unit of Work (184) rolls back the system transaction when it
                                detects a concurrency violation. Most likely you would decide to roll back for
                                any exception during the commit. Do not forget this step! As an alternative to
                                version objects, you can add version checks to your mapper interface.
                                426 OFFLINE CONCURRENCY PATTERNS
                                Pessimistic
                                Offline Lock</p>
                <h3 id="426">Pessimistic Offline Lock</h3>
                <p>Prevents conflicts between concurrent business
                                transactions by allowing only one business
                                transaction at a time to access data.
                                Since offline concurrency involves manipulating data for a business transaction
                                that spans multiple requests, the simplest approach would seem to be having a
                                system transaction open for the whole business transaction. Sadly, however, this
                                doesnâ€™t always work well because transaction systems arenâ€™t geared to work
                                with long transactions. For that reason you have to use multiple system transacMartin's Session Database David's Session
                                tions, at which point youâ€™re left to your own devices to manage concurrent
                                access to your data.</p>
                <p>The first approach to try is Optimistic Offline Lock (416). However, that
                                pattern has its problems. If several people access the same data within a business transaction, one of them will commit easily but the others will conflict
                                and fail. Since the conflict is only detected at the end of the business transaction, the victims will do all the transaction work only to find at the last minute
                                that the whole thing will fail and their time will have been wasted. If this happens a lot on lengthy business transactions the system will soon become very
                                unpopular.
                                Pessimistic Offline Lock prevents conflicts by avoiding them altogether. It
                                forces a business transaction to acquire a lock on a piece of data before it starts
                                to use it, so that, most of the time, once you begin a business transaction you
                                can be pretty sure youâ€™ll complete it without being bounced by concurrency
                                control.</p>
                <h3 id="427">How It Works</h3>
                <p>You implement Pessimistic Offline Lock in three phases: determining what type
                                of locks you need, building a lock manager, and defining procedures for a business transaction to use locks. Additionally, if youâ€™re using Pessimistic Offline
                                Lock as a complement to Optimistic Offline Lock (416) you need to determine
                                which record types to lock.
                                As for lock types, the first option is an exclusive write lock, which require
                                only that a business transaction acquire a lock in order to edit session data.
                                This avoids conflict by not allowing two business transactions to make changes
                                to the same record simultaneously. What this locking scheme ignores is the
                                reading of data, so if itâ€™s not critical that a view session have the most recent
                                data this strategy will suffice.
                                If it becomes critical that a business transaction must always have the most
                                recent data, regardless of its intention to edit, use the exclusive read lock. This
                                requires that a business transaction acquire a lock simply to load the record.
                                Clearly such a strategy has the potential to severely restrict a systemâ€™s concurrency. For most enterprise systems the exclusive write lock will afford much
                                more concurrent record access than this lock will.</p>
                <p>A third strategy combines the two lock types to provide the restrictive locking of the exclusive read lock as well as the increased concurrency of the exclusive write lock. Called the read/write lock, itâ€™s a bit more complicated than the
                                first two. The relationship of the read and write locks is the key to getting the
                                best of both worlds:
                <ul>
                        <li>Read and write locks are mutually exclusive. A record canâ€™t be writelocked if any other business transaction owns a read lock on it; it canâ€™t be read-locked if any other business transaction owns a write lock on it.</li>
                        <li>Concurrent read locks are acceptable. The existence of a single read lock prevents any business transaction from editing the record, so thereâ€™s no harm in allowing any number of sessions as readers once one has been allowed to read.</li>
                </ul>
                                Allowing multiple read locks is what increases system concurrency. The
                                downside of this scheme is that itâ€™s a bit nasty to implement and presents more
                                of a challenge for domain experts to wrap their heads around when theyâ€™re
                                modeling the system.</p>
                <p>In choosing the correct lock type think about maximizing system concurrency, meeting business needs, and minimizing code complexity. Also keep in
                                mind that the locking strategy must be understood by domain modelers and
                                analysts. Locking is not just a technical problem; the wrong lock type, simply
                                locking every record, or locking the wrong types of records can result an ineffective Pessimistic Offline Lock strategy. An ineffective Pessimistic Offline Lock
                                strategy is one that doesnâ€™t prevent conflict at the onset of the business transaction or that degrades the concurrency of your multi-user system such that it
                                seems more like single-user system. The wrong locking strategy canâ€™t be saved
                                by a proper technical implementation. In fact, itâ€™s not a bad idea to include Pessimistic Offline Lock in your domain model.
                                Once youâ€™ve decided upon your lock type, define your lock manager. The
                                lock managerâ€™s job is to grant or deny any request by a business transaction to
                                acquire or release a lock. To do its job it needs to know whatâ€™s being locked as
                                well as the intended owner of the lockâ€”the business transaction. Itâ€™s quite
                                possible that your concept of a business transaction isnâ€™t some thing that can
                                be uniquely identified, which makes it a bit difficult to pass a business transaction to the lock manager. In this case consider your concept of a session, as
                                youâ€™re more likely to have a session object at your disposal. The terms â€œsessionâ€ and â€œbusiness transactionâ€ are fairly interchangeable. As long as business transactions execute serially within a session the session will be fine as a
                                Pessimistic Offline Lock owner. The code example should shed some light on
                                this idea.</p>
                <p>The lock manager shouldnâ€™t consist of much more than a table that maps
                                locks to owners. A simple one might wrap an in-memory hash table, or it might
                                be a database table. Whatever, you must have one and only one lock table, so if
                                itâ€™s in memory be sure to use a singleton [Gang of Four]. If your application
                                server is clustered, an in-memory lock table wonâ€™t work unless itâ€™s pinned to a
                                single server instance. The database-based lock manager is probably more
                                appropriate once youâ€™re in a clustered application server environment.
                                The lock, whether implemented as an object or as SQL against a database
                                table, should remain private to the lock manager. Business transactions should
                                interact only with the lock manager, never with a lock object.</p>
                <p>Now itâ€™s time to define the protocol according to which a business transaction must use the lock manager. This protocol has to include what to lock and
                                when, when to release a lock, and how to act when a lock canâ€™t be acquired.
                                What to lock depends upon when to lock, so letâ€™s look at when first. Generally, the business transaction should acquire a lock before loading the data, as
                                thereâ€™s not much point in acquiring a lock without a guarantee that youâ€™ll have
                                the latest version of the locked item. Since weâ€™re acquiring locks within a system
                                transaction, however, there are circumstances where the order of the lock and
                                load wonâ€™t matter. Depending on your lock type, if youâ€™re using serializable or
                                repeatable read transactions, the order in which you load objects and acquire
                                locks might not matter. An option is to perform an optimistic check on an item
                                after you acquire the Pessimistic Offline Lock. You should be very sure that you
                                have the latest version of an object after youâ€™ve locked it, which usually translates to acquiring the lock before loading the data.
                                Now, what are we locking? It seems that weâ€™re locking objects or records or
                                just about anything, but what we usually lock is actually the ID, or primary key,
                                that we use to find those objects. This allows us to obtain the lock before we
                                load them. Locking the object works fine so long as it doesnâ€™t force you to
                                break the rule about an objectâ€™s being current after you acquire its lock.
                                The simplest rule for releasing locks is to do it when the business transaction
                                completes. Releasing a lock prior to completion might be allowable, depending
                                on your lock type and your intention to use that object again within the transaction. Still, unless you have a very specific reason to release early, such as a
                                particularly nasty system liveliness issue, stick to doing it upon completion of
                                the business transaction.</p>
                <p>The easiest course of action for a business transaction that canâ€™t acquire a
                                lock is to abort. The user should find this acceptable since Pessimistic Offline
                                Lock should result in failure rather early in the transaction. The developer and
                                designer can certainly help the situation by not waiting until late in the transaction to acquire a particularly contentious lock. If at all possible acquire all of
                                your locks before the user begins work.
                                For any given item that you intend to lock, access to the lock table must be
                                serialized. With an in-memory lock table itâ€™s easiest to serialize access to the
                                entire lock manager with whatever constructs your programming language provides. If you need concurrency greater than this affords, be aware you are entering complex territory.
                                If the lock table is stored in a database the first rule, of course, is to interact
                                with it within a system transaction. Take full advantage of the serialization
                                capabilities that a database provides. With the exclusive read and exclusive
                                write locks serialization is a simple matter of having the database enforce a
                                uniqueness constraint on the column storing the lockable itemâ€™s ID. Storing
                                read/write locks in a database makes things a bit more difficult since the logic
                                requires reads of the lock table in addition to inserts and so it becomes imperative to avoid inconsistent reads. A system transaction with an isolation level of
                                serializable provides ultimate safety as it guarantees no inconsistent reads.
                                Using serializable transactions throughout our system might get us into performance trouble, but a separate serializable system transaction for lock acquisition and a less strict isolation level for other work might ease this problem.
                                Another option is to investigate whether a stored procedure might help with
                                lock management. Concurrency management can be tough, so donâ€™t be afraid
                                to defer to your database at key moments.</p>
                <p>The serial nature of lock management screams performance bottleneck. A
                                big consideration here is lock granularity, as the fewer locks required the less of
                                a bottleneck youâ€™ll have. A Coarse-Grained Lock (438) can address lock table
                                contention.
                                With a system transaction pessimistic locking scheme, such as â€œSELECT
                                FOR UPDATE...â€ or entity EJBs, deadlock is a distinct possibility because these
                                locking mechanisms will wait until a lock becomes available. Think of deadlock
                                this way. Two users need resources A and B. If one gets the lock on A and the
                                other gets the lock on B, both transactions might sit and wait forever for the
                                other lock. Given that weâ€™re spanning multiple system transactions, waiting for
                                a lock doesnâ€™t make much sense, especially since a business transaction might
                                take 20 minutes. Nobody wants to wait for those locks. And this is good
                                because coding for a wait involves timeouts and quickly gets complicated. Simply have your lock manager throw an exception as soon as a lock is unavailable. This removes the burden of coping with deadlock.
                                A final requirement is managing lock timeouts for lost sessions. If a client
                                machine crashes in the middle of a transaction that lost transaction is unable to
                                complete and release any owned locks. This is a big deal for a Web application
                                where sessions are regularly abandoned by users. Ideally youâ€™ll have a timeout
                                mechanism managed by your application server rather than make your application handle timeouts. Web application servers provide an HTTP session for this.
                                Timeouts can be implemented by registering a utility object that releases all locks
                                when the HTTP session becomes invalid. Another option is to associate a timestamp with each lock and consider invalid any lock older than a certain age.</p>
                <h3 id="431">When to Use It</h3>
                <p>Pessimistic Offline Lock is appropriate when the chance of conflict between
                                concurrent sessions is high. A user should never have to throw away work.
                                Locking is also appropriate when the cost of a conflict is too high regardless of
                                its likelihood. Locking every entity in a system will almost surely create tremendous data contention problems, so remember that Pessimistic Offline Lock is
                                very complementary to Optimistic Offline Lock (416) and only use Pessimistic
                                Offline Lock where itâ€™s truly required.
                                If you have to use Pessimistic Offline Lock, you should also consider a long
                                transaction. Long transactions are never a good thing, but in some situations
                                they may be no more damaging than Pessimistic Offline Lock and much easier
                                to program. Do some load testing before you choose.</p>
                <p>Donâ€™t use these techniques if your business transactions fit within a single
                                system transaction. Many system transaction pessimistic locking techniques
                                ship with the application and database servers youâ€™re already using, among
                                them the â€œSELECT FOR UPDATEâ€ SQL statement for database locking and
                                the entity EJB for application server locking. Why worry about timeouts, lock
                                visibility, and such, when thereâ€™s no need to? Understanding these locking types
                                can certainly add a lot of value to your implementation of Pessimistic Offline
                                Lock. Understand, though, that the inverse isnâ€™t true! What you read here
                                wonâ€™t prepare you to write a database manager or transaction monitor. All the
                                offline locking techniques presented in this book depend on your system having
                                a real transaction monitor of its own.</p>
                <h3 id="431(2)">Example: Simple Lock Manager (Java)</h3>
                <p>In this example weâ€™ll first build a lock manager for exclusive read locksâ€”
                                remember that you need these locks to read or edit an object. Then weâ€™ll demonstrate how the lock manager might be used for a business transaction that
                                spans multiple system transactions.
                                The first step is to define our lock manager interface.
                                <pre>interface ExclusiveReadLockManager...
                                public static final ExclusiveReadLockManager INSTANCE =
                                (ExclusiveReadLockManager) Plugins.getPlugin(ExclusiveReadLockManager.class);
                                public void acquireLock(Long lockable, String owner) throws ConcurrencyException;
                                public void releaseLock(Long lockable, String owner);
                                public void relaseAllLocks(String owner);</pre>
                                Notice that weâ€™re identifying lockable with a long and owner with a string. Lockable
                                is a long because each table in our database uses a long primary key thatâ€™s
                                unique across the entire system and so serves as a nice lockable ID (which must
                                be unique across all types handled by the lock table). The owner ID is a string
                                because the example will be a Web application, and the HTTP session ID makes
                                a good lock owner within it.
                                Weâ€™ll write a lock manager that interacts directly with a lock table in our
                                database rather than with a lock object. Note that this is our own table called
                                lock, like any other application table, and not part of the databaseâ€™s internal
                                locking mechanism. Acquiring a lock is a matter of successfully inserting a row
                                into the lock table. Releasing it is a matter of deleting that row. Hereâ€™s the
                                schema for the lock table and part of the lock manager implementation:
                                <pre>table lock...
                                create table lock(lockableid bigint primary key, ownerid varchar)
                                class ExclusiveReadLockManagerDBImpl implements ExclusiveReadLockManager...
                                private static final String INSERT_SQL =
                                "insert into lock values(?, ?)";
                                private static final String DELETE_SINGLE_SQL =
                                "delete from lock where lockableid = ? and ownerid = ?";
                                private static final String DELETE_ALL_SQL =
                                "delete from lock where ownerid = ?";
                                private static final String CHECK_SQL =
                                "select lockableid from lock where lockableid = ? and ownerid = ?";
                                public void acquireLock(Long lockable, String owner) throws ConcurrencyException {
                                if (!hasLock(lockable, owner)) {
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(INSERT_SQL);
                                pstmt.setLong(1, lockable.longValue());
                                pstmt.setString(2, owner);
                                pstmt.executeUpdate();
                                } catch (SQLException sqlEx) {
                                throw new ConcurrencyException("unable to lock " + lockable);
                                } finally {
                                closeDBResources(conn, pstmt);
                                }
                                }
                                }
                                public void releaseLock(Long lockable, String owner) {
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(DELETE_SINGLE_SQL);
                                pstmt.setLong(1, lockable.longValue());
                                pstmt.setString(2, owner);
                                pstmt.executeUpdate();
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected error releasing lock on " + lockable);
                                } finally {
                                closeDBResources(conn, pstmt);
                                }
                                }</pre>
                                Not shown in the lock manager are the public releaseAllLocks() and the private
                                hasLock() methods. releaseAllLocks() does exactly as its name implies and releases
                                all locks for an owner. hasLock() queries the database to check if an owner
                                already owns a lock. Itâ€™s not uncommon for session code to attempt to acquire a
                                lock it already owns. This means that acquireLock() must first check that the
                                owner doesnâ€™t already have the lock before attempting to insert the lock row. As
                                the lock table is usually a point of resource contention, these repetitive reads can
                                degrade application performance. It may be necessary for you to cache owned
                                locks at the session level for the ownership checks. Be careful doing this.
                                Now letâ€™s put together a simple Web application to maintain customer
                                records. First weâ€™ll set up a bit of infrastructure to facilitate business transaction
                                processing. Some concept of a user session will be required by the layers
                                beneath the Web tier, so we wonâ€™t be able to rely solely on the HTTP session.
                                Letâ€™s refer to this new session as the application session to distinguish it from
                                the HTTP session. Application sessions will store their ID, a user name, and an
                                Identity Map (195) to cache objects loaded or created during the business transaction. Theyâ€™ll be associated with the currently executing thread in order that
                                they be found.
                                <pre>class AppSession...
                                private String user;
                                private String id;
                                private IdentityMap imap;
                                public AppSession(String user, String id, IdentityMap imap) {
                                this.user = user;
                                this.imap = imap;
                                this.id = id;
                                }
                                class AppSessionManager...
                                private static ThreadLocal current = new ThreadLocal();
                                public static AppSession getSession() {
                                return (AppSession) current.get();
                                }
                                public static void setSession(AppSession session) {
                                current.set(session);
                                }</pre>
                                Weâ€™re going to use a Front Controller (344) to handle requests, so weâ€™ll need
                                to define a command. The first thing each command must do is indicate its
                                intention to either start a new business transaction or continue one that already
                                exists. This is a matter of setting up a new application session or finding the
                                current one. Here we have an abstract command that provides convenience
                                methods for establishing business transaction context.
                                <pre>interface Command...
                                public void init(HttpServletRequest req, HttpServletResponse rsp);
                                public void process() throws Exception;
                                abstract class BusinessTransactionCommand implements Command...
                                public void init(HttpServletRequest req, HttpServletResponse rsp) {
                                this.req = req;
                                this.rsp = rsp;
                                }
                                protected void startNewBusinessTransaction() {
                                HttpSession httpSession = getReq().getSession(true);
                                AppSession appSession = (AppSession) httpSession.getAttribute(APP_SESSION);
                                if (appSession != null) {
                                ExclusiveReadLockManager.INSTANCE.relaseAllLocks(appSession.getId());
                                }
                                appSession = new AppSession(getReq().getRemoteUser(),
                                httpSession.getId(), new IdentityMap());
                                AppSessionManager.setSession(appSession);
                                httpSession.setAttribute(APP_SESSION, appSession);
                                httpSession.setAttribute(LOCK_REMOVER,
                                new LockRemover(appSession.getId()));
                                }
                                protected void continueBusinessTransaction() {
                                HttpSession httpSession = getReq().getSession();
                                AppSession appSession = (AppSession) httpSession.getAttribute(APP_SESSION);
                                AppSessionManager.setSession(appSession);
                                }
                                protected HttpServletRequest getReq() {
                                return req;
                                }
                                protected HttpServletResponse getRsp() {
                                return rsp;
                                }</pre>
                                Notice that when we establish a new application session we remove locks for
                                any existing one. We also add a listener to the HTTP sessionâ€™s binding events
                                that will remove any locks owned by an application session when the corresponding HTTP session expires.
                                <pre>class LockRemover implements HttpSessionBindingListener...
                                private String sessionId;
                                public LockRemover(String sessionId) {
                                this.sessionId = sessionId;
                                }
                                public void valueUnbound(HttpSessionBindingEvent event) {
                                try {
                                beginSystemTransaction();
                                ExclusiveReadLockManager.INSTANCE.relaseAllLocks(this.sessionId);
                                commitSystemTransaction();
                                } catch (Exception e) {
                                handleSeriousError(e);
                                }
                                }</pre>
                                Our commands contain both standard business logic and lock management,
                                and each command must execute within the bounds of a single system transaction. To ensure this we can decorate [Gang of Four] it with a transactional command object. Be sure that all locking and standard domain business for a single
                                request occur within a single system transaction. The methods that define system transaction boundaries depend on your deployment context. Itâ€™s mandatory to roll back the system transaction when a concurrency exception, and any
                                other exception in this case, is detected, as that will prevent any changes from
                                entering the permanent record data when a conflict occurs.
                                <pre>class TransactionalComamnd implements Command...
                                public TransactionalCommand(Command impl) {
                                this.impl = impl;
                                }
                                public void process() throws Exception {
                                beginSystemTransaction();
                                try {
                                impl.process();
                                commitSystemTransaction();
                                } catch (Exception e) {
                                rollbackSystemTransaction();
                                throw e;
                                }
                                }</pre>
                                Now itâ€™s a matter of writing the controller servlet and concrete commands.
                                The controller servlet has the responsibility of wrapping each command with
                                transaction control. The concrete commands are required to establish business
                                transaction context, execute domain logic, and acquire and release locks where
                                appropriate.
                                <pre>class ControllerServlet extends HttpServlet...
                                protected void doGet(HttpServletRequest req, HttpServletResponse rsp)
                                throws ServletException, IOException {
                                try {
                                String cmdName = req.getParameter("command");
                                Command cmd = getCommand(cmdName);
                                cmd.init(req, rsp);
                                cmd.process();
                                } catch (Exception e) {
                                writeException(e, rsp.getWriter());
                                }
                                }
                                private Command getCommand(String name) {
                                try {
                                String className = (String) commands.get(name);
                                Command cmd = (Command) Class.forName(className).newInstance();
                                return new TransactionalCommand(cmd);
                                } catch (Exception e) {
                                e.printStackTrace();
                                throw new SystemException("unable to create command object for " + name);
                                }
                                }
                                class EditCustomerCommand implements Command...
                                public void process() throws Exception {
                                startNewBusinessTransaction();
                                Long customerId = new Long(getReq().getParameter("customer_id"));
                                ExclusiveReadLockManager.INSTANCE.acquireLock(
                                customerId, AppSessionManager.getSession().getId());
                                Mapper customerMapper = MapperRegistry.INSTANCE.getMapper(Customer.class);
                                Customer customer = (Customer) customerMapper.find(customerId);
                                getReq().getSession().setAttribute("customer", customer);
                                forward("/editCustomer.jsp");
                                }
                                class SaveCustomerCommand implements Command...
                                public void process() throws Exception {
                                continueBusinessTransaction();
                                Customer customer = (Customer) getReq().getSession().getAttribute("customer");
                                String name = getReq().getParameter("customerName");
                                customer.setName(name);
                                Mapper customerMapper = MapperRegistry.INSTANCE.getMapper(Customer.class);
                                customerMapper.update(customer);
                                ExclusiveReadLockManager.INSTANCE.releaseLock(customer.getId(),
                                AppSessionManager.getSession().getId());
                                forward("/customerSaved.jsp");
                                }</pre>
                                The commands just shown will prevent any two sessions from working with
                                the same customer at the same time. Any other command in the application
                                that works with a customer object must be sure either to acquire the lock or to
                                work only with a customer locked by a previous command in the same business
                                transaction. Given that we have a hasLock() check in the lock manager we could
                                simply acquire the lock in every command. This might be bad for performance,
                                but it would certainly guarantee that we have a lock. Implicit Lock (449) discusses other foolproof approaches to locking mechanics.
                                The amount of framework code might seem a bit out of proportion to the
                                amount of domain code. Indeed, Pessimistic Offline Lock requires at a minimum choreographing an application session, a business transaction, a lock
                                manager, and a system transaction, which is clearly a challenge. This example
                                serves more as an inspiration than as an architecture template, as it lacks
                                robustness in many areas.</p>
                <h3 id="438">Coarse-Grained Lock</h3>
                <p>Locks a set of related objects with a single lock.
                                Objects can often be edited as a group. Perhaps you have a customer and its set
                                of addresses. If so, when using the application it makes sense to lock all of these
                                items if you want to lock any one of them. Having a separate lock for individual objects presents a number of challenges. First, anyone manipulating them
                                has to write code that can find them all in order to lock them. This is easy
                                enough for a customer and its addresses, but it gets tricky as you get more locking groups. And what if the groups get complicated? Where is this behavior
                                when your framework is managing lock acquisition? If your locking strategy
                                requires that an object be loaded in order to be locked, such as with Optimistic
                                Offline Lock (416), locking a large group affects performance. And with Pessimistic Offline Lock (426) a large lock set is a management headache and
                                increases lock table contention.
                                A Coarse-Grained Lock is a single lock that covers many objects. It not only
                                simplifies the locking action itself but also frees you from having to load all the
                                members of a group in order to lock them.</p>
                <h3 id="438(2)">How It Works</h3>
                <p>The first step in implementing Coarse-Grained Lock is to create a single point
                                of contention for locking a group of objects. This makes only one lock necessary for locking the entire set. Then you provide the shortest path possible to
                                finding that single lock point in order to minimize the group members that must
                                be identified and possibly loaded into memory in the process of obtaining that
                                lock.
                                With Optimistic Offline Lock (416), having each item in a group share a version (see Figure 16.2) creates the single point of contention, which means sharing the same version, not an equal version. Incrementing this version will lock
                                the entire group with a shared lock. Set up your model to point every member
                                of the group at the shared version and you have certainly minimized the path to
                                the point of contention.
                                A shared Pessimistic Offline Lock (426) requires that each member of the
                                group share some sort of lockable token, on which it must then be acquired. As
                                Pessimistic Offline Lock (426) is often used as a complement to Optimistic
                                Offline Lock (416), a shared version object makes an excellent candidate for
                                the lockable token role (Figure 16.3).</p>
                <p>Eric Evans and David Siegel [Evans] define an aggregate as a cluster of associated objects that we treat as a unit for data changes. Each aggregate has a root
                                that provides the only access point to members of the set and a boundary that
                                defines whatâ€™s included in the set. The aggregateâ€™s characteristics call for a
                                Coarse-Grained Lock, since working with any of its members requires locking
                                all of them. Locking an aggregate yields an alternative to a shared lock that I
                                call a root lock (see Figure 16.4). By definition locking the root locks all members of the aggregate. The root lock gives us a single point of contention.
                                Using a root lock as a Coarse-Grained Lock makes it necessary to implement
                                navigation to the root in your object graph. This allows a locking mechanism,
                                when asked to lock any object in the aggregate, to navigate to the root and lock
                                it instead. This navigation can be accomplished in a couple of ways. You can
                                maintain a direct navigation to the root for each object in the aggregate, or you
                                can use a sequence of intermediate relationships. For example, in a hierarchy
                                the obvious root is the top level parent, to which you can link the descendents
                                directly. Alternatively, you can give each node a link to its immediate parent
                                and navigate that structure to reach the root. In a large graph the latter strategy
                                might cause performance problems as each parent must be loaded in order to
                                determine whether it has a parent of its own. Be sure to use a Lazy Load (200)
                                when loading the objects that make up the path to your root. This not only preFigure 16.3 Locking a shared version.
                                vents objects from being loaded before theyâ€™re needed but prevents an infinite
                                mapping loop when you map a bidirectional relationship. Be wary of the fact
                                that Lazy Loads (200) for a single aggregate can occur across multiple system
                                transactions and so you may end up with an aggregate built from inconsistent
                                parts. Of course, thatâ€™s not good.</p>
                <p>Note that a shared lock also works for aggregate locking as locking any
                                object in the aggregate will simultaneously lock the root.
                                The shared lock and root lock implementations of Coarse-Grained Lock
                                both have their trade-offs. When using a relational database the shared lock
                                carries the burden that almost all of your selects will require a join to the version table. But loading objects while navigating to the root can be a performance hit as well. The root lock and Pessimistic Offline Lock (426) perhaps
                                make an odd combination. By the time you navigate to the root and lock it you
                                may need to reload a few objects to guarantee their freshness. And, as always,
                                building a system against a legacy data store will place numerous constraints on
                                your implementation choice. Locking implementations abound, and the subtleties are even more numerous. Be sure to arrive at an implementation that suits
                                your needs.</p>
                <h3 id="441">When to Use It</h3>
                <p>The most obvious reason to use a Coarse-Grained Lock is to satisfy business
                                requirements. This is the case when locking an aggregate. Consider a lease
                                object that owns a collection of assets. It probably doesnâ€™t make business sense
                                for one user to edit the lease and another user to simultaneously edit an asset.
                                Locking either the asset or the lease ought to result in the lease and all of its
                                assets being locked.
                                A very positive outcome of using Coarse-Grained Locks is that acquiring
                                and releasing lock is cheaper. This is certainly a legitimate motivation for using
                                them. The shared lock can be used beyond the concept of the [Evans] aggregate,
                                but be careful when working from nonfunctional requirements such as performance. Beware of creating unnatural object relationships in order to facilitate
                                Coarse-Grained Lock.</p>
                <h3 id="441(2)">Example: Shared Optimistic Offline Lock (416) (Java)</h3>
                <p>For this example we have a domain model with Layer Supertype (475), a relational database as our persistent store, and Data Mappers (165).
                                The first thing to do is create a version class and table. To keep things simple
                                weâ€™ll create a rather versatile version class that will not only store its value but
                                442 OFFLINE CONCURRENCY PATTERNS
                                CoarseGrained
                                Lock
                                will also have a static finder method. Note that weâ€™re using an identity map to
                                cache versions for a session. If objects share a version itâ€™s critical that they all
                                point to the exact same instance of it. As the version class is a part of our
                                domain model itâ€™s probably poor form to put database code in there, so Iâ€™ll
                                leave separating version database code into the mapper layer as an exercise for
                                you.
                                <pre>table version...
                                create table version(id bigint primary key, value bigint,
                                modifiedBy varchar, modified datetime)
                                class Version...
                                private Long id;
                                private long value;
                                private String modifiedBy;
                                private Timestamp modified;
                                private boolean locked;
                                private boolean isNew;
                                private static final String UPDATE_SQL =
                                "UPDATE version SET VALUE = ?, modifiedBy = ?, modified = ? " +
                                "WHERE id = ? and value = ?";
                                private static final String DELETE_SQL =
                                "DELETE FROM version WHERE id = ? and value = ?";
                                private static final String INSERT_SQL =
                                "INSERT INTO version VALUES (?, ?, ?, ?)";
                                private static final String LOAD_SQL =
                                "SELECT id, value, modifiedBy, modified FROM version WHERE id = ?";
                                public static Version find(Long id) {
                                Version version = AppSessionManager.getSession().getIdentityMap().getVersion(id);
                                if (version == null) {
                                version = load(id);
                                }
                                return version;
                                }
                                private static Version load(Long id) {
                                ResultSet rs = null;
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                Version version = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(LOAD_SQL);
                                pstmt.setLong(1, id.longValue());
                                rs = pstmt.executeQuery();
                                if (rs.next()) {
                                long value = rs.getLong(2);
                                String modifiedBy = rs.getString(3);
                                Timestamp modified = rs.getTimestamp(4);
                                version = new Version(id, value, modifiedBy, modified);
                                AppSessionManager.getSession().getIdentityMap().putVersion(version);
                                } else {
                                throw new ConcurrencyException("version " + id + " not found.");
                                }
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected sql error loading version", sqlEx);
                                } finally {
                                cleanupDBResources(rs, conn, pstmt);
                                }
                                return version;
                                }</pre>
                                The version also knows how to create itself. The database insert is separated
                                from the creation to allow deferment of insertion until at least one owner is
                                inserted into the database. Each of our domain Data Mappers (165) can safely
                                call insert on the version when inserting the corresponding domain object. The
                                version tracks whether itâ€™s new to make sure it will only be inserted once.
                                <pre>class Version...
                                public static Version create() {
                                Version version = new Version(IdGenerator.INSTANCE.nextId(), 0,
                                AppSessionManager.getSession().getUser(), now());
                                version.isNew = true;
                                return version;
                                }
                                public void insert() {
                                if (isNew()) {
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(INSERT_SQL);
                                pstmt.setLong(1, this.getId().longValue());
                                pstmt.setLong(2, this.getValue());
                                pstmt.setString(3, this.getModifiedBy());
                                pstmt.setTimestamp(4, this.getModified());
                                pstmt.executeUpdate();
                                AppSessionManager.getSession().getIdentityMap().putVersion(this);
                                isNew = false;
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected sql error inserting version", sqlEx);
                                } finally {
                                cleanupDBResources(conn, pstmt);
                                }
                                }
                                }</pre>
                                Next, we have an increment() method that increases the value of the version in
                                the corresponding database row. Itâ€™s likely that multiple objects in a change set
                                will share the same version, so the version first makes sure itâ€™s not already
                                locked before incrementing itself. After calling the database, the increment()
                                method must check that the version row was indeed updated. If it returns a row
                                count of zero, it has detected a concurrency violation and throws an exception.
                                <pre>class Version...
                                public void increment() throws ConcurrencyException {
                                if (!isLocked()) {
                                Connection conn = null;
                                PreparedStatement pstmt = null;
                                try {
                                conn = ConnectionManager.INSTANCE.getConnection();
                                pstmt = conn.prepareStatement(UPDATE_SQL);
                                pstmt.setLong(1, value + 1);
                                pstmt.setString(2, getModifiedBy());
                                pstmt.setTimestamp(3, getModified());
                                pstmt.setLong(4, id.longValue());
                                pstmt.setLong(5, value);
                                int rowCount = pstmt.executeUpdate();
                                if (rowCount == 0) {
                                throwConcurrencyException();
                                }
                                value++;
                                locked = true;
                                } catch (SQLException sqlEx) {
                                throw new SystemException("unexpected sql error incrementing version", sqlEx);
                                } finally {
                                cleanupDBResources(conn, pstmt);
                                }
                                }
                                }
                                private void throwConcurrencyException() {
                                Version currentVersion = load(this.getId());
                                throw new ConcurrencyException(
                                "version modified by " + currentVersion.modifiedBy + " at " +
                                DateFormat.getDateTimeInstance().format(currentVersion.getModified()));
                                }</pre>
                                With the code here be sure to invoke increment only in the system transaction
                                in which you commit the business transaction. The isLocked flag makes it so that
                                incrementing in earlier transactions will result in false lock acquisition during
                                the commit transaction. This isnâ€™t a problem because the whole point of an
                                optimistic lock is that you only get the lock when you commit.
                                When you use this pattern you may want to see if your data is still current
                                with the database in an earlier system transaction. You can do this by adding a
                                checkCurrent method to the version class that simply checks if an Optimistic
                                Offline Lock (416) is available without updating.</p>
                <p>Not shown is a delete method that executes the SQL to remove the version
                                from the database. If the returned row count is zero, a concurrency exception is
                                thrown. Coarse Grained Lock. This is because the Optimistic Offline Lock (416) probably wasnâ€™t
                                obtained when deleting the last of the objects using this version. That should
                                never happen. The real trick is knowing when itâ€™s okay to delete a shared version. If youâ€™re sharing a version across an aggregate, simply delete it after you
                                delete the aggregate root. Other scenarios make things much more problematic.
                                One possibility is for the version object to keep a reference count of its owners
                                and delete itself when the count reaches zero. Be warned that this could make
                                for a version object thatâ€™s rather sophisticated. Once your version gets complicated you might consider making it a full-blown domain object. This makes
                                good sense, but, of course, it will be a special domain object without a version.
                                Now letâ€™s look at how we use the shared version. The domain Layer Supertype (475) contains a version object rather than a simple count. Each Data
                                Mapper (165) can set the version when loading the domain object.
                                <pre>class DomainObject...
                                private Long id;;
                                private Timestamp modified;
                                private String modifiedBy;
                                private Version version;
                                public void setSystemFields(Version version, Timestamp modified, String modifiedBy) {
                                this.version = version;
                                this.modified = modified;
                                this.modifiedBy = modifiedBy;
                                }</pre>
                                For creation, letâ€™s look at an aggregate consisting of a customer root and its
                                addresses. The customerâ€™s create method will create the shared version. Customer will have an addAddress() method that creates an address, passing along
                                the customerâ€™s version. Our abstract database mapper will insert the version
                                before it inserts corresponding domain objects. Remember that the version will
                                ensure that itâ€™s only inserted once.
                                <pre>class Customer extends DomainObject...
                                public static Customer create(String name) {
                                return new Customer(IdGenerator.INSTANCE.nextId(), Version.create(),
                                name, new ArrayList());
                                }
                                class Customer extends DomainObject...
                                public Address addAddress(String line1, String city, String state) {
                                Address address = Address.create(this, getVersion(), line1, city, state);
                                addresses.add(address);
                                return address;
                                }
                                class Address extends DomainObject...
                                public static Address create(Customer customer, Version version,
                                String line1, String city, String state) {
                                return new Address(IdGenerator.INSTANCE.nextId(), version, customer,
                                line1, city, state);
                                }
                                class AbstractMapper...
                                public void insert(DomainObject object) {
                                object.getVersion().insert();
                                Increment should be called on a version by the Data Mapper (165) before it
                                updates or deletes an object.
                                class AbstractMapper...
                                public void update(DomainObject object) {
                                object.getVersion().increment();
                                class AbstractMapper...
                                public void delete(DomainObject object) {
                                object.getVersion().increment();
                                As this is an aggregate, we delete the addresses when we delete the customer.
                                This allows us to delete the version immediately after that.
                                class CustomerMapper extends AbstractMapper...
                                public void delete(DomainObject object) {
                                Customer cust = (Customer) object;
                                for (Iterator iterator = cust.getAddresses().iterator(); iterator.hasNext();) {
                                Address add = (Address) iterator.next();
                                MapperRegistry.getMapper(Address.class).delete(add);
                                }
                                super.delete(object);
                                cust.getVersion().delete();
                                }</pre></p>
                <h3 id="446">Example: Shared Pessimistic Offline Lock (426) (Java)</h3>
                <p>We need some sort of lockable token that we can associate with all objects in
                                the related set. As discussed above weâ€™ll use Pessimistic Offline Lock (426) as a
                                complement to Optimistic Offline Lock (416) so we can use as the lockable
                                token the shared version. Weâ€™ll use all of the same code to arrive at a shared
                                version.
                                The only issue is that some of our data must be loaded in order to get the
                                version. If we acquire the Pessimistic Offline Lock (426) after loading its data,
                                how do we know that the data is current? Something we can easily do is increment the version within the system transaction where we obtained the Pessimistic Offline Lock (426). Once that system transaction commits, our pessimistic
                                lock is valid and we know that we have the latest copy of any data sharing that
                                version, regardless of where we loaded within the system transaction.
                                <pre>class LoadCustomerCommand...
                                try {
                                Customer customer = (Customer) MapperRegistry.getMapper(Customer.class).find(id);
                                ExclusiveReadLockManager.INSTANCE.acquireLock
                                (customer.getId(), AppSessionManager.getSession().getId());
                                customer.getVersion().increment();
                                TransactionManager.INSTANCE.commit();
                                } catch (Exception e) {
                                TransactionManager.INSTANCE.rollback();
                                throw e;
                                }</pre>
                                You can see that the version increment might be something that you would
                                want to build into your lock manager. At least you want to decorate [Gang of
                                Four] your lock manager with code that increments the version. Your production code will, of course, require more robust exception handling and transaction control than the example shows.</p>
                <h3 id="447">Example: Root Optimistic Offline Lock (416) (Java)</h3>
                <p>This example makes most of the same assumptions as the previous examples,
                                including a domain Layer Supertype (475) and Data Mappers (165). Thereâ€™s a
                                version object, but in this case it wonâ€™t be shared. It simply provides a convenient increment() method to more easily allow acquisition of the Optimistic
                                Offline Lock (416) outside of the Data Mapper (165). Weâ€™re also using a Unit
                                of Work (184) to track our change set.
                                Our aggregate contains parent-child relationships, so weâ€™ll use child-toparent navigation to find the root. Weâ€™ll need to accommodate this in our
                                domain and data models.
                                <pre>class DomainObject...
                                private Long id;
                                private DomainObject parent;
                                public DomainObject(Long id, DomainObject parent) {
                                this.id = id;
                                this.parent = parent;
                                }
                                Once we have our owners we can acquire our root locks before we commit
                                the Unit of Work.
                                class UnitOfWork...
                                public void commit() throws SQLException {
                                for (Iterator iterator = _modifiedObjects.iterator(); iterator.hasNext();) {
                                DomainObject object = (DomainObject) iterator.next();
                                for (DomainObject owner = object; owner != null; owner = owner.getParent()) {
                                owner.getVersion().increment();
                                }
                                }
                                for (Iterator iterator = _modifiedObjects.iterator(); iterator.hasNext();) {
                                DomainObject object = (DomainObject) iterator.next();
                                Mapper mapper = MapperRegistry.getMapper(object.getClass());
                                mapper.update(object);
                                }
                                }</pre></p>
                <h3 id="449">Implicit Lock</h3>
                <p>Allows framework or layer supertype code to acquire offline locks.
                                The key to any locking scheme is that there are no gaps in its use. Forgetting to
                                write a single line of code that acquires a lock can render an entire offline locking scheme useless. Failing to retrieve a read lock where other transactions use
                                write locks means you might not get up-to-date session data; failing to use a
                                version count properly can result in unknowingly writing over someoneâ€™s
                                changes. Generally, if an item might be locked anywhere it must be locked
                                everywhere. Ignoring its applicationâ€™s locking strategy allows a business transaction to create inconsistent data. Not releasing locks wonâ€™t corrupt your
                                record data, but it will eventually bring productivity to a halt. Because offline
                                concurrency management is difficult to test, such errors might go undetected by
                                all of your test suites.
                                One solution is to not allow developers to make such a mistake. Locking
                                tasks that cannot be overlooked should be handled not explicitly by developers
                                but implicitly by the application. The fact that most enterprise applications
                                make use of some combination of framework, Layer Supertypes (475), and
                                code generation provides us with ample opportunity to facilitate Implicit Lock.</p>
                <h3 id="450">How It Works</h3>
                <p>Implementing Implicit Lock is a matter of factoring your code such that any
                                locking mechanics that absolutely cannot be skipped can be carried out by your
                                application framework. For lack of a better word weâ€™ll use â€œframeworkâ€ to
                                mean a combination of Layer Supertypes (475), framework classes, and any
                                other â€œplumbingâ€ code. Code generation tools are another avenue to enforce
                                proper locking. I realize this is by no means a ground-breaking idea. Youâ€™re
                                very likely to head down this path once youâ€™ve coded the same locking mechanics a few times over in your application. Still, Iâ€™ve seen it done poorly often
                                enough that it merits a quick look.
                                The first step is to assemble a list of what tasks are mandatory for a business
                                transaction to work within your locking strategy. For Optimistic Offline Lock
                                (416) that list will contain items such as storing a version count for each
                                record, including the version in update SQL criteria, and storing an incremented version when changing the record. The Pessimistic Offline Lock (426)
                                list will include items along the lines of acquiring any lock necessary to load a
                                piece of dataâ€”typically the exclusive read lock or the read portion of the read/
                                write lockâ€”and releasing all locks when the business transaction or session
                                completes.</p>
                <p>Note that the Pessimistic Offline Lock (426) list doesnâ€™t include acquiring
                                any lock necessary only for editing a piece of dataâ€”that is, exclusive write
                                lock and the write portion of the read/write lock. Yes, these are mandatory if
                                your business transaction wants to edit the data, but implicitly acquiring them
                                presents, should the locks be unavailable, a couple of difficulties. First, the
                                only points where we might implicitly acquire a write lock, such as the registration of a dirty object within a Unit of Work (184), offer us no promise
                                should the locks be unavailable, that the transaction will abort as soon as the
                                user begins to work. The application canâ€™t figure out on its own when is a
                                good time to acquire these locks. A transaction not failing rapidly conflicts
                                with an intent of Pessimistic Offline Lock (426)â€”that a user not have to perform work twice.
                                Second, and just as important, is that these lock types most greatly limit system concurrency. Avoiding Implicit Lock here helps us think about how we
                                impact concurrency by forcing the issue out of the technical arena and into the
                                business domain. Still we have to make sure that locks necessary for writing are
                                acquired before changes are committed. What your framework can do is ensure
                                that a write lock has already been obtained before committing any changes.</p>
                <p>Not having acquired the lock by commit time is a programmer error and the
                                code should at least throw an assertion failure. I advise skipping the assertion
                                and throwing a concurrency exception here, as you really donâ€™t want any such
                                errors in your production system when assertions are turned off.
                                A word of caution about using the Implicit Lock. While it allows developers
                                to ignore much of the locking mechanics it doesnâ€™t allow them to ignore consequences. For example, if developers are using Implicit Lock with a pessimistic
                                locking scheme that waits for locks, they still need to think about deadlock possibilities. The danger with Implicit Lock is that business transactions can fail in
                                unexpected ways once developers stop thinking about locking.
                                Making locking work is a matter of determining the best way to get your
                                framework to implicitly carry out the locking mechanics. See Optimistic Offline
                                Lock (416) for samples of implicit handling of that lock type. The possibilities
                                for a quality Implicit Lock implementation are far too numerous to demonstrate them all here.</p>
                <h3 id="451">When to Use It</h3>
                <p>Implicit Lock should be used in all but the simplest of applications that have no
                                concept of framework. The risk of a single forgotten lock is too great.</p>
                <h3 id="451(2)">Example: Implicit Pessimistic Offline Lock (426) (Java)</h3>
                <p>Letâ€™s consider a system that uses an exclusive read lock. Our architecture contains a Domain Model (116), and weâ€™re using Data Mappers (165) to mediate
                                between our domain objects and our relational database. With the exclusive
                                read lock the framework must acquire a lock on a domain object before allowing a business transaction to do anything with it.
                                Any domain object used in a business transaction is located via the find()
                                method on a mapper. This is true whether the business transaction uses the
                                mapper directly by invoking find() or indirectly by navigating the object graph.
                                Now itâ€™s possible for us to decorate [Gang of Four] our mappers with required
                                locking functionality. Weâ€™ll write a locking mapper that acquires a lock before
                                attempting to find an object.
                                <pre>interface Mapper...
                                public DomainObject find(Long id);
                                public void insert(DomainObject obj);
                                public void update(DomainObject obj);
                                public void delete(DomainObject obj);
                                452 OFFLINE CONCURRENCY PATTERNS
                                Implicit Lock
                                class LockingMapper implements Mapper...
                                private Mapper impl;
                                public LockingMapper(Mapper impl) {
                                this.impl = impl;
                                }
                                public DomainObject find(Long id) {
                                ExclusiveReadLockManager.INSTANCE.acquireLock(
                                id, AppSessionManager.getSession().getId());
                                return impl.find(id);
                                }
                                public void insert(DomainObject obj) {
                                impl.insert(obj);
                                }
                                public void update(DomainObject obj) {
                                impl.update(obj);
                                }
                                public void delete(DomainObject obj) {
                                impl.delete(obj);
                                }</pre>
                                Because itâ€™s quite common to look up an object more than once in a session,
                                for the above code to work the lock manager must first check that the session
                                doesnâ€™t already have a lock before it obtains one. If we were using an exclusive
                                write lock rather than the exclusive read lock weâ€™d write a mapper decorator
                                that checked for previous lock acquisition on update and delete rather than
                                actually acquiring a lock.
                                One of the nice things about decorators is that the object being wrapped
                                doesnâ€™t even know that itâ€™s functionality is being enhanced. Here we can wrap
                                the mappers in our registry:
                                <pre>LockingMapperRegistry implements MappingRegistry...
                                private Map mappers = new HashMap();
                                public void registerMapper(Class cls, Mapper mapper) {
                                mappers.put(cls, new LockingMapper(mapper));
                                }
                                public Mapper getMapper(Class cls) {
                                return (Mapper) mappers.get(cls);
                                }</pre>
                                When the business transaction gets its hands on a mapper it thinks that itâ€™s
                                about to invoke a standard update method, but what really happens is shown in</p>
                <h3 id="455">Chapter 17</h3>
                <h2>Session State Patterns</h2>
                <h3 id="456">Client Session State</h3>
                <h3 id="456(2)">How It Works</h3>
                <p>Even the most server-oriented designs need at least a little Client Session State,
                                if only to hold a session identifier. With some applications you can consider putting all of the session data on the client, in which case the client sends the full
                                set of session data with each request and the server sends back the full session
                                state with each response. This allows the server to be completely stateless.
                                Most of the time youâ€™ll want to use Data Transfer Object (401) to handle the
                                data transfer. The Data Transfer Object (401) can serialize itself over the wire
                                and thus allow even complex data to be transmitted.
                                The client also needs to store the data. If itâ€™s a rich-client application it can
                                do this within its own structures, such as the fields in its interfaceâ€”although I
                                would drink Budweiser rather than do that. A set of nonvisual objects often
                                makes a better bet, such as the Data Transfer Object (401) itself or a domain
                                model. Either way itâ€™s not usually a big problem.
                                With an HTML interface, things get a bit more complicated. There are three
                                common ways to do client session state: URL parameters, hidden fields, and
                                cookies.</p>
                <p>URL parameters are the easiest to work with for a small amount of data.
                                Essentially all URLs on any response page take the session state as a parameter.
                                The clear limit to doing this is that the size of an URL is limited, but if you only
                                have a couple of data items it works well, thatâ€™s why itâ€™s a popular choice for
                                something like a session ID. Some platforms will do automatic URL rewriting
                                to add a session ID. Changing the URL may be a problem with bookmarks, so
                                thatâ€™s an argument against using URL parameters for consumer sites.
                                A hidden field is a field sent to the browser that isnâ€™t displayed on the Web
                                page. You get it with a tag of the form <INPUT type = â€œhiddenâ€>. To make a hidden
                                field work you serialize your session state into it when you make a response and
                                read it back in on each request. Youâ€™ll need a format for putting the data in the
                                hidden field. XML is an obvious standard choice, but of course itâ€™s rather
                                wordy. You can also encode the data in some text-based encoding scheme.
                                Remember that a hidden field is only hidden from the displayed page; anyone
                                can look at the data by looking at the page source.
                                Beware a mixed site that has older or fixed Web pages. You can lose all the
                                session data if you navigate to them.</p>
                <p>The last, and sometimes controversial, choice is cookies, which are sent back
                                and forth automatically. Just like a hidden field you can use a cookie by serializing the session state into it. Youâ€™re limited in how big the cookie can be. Also,
                                many people donâ€™t like cookies and turn them off. If they do that, your site will
                                stop working. However, more and more sites are dependent on cookies now, so
                                that will happen less often, and certainly isnâ€™t a problem for a purely in-house
                                system.
                                Realize that cookies are no more secure than anything else, so assume that
                                prying of all kinds can happen. Cookies also work only within a single domain
                                name, so if your site is separated into different domain names the cookies wonâ€™t
                                travel between them.
                                Some platforms can detect whether cookies are enabled; and if not, they can
                                use URL rewriting. This can make client session state very easy for very small
                                amounts of data.</p>
                <h3 id="457">When to Use It</h3>
                <p>Client Session State contains a number of advantages. In particular, it reacts
                                well in supporting stateless server objects with maximal clustering and failover
                                resiliency. Of course, if the client fails all is lost, but often the user expects that
                                anyway.
                                The arguments against Client Session State vary exponentially with the
                                amount of data involved. With just a few fields everything works nicely. With
                                large amounts of data the issues of where to store the data and the time cost of
                                transferring everything with every request become prohibitive. This is especially
                                true if your stars include an http client.
                                Thereâ€™s also the security issue. Any data sent to the client is vulnerable to
                                being looked at and altered. Encryption is the only way to stop this, but
                                encrypting and decrypting with each request are a performance burden. Without encryption you have to be sure you arenâ€™t sending anything you would
                                rather hide from prying eyes. Fingers can pry too, so donâ€™t assume that what
                                got sent out is the same as what gets sent back. Any data coming back will need
                                to be completely revalidated.
                                You almost always have to use Client Session State for session identification.
                                Fortunately, this should be just one number, which wonâ€™t burden any of the
                                above schemes. You should still be concerned about session stealing, which is
                                what happens when a malicious user changes his session ID to see if he can snag
                                someone elseâ€™s session. Most platforms come up with a random session ID to
                                reduce this risk; if not, run a simple session ID through a hash.</p>
                <h3 id="458">Server Session State</h3>
                <p>Keeps the session state on a server system in a serialized form.</p>
                <h3 id="458(2)">How It Works</h3>
                <p>In the simplest form of this pattern a session object is held in memory on an
                                application server. You can have some kind of map in memory that holds these
                                session objects keyed by a session ID; all the client needs to do is to give the session ID and the session object can be retrieved from the map to process the
                                request.
                                This basic scenario assumes, of course, that the application server carries
                                enough memory to perform this task. It also assumes that thereâ€™s only one
                                application serverâ€”that is, no clusteringâ€”and that, if the application server
                                fails, itâ€™s appropriate for the session to be abandoned and all work done so far
                                to be lost in the great bit-bucket in the sky.
                                For many applications this set of assumptions is actually not a problem.
                                However, for others it may be problematic. There are ways of dealing with
                                cases where the assumptions are no longer valid, and these introduce common
                                variations that add complexity to an essentially simple pattern.
                                The first issue is that of dealing with memory resources held by the session
                                objects. Indeed, this is the common objection to Server Session State. The
                                answer, of course, is not to keep resources in memory but instead serialize all
                                the session state to a memento [Gang of Four] for persistent storage. This presents two questions: In what form do you persist the Server Session State, and
                                where do you persist it?</p>
                <p>The form to use is usually as simple a form as possible, since the accent of
                                Server Session State is its simplicity in programming. Several platforms provide
                                a simple binary serialization mechanism that allows you to serialize a graph of
                                objects quite easily. Another route is to serialize into another form, such as
                                textâ€”fashionably as an XML file.
                                The binary form is usually easier, since it requires little programming, while
                                the textual form usually requires at least a little code. Binary serializations also
                                require less disk space; although total disk space is rarely a concern, large serialized graphs will take longer to activate into memory.
                                There are two common issues with binary serialization. First, the serialized
                                form is not human readableâ€”which is a problem if humans want to read it.
                                Second, there may be problems with versioning. If you modify a class by, say,
                                adding a field after youâ€™ve serialized it, you may not be able to read it back. Of
                                course, not many sessions are likely to span an upgrade of the server software
                                unless itâ€™s a 24/7 server where you may have a cluster of machines running,
                                some upgraded and some not.</p>
                <p>This brings us to the question of where to store the Server Session State. An
                                obvious possibility is on the application server itself, either in the file system or
                                in a local database. This is the simple route, but it may not support efficient
                                clustering or failover. To support these the passivated Server Session State needs
                                to be somewhere generally accessible, such as on shared server. This will support clustering and failover at the cost of a longer time to activate the serverâ€”
                                although caching may well eliminate much of this cost.
                                This line of reasoning may lead, ironically to storing the serialized Server Session State in the database using a session table indexed by the session ID. This
                                table would require a Serialized LOB (272) to hold the serialized Server Session
                                State. Database performance varies when it comes to handling large objects, so
                                the performance aspects of this one are very database dependent.
                                At this point weâ€™re right at the boundary between Server Session State and
                                Database Session State (462). This boundary is completely arbitrary, but Iâ€™ve
                                drawn the line at the point where you convert the data in the Server Session
                                State into tabular form.</p>
                <p>If youâ€™re storing Server Session State in a database, youâ€™ll have to worry
                                about handling sessions going away, especially in a consumer application. One
                                route is to have a daemon that looks for aged sessions and deletes them, but this
                                can lead to a lot of contention on the session table. Kai Yu told me about an
                                approach he used with success: partitioning the session table into twelve database segments and every two hours rotating the segments, deleting everything in
                                the oldest segment and then directing all inserts to it. While this meant that any
                                session that was active for twenty-four hours got unceremoniously dumped,
                                that would be sufficiently rare to not be a problem.
                                All these variations take more and more effort to do, but the good news is
                                that application servers increasingly support these capabilities automatically.
                                Thus, it may well be that application server vendors can worry their ugly little
                                heads about them.
                                Java Implementation
                                The two most common techniques for Server Session State are using the http
                                session and using a stateful session bean. The http session is the simple route
                                and causes the session data to be stored by the Web server. In most cases this
                                leads to server affinity and it canâ€™t cope with failover. Some vendors are
                                implementing a shared http session capability that allows you to store http
                                session data in a database thatâ€™s available to all application servers. (You
                                can also do this manually, of course.)</p>
                <p>The other common route is via a stateful session bean, which requires an
                                EJB server. The EJB container handles all persistence and passivation, so this
                                makes it very easy to program to. The main disadvantage is that the specification doesnâ€™t ask the application server to avoid server affinity. However,
                                some application servers provide this capability. One, IBMâ€™s WebSphere,
                                can serialize a stateful session bean into a BLOB in DB2, which allows multiple application servers to get at its state.
                                A lot of people say that, since stateless session beans perform better, you
                                should always use them instead of stateful beans. Frankly, thatâ€™s hogwash.
                                Load-test with your environment first to see if you fall into the range of
                                speed difference between stateful and stateless that makes any difference to
                                your application. ThoughtWorks has load-tested apps with a couple of hundred of concurrent users and not found any performance problems due to
                                stateful beans on that size of user load. If the performance advantage isnâ€™t
                                significant for your loads, and stateful beans are easier, then you should use
                                them. There are other reasons to be wary of stateful beansâ€”failover may be
                                more problematic depending on your vendor, but the performance difference only appears under a heavy load.
                                Another alternative is to use an entity bean. On the whole, Iâ€™ve been
                                pretty dismissive of entity beans, but you can use one to store a Serialized
                                LOB (272) of session data. This is pretty simple and less likely to raise many
                                of the issues that usually surround entity beans.
                                .NET Implementation
                                Server Session State is easy to implement with the built-in session state capability. By default .NET stores session data in the server process itself. You
                                can also adjust the storage using a state service, which can reside on the
                                local machine or on any other machine on the network. With a separate
                                state service you can reset the Web server and still retain the session state.
                                You make the change between in-process state and a state service in the configuration file, so you donâ€™t have to change the application.</p>
                <h3 id="460">When to Use It</h3>
                <p>The great appeal of Server Session State is its simplicity. In a number of cases
                                you donâ€™t have to do any programming at all to make this work. Whether you
                                can get away with that depends on if you can get away with the in-memory
                                implementation and, if not, how much help your application server platform
                                gives you.
                                Even without that you may well find that the effort you do need is small.
                                Serializing a BLOB to a database table may turn out to be much less effort than
                                converting the server objects to tabular form.
                                Where the programming effort comes into play is in session maintenance,
                                particularly if you have to roll your own support to enable clustering and
                                failover. It may work out to be more trouble than your other options, especially
                                if you donâ€™t have much session data to deal with or if your session data is easily
                                converted to tabular form.
                                462 SESSION STATE PATTERNS
                                Database
                                Session
                                State</p>
                <h3 id="462">Database Session State</h3>
                <h3 id="462(2)">How It Works</h3>
                <p>When a call goes out from the client to the server, the server object first pulls the
                                data required for the request from the database. Then it does the work it needs
                                to do and saves back to the database all the data required.
                                In order to pull information from the database, the server object will need
                                some information about the session, which requires at least a session ID number to be stored on the client. Usually, however, this information is nothing
                                more than the appropriate set of keys needed to find the appropriate amount of
                                data in the database.
                                The data involved is typically a mix of session data thatâ€™s only local to the
                                current interaction and committed data thatâ€™s relevant to all interactions.
                                One of the key issues to consider here is the fact that session data is usually
                                considered local to the session and shouldnâ€™t affect other parts of the system
                                until the session as a whole is committed. Thus, if youâ€™re working on an order
                                in a session and you want to save its intermediate state to the database, you
                                usually need to handle it differently from an order thatâ€™s confirmed at the end of
                                a session. This is because you donâ€™t want pending orders to appear that often in
                                queries run against the database for such things as book availability and daily
                                revenue.</p>
                <p>So how do you separate the session data? Adding a field to each database
                                row that may have session data is one route.The simplest form of this just
                                requires a Boolean isPending field. However, a better way is to store a session ID
                                as a pending field, which makes it much easier to find all the data for a particular session. All queries that want only record data now need to be modified
                                with a sessionID is not NULL clause, or need a view that filters out that data.
                                Using a session ID field is a very invasive solution because all applications
                                that touch the record database need to know the fieldâ€™s meaning to avoid getting session data. Views will sometimes do the trick and remove the invasiveness, but they often impose costs of their own.
                                A second alternative is a separate set of pending tables. So if you have orders
                                and order lines tables already in your database, you would add tables for pending orders and pending order lines. Pending session data you save to the pending table; when it becomes record data you save it to the real tables. This
                                removes much of the invasiveness. However, youâ€™ll need to add the appropriate
                                table selection logic to your database mapping code, which will certainly add
                                some complications.
                                Often the record data will have integrity rules that donâ€™t apply to pending
                                data. In this case the pending tables allow you to forgo the rules when you
                                donâ€™t want them but to enforce them when you do. Validation rules as well typically arenâ€™t applied when saving pending data. You may face different validation rules depending on where you are in the session, but this usually appears in
                                server object logic.
                                If you use pending tables, they should be exact clones of the real tables. That
                                way you can keep your mapping logic as similar as possible. Use the same field
                                names between the two tables, but add a session ID field to the pending tables
                                so you can easily find all the data for a session.
                                Youâ€™ll need a mechanism to clean out the session data if a session is canceled
                                or abandoned. Using a session ID you can find all data with it and delete it. If
                                users abandon the session without telling you, youâ€™ll need some kind of timeout
                                mechanism. A daemon that runs every few minutes can look for old session
                                data. This requires a table in the database that keeps track of the time of the
                                last interaction with the session.</p>
                <p>Rollback is made much more complicated by updates. If you update an existing order in a session that allows a rollback of the whole session, how do you
                                perform the rollback? One option is not to allow cancellation of a session like
                                this. Any updates to existing record data become part of the record data at the
                                end of the request. This is simple and often fits the usersâ€™ view of the world. The
                                alternative is awkward whether you use pending fields or pending tables. Itâ€™s
                                easy to copy all the data that may be modified into pending tables, modify it
                                there, and commit it back to the record tables at the end of the session. You can
                                do this with a pending field, but only if the session ID becomes part of the key.
                                In this way you can keep the old and new IDs in the same table at the same
                                time, which can get very messy.
                                If youâ€™re going to use separate pending tables that are only read by objects
                                that handle a session, then there may be little point in tabularizing the data. Itâ€™s
                                better to use a Serialized LOB (272). At this point weâ€™ve crossed the boundary
                                into a Server Session State (458).</p>
                <p>You can avoid all of the hassles of pending data by not having any. That is,
                                you design your system so that all data is considered record data. This isnâ€™t
                                always possible, of course, and if it is it can be so awkward that designers
                                would be better off thinking about explicit pending data. Still, if you have the
                                option it makes Database Session State a lot easier to work with.</p>
                <h3 id="464">When to Use It</h3>
                <p>Database Session State is one alternative to handling session state; it should be
                                compared with Server Session State (458) and Client Session State (456).
                                The first aspect to consider with this pattern is performance. Youâ€™ll gain by
                                using stateless objects on the server, thus enabling pooling and easy clustering.
                                However, youâ€™ll pay with the time needed to pull the data in and out of the
                                database with each request. You can reduce this cost by caching the server
                                object so you wonâ€™t have to read the data out of the database whenever the
                                cache is hit, but youâ€™ll still pay the write costs.
                                The second main issue is the programming effort, most of which centers
                                around handling session state. If you have no session state and are able to save
                                all your data as record data in each request, this pattern is an obvious choice
                                because you lose nothing in either effort or performance (if you cache your
                                server objects).
                                In a choice between Database Session State and Server Session State (458)
                                the biggest issue may be how easy it is to support clustering and failover with
                                Server Session State (458) in your particular application server. Clustering and
                                failover with Database Session State are usually more straightforward, at least
                                with the regular solutions.
                                Base
                                Patterns</p>
                <h3 id="465">Chapter 18</h3>
                <h2>Base Patterns</h2>
                <h3 id="466">Gateway</h3>
                <p>An object that encapsulates access to an external system or resource.
                                Interesting software rarely lives in isolation. Even the purest object-oriented
                                system often has to deal with things that arenâ€™t objects, such as relational database tables, CICS transactions, and XML data structures.
                                When accessing external resources like this, youâ€™ll usually get APIs for them.
                                However, these APIs are naturally going to be somewhat complicated because
                                they take the nature of the resource into account. Anyone who needs to understand a resource needs to understand its APIâ€”whether JDBC and SQL for relational databases or W3C or JDOM for XML. Not only does this make the
                                software harder to understand, it also makes it much harder to change should
                                you shift some data from a relational database to an XML message at some
                                point in the future.
                                The answer is so common that itâ€™s hardly worth stating. Wrap all the special
                                API code into a class whose interface looks like a regular object. Other objects
                                access the resource through this Gateway, which translates the simple method
                                calls into the appropriate specialized API. </p>
                <h3 id="466(2)">How It Works</h3>
                <p>In reality this is a very simple wrapper pattern. Take the external resource.
                                What does the application need to do with it? Create a simple API for your
                                usage and use the Gateway to translate to the external source.
                                One of the key uses for a Gateway is as a good point at which to apply a Service Stub (504). You can often alter the design of the Gateway to make it easier
                                to apply a Service Stub (504). Donâ€™t be afraid to do thisâ€”well placed Service
                                Stubs (504) can make a system much easier to test and thus much easier to
                                write.
                                Keep a Gateway as simple as you can. Focus on the essential roles of adapting the external service and providing a good point for stubbing. The Gateway
                                should be as minimal as possible and yet able to handle these tasks. Any more
                                complex logic should be in the Gatewayâ€™s clients.</p>
                <p>Often itâ€™s a good idea to use code generation to create Gateways. By defining
                                the structure of the external resource, you can generate a Gateway class to
                                wrap it. You might use relational metadata to create a wrapper class for a relational table, or an XML schema or DTD to generate code for a Gateway for
                                XML. The resulting Gateways are dumb but they do the trick. Other objects
                                can carry out more complicated manipulations.
                                Sometimes a good strategy is to build the Gateway in terms of more than one
                                object. The obvious form is to use two objects: a back end and a front end. The
                                back end acts as a minimal overlay to the external resource and doesnâ€™t simplify
                                the resourceâ€™s API at all. The front end then transforms the awkward API into a
                                more convenient one for your application to use. This approach is good if the
                                wrapping of the external service and the adaptation to your needs are reasonably complicated, because each responsibility is handled by a single class. Conversely, if the wrapping of the external service is simple, one class can handle
                                that and any adaptation thatâ€™s needed.</p>
                <h3 id="467">When to Use It</h3>
                <p>You should consider Gateway whenever you have an awkward interface to
                                something that feels external. Rather than let the awkwardness spread through
                                the whole system, use a Gateway to contain it. Thereâ€™s hardly any downside to
                                making the Gateway, and the code elsewhere in the system becomes much easier to read.
                                Gateway usually makes a system easier to test by giving you a clear point at
                                which to deploy Service Stubs (504). Even if the external systemâ€™s interface is
                                fine, a Gateway is useful as a first move in applying Service Stub (504).
                                A clear benefit of Gateway is that it also makes it easier for you to swap out
                                one kind of resource for another. Any change in resources means that you only
                                have to alter the Gateway classâ€”the change doesnâ€™t ripple through the rest of
                                the system. Gateway is a simple and powerful form of protected variation. In
                                many cases reasoning about this flexibility is the focus of debate about using
                                Gateway. However, donâ€™t forget that even if you donâ€™t think the resource is ever
                                going to change, you can benefit from the simplicity and testability Gateway
                                gives you.
                                When you have a couple of subsystems like this, another choice for decoupling them is a Mapper (473). However, Mapper (473) is more complicated
                                than Gateway. As a result, I use Gateway for the majority of my external
                                resource access.
                                I must admit that Iâ€™ve struggled a fair bit with whether to make this a new
                                pattern as opposed to referencing existing patterns such as Facade and Adapter
                                [Gang of Four]. I decided to separate it out from these other patterns because I
                                think thereâ€™s a useful distinction to be made.
                <ul>
                        <li>While Facade simplifies a more complex API, itâ€™s usually done by the writer of the service for general use. A Gateway is written by the client for its particular use. In addition, a Facade always implies a different interface to what itâ€™s covering, whereas a Gateway may copy the wrapped facade entirely, being used for substitution or testing purposes.</li>
                        <li>Adapter alters an implementationâ€™s interface to match another interface you need to work with. With Gateway there usually isnâ€™t an existing interface, although you might use an adapter to map an implementation to a Gateway interface. In this case the adapter is part of the Gateway implementation.</li>
                        <li>Mediator usually separates multiple objects so that they donâ€™t know about each other but do know about the mediator. With a Gateway there are usually only two objects involved and the resource thatâ€™s being wrapped doesnâ€™t know about the Gateway.</li>
                </ul>
                </p>
                <h3 id="468">Example: A Gateway to a Proprietary Messaging Service (Java)</h3>
                <p>I was talking about this pattern with my colleague, Mike Rettig, and he
                                described how heâ€™s used it to handle interfaces with Enterprise Application Integration (EAI) software. We decided that this would be a good inspiration for a
                                Gateway example.
                                To keep things at the usual level of ludicrous simplicity, weâ€™ll build a gateway
                                to an interface that just sends a message using the message service. The interface
                                is just a single method.
                                int send(String messageType, Object[] args);
                                The first argument is a string indicating the type of the message; the second is
                                the arguments of the message. The messaging system allows you to send any
                                kind of message, so it needs a generic interface like this. When you configure
                                the message system you specify the types of message the system will send and
                                the number and types of arguments for them. Thus, we might configure the
                                confirm message with the string â€œCNFRMâ€ and have arguments for an ID number
                                as a string, an integer amount, and a string for the ticker code. The messaging
                                system checks the types of the arguments for us and generates an error if we
                                send a wrong message or the right message with the wrong arguments.</p>
                <p>This is laudable, and necessary, flexibility, but the generic interface is awkward to use because it isnâ€™t explicit. You canâ€™t tell by looking at the interface
                                what the legal message types are or what arguments are needed for a certain
                                message type. What we need instead is an interface with methods like this:
                                public void sendConfirmation(String orderID, int amount, String symbol);
                                That way if we want a domain object to send a message, it can do so like this:
                                <pre>class Order...
                                public void confirm() {
                                if (isValid()) Environment.getMessageGateway().sendConfirmation(id, amount, symbol);
                                }</pre>
                                Here the name of the method tells us what message weâ€™re sending, and the
                                arguments are typed and given names. This is a much easier method to call than
                                the generic method. Itâ€™s the gatewayâ€™s role to make a more convenient interface.
                                It does mean, though, that every time we add or change a message type in the
                                messaging system we need to change the gateway class, but we would have to
                                change the calling code anyway. At least this way the compiler can help us find
                                clients and check for errors.
                                Thereâ€™s another problem. When we get an error with this interface it tells us
                                by giving us a return error code. Zero indicates success; anything else indicates
                                failure, and different numbers indicate different errors. This is a natural way for
                                a C programmer to work, but it isnâ€™t the way Java does things. In Java you
                                throw an exception to indicate an error, so the Gatewayâ€™s methods should
                                throw exceptions rather than return error codes.</p>
                <p>The full range of possible errors is something that weâ€™ll naturally ignore. Iâ€™ll
                                focus on just two: sending a message with an unknown message type and sending a message where one of the arguments is null. The return codes are defined
                                in the messaging systemâ€™s interface.
                                <pre>public static final int NULL_PARAMETER = -1;
                                public static final int UNKNOWN_MESSAGE_TYPE = -2;
                                public static final int SUCCESS = 0;</pre>
                                The two errors have a significant difference. The unknown message type
                                error indicates an error in the gateway class; since any client is only calling a
                                fully explicit method, clients should never generate this error. They might pass
                                in a null, however, and thus see the null parameter error. This error isnâ€™t a
                                checked exception since it indicates a programmer errorâ€”not something that
                                you would write a specific handler for. The gateway could actually check for
                                nulls itself, but if the messaging system is going to raise the same error it probably isnâ€™t worth it.
                                For these reasons the gateway has to both translate from the explicit interface to the generic interface and translate the return codes into exceptions.
                                <pre>class MessageGateway...
                                protected static final String CONFIRM = "CNFRM";
                                private MessageSender sender;
                                public void sendConfirmation(String orderID, int amount, String symbol) {
                                Object[] args = new Object[]{orderID, new Integer(amount), symbol};
                                send(CONFIRM, args);
                                }
                                private void send(String msg, Object[] args) {
                                int returnCode = doSend(msg, args);
                                if (returnCode == MessageSender.NULL_PARAMETER)
                                throw new NullPointerException("Null Parameter passed for msg type: " + msg);
                                if (returnCode != MessageSender.SUCCESS)
                                throw new IllegalStateException(
                                "Unexpected error from messaging system #:" + returnCode);
                                }
                                protected int doSend(String msg, Object[] args) {
                                Assert.notNull(sender);
                                return sender.send(msg, args);
                                }</pre>
                                So far, itâ€™s hard to see the point of the doSend method, but itâ€™s there for
                                another key role for a gatewayâ€”testing. We can test objects that use the gateway without the message-sending service being present. To do this we need to
                                create a Service Stub (504). In this case the gateway stub is a subclass of the real
                                gateway and overrides doSend.
                                <pre>class MessageGatewayStub...
                                protected int doSend(String messageType, Object[] args) {
                                int returnCode = isMessageValid(messageType, args);
                                if (returnCode == MessageSender.SUCCESS) {
                                messagesSent++;
                                }
                                return returnCode;
                                }
                                private int isMessageValid(String messageType, Object[] args) {
                                if (shouldFailAllMessages) return -999;
                                if (!legalMessageTypes().contains(messageType))
                                return MessageSender.UNKNOWN_MESSAGE_TYPE;
                                for (int i = 0; i < args.length; i++) {
                                Object arg = args[i];
                                if (arg == null) {
                                return MessageSender.NULL_PARAMETER;
                                }
                                }
                                return MessageSender.SUCCESS;
                                }
                                public static List legalMessageTypes() {
                                List result = new ArrayList();
                                result.add(CONFIRM);
                                return result;
                                }
                                private boolean shouldFailAllMessages = false;
                                public void failAllMessages() {
                                shouldFailAllMessages = true;
                                }
                                public int getNumberOfMessagesSent() {
                                return messagesSent;
                                }
                                Capturing the number of messages sent is a simple way of helping us test that
                                the gateway works correctly with tests like these.
                                class GatewayTester...
                                public void testSendNullArg() {
                                try {
                                gate().sendConfirmation(null, 5, "US");
                                fail("Didnâ€™t detect null argument");
                                } catch (NullPointerException expected) {
                                }
                                assertEquals(0, gate().getNumberOfMessagesSent());
                                }
                                private MessageGatewayStub gate() {
                                return (MessageGatewayStub) Environment.getMessageGateway();
                                }
                                protected void setUp() throws Exception {
                                Environment.testInit();
                                }</pre>
                                You usually set up the Gateway so that classes can find it from a well-known
                                place. Here Iâ€™ve used a static environment interface. You can switch between
                                the real service and the stub at configuration time by using a Plugin (499), or
                                you can have the test setup routines initialize the environment to use the Service
                                Stub (504).
                                In this case Iâ€™ve used a subclass of the gateway to stub the messaging service.
                                Another route is to subclass (or reimplement) the service itself. For testing you
                                connect the gateway to the sending Service Stub (504); it works if reimplementation of the service isnâ€™t too difficult. You always have the choice of stubbing
                                the service or stubbing the gateway. In some cases itâ€™s even useful to stub both,
                                using the stubbed gateway for testing clients of the gateway and the stubbed
                                service to test the gateway itself.</p>
                <h3 id="473">Mapper</h3>
                <p>An object that sets up a communication
                                between two independent objects.
                                Sometimes you need to set up communications between two subsystems that
                                still need to stay ignorant of each other. This may be because you canâ€™t modify
                                them or you can but you donâ€™t want to create dependencies between the two or
                                even between them and the isolating element.</p>
                <h3 id="473(2)">How It Works</h3>
                <p>A mapper is an insulating layer between subsystems. It controls the details of
                                the communication between them without either subsystem being aware of it.
                                A mapper often shuffles data from one layer to another. Once activated for
                                this shuffling, itâ€™s fairly easy to see how it works. The complicated part of using
                                a mapper is deciding how to invoke it, since it canâ€™t be directly invoked by
                                either of the subsystems that itâ€™s mapping between. Sometimes a third subsystem drives the mapping and invokes the mapper as well. An alternative is to
                                make the mapper an observer [Gang of Four] of one or the other subsystem.
                                That way it can be invoked by listening to events in one of them.
                                How a mapper works depends on the kind of layers itâ€™s mapping. The most
                                common case of a mapping layer that we run into is in a Data Mapper (165), so
                                look there for more details on how a Mapper is used.</p>
                <h3 id="474">When to Use It</h3>
                <p>Essentially a Mapper decouples different parts of a system. When you want to
                                do this you have a choice between Mapper and Gateway (466). Gateway (466)
                                is by far the most common choice because itâ€™s much simpler to use a Gateway
                                (466) than a Mapper both in writing the code and in using it later.
                                As a result you should only use a Mapper when you need to ensure that neither subsystem has a dependency on this interaction. The only time this is really
                                important is when the interaction between the subsystems is particularly complicated and somewhat independent to the main purpose of both subsystems.
                                Thus, in enterprise applications we mostly find Mapper used for interactions
                                with a database, as in Data Mapper (165).
                                Mapper is similar to Mediator [Gang of Four] in that itâ€™s used to separate
                                different elements. However, the objects that use a mediator are aware of it,
                                even if they arenâ€™t aware of each other; the objects that a Mapper separates
                                arenâ€™t even aware of the mapper.</p>
                <h3 id="475">Layer Supertype</h3>
                <p>Itâ€™s not uncommon for all the objects in a layer to have methods you donâ€™t want
                                to have duplicated throughout the system. You can move all of this behavior
                                into a common Layer Supertype.</p>
                <h3 id="475(2)">How It Works</h3>
                <p>Layer Supertype is a simple idea that leads to a very short pattern. All you need
                                is a superclass for all the objects in a layerâ€”for example, a Domain Object
                                superclass for all the domain objects in a Domain Model (116). Common features, such as the storage and handling of Identity Fields (216), can go there.
                                Similarly all Data Mappers (165) in the mapping layer can have a superclass
                                that relies on the fact that all domain objects have a common superclass.
                                If you have more than one kind of object in a layer, itâ€™s useful to have more
                                than one Layer Supertype.</p>
                <h3 id="475(3)">When to Use It</h3>
                <p>Use Layer Supertype when you have common features from all objects in a layer.
                                I often do this automatically because I make a lot of use of common features.</p>
                <h3 id="475(4)">Example: Domain Object (Java)</h3>
                <p>Domain objects can have a common superclass for ID handling.
                                <pre>class DomainObject...
                                private Long ID;
                                public Long getID() {
                                return ID;
                                }
                                public void setID(Long ID) {
                                Assert.notNull("Cannot set a null ID", ID);
                                this.ID = ID;
                                }
                                public DomainObject(Long ID) {
                                this.ID = ID;
                                }
                                public DomainObject() {
                                }</pre></p>
                <h3 id="476">Separated Interface</h3>
                <p>Defines an interface in a separate package from its implementation.
                                As you develop a system, you can improve the quality of its design by reducing
                                the coupling between the systemâ€™s parts. A good way to do this is to group the
                                classes into packages and control the dependencies between them.You can then
                                follow rules about how classes in one package can call classes in anotherâ€”for
                                example, one that says that classes in the domain layer may not call classes in
                                the presentation package.
                                However, you might need to invoke methods that contradict the general
                                dependency structure. If so, use Separated Interface to define an interface in one
                                package but implement it in another. This way a client that needs the depen Customer
                                dency to the interface can be completely unaware of the implementation. The
                                Separated Interface provides a good plug point for Gateway (466).</p>
                <h3 id="477">How It Works</h3>
                <p>This pattern is very simple to employ. Essentially it takes advantage of the fact
                                that an implementation has a dependency to its interface but not vice versa.
                                This means you can put the interface and the implementation in separate packages and the implementation package has a dependency to the interface package. Other packages can depend on the interface package without depending on
                                the implementation package.
                                Of course, the software wonâ€™t work at runtime without some implementation of the interface. This can be either at compile time using a separate package that ties the two together or at configuration time using Plugin (499).
                                You can place the interface in the clientâ€™s package (as in the sketch) or in a
                                third package (Figure 18.1). If thereâ€™s only one client for the implementation, or
                                all the clients are in the same package, then you might as well put the interface in
                                with the client. A good way of thinking about this is that the developers of the
                                client package are responsible for defining the interface. Essentially the client
                                package indicates that it will work with any other package that implements the
                                interface it defines. If you have multiple client packages, a third interface package is better. Itâ€™s also better if you want to show that the interface definition isnâ€™t
                                the responsibility of the client package developers. This would be the case if the
                                developers of the implementation were responsible for it.</p>
                <p>You have to consider what language feature to use for the interface. For languages that have an interface construct, such as Java and C#, the interface keyword is the obvious choice. However, it may not be the best. An abstract class
                                can make a good interface because you can have common, but optional, implementation behavior in it.
                                One of the awkward things about separate interfaces is how to instantiate
                                the implementation. It usually requires knowledge of the implementation class.
                                The common approach is to use a separate factory object, where again there is
                                a Separated Interface for the factory. You still have to bind an implementation
                                to the factory, and Plugin (499) is a good way to do this. Not only does it mean
                                there is no dependency, but it also defers the decision about implementation
                                class to configuration time.
                                If you donâ€™t want to go all the way to Plugin (499), a simpler alternative is to
                                let yet another package that knows both the interface and the implementation
                                instantiate the right objects at application startup. Any objects that use Separated Interface can either themselves be instantiated or have factories instantiated at startup.</p>
                <h3 id="478">When to Use It</h3>
                <p>You use Separated Interface when you need to break a dependency between
                                two parts of the system. Here are some examples:
                <ul>
                        <li>Youâ€™ve built some abstract code for common cases into a framework package that needs to call some particular application code.</li>
                        <li>You have some code in one layer that needs to call code in another layer that it shouldnâ€™t see, such as domain code calling a Data Mapper (165).</li>
                        <li>You need to call functions developed by another development group but donâ€™t want a dependency into their APIs.</li>
                </ul>
                                I come across many developers who have separate interfaces for every class
                                they write. I think this is excessive, especially for application development. Keeping separate interfaces and implementations is extra work, especially since you
                                often need factory classes (with interfaces and implementations) as well. For
                                applications I recommend using a separate interface only if you want to break a
                                dependency or you want to have multiple independent implementations. If you
                                put the interface and implementation together and need to separate them later,
                                this is a simple refactoring that can be delayed until you need to do it.
                                There is a degree to where the determined management of dependencies in
                                this way can get a little silly. Having only a dependency to create an object, and
                                using the interface ever after, is usually enough. The trouble comes when you
                                want to enforce dependency rules, such as by doing a dependency check at
                                build time. Then all dependencies have to be removed. For a smaller system
                                enforcing dependency rules is less of an issue, but for bigger systems itâ€™s a very
                                worthwhile discipline.</p>
                <h3 id="480">Registry</h3>
                <p>A well-known object that other objects can use
                                to find common objects and services.
                                When you want to find an object you usually start with another object that has
                                an association to it, and use the association to navigate to it. Thus, if you want
                                to find all the orders for a customer, you start with the customer object and use
                                a method on it to get the orders. However, in some cases you wonâ€™t have an
                                appropriate object to start with. You may know the customerâ€™s ID number but
                                not have a reference. In this case you need some kind of lookup methodâ€”a
                                finderâ€”but the question remains: How do you get to the finder?
                                A Registry is essentially a global object, or at least it looks like oneâ€”even if
                                it isnâ€™t as global as it may appear. </p>
                <h3 id="480(2)">How It Works</h3>
                <p>As with any object, you have to think about the design of a Registry in terms of
                                interface and implementation. And like many objects, the two are quite different, although people often make the mistake of thinking they should be the
                                same.
                                The first thing to think of is the interface, and for Registries my preferred
                                interface is static methods. A static method on a class is easy to find anywhere
                                in an application. Furthermore, you can encapsulate any logic you like within
                                the static method, including delegation to other methods, either static or
                                instance.
                                However, just because your methods are static doesnâ€™t mean that your data
                                should be in static fields. Indeed, I almost never use static fields unless theyâ€™re
                                constants.
                                Before you decide on how to hold your data, think about the dataâ€™s scope.
                                The data for a Registry can vary with different execution contexts. Some of it is
                                global across an entire process; some, global across a thread; and some, global
                                <pre>getPerson (id)
                                addPerson (Person)</pre>
                                across a session. Different scopes call for different implementations, but they
                                donâ€™t call for different interfaces. The application programmer doesnâ€™t have to
                                know whether a call to a static method yields process-scoped or thread-scoped
                                data. You can have different Registries for different scopes, but you can also
                                have a single Registry in which different methods are at different scopes.
                                If your data is common to a whole process, a static field is an option. However, I rarely use static mutable fields because they donâ€™t allow for substitution.
                                It can be extremely useful to be able to substitute a Registry for a particular
                                purpose, especially for testing (Plugin (499) is a good way to do this).
                                For a process-scoped Registry, then, the usual option is a singleton [Gang of
                                Four]. The Registry class contains a single static field that holds a Registry
                                instance. When people use a singleton they often make its caller explicitly
                                access the underlying data (Registry.soleInstance.getFoo()), but I prefer a static
                                method that hides the singleton object from me (Registry.getFoo()). This works
                                particularly well since C-based languages allow static methods to access private
                                instance data.</p>
                <p>Singletons are widely used in single-threaded applications, but can be a problem for multi-threaded applications. This is because itâ€™s too easy for multiple
                                threads to manipulate the same object in unpredictable ways. You may be able
                                to solve this with synchronization, but the difficulty of writing the synchronization code is likely to drive you into an insane asylum before you get all the bugs
                                out. For that reason I donâ€™t recommend using a singleton for mutable data in a
                                multi-threaded environment. It does work well for immutable data, since anything that canâ€™t change isnâ€™t going to run into thread clash problems. Thus,
                                something like a list of all states in the United States makes a good candidate
                                for a process-scoped Registry. Such data can be loaded when a process starts up
                                and never need changing, or it may be updated rarely with some kind of process
                                interrupt.</p>
                <p>A common kind of Registry data is thread scoped. A good example is a database connection. In this case many environments give you some form of threadspecific storage, such as Javaâ€™s thread local. Another technique is a dictionary
                                keyed by thread whose value is an appropriate data object. A request for a connection results in a lookup in that dictionary by the current thread.
                                The important thing to remember about thread-scoped data is that it
                                looks no different from process-scoped data. I can still use a method such as
                                Registry.getDbConnection(), which is the same form when Iâ€™m accessing processscoped data.
                                A dictionary lookup is also a technique you can use for session-scoped data.
                                Here you need a session ID, but it can be put into a thread-scoped registry when
                                a request begins. Any subsequent accesses for session data can look up the data
                                in a map thatâ€™s keyed by session using the session ID thatâ€™s held in thread-specific storage.
                                If youâ€™re using a thread-scoped Registry with static methods, you may run
                                into a performance issue with multiple threads going through them. In that case
                                direct access to the threadâ€™s instance will avoid the bottleneck.
                                Some applications may have a single Registry; some may have several. Registries are usually divided up by system layer or by execution context. My preference is to divide them up by how they are used, rather than implementation.</p>
                <h3 id="482">When to Use It</h3>
                <p>Despite the encapsulation of a method, a Registry is still global data and as
                                such is something Iâ€™m uncomfortable using. I almost always see some form of
                                Registry in an application, but I always try to access objects through regular
                                inter-object references instead. Basically, you should only use a Registry as a last
                                resort.
                                There are alternatives to using a Registry. One is to pass around any widely
                                needed data in parameters. The problem with this is that parameters are added
                                to method calls where they arenâ€™t needed by the called method but only by
                                some other method thatâ€™s called several layers deep in the call tree. Passing a
                                parameter around when itâ€™s not needed 90 percent of the time is what leads me
                                to use a Registry instead.</p>
                <p>Another alternative Iâ€™ve seen to a Registry is to add a reference to the common data to objects when theyâ€™re created. Although this leads to an extra
                                parameter in a constructor, at least itâ€™s only used by that constructor. Itâ€™s still
                                more trouble than itâ€™s often worth, but if you have data thatâ€™s only used by a
                                subset of classes, this technique allows you to restrict things that way.
                                One of the problems with a Registry is that it has to be modified every time
                                you add a new piece of data. This is why some people prefer to use a map as
                                their holder of global data. I prefer the explicit class because it keeps the methods explicit, so thereâ€™s no confusion about what key you use to find something.
                                With an explicit class you can just look at the source code or generated documentation to see whatâ€™s available. With a map you have to find places in the
                                system where data is read or written to the map to find out what key is used or
                                to rely on documentation that quickly becomes stale. An explicit class also
                                allows you to keep type safety in a statically typed language as well as to encapsulate the structure of the Registry so that you can refactor it as the system
                                grows. A bare map also is unencapsulated, which makes it harder to hide the
                                implementation. This is particularly awkward if you have to change the dataâ€™s
                                execution scope.
                                So there are times when itâ€™s right to use a Registry, but remember that any
                                global data is always guilty until proven innocent. </p>
                <h3 id="483">Example: A Singleton Registry (Java)</h3>
                <p>Consider an application that reads data from a database and then munges on it
                                to turn it into information. Well, imagine a fairly simple system that uses Row
                                Data Gateways (152) for data access. This system has finder objects to encapsulate the database queries. The finders are best made as instances because that
                                way we can substitute them to make a Service Stub (504) for testing. We need a
                                place to put them; a Registry is the obvious choice.
                                A singleton registry is a very simple example of the Singleton pattern [Gang
                                of Four]. You have a static variable for the single instance.
                                <pre>class Registry...
                                private static Registry getInstance() {
                                return soleInstance;
                                }
                                private static Registry soleInstance = new Registry();
                                Everything thatâ€™s stored on the registry is stored on the instance.
                                class Registry...
                                protected PersonFinder personFinder = new PersonFinder();
                                To make access easier, however, I make the public methods static.
                                class Registry...
                                public static PersonFinder personFinder() {
                                return getInstance().personFinder;
                                }
                                I can reinitialize the registry simply by creating a new sole instance.
                                class Registry...
                                public static void initialize() {
                                soleInstance = new Registry();
                                }
                                If I want to use Service Stubs (504) for testing, I use a subclass instead.
                                class RegistryStub extends Registry...
                                public RegistryStub() {
                                personFinder = new PersonFinderStub();
                                }
                                484 BASE PATTERNS
                                Registry
                                The finder Service Stub (504) just returns hardcoded instances of the person
                                Row Data Gateway (152).
                                class PersonFinderStub...
                                public Person find(long id) {
                                if (id == 1) {
                                return new Person("Fowler", "Martin", 10);
                                }
                                throw new IllegalArgumentException("Canâ€™t find id: " + String.valueOf(id));
                                }
                                I put a method on the registry to initialize it in stub mode, but by keeping all
                                the stub behavior in the subclass I can separate all the code required for testing.
                                class Registry...
                                public static void initializeStub() {
                                soleInstance = new RegistryStub();
                                }</pre></p>
                <h3 id="484">Example: Thread-Safe Registry (Java) Matt Foemmel and Martin Fowler</h3>
                <p>The simple example above wonâ€™t work for a multi-threaded application where
                                different threads need their own registry. Java provides Thread Specific Storage
                                variables [Schmidt] that are local to a thread, helpfully called thread local variables. You can use them to create a registry thatâ€™s unique for a thread.
                                <pre>class ThreadLocalRegistry...
                                private static ThreadLocal instances = new ThreadLocal();
                                public static ThreadLocalRegistry getInstance() {
                                return (ThreadLocalRegistry) instances.get();
                                }</pre>
                                The Registry needs to be set up with methods for acquiring and releasing it.
                                You typically do this on a transaction or session call boundary.
                                <pre>class ThreadLocalRegistry...
                                public static void begin() {
                                Assert.isTrue(instances.get() == null);
                                instances.set(new ThreadLocalRegistry());
                                }
                                public static void end() {
                                Assert.notNull(getInstance());
                                instances.set(null);
                                }
                                You can then store person finders as before.
                                class ThreadLocalRegistry...
                                private PersonFinder personFinder = new PersonFinder();;
                                public static PersonFinder personFinder() {
                                return getInstance().personFinder;
                                }</pre>
                                Calls from the outside wrap their use of a registry in the begin and end methods.
                                <pre>try {
                                ThreadLocalRegistry.begin();
                                PersonFinder f1 = ThreadLocalRegistry.personFinder();
                                Person martin = Registry.personFinder().find(1);
                                assertEquals("Fowler", martin.getLastName());
                                } finally {ThreadLocalRegistry.end();
                                }</pre></p>
                <h3 id="486">Value Object</h3>
                <p>A small simple object, like money or a date
                                range, whose equality isnâ€™t based on identity.
                                With object systems of various kinds, Iâ€™ve found it useful to distinguish between
                                reference objects and Value Objects. Of the two a Value Object is usually the
                                smaller; itâ€™s similar to the primitive types present in many languages that arenâ€™t
                                purely object-oriented. </p>
                <h3 id="486(2)">How It Works</h3>
                <p>Defining the difference between a reference object and Value Object can be a
                                tricky thing. In a broad sense we like to think that Value Objects are small
                                objects, such as a money object or a date, while reference objects are large, such
                                as an order or a customer. Such a definition is handy but annoyingly informal.
                                The key difference between reference and value objects lies in how they deal
                                with equality. A reference object uses identity as the basis for equalityâ€”maybe
                                the identity within the programming system, such as the built-in identity of OO
                                programming languages, or maybe some kind of ID number, such as the primary key in a relational database. A Value Object bases its notion of equality
                                on field values within the class. Thus, two date objects may be the same if their
                                day, month, and year values are the same.</p>
                <p>This difference manifests itself in how you deal with them. Since Value
                                Objects are small and easily created, theyâ€™re often passed around by value
                                instead of by reference. You donâ€™t really care about how many March 18, 2001,
                                objects there are in your system. Nor do you care if two objects share the same
                                physical date object or whether they have different yet equal copies.
                                Most languages have no special facility for value objects. For value objects to
                                work properly in these cases itâ€™s a very good idea to make them immutableâ€”
                                that is, once created none of their fields change. The reason for this is to avoid
                                aliasing bugs. An aliasing bug occurs when two objects share the same value
                                object and one of the owners changes the values in it. Thus, if Martin has a hire
                                date of March 18 and we know that Cindy was hired on the same day, we may
                                set Cindyâ€™s hire date to be the same as Martinâ€™s. If Martin then changes the
                                month in his hire date to May, Cindyâ€™s hire date changes too. Whether itâ€™s correct or not, it isnâ€™t what people expect. Usually with small values like this people expect to change a hire date by replacing the existing date object with a new
                                one. Making Value Objects immutable fulfills that expectation.</p>
                <p>Value Objects shouldnâ€™t be persisted as complete records. Instead use
                                Embedded Value (268) or Serialized LOB (272). Since Value Objects are small,
                                Embedded Value (268) is usually the best choice because it also allows SQL
                                querying using the data in a Value Object.
                                If youâ€™re doing a lot of binary serializing, you may find that optimizing the
                                serialization of Value Objects can improve performance, particularly in languages like Java that donâ€™t treat for Value Objects in a special way.
                                For an example of a Value Object see Money (488).
                                .NET Implementation
                                .NET has a first-class treatment of Value Object. In C# an object is marked
                                as a Value Object by declaring it as a struct instead as a class. The environment then treats it with value semantics.</p>
                <h3 id="487">When to Use It</h3>
                <p>Treat something as a Value Object when youâ€™re basing equality on something
                                other than an identity. Itâ€™s worth considering this for any small object thatâ€™s
                                easy to create.
                                Name Collisions Iâ€™ve seen the term Value Object used for this pattern for quite
                                some time. Sadly recently Iâ€™ve seen the J2EE community [Alur et al.] use the
                                term â€œvalue objectâ€ to mean Data Transfer Object (401), which has caused a
                                storm in the teacup of the patterns community. This is just one of those clashes
                                over names that happen all the time in this business. Recently [Alur et al.]
                                decided to use the term transfer object instead.
                                I continue to use Value Object in this way in this text. If nothing else it
                                allows me to be consistent with my previous writings!</p>
                <h3 id="488">Money</h3>
                <p>Represents a monetary value.
                                A large proportion of the computers in this world manipulate money, so itâ€™s
                                always puzzled me that money isnâ€™t actually a first class data type in any
                                mainstream programming language. The lack of a type causes problems, the
                                most obvious surrounding currencies. If all your calculations are done in a
                                single currency, this isnâ€™t a huge problem, but once you involve multiple currencies you want to avoid adding your dollars to your yen without taking the
                                currency differences into account. The more subtle problem is with rounding.
                                Monetary calculations are often rounded to the smallest currency unit. When
                                you do this itâ€™s easy to lose pennies (or your local equivalent) because of
                                rounding errors.
                                The good thing about object-oriented programming is that you can fix these
                                problems by creating a Money class that handles them. Of course, itâ€™s still surprising that none of the mainstream base class libraries actually do this.</p>
                <h3 id="488(2)">How It Works</h3>
                <p>The basic idea is to have a Money class with fields for the numeric amount and
                                the currency. You can store the amount as either an integral type or a fixed decimal type. The decimal type is easier for some manipulations, the integral for others. You should absolutely avoid any kind of floating point type, as that will
                                introduce the kind of rounding problems that Money is intended to avoid. Most
                                of the time people want monetary values rounded to the smallest complete unit,
                                such as cents in the dollar. However, there are times when fractional units are
                                needed. Itâ€™s important to make it clear what kind of money youâ€™re working with,
                                especially in an application that uses both kinds. It makes sense to have different
                                types for the two cases as they behave quite differently under arithmetic.
                                <pre>+, -, *
                                allocate
                                >, >, <=, >=, =
                                amount
                                currency
                                Money</pre>
                                Money is a Value Object (486), so it should have its equality and hash code
                                operations overridden to be based on the currency and amount.
                                Money needs arithmetic operations so that you can use money objects as easily as you use numbers. But arithmetic operations for money have some important differences to money operations in numbers. Most obviously, any addition
                                or subtraction needs to be currency aware so you can react if you try to add
                                together monies of different currencies. The simplest, and most common,
                                response is to treat the adding together of disparate currencies as an error. In
                                some more sophisticated situations you can use Ward Cunninghamâ€™s idea of a
                                money bag. This is an object that contains monies of multiple currencies
                                together in one object. This object can then participate in calculations just like
                                any money object. It can also be valued into a currency.
                                Multiplication and division end up being more complicated due to rounding
                                problems. When you multiply money you do it with a scalar. If you want to add
                                5% tax to a bill you multiply by 0.05, so you see multiplication by regular
                                numeric types.
                                The awkward complication comes with rounding, particularly when allocating money between different places. Hereâ€™s Matt Foemmelâ€™s simple conundrum.
                                Suppose I have a business rule that says that I have to allocate the whole amount
                                of a sum of money to two accounts: 70% to one and 30% to another. I have 5
                                cents to allocate. If I do the math I end up with 3.5 cents and 1.5 cents. Whichever way I round these I get into trouble. If I do the usual rounding to nearest
                                then 1.5 becomes 2 and 3.5 becomes 4. So I end up gaining a penny. Rounding
                                down gives me 4 cents and rounding up gives me 6 cents. Thereâ€™s no general
                                rounding scheme I can apply to both that will avoid losing or gaining a penny.
                                Iâ€™ve seen various solutions to this problem.
                <ul>
                        <li>Perhaps the most common is to ignore itâ€”after all, itâ€™s only a penny here
                                and there. However this tends to make accountants understandably nervous.</li>
                        <li>When allocating you always do the last allocation by subtracting from
                                what youâ€™ve allocated so far. This avoids losing pennies, but you can get a
                                cumulative amount of pennies on the last allocation.</li>
                        <li>Allow users of a Money class to declare the rounding scheme when they call
                                the method. This permits a programmer to say that the 70% case rounds up and
                                the 30% rounds down. Things can get complicated when you allocate across ten
                                accounts instead of two. You also have to remember to round. To encourage people to remember Iâ€™ve seen some Money classes force a rounding parameter into
                                the multiply operation. Not only does this force the programmer to think about
                                what rounding she needs, it also might remind her of the tests to write. However,
                                it gets messy if you have a lot of tax calculations that all round the same way.</li>
                        <li>My favorite solution: have an allocator function on the money. The
                                parameter to the allocator is a list of numbers, representing the ratio to be allocated (it would look something like aMoney.allocate([7,3])). The allocator returns
                                a list of monies, guaranteeing that no pennies get dropped by scattering them
                                across the allocated monies in a way that looks pseudo-random from the outside. The allocator has faults: You have to remember to use it and any precise
                                rules about where the pennies go are difficult to enforce.</li>
                </ul>
                                The fundamental issue here is between using multiplication to determine
                                proportional charge (such as a tax) and using it to allocate a sum of money
                                across multiple places. Multiplication works well for the former, but an allocator works better for the latter. The important thing is to consider your intent in
                                using multiplication or division on a monetary value.
                                You may want to convert from one currency to another with a method like
                                aMoney.convertTo(Currency.DOLLARS). The obvious way to do this is to look up an
                                exchange rate and multiply by it. While this works in many situations, there are
                                cases where it doesnâ€™tâ€”again due to rounding. The conversion rules between
                                the fixed euro currencies had specific roundings applied that made simple multiplication unworkable. Thus, itâ€™s wise to have a convertor object to encapsulate
                                the algorithm.</p>
                <p>Comparison operations allow you to sort monies. Like the addition operation, conversions need to be currency aware. You can either choose to throw an
                                exception if you compare different currencies or do a conversion.
                                A Money can encapsulate the printing behavior. This makes it much easier to
                                provide good display on user interfaces and reports. A Money class can also
                                parse a string to provide a currency-aware input mechanism, which again is
                                very useful for the user interface. This is where your platformâ€™s libraries can
                                provide help. Increasingly platforms provide globalization support with specific
                                number formatters for particular countries.
                                Storing a Money in a database always raises an issue, since databases also
                                donâ€™t seem to understand that money is important (although their vendors do.)
                                The obvious route to take is to use Embedded Value (268), which results in
                                storing a currency for every money. That can be overkill when, for instance, an
                                account may have all its entries be in pounds. In this case you may store the
                                currency on the account and alter the database mapping to pull the accountâ€™s
                                currency whenever you load entries. </p>
                <h3 id="490">When to Use It</h3>
                <p>I use Money for pretty much all numeric calculation in object-oriented environments. The primary reason is to encapsulate the handling of rounding behavior,
                                MONEY 491
                                Money
                                which helps reduce the problems of rounding errors. Another reason to use
                                Money is to make multi-currency work much easier. The most common objection to Money is performance, although Iâ€™ve only rarely heard of cases where it
                                makes any noticeable difference, and even then the encapsulation often makes
                                tuning easier.</p>
                <h3 id="491">Example: A Money Class (Java) by Matt Foemmel and Martin Fowler</h3>
                <p>The first decision is what data type to use for the amount. If anyone needs convincing that a floating point number is a bad idea, ask them to run this code.
                                <pre>double val = 0.00;
                                for (int i = 0; i < 10; i++) val += 0.10;
                                System.out.println(val == 1.00);</pre>
                                With floats safely disposed of, the choice lies between fixed-point decimals
                                and integers, which in Java boils down to BigDecimal, BigInteger and long. Using
                                an integral value actually makes the internal math easier, and if we use long we
                                can use primitives and thus have readable math expressions.
                                <pre>class Money...
                                private long amount;
                                private Currency currency;</pre>
                                Iâ€™m using an integral amount, that is, the amount of the smallest base unit,
                                which I refer to as cents in the code because itâ€™s as good a name as any. With a
                                long we get an overflow error if the number gets too big. If you give us
                                $92,233,720,368,547,758.09 weâ€™ll write you a version that uses BigInteger.
                                Itâ€™s useful to provide constructors from various numeric types.
                                <pre>public Money(double amount, Currency currency) {
                                this.currency = currency;
                                this.amount = Math.round(amount * centFactor());
                                }
                                public Money(long amount, Currency currency) {
                                this.currency = currency;
                                this.amount = amount * centFactor();
                                }
                                private static final int[] cents = new int[] { 1, 10, 100, 1000 };
                                private int centFactor() {
                                return cents[currency.getDefaultFractionDigits()];
                                }</pre>
                                Different currencies have different fractional amounts. The Java 1.4 Currency
                                class will tell you the number of fractional digits in a class. We can determine
                                how many minor units there are in a major unit by raising ten to the power, but
                                thatâ€™s such a pain in Java that the array is easier (and probably quicker). Weâ€™re
                                prepared to live with the fact that this code breaks if someone uses four fractional digits.
                                Although most of the time youâ€™ll want to use money operation directly, there
                                are occasions when youâ€™ll need access to the underlying data.
                                <pre>class Money...
                                public BigDecimal amount() {
                                return BigDecimal.valueOf(amount, currency.getDefaultFractionDigits());
                                }
                                public Currency currency() {
                                return currency;
                                }</pre>
                                You should always question your use of accessors. Thereâ€™s almost always a
                                better way that wonâ€™t break encapsulation. One example that we couldnâ€™t avoid
                                is database mapping, as in Embedded Value (268).
                                If you use one currency very frequently for literal amounts, a helper constructor can be useful.
                                <pre>class Money...
                                public static Money dollars(double amount) {
                                return new Money(amount, Currency.USD);
                                }
                                As Money is a Value Object (486) youâ€™ll need to define equals.
                                class Money...
                                public boolean equals(Object other) {
                                return (other instanceof Money) && equals((Money)other);
                                }
                                public boolean equals(Money other) {
                                return currency.equals(other.currency) && (amount == other.amount);
                                }</pre>
                                And wherever thereâ€™s an equals there should be a hash.
                                <pre>class Money...
                                public int hashCode() {
                                return (int) (amount ^ (amount >>> 32));
                                }</pre>
                                Weâ€™ll start going through the arithmetic with addition and subtraction.
                                <pre>class Money...
                                public Money add(Money other) {
                                assertSameCurrencyAs(other);
                                return newMoney(amount + other.amount);
                                }
                                private void assertSameCurrencyAs(Money arg) {
                                Assert.equals("money math mismatch", currency, arg.currency);
                                }
                                private Money newMoney(long amount) {
                                Money money = new Money();
                                money.currency = this.currency;
                                money.amount = amount;
                                return money;
                                }</pre>
                                Note the use of a private factory method here that doesnâ€™t do the usual conversion into the cent-based amount. Weâ€™ll use that a few times inside the Money
                                code itself.
                                With addition defined, subtraction is easy.
                                <pre>class Money...
                                public Money subtract(Money other) {
                                assertSameCurrencyAs(other);
                                return newMoney(amount - other.amount);
                                }
                                The base method for comparison is compareTo.
                                class Money...
                                public int compareTo(Object other) {
                                return compareTo((Money)other);
                                }
                                public int compareTo(Money other) {
                                assertSameCurrencyAs(other);
                                if (amount < other.amount) return -1;
                                else if (amount == other.amount) return 0;
                                else return 1;
                                }</pre>
                                Although thatâ€™s all you get on most Java classes these days, we find code is
                                more readable with the other comparison methods such as these.
                                <pre>class Money...
                                public boolean greaterThan(Money other) {
                                return (compareTo(other) > 0);
                                }</pre>
                                Now weâ€™re ready to look at multiplication. Weâ€™re providing a default rounding mode but you can set one yourself as well.
                                <pre>class Money...
                                public Money multiply(double amount) {
                                return multiply(new BigDecimal(amount));
                                }
                                public Money multiply(BigDecimal amount) {
                                return multiply(amount, BigDecimal.ROUND_HALF_EVEN);
                                }
                                public Money multiply(BigDecimal amount, int roundingMode) {
                                return new Money(amount().multiply(amount), currency, roundingMode);
                                }</pre>
                                If you want to allocate a sum of money among many targets and you donâ€™t
                                want to lose cents, youâ€™ll want an allocation method. The simplest one allocates
                                the same amount (almost) amongst a number of targets.
                                <pre>class Money...
                                public Money[] allocate(int n) {
                                Money lowResult = newMoney(amount / n);
                                Money highResult = newMoney(lowResult.amount + 1);
                                Money[] results = new Money[n];
                                int remainder = (int) amount % n;
                                for (int i = 0; i < remainder; i++) results[i] = highResult;
                                for (int i = remainder; i < n; i++) results[i] = lowResult;
                                return results;
                                }</pre>
                                A more sophisticated allocation algorithm can handle any ratio.
                                <pre>class Money...
                                public Money[] allocate(long[] ratios) {
                                long total = 0;
                                for (int i = 0; i < ratios.length; i++) total += ratios[i];
                                long remainder = amount;
                                Money[] results = new Money[ratios.length];
                                for (int i = 0; i < results.length; i++) {
                                results[i] = newMoney(amount * ratios[i] / total);
                                remainder -= results[i].amount;
                                }
                                for (int i = 0; i < remainder; i++) {
                                results[i].amount++;
                                }
                                return results;
                                }</pre>
                                You can use this to solve Foemmelâ€™s Conundrum.
                                <pre>class Money...
                                public void testAllocate2() {
                                long[] allocation = {3,7};
                                Money[] result = Money.dollars(0.05).allocate(allocation);
                                assertEquals(Money.dollars(0.02), result[0]);
                                assertEquals(Money.dollars(0.03), result[1]);
                                }</pre></p>
                <h3 id="496">Special Case</h3>
                <p>A subclass that provides special behavior for particular cases.
                                Nulls are awkward things in object-oriented programs because they defeat
                                polymorphism. Usually you can invoke foo freely on a variable reference of a
                                given type without worrying about whether the item is the exact type or a subclass. With a strongly typed language you can even have the compiler check
                                that the call is correct. However, since a variable can contain null, you may run
                                into a runtime error by invoking a message on null, which will get you a nice,
                                friendly stack trace.
                                If itâ€™s possible for a variable to be null, you have to remember to surround it
                                with null test code so youâ€™ll do the right thing if a null is present. Often the right
                                thing is the same in many contexts, so you end up writing similar code in lots of
                                placesâ€”committing the sin of code duplication.
                                Nulls are a common example of such problems and others crop up regularly.
                                In number systems you have to deal with infinity, which has special rules for
                                things like addition that break the usual invariants of real numbers. One of my
                                earliest experiences in business software was with a utility customer who wasnâ€™t
                                fully known, referred to as â€œoccupant.â€ All of these imply altering the usual
                                behavior of the type.
                                Instead of returning null, or some odd value, return a Special Case that has
                                the same interface as what the caller expects.</p>
                <h3 id="497">How It Works</h3>
                <p>The basic idea is to create a subclass to handle the Special Case. Thus, if you
                                have a customer object and you want to avoid null checks, you make a null customer object. Take all of the methods for customer and override them in the
                                Special Case to provide some harmless behavior. Then, whenever you have a
                                null, put in an instance of null customer instead.
                                Thereâ€™s usually no reason to distinguish between different instances of null
                                customer, so you can often implement a Special Case with a flyweight [Gang of
                                Four]. You canâ€™t do it all the time. For a utility you can accumulate charges
                                against an occupant customer even you canâ€™t do much billing, so itâ€™s important
                                to keep your occupants separate.</p>
                <p>A null can mean different things. A null customer may mean no customer or
                                it may mean that thereâ€™s a customer but we donâ€™t know who it is. Rather than
                                just using a null customer, consider having separate Special Cases for missing
                                customer and unknown customer.
                                A common way for a Special Case to override methods is to return another
                                Special Case, so if you ask an unknown customer for his last bill, you may well
                                get an unknown bill.
                                IEEE 754 floating-point arithmetic offers good examples of Special Case
                                with positive infinity, negative infinity, and not-a-number (NaN). If you divide
                                by zero, instead of getting an exception that you have to deal with, the system
                                just returns NaN, and NaN participates in arithmetic just like any other floating point number.</p>
                <h3 id="497(2)">When to Use It</h3>
                <p>Use Special Case whenever you have multiple places in the system that have the
                                same behavior after a conditional check for a particular class instance, or the
                                same behavior after a null check.</p>
                <h3 id="497(3)">Further Reading</h3>
                <p>I havenâ€™t seen Special Case written up as a pattern yet, but Null Object has been
                                written up in [Woolf]. If youâ€™ll pardon the unresistable pun, I see Null Object as
                                special case of Special Case.
                                498 BASE PATTERNS
                                Special Case</p>
                <h3 id="498">Example: A Simple Null Object (C#)</h3>
                <p>Hereâ€™s a simple example of Special Case used as a null object.
                                We have a regular employee.
                                <pre>class Employee...
                                public virtual String Name {
                                get {return _name;}
                                set {_name = value;}
                                }
                                private String _name;
                                public virtual Decimal GrossToDate {
                                get {return calculateGrossFromPeriod(0);}
                                }
                                public virtual Contract Contract {
                                get {return _contract;}
                                }
                                private Contract _contract;
                                The features of the class could be overridden by a null employee
                                class NullEmployee : Employee, INull...
                                public override String Name {
                                get {return "Null Employee";}
                                set {}
                                }
                                public override Decimal GrossToDate {
                                get {return 0m;}
                                }
                                public override Contract Contract {
                                get {return Contract.NULL;}
                                }</pre>
                                Notice that when you ask a null employee for its contract you get a null contract back.
                                The default values here avoid a lot of null tests if they end up with the same
                                null values. The repeated null values are handled by the null object by default.
                                You can also test for nullness explicitly either by giving the customer an isNull
                                method or by using a type test for a marker interface.</p>
                <h3 id="499">Plugin</h3>
                <p>Links classes during configuration rather than compilation.
                                Separated Interface (476) is often used when application code runs in multiple
                                runtime environments, each requiring different implementations of particular
                                behavior. Most developers supply the correct implementation by writing a factory method. Suppose you define your primary key generator with a Separated
                                Interface (476) so that you can use a simple in-memory counter for unit testing
                                but a database-managed sequence for production. Your factory method will
                                most likely contain a conditional statement that looks at a local environment
                                variable, determines if the system is in test mode, and returns the correct key
                                generator. Once you have a few factories you have a mess on your hands.
                                Establishing a new deployment configurationâ€”say â€œexecute unit tests against
                                in-memory database without transaction controlâ€ or â€œexecute in production
                                mode against DB2 database with full transaction controlâ€â€”requires editing
                                conditional statements in a number of factories, rebuilding, and redeploying.
                                Configuration shouldnâ€™t be scattered throughout your application, nor should it
                                require a rebuild or redeployment. Plugin solves both problems by providing
                                centralized, runtime configuration.</p>
                <h3 id="499(2)">How It Works</h3>
                The first thing to do is define with a Separated Interface (476) any behaviors that
                                will have different implementations based on runtime environment. Beyond that,
                                we use the basic factory pattern, only with a few special requirements. The
                                Plugin factory requires its linking instructions to be stated at a single, external
                                point in order that configuration can be easily managed. Additionally, the
                                linking to implementations must occur dynamically at runtime rather than
                                during compilation, so that reconfiguration wonâ€™t require a rebuild.
                                A text file works quite well as the means of stating linking rules. The Plugin
                                factory will simply read the text file, look for an entry specifying the implementation of a requested interface, and return that implementation.
                                Plugin works best in a language that supports reflection because the factory
                                can construct implementations without compile-time dependencies on them.
                                When using reflection, the configuration file must contain mappings of interface
                                names to implementation class names. The factory can sit independently in a
                                framework package and neednâ€™t be changed when you add new implementations to your configuration options.
                                Even when not using a language that supports reflection itâ€™s still worthwhile
                                to establish a central point of configuration. You can even use a text file to set
                                up linking rules, with the only difference that your factory will use conditional
                                logic to map an interface to the desired implementation. Each implementation
                                type must be accounted for in the factoryâ€”not a big a deal in practice. Just add
                                another option within the factory method whenever you add a new implementation to the code base. To enforce layer and package dependencies with a
                                build-time check, place this factory in its own package to avoid breaking your
                                build process.</p>
                <h3 id="500">When to Use It</h3>
                <p>Use Plugin whenever you have behaviors that require different implementations
                                based on runtime environment.</p>
                <h3 id="501">Example: An Id Generator (Java)</h3>
                <p>As discussed above, key, or ID, generation is a task whose implementation
                                might vary between deployment environments (Figure 18.3).
                                First weâ€™ll write the IdGenerator Separated Interface (476) as well as any
                                needed implementations.
                                <pre>interface IdGenerator...
                                public Long nextId();
                                class OracleIdGenerator implements IdGenerator...
                                public OracleIdGenerator() {
                                this.sequence = Environment.getProperty("id.sequence");
                                this.datasource = Environment.getProperty("id.source");
                                }</pre>
                                In the OracleIdGenerator, nextId() selects the next available number out of the
                                defined sequence from the defined data source.
                                <pre>class Counter implements IdGenerator...
                                private long count = 0;
                                public synchronized Long nextId() {
                                return new Long(count++);
                                }
                                Now that we have something to construct, letâ€™s write the plugin factory that
                                will realize the current interface-to-implementation mappings.
                                class PluginFactory...
                                private static Properties props = new Properties();
                                static {
                                try {
                                String propsFile = System.getProperty("plugins");
                                props.load(new FileInputStream(propsFile));
                                } catch (Exception ex) {
                                throw new ExceptionInInitializerError(ex);
                                }
                                }
                                public static Object getPlugin(Class iface) {
                                String implName = props.getProperty(iface.getName());
                                if (implName == null) {
                                throw new RuntimeException("implementation not specified for " +
                                iface.getName() + " in PluginFactory propeties.");
                                }
                                try {
                                return Class.forName(implName).newInstance();
                                } catch (Exception ex) {
                                throw new RuntimeException("factory unable to construct instance of " +
                                iface.getName());
                                }
                                }</pre>
                                Note that weâ€™re loading the configuration by looking for a system property
                                named plugins that will locate the file containing our linking instructions.
                                Many options exist for defining and storing linking instructions, but we find a
                                simple properties file the easiest. Using the system property to find the file
                                rather than looking on the classpath makes it simple to specify a new configuration anywhere on your machine. This can be very convenient when moving
                                builds between development, test, and production environments. Hereâ€™s how
                                two different configuration files, one for test and one for production, might
                                look:
                                <pre>config file test.properties...
                                # test configuration
                                IdGenerator=TestIdGenerator
                                config file prod.properties...
                                # production configuration
                                IdGenerator=OracleIdGenerator</pre>
                                Letâ€™s go back to the IdGenerator interface and add a static INSTANCE member
                                thatâ€™s set by a call to the Plugin factory. It combines Plugin with the singleton
                                pattern to provide an extremely simple, readable call to obtain an ID.
                                <pre>interface IdGenerator...
                                public static final IdGenerator INSTANCE =
                                (IdGenerator) PluginFactory.getPlugin(IdGenerator.class);
                                We can now make that call knowing that weâ€™ll get the right ID for the right
                                environment.
                                class Customer extends DomainObject...
                                private Customer(String name, Long id) {
                                super(id);
                                this.name = name;
                                }
                                public Customer create(String name) {
                                Long newObjId = IdGenerator.INSTANCE.nextId();
                                Customer obj = new Customer(name, newObjId);
                                obj.markNew();
                                return obj;
                                }</pre></p>
                <h3 id="504">Service Stub</h3>
                <p>Removes dependence upon problematic services during testing.
                                Enterprise systems often depend on access to third-party services such as credit
                                scoring, tax rate lookups, and pricing engines. Any developer who has built
                                such a system can speak to the frustration of being dependent on resources
                                completely out of his control. Feature delivery is unpredictable, and as these
                                services are often remote reliability and performance can suffer as well.
                                At the very least these problems slow the development process. Developers
                                sit around waiting for the service to come back on line or maybe put some
                                hacks into the code to compensate for yet to be delivered features. Much worse,
                                and quite likely, such dependencies will lead to times when tests canâ€™t execute.
                                When tests canâ€™t run the development process is broken.
                                Replacing the service during testing with a Service Stub that runs locally,
                                fast, and in memory improves your development experience.</p>
                <h3 id="504(2)">How It Works</h3>
                <p>The first step is to define access to the service with a Gateway (466). The Gateway (466) should not be a class but rather a Separated Interface (476) so you
                                can have one implementation that calls the real service and at least one thatâ€™s
                                only a Service Stub. The desired implementation of the Gateway (466) should
                                be loaded using a Plugin (499). The key to writing a Service Stub is that you
                                keep it as simple as possibleâ€”complexity will defeat your purpose.
                                Letâ€™s walk through the process of stubbing a sales tax service that provides
                                state sales tax amount and rate, given an address, product type, and sales
                                amount. The simplest way to provide a Service Stub is to write two or three
                                lines of code that use a flat tax rate to satisfy all requests.
                                Tax laws arenâ€™t that simple, of course. Certain products are exempt from
                                taxation in certain states, so we rely on our real tax service to know which
                                product and state combinations are tax exempt. However, a lot of our application functionality depends on whether taxes are charged, so we need to accommodate tax exemption in our Service Stub. The simplest means of adding this
                                behavior to the stub is via a conditional statement that exempt a specific combination of address and product and then uses that same data in any relevant
                                test cases. The number of lines of code in our stub can still be counted on one
                                hand.</p>
                <p>A more dynamic Service Stub maintains a list of exempt product and state
                                combinations, allowing test cases to add to it. Even here weâ€™re at about 10 lines
                                of code. Weâ€™re keeping things simple given our aim of speeding the development
                                process.
                                The dynamic Service Stub brings up an interesting question regarding the
                                dependency between it and test cases. The Service Stub relies on a setup method
                                for adding exemptions that isnâ€™t in the original tax service Gateway (466) interface. To take advantage of a Plugin (499) to load the Service Stub, this method
                                must be added to the Gateway (466), which is fine as it doesnâ€™t add much noise
                                to your code and is done in the name of testing. Be sure that the Gateway (466)
                                implementation that calls the real service throws assertion failures within any
                                test methods.</p>
                <h3 id="505">When to Use It</h3>
                <p>Use Service Stub whenever you find that dependence on a particular service is
                                hindering your development and testing.
                                Many practitioners of Extreme Programming use the term Mock Object, for
                                a Service Stub. Weâ€™ve stuck with Service Stub because itâ€™s been around longer.</p>
                <h3 id="505(2)">Example: Sales Tax Service (Java)</h3>
                <p>Our application uses a tax service thatâ€™s deployed as a Web service. The first item
                                weâ€™ll take care of is defining a Gateway (466) so that our domain code isnâ€™t
                                forced to deal with the wonders of Web services. The Gateway (466) is defined
                                as an interface to facilitate loading of any Service Stubs that we write. Weâ€™ll use
                                Plugin (499) to load the correct tax service implementation.
                                <pre>interface TaxService...
                                public static final TaxService INSTANCE =
                                (TaxService) PluginFactory.getPlugin(TaxService.class);
                                public TaxInfo getSalesTaxInfo(String productCode, Address addr, Money saleAmount);
                                The simple flat rate Service Stub would look like this:
                                class FlatRateTaxService implements TaxService...
                                private static final BigDecimal FLAT_RATE = new BigDecimal("0.0500");
                                public TaxInfo getSalesTaxInfo(String productCode, Address addr, Money saleAmount) {
                                return new TaxInfo(FLAT_RATE, saleAmount.multiply(FLAT_RATE));
                                }</pre>
                                Hereâ€™s a Service Stub that provides tax exemptions for a particular address
                                and product combination:
                                <pre>class ExemptProductTaxService implements TaxService...
                                private static final BigDecimal EXEMPT_RATE = new BigDecimal("0.0000");
                                private static final BigDecimal FLAT_RATE = new BigDecimal("0.0500");
                                private static final String EXEMPT_STATE = "IL";
                                private static final String EXEMPT_PRODUCT = "12300";
                                public TaxInfo getSalesTaxInfo(String productCode, Address addr, Money saleAmount) {
                                if (productCode.equals(EXEMPT_PRODUCT) && addr.getStateCode().equals(EXEMPT_STATE)) {
                                return new TaxInfo(EXEMPT_RATE, saleAmount.multiply(EXEMPT_RATE));
                                } else {
                                return new TaxInfo(FLAT_RATE, saleAmount.multiply(FLAT_RATE));
                                }
                                }</pre>
                                Now hereâ€™s a more dynamic Service Stub whose methods allow a test case to
                                add and reset exemption combinations. Once we feel it necessary to add these
                                test methods we need to go back and add these methods to our simpler Service
                                Stubs as well as to the implementation that calls the actual tax Web service. The
                                unused test methods should all throw assertion failures.
                                <pre>class TestTaxService implements TaxService...
                                private static Set exemptions = new HashSet();
                                public TaxInfo getSalesTaxInfo(String productCode, Address addr, Money saleAmount) {
                                BigDecimal rate = getRate(productCode, addr);
                                return new TaxInfo(rate, saleAmount.multiply(rate));
                                }
                                public static void addExemption(String productCode, String stateCode) {
                                exemptions.add(getExemptionKey(productCode, stateCode));
                                }
                                public static void reset() {
                                exemptions.clear();
                                }
                                private static BigDecimal getRate(String productCode, Address addr) {
                                if (exemptions.contains(getExemptionKey(productCode, addr.getStateCode()))) {
                                return EXEMPT_RATE;
                                } else {
                                return FLAT_RATE;
                                }
                                }</pre>
                                Not shown is the implementation that calls the Web service providing our
                                real tax data, to which our production Plugin (499) configuration would link
                                the tax service interface. Our test Plugin (499) configurations would link to the
                                appropriate Service Stub above.
                                Finally, any caller to the tax service must access the service via the Gateway
                                (466). We have a charge generator here that creates standard charges and then
                                calls the tax service in order to create any corresponding taxes.
                                <pre>class ChargeGenerator...
                                public Charge[] calculateCharges(BillingSchedule schedule) {
                                List charges = new ArrayList();
                                Charge baseCharge = new Charge(schedule.getBillingAmount(), false);
                                charges.add(baseCharge);
                                TaxInfo info = TaxService.INSTANCE.getSalesTaxInfo(
                                schedule.getProduct(), schedule.getAddress(), schedule.getBillingAmount());
                                if (info.getStateRate().compareTo(new BigDecimal(0)) > 0) {
                                Charge taxCharge = new Charge(info.getStateAmount(), true);
                                charges.add(taxCharge);
                                }
                                return (Charge[]) charges.toArray(new Charge[charges.size()]);
                                }</pre></p>
                <h3 id="508">Record Set</h3>
                <p>An in-memory representation of tabular data.
                                In the last twenty years, the dominant way to represent data in a database has
                                been the tabular relational form. Backed by database companies big and small,
                                and a fairly standard query language, almost every new development I see uses
                                relational data.
                                On top of this has come a wealth of tools for building UIâ€™s quickly. These
                                data-aware UI frameworks rely on the fact that the underlying data is relational, and they provide UI widgets of various kinds that make it easy to view
                                and manipulate this data with almost no programming.
                                The dark side of these environments is that, while they make display and
                                simple updates ridiculously easy, they have no real facilities in which to place
                                business logic. Any validations beyond â€œis this a valid date,â€ and any business
                                rules or computations have no good place to go. Either theyâ€™re jammed into the
                                database as stored procedures or theyâ€™re mingled with UI code.
                                The idea of the Record Set is to give you your cake and let you eat it, by providing an in-memory structure that looks exactly like the result of an SQL
                                query but can be generated and manipulated by other parts of the system.</p>
                <h3 id="508(2)">How It Works</h3>
                <p>A Record Set is usually something that you wonâ€™t build yourself, provided by
                                the vendor of the software platform youâ€™re working with. Examples include the
                                data set of ADO.NET and the row set of JDBC 2.0.
                                The first essential element of a Record Set is that it looks exactly like the
                                result of a database query. That means you can use the classical two-tier
                                approach of issuing a query and throwing the data directly into a data-aware UI
                                with all the ease that these two-tier tools give you. The second essential element
                                is that you can easily build a Record Set yourself or take one that has resulted
                                from a database query and easily manipulate it with domain logic code.
                                Although platforms often give you a Record Set, you can create one yourself.
                                The problem is that there isnâ€™t that much point without the data-aware UI
                                tools, which you would also need to create yourself. In any case itâ€™s fair to say
                                that building a Record Set structure as a list of maps, which is common in
                                dynamically typed scripting languages, is a good example of this pattern.
                                The ability to disconnect the Record Set from its link to the data source is
                                very valuable. This allows you to pass the Record Set around a network without having to worry about database connections. Furthermore, if you can then
                                easily serialize the Record Set it can also act as a Data Transfer Object (401) for
                                an application.</p>
                <p>Disconnection raises the question of what happens when you update the
                                Record Set. Increasingly platforms are allowing the Record Set to be a form of
                                Unit of Work (184), so you can modify it and then return it to the data source to
                                be committed. A data source can typically use Optimistic Offline Lock (416) to
                                see if there are any conflicts and, if not, write the changes out to the database.
                                Explicit Interface Most Record Set implementations use an implicit interface.
                                This means that to get information out of the Record Set you invoke a generic
                                method with an argument to indicate which field you want. For example, to get
                                the passenger on an airline reservation you use an expression like aReservation["passenger"]. An explicit interface requires a real reservation class with
                                defined methods and properties. With an explicit reservation the expression for
                                a passenger might be aReservation.passenger.
                                Implicit interfaces are flexible in that you can use a generic Record Set for
                                any kind of data. This saves you having to write a new class every time you
                                define a new kind of Record Set. In general, however, I find implicit interfaces
                                to be a Bad Thing. If Iâ€™m programming with a reservation, how do I know how
                                to get the passenger? Is the appropriate string â€œpassengerâ€ or â€œguestâ€ or
                                â€œflyerâ€? The only way I can tell is to wander around the code base trying to find
                                where reservations are created and used. If I have an explicit interface I can
                                look at the definition of the reservation to see what property I need.
                                This problem is exacerbated with statically typed languages. If I want the last
                                name of the passenger, I have to resort to some horrible expression such as ((Person)aReservation["passenger"]).lastName, but then the compiler loses all type information and I have to manually enter it in to get the information I want. An explicit
                                interface can keep the type information so I can use aReservation.passenger.lastName.</p>
                <p>For these reasons, I generally frown on implicit interfaces (and their evil
                                cousin, passing data around in dictionaries). Iâ€™m also not too keen on them with
                                Record Sets, but the saving grace here is that the Record Set usually carries
                                information on the legal columns in it. Furthermore, the column names are
                                defined by the SQL that creates the Record Set, so itâ€™s not too difficult to find
                                the properties when you need them.
                                But itâ€™s nice to go further and have an explicit interface. ADO.NET provides
                                this with its strongly typed data sets, generated classes that provide an explicit
                                and fully typed interface for a Record Set. Since an ADO.NET data set can contain many tables and the relationships between them, strongly typed data sets
                                also provide properties that can use that relationship information. The classes
                                are generated from the XSD data set definition.
                                Implicit interfaces are more common, so Iâ€™ve used untyped data sets in my
                                examples for this book. For production code in ADO.NET, however, I suggest
                                using data sets that are typed. In a non-ADO.NET environment, I suggest using
                                code generation for your own explicit Record Sets.</p>
                <h3 id="510">When to Use It</h3>
                <p>To my mind the value of Record Set comes from having an environment that
                                relies on it as a common way of manipulating data. A lot of UI tools use Record
                                Set, and thatâ€™s a compelling reason to use them yourself. If you have such an
                                environment, you should use Table Module (125) to organize your domain
                                logic: Get a Record Set from the database; pass it to a Table Module (125) to
                                calculate derived information; pass it to a UI for display and editing; and pass it
                                back to a Table Module (125) for validation. Then commit the updates to the
                                database.
                                In many ways the tools that make Record Set so valuable appeared because
                                of the ever-presence of relational databases and SQL and the absence of any
                                real alternative structure and query language. Now, of course, thereâ€™s XML,
                                which has a widely standardized structure and a query language in XPath, and I
                                think itâ€™s likely that weâ€™ll see tools that use a hierarchic structure in the same
                                way that current tools now use Record Set. Perhaps this is actually a particular
                                case of a more generic pattern: something like Generic Data Structure. But Iâ€™ll
                                leave thinking about that pattern until then.
                                511</p>
                <h2 id="511">References</h2>
                <p><pre>[Alexander et al.]
                                Alexander, et al. A Pattern Language. Oxford, 1977.
                                An inspiration for many people in the patterns movement. Iâ€™m less
                                enamored of it than most, but itâ€™s worth looking at to understand an
                                approach that so many draw so much from.
                                [Alpert et al.]
                                Alpert, Brown and Woolf. Design Patterns Smalltalk Companion. AddisonWesley, 1998.
                                Little known outside the Smalltalk community, this book expands and
                                explains many of the classic patterns.
                                [Alur et al.]
                                Alur, Crupi, and Malks. Core J2EE Patterns: Best Practices and Design Strategies. Prentice Hall, 2001.
                                One of the new wave of patterns books that put new life into the form.
                                Although the patterns are expressed specifically for the J2EE platform,
                                most also make sense in other places.
                                [Ambler]
                                http://www.ambysoft.com/mappingObjects.html
                                A useful source of ideas on object-relational mapping.
                                [Beck XP 2000]
                                Beck, Extreme Programming Explained. Addison-Wesley, 2000.
                                The manifesto for Extreme Programming. It should be read by anyone
                                interested in software process.
                                [Beck Patterns]
                                Beck. Smalltalk Best Practice Patterns. Prentice Hall, 1997.
                                Undeservedly little read because of its Smalltalk base. It has more good
                                advice for other OO languages than most books that are specially written
                                for them. The only downside is that you might realize how much we all
                                miss by not programming in Smalltalk.
                                [Beck TDD]
                                Beck. Test-Driven Development: By Example. Addison-Wesley, 2003.
                                Due to be out on the same day as this book. TDD is Kentâ€™s guide to the
                                tight cycle of testing and refactoring that can evolve a design.
                                [Bernstein and Newcomer]
                                Bernstein and Newcomer. Principles of Transaction Processing. Morgan Kaufmann, 1997.
                                An excellent introduction to the head-hurting world of transactions.
                                [Brown et al.]
                                Brown et al. Enterprise Java Programming with IBM Websphere. Addison-Wesley, 2001.
                                Although two-thirds of this book is a software manual, the other third
                                packs more good design advice than do most entire books devoted to the
                                subject.
                                [Brown and Whitenack]
                                http://members.aol.com/kgb1001001/Chasms.htm
                                One of the earliest, and best, papers on object-relational mapping.
                                [Cockburn UC]
                                Cockburn. Writing Effective Use Cases. Addison-Wesley, 2001.
                                By far the best reference on use cases.
                                [Cockburn PloP]
                                Cockburn, â€œPrioritizing Forces in Software Design,â€ in [PLoPD 2].
                                A discussion of application boundaries.
                                REFERENCES 513
                                [Coleman et al.]
                                Coleman, Arnold, and Bodoff. Object-Oriented Development: The Fusion
                                Method, Second Edition. Prentice Hall, 2001.
                                Although much of this pre-UML book is primarily of historic interest, its
                                discussion of the interface model is very helpful to those designing a service
                                layer.
                                [Evans and Fowler]
                                http://martinfowler.com/apsupp/spec.pdf
                                A discussion of the Specification pattern.
                                [Evans]
                                Evans. Domain Driven. Addison Wesley, in preparation.
                                A book on developing domain models. Although I donâ€™t usually like to
                                reference books not yet published, the manuscript promises a fascinating
                                discussion of an important and difficult aspect of enterprise application
                                developments.
                                [Fowler Temporal Patterns]
                                http://martinfowler.com/ap2/timeNarrative.html
                                Patterns dealing with object histories that change over time.
                                [Fowler AP]
                                Fowler. Analysis Patterns. Addison-Wesley, 1997.
                                Domain model patterns.
                                [Fowler Refactoring]
                                Fowler, Refactoring. Addison-Wesley, 1999.
                                A technique for improving the design of an existing code base.
                                [Fowler CI]
                                http://martinfowler.com/articles/continuousIntegration.html
                                An essay that explains how to automatically build software several times a
                                day.
                                514 REFERENCES
                                [Gang of Four]
                                Gamma, Helm, Johnson, and Vlissides. Design Patterns. Addison-Wesley, 1995.
                                The seminal book on patterns.
                                [Hay]
                                Hay. Data Model Patterns. Dorset House, 1995.
                                Patterns of conceptual models from a relational perspective.
                                [Jacobson et al.]
                                Jacobson et al. Object-Oriented Software Engineering. Addison-Wesley, 1992.
                                An early book on OO design; introduces use cases and the interfacecontroller-entity approach to design.
                                [Keller and Coldewey]
                                http://www.objectarchitects.de/ObjectArchitects/orpatterns/index.htm
                                An excellent resource for object-relational mapping.
                                [Kirtland]
                                Kirtland. Designing Component-Based Applications. Microsoft Press, 1998.
                                Description of the DNA architecture.
                                [Knight and Dai]
                                Knight and Dai. â€œObjects and the Web.â€ IEEE Software, March/April 2002.
                                An excellent paper on model view controller, its evolution and use in Web
                                applications.
                                [Larman]
                                Larman. Applying UML and Patterns, Second Edition. Prentice Hall, 2001.
                                Currently my first-choice introduction to OO design.
                                [Lea]
                                Lea. Concurrent Programming in Java, Second Edition. Addison-Wesley, 2000.
                                If you want to program with multiple threads, you need to understand this
                                book first.
                                REFERENCES 515
                                [Marinescu]
                                Marinescu. EJB Design Patterns. New York: John Wiley, 2002.
                                Recent patterns book for Javaâ€™s EJB.
                                [Martin and Odell]
                                Martin and Odell. Object Oriented Methods: A Foundation (UML Edition).
                                Prentice Hall, 1998.
                                Object modeling from a conceptual perspective, as well as investigation
                                into the foundations of what modeling is about.
                                [Nilsson]
                                Nilsson. .NET Enterprise Design with Visual Basic .NET and SQL Server 2000.
                                Sams, 2002.
                                A solid book on architecture for the Microsoft platform.
                                [Peckish]
                                two million (see page 79)
                                [PLoPD 2]
                                Vlissides, Coplien, and Kerth (eds.). Pattern Languages of Program Design 2.
                                Addison-Wesley, 1996.
                                Compendium of patterns papers.
                                [PLoPD 3]
                                Martin, Buschmann, and Rielhe (eds.). Pattern Languages of Program Design 3.
                                Addison-Wesley, 1998.
                                Compendium of patterns papers.
                                [POSA]
                                Buschmann et al. Pattern-Oriented Software Architecture. Wiley, 2000.
                                The best book on broader architectural patterns.
                                [Riehle et al.]
                                Riehle, Siberski, Baumer, Megert, and Zullighoven. â€œSerializer,â€ in [PLoPD 3].
                                In-depth description of serialization of object structures, particularly when
                                you need to serialize into different forms.
                                516 REFERENCES
                                [Schmidt]
                                Schmidt, Stal, Rohnert, and Buschmann. Pattern-Oriented Software Architecture,
                                Volume 2. New York: John Wiley, 2000.
                                Patterns for concurrent and distributed systems. More for people who
                                design application servers than for those who use application servers, but
                                itâ€™s good to have some knowledge of these ideas when you use the results.
                                [Snodgrass]
                                Snodgrass. Developing Time-Oriented Database Applications in SQL. MorganKaufmann, 1999.
                                How to deal with tracking historic information in relational databases.
                                [Struts]
                                http://jakarta.apache.org/struts/
                                A Web presentation framework for Java thatâ€™s growing in popularity.
                                [Waldo et al.]
                                Waldo, Wyant, Wollrath, and Kendall. A Note on Distributed Computing. SMLI
                                TR-94-29, http://research.sun.com/technical-reports/1994/smli_tr-94-29.pdf, Sun
                                Microsystems, 1994.
                                A classic paper on why â€œtransparent distributed objectsâ€ is a dangerous
                                oxymoron.
                                [wiki]
                                http://c2.com/cgi/wiki
                                The original wiki web, developed by Ward Cunningham. A rambling but
                                fascinating open Web site where all sorts of people share all sorts of ideas.
                                [Woolf]
                                Woolf. â€œNull Object,â€ in [PLoPD 3].
                                A description of the Null Object pattern.
                                [Yoder]
                                http://www.joeyoder.com/Research/objectmappings
                                A good source of object-relational patterns.</pre></p>
                <h3 id="517">Index</h3>
                <p><pre>A ACID (atomicity, consistency, isolation, and durability), 71â€“76
                                business and system transactions, 74â€“76
                                reducing transaction isolation for liveness, 73â€“74
                                transactional resources, 72â€“73
                                Active Record, 160â€“64
                                example
                                simple person (Java), 162â€“64
                                how it works, 160â€“61
                                when to use it, 161â€“62
                                ADO.NET data sets, 148â€“51
                                Advice, some technology-specific,
                                100â€“103
                                Java and J2EE, 100â€“101
                                .NET, 101â€“2
                                stored procedures, 102â€“3
                                Web services, 103
                                Affinity, server, 85
                                Albums and tracks (Java), 264â€“67
                                Albums, transferring information about,
                                407â€“11
                                Application Controller, 379â€“86
                                example
                                state model Application Controller
                                (Java), 382â€“86
                                further reading, 382
                                how it works, 380â€“81
                                when to use it, 381â€“82
                                Application Controller, state model,
                                382â€“86
                                Application server concurrency, 78â€“80
                                Applications, evolution of layers in enterprise, 18â€“19
                                Architectural patterns, 33â€“38
                                Architectural patterns, data source,
                                143â€“81
                                Active Record, 160â€“64
                                Data Mapper, 165â€“81
                                Row Data Gateway, 152â€“59
                                Table Data Gateway, 144â€“51
                                ASP.NET server page (C#), 357â€“60
                                Association Table Mapping, 248â€“61
                                examples
                                employees and skills (C#), 250â€“53
                                using direct SQL (Java), 253â€“56
                                using single query for multiple
                                employees (Java), 256â€“61
                                how it works, 248â€“49
                                when to use it, 249
                                B
                                Base patterns, 465â€“510
                                Gateway, 466â€“72
                                Layer Supertype, 475
                                Mapper, 473â€“74
                                Money, 488â€“95
                                Plugin, 499â€“503
                                Record Set, 508â€“10
                                Registry, 480â€“85
                                Separated Interface, 476â€“79
                                Service Stub, 504â€“7
                                Special Case, 496â€“98
                                Value Object, 486â€“87
                                Behavioral patterns, object-relational,
                                183â€“214
                                Identity Map, 195â€“99
                                Lazy Load, 200â€“214
                                Unit of Work, 184â€“94
                                Behavioral problem, 38â€“39
                                Boosters, complexity, 24
                                518 Index
                                Boundaries, working with distribution,
                                91â€“92
                                Brown layers, 104
                                Business and system transactions, 74â€“76
                                Business logic, 20
                                C
                                C#
                                ASP.NET server page, 357â€“60
                                collection of references, 244â€“47
                                concrete players, 296â€“301
                                employees and skills, 250â€“53
                                integral key, 221â€“22
                                page handler with code behind, 340â€“43
                                Person Gateway, 146â€“48
                                players and their kin, 287â€“92
                                revenue recognition with Table Module,
                                129â€“32
                                simple null objects, 498
                                single table for players, 280â€“81
                                using ADO.NET data sets, 148â€“51
                                using ghosts, 206â€“14
                                Web service, 395â€“400
                                Cases, Special, 496â€“98
                                example
                                simple null objects (C#), 498
                                further reading, 497
                                how it works, 497
                                when to use it, 497
                                Class, money, 491â€“95
                                Class Table Inheritance, 285â€“92
                                example
                                players and their kin (C#), 287â€“92
                                further reading, 287
                                how it works, 285â€“86
                                when to use it, 286â€“87
                                Client Session State, 456â€“57
                                how it works, 456â€“57
                                when to use it, 457
                                Coarse-Grained Lock, 438â€“48
                                examples
                                root Optimistic Offline Lock (Java),
                                447â€“48
                                shared Optimistic Offline Lock
                                (Java), 441â€“46
                                shared Pessimistic Offline Lock
                                (Java), 446â€“47
                                how it works, 438â€“41
                                when to use it, 441
                                Committed, read, 73
                                Complexity boosters defined, 24
                                Compound key (Java), 224â€“35
                                Concrete players (C#), 296â€“301
                                Concrete Table Inheritance, 293â€“301
                                example
                                concrete players (C#), 296â€“301
                                how it works, 293â€“95
                                when to use it, 295â€“96
                                Concurrency, 63â€“80
                                application server, 78â€“80
                                application server concurrency, 78â€“80
                                concurrency problems, 64â€“65
                                execution contexts, 65â€“66
                                isolation and immutability, 66â€“67
                                off line, 75
                                offline, 63
                                optimistic and pessimistic concurrency
                                controls, 67â€“71
                                patterns for off line concurrency control, 76â€“78
                                Concurrency controls
                                optimistic and pessimistic, 67â€“71
                                ACID (atomicity, consistency, isolation, and durability), 71â€“76
                                deadlocks, 70â€“71
                                preventing inconsistent reads, 68â€“69
                                transactions, 71
                                patterns for offline, 76â€“78
                                Concurrency patterns, offline, 415â€“53
                                Connections, database, 50â€“52
                                Contexts, execution, 65â€“66
                                Controller, Front, 344â€“49
                                example
                                simple display (Java), 347â€“49
                                further reading, 347
                                how it works, 344â€“46
                                when to use it, 346
                                Controller, Page, 333â€“43
                                examples
                                page handler with code behind (C#),
                                340â€“43
                                simple display with JSP view (Java),
                                335â€“37
                                Index 519
                                simple display with servlet controller
                                (Java), 335â€“37
                                using JSP as handler (Java), 337â€“40
                                how it works, 333â€“34
                                when to use it, 334â€“35
                                Controller patterns, input, 61
                                Controllers
                                simple display with, 335â€“37
                                state model Application, 382â€“86
                                using JSP as view with separate, 355â€“57
                                Controllers, Application, 379â€“86
                                example
                                state model Application Controller
                                (Java), 382â€“86
                                further reading, 382
                                how it works, 380â€“81
                                when to use it, 381â€“82
                                Controls
                                optimistic and pessimistic concurrency,
                                67â€“71
                                ACID (atomicity, consistency, isolation, and durability), 71â€“76
                                deadlocks, 70â€“71
                                preventing inconsistent reads,
                                68â€“69
                                transactions, 71
                                patterns for offline concurrency,
                                76â€“78
                                Correctness, 65
                                Custom tags, JSP and, 374â€“78
                                D
                                Data
                                immutable, 67
                                reading in, 40â€“41
                                record, 83
                                Data holder for domain object (Java),
                                158â€“59
                                Data Mapper, 165â€“81
                                domain layer with, 421â€“25
                                examples
                                creating empty objects (Java), 179â€“81
                                separating finders (Java), 176â€“79
                                simple database mapper (Java),
                                171â€“76
                                how it works, 165â€“70
                                when to use it, 170â€“71
                                Data sets, ADO.NET, 148â€“51
                                Data source
                                architectural patterns, 143â€“81
                                Active Record, 160â€“64
                                Data Mapper, 165â€“81
                                Row Data Gateway, 152â€“59
                                Table Data Gateway, 144â€“51
                                for Domain Models, 98â€“99
                                logic, 20
                                Table Modules, 98
                                for Transaction Scripts, 97â€“98
                                Data source layers, down to, 97â€“100
                                data source for Domain Models, 98â€“99
                                data source for Transaction Scripts,
                                97â€“98
                                data source Table Modules, 98
                                presentation layers, 99â€“100
                                Data Transfer Objects, 401â€“13
                                examples
                                serializing using XML (Java), 411â€“13
                                transferring information about
                                albums (Java), 407â€“11
                                further reading, 407
                                how it works, 401â€“6
                                when to use it, 406
                                Database connections, 50â€“52
                                Database mapper, simple, 171â€“76
                                Database Session State, 462â€“64
                                how it works, 462â€“63
                                when to use it, 464
                                Databases
                                loading objects from, 281â€“84
                                mapping to relational, 33â€“53
                                architectural patterns, 33â€“38
                                behavioral problem, 38â€“39
                                building mapping, 47â€“49
                                database connections, 50â€“52
                                Databases, mapping to relational, continued
                                reading in data, 40â€“41
                                some miscellaneous points, 52â€“53
                                structural mapping patterns, 41â€“47
                                using metadata, 49â€“50
                                Deadlocks, 70â€“71
                                Department hierarchy, serializing, 274â€“77
                                520 Index
                                Dependent Mapping, 262â€“67
                                example
                                albums and tracks (Java), 264â€“67
                                how it works, 262â€“63
                                when to use it, 263â€“64
                                Dependents, finding personâ€™s, 325â€“26
                                Dirty reads, 74
                                Display, simple, 347â€“49
                                Distributed objects, allure of, 87â€“88
                                Distribution boundaries, working with,
                                91â€“92
                                Distribution, interfaces for, 92â€“93
                                Distribution patterns, 387â€“413
                                Data Transfer Objects, 401â€“13
                                Remote Facade, 388â€“400
                                Distribution strategies, 87â€“93
                                allure of distributed objects, 87â€“88
                                interfaces for distribution, 92â€“93
                                remote and local interfaces, 88â€“90
                                where you have to distribute, 90â€“91
                                working with distribution boundaries,
                                91â€“92
                                DNA layers, Microsoft, 105
                                Domain layer with Data Mappers (Java),
                                421â€“25
                                Domain layers, starting with, 96â€“97
                                Domain logic, 20
                                organizing, 25â€“32
                                making choices, 29â€“30
                                Service Layers, 30â€“32
                                patterns, 109â€“41
                                Domain Model, 116â€“24
                                Service Layer, 133â€“41
                                Table Module, 125â€“32
                                Transaction Script, 110â€“15
                                Domain Model, 116â€“24
                                data source for, 98â€“99
                                example
                                revenue recognition (Java),
                                120â€“24
                                further reading, 119â€“20
                                how it works, 116â€“19
                                when to use it, 119
                                Domain objects, data holder for, 158â€“59
                                Domain objects (Java), 475
                                E
                                EAI (Enterprise Application Integration),
                                468
                                Embedded Value, 268â€“71
                                example
                                simple value objects (Java), 270â€“71
                                further reading, 270
                                how it works, 268
                                when to use it, 268â€“69
                                Employees and skills (C#), 250â€“53
                                Employees, using single query for multiple, 256â€“61
                                Enterprise Application Integration (EAI),
                                468
                                Enterprise applications, evolution of layers
                                in, 18â€“19
                                Examples
                                albums and tracks (Java), 264â€“67
                                ASP.NET server page (C#), 357â€“60
                                collection of references (C#), 244â€“47
                                concrete players (C#), 296â€“301
                                data holder for domain object (Java),
                                158â€“59
                                domain objects (Java), 475
                                employees and skills (C#), 250â€“53
                                finding personâ€™s dependents (Java),
                                325â€“26
                                gateway to proprietary messaging service (Java), 468â€“72
                                Id Generator (Java), 501â€“3
                                implicit Pessimistic Offline Lock (Java),
                                451â€“53
                                integral key (C#), 221â€“22
                                lazy initialization (Java), 203
                                methods for Identity Map (Java),
                                198â€“99
                                money class (Java), 491â€“95
                                multitable find (Java}, 243â€“44
                                Person Gateway (C#), 146â€“48
                                person record (Java), 155â€“58
                                players and their kin (C#), 287â€“92
                                revenue recognition (Java), 120â€“24,
                                138â€“41
                                revenue recognition with Table Module
                                (C#), 129â€“32
                                root Optimistic Offline Lock (Java),
                                447â€“48
                                sales tax service (Java), 505â€“7
                                Index 521
                                separating finders (Java), 176â€“79
                                serializing department hierarchy in
                                XML (Java), 274â€“77
                                serializing using XML (Java), 411â€“13
                                shared Optimistic Offline Lock (Java),
                                441â€“46
                                shared Pessimistic Offline Lock (Java),
                                446â€“47
                                simple database mapper (Java), 171â€“76
                                simple display (Java), 347â€“49
                                simple display with servlet controller
                                (Java), 335â€“37
                                simple lock manager (Java), 431â€“37
                                simple null objects (C#), 498
                                simple person (Java), 162â€“64
                                simple Query Object (Java), 318â€“21
                                simple transform (Java), 363â€“64
                                simple value objects (Java), 270â€“71
                                single table for players (C#), 280â€“81
                                single-valued reference (Java), 240â€“43
                                singleton registry (Java), 483â€“84
                                state model Application Controller
                                (Java), 382â€“86
                                swapping Repository strategies (Java),
                                326â€“27
                                thread-safe registry (Java), 484â€“85
                                transferring information about albums
                                (Java), 407â€“11
                                two-stage XSLT (XSLT), 371â€“74
                                Unit of Work with object registration
                                (Java), 190â€“94
                                using ADO.NET data sets (C#),
                                148â€“51
                                using compound key (Java), 224â€“35
                                using direct SQL (Java), 253â€“56
                                using ghosts (C#), 206â€“14
                                using Java session been as Remote
                                Facade (Java), 392â€“95
                                using JSP as handler (Java), 337â€“40
                                using key table (Java), 222â€“24
                                using metadata and reflection(Java),
                                309â€“15
                                using single query for multiple employees (Java), 256â€“61
                                using value holder (Java), 205â€“6
                                virtual proxy (Java), 203â€“5
                                Web service (C#), 395â€“400
                                Execution contexts, 65â€“66
                                F
                                Facade, Remote, 388â€“400
                                examples
                                using Java session been as Remote
                                Facade (Java), 392â€“95
                                Web service (C#), 395â€“400
                                how it works, 389â€“92
                                when to use it, 392
                                Fields, Identity, 216â€“35
                                examples
                                integral key (C#), 221â€“22
                                using compound key (Java), 224â€“35
                                using key table (Java), 222â€“24
                                further reading, 221
                                how it works, 216â€“20
                                when to use it, 220â€“21
                                Find, multitable, 243â€“44
                                Finders, separating, 176â€“79
                                Foreign Key Mapping, 236â€“47
                                examples
                                collection of references (C#), 244â€“47
                                multitable find (Java}, 243â€“44
                                single-valued reference (Java),
                                240â€“43
                                how it works, 236â€“39
                                when to use it, 239â€“40
                                Front Controller, 344â€“49
                                example
                                simple display (Java), 347â€“49
                                further reading, 347
                                how it works, 344â€“46
                                when to use it, 346
                                G
                                Gateway, 466â€“72
                                example
                                gateway to proprietary messaging service (Java), 468â€“72
                                how it works, 466â€“67
                                Gateway, continued
                                Person, 146â€“48
                                when to use it, 467â€“68
                                Gateway, Row Data, 152â€“59
                                examples
                                data holder for domain object (Java),
                                158â€“59
                                522 Index
                                person record (Java), 155â€“58
                                how it works, 152â€“53
                                when to use it, 153â€“55
                                Gateway, Table Data, 144â€“51
                                examples
                                Person Gateway (C#), 146â€“48
                                using ADO.NET data sets (C#),
                                148â€“51
                                further reading, 146
                                how it works, 144â€“45
                                when to use it, 145â€“46
                                Gateway to proprietary messaging service
                                (Java), 468â€“72
                                Generator, Id, 501â€“3
                                Ghosts, 202, 206â€“14
                                Globally Unique IDentifier (GUID), 219
                                GUID (Globally Unique IDentifier), 219
                                H
                                Handlers
                                page, 340â€“43
                                using JSP as, 337â€“40
                                Hierarchy, serializing department, 274â€“77
                                Holder, using value, 205â€“6
                                I
                                Id Generator (Java), 501â€“3
                                Identity Field, 216â€“35
                                examples
                                integral key (C#), 221â€“22
                                using compound key (Java), 224â€“35
                                using key table (Java), 222â€“24
                                further reading, 221
                                how it works, 216â€“20
                                when to use it, 220â€“21
                                Identity Map, 195â€“99
                                example
                                methods for Identity Map (Java),
                                198â€“99
                                how it works, 195â€“97
                                methods for, 198â€“99
                                when to use it, 198
                                Immutability, isolation and, 66â€“67
                                Immutable data, 67
                                Implicit Lock, 449â€“53
                                example
                                implicit Pessimistic Offline Lock
                                (Java), 451â€“53
                                how it works, 450â€“51
                                when to use it, 451
                                Implicit Pessimistic Offline Lock (Java),
                                451â€“53
                                Inconsistent reads, 64
                                preventing, 68â€“69
                                Inheritance, 45â€“47
                                Inheritance, Class Table, 285â€“92
                                example
                                players and their kin (C#), 287â€“92
                                further reading, 287
                                how it works, 285â€“86
                                when to use it, 286â€“87
                                Inheritance, Concrete Table, 293â€“301
                                example
                                concrete players (C#), 296â€“301
                                how it works, 293â€“95
                                when to use it, 295â€“96
                                Inheritance Mappers, 302â€“4
                                how it works, 303â€“4
                                when to use it, 304
                                Inheritance, Single Table
                                example
                                single table for players (C#), 280â€“81
                                how it works, 278â€“79
                                loading objects from databases, 281â€“84
                                when to use it, 279â€“80
                                Initialization, lazy, 203
                                Input controller patterns, 61
                                Integral key (C#), 221â€“22
                                Interfaces
                                for distribution, 92â€“93
                                remote and local, 88â€“90
                                Separated, 476â€“79
                                how it works, 477â€“78
                                when to use it, 478â€“79
                                Isolated threads, 66
                                Isolation
                                and immutability, 66â€“67
                                reducing transaction for liveness,
                                73â€“74
                                J
                                J2EE, Java and, 100â€“101
                                J2EE layers, core, 104
                                Index 523
                                Java
                                albums and tracks, 264â€“67
                                creating empty objects, 179â€“81
                                data holder for domain object, 158â€“59
                                domain layer with Data Mappers,
                                421â€“25
                                domain objects, 475
                                finding personâ€™s dependents, 325â€“26
                                gateway to proprietary messaging service, 468â€“72
                                Id Generator, 501â€“3
                                and J2EE, 100â€“101
                                JSP and custom tags, 374â€“78
                                methods for Identity Map, 198â€“99
                                money class, 491â€“95
                                multitable find, 243â€“44
                                person record, 155â€“58
                                revenue recognition, 113â€“15, 120â€“24,
                                138â€“41
                                root Optimistic Offline Lock, 447â€“48
                                sales tax service, 505â€“7
                                separating finders, 176â€“79
                                serializing department hierarchy in
                                XML, 274â€“77
                                serializing using XML, 411â€“13
                                shared Optimistic Offline Lock, 441â€“46
                                shared Pessimistic Offline Lock, 446â€“47
                                simple database mapper, 171â€“76
                                simple display, 347â€“49
                                simple display with JSP view, 335â€“37
                                simple display with servlet controller,
                                335â€“37
                                simple person, 162â€“64
                                simple Query Object, 318â€“21
                                simple transform, 363â€“64
                                simple value objects, 270â€“71
                                single-valued reference (Java),
                                240â€“43
                                singleton registry, 483â€“84
                                state model Application Controller,
                                382â€“86
                                swapping Repository strategies,
                                326â€“27
                                thread-safe registry, 484â€“85
                                transferring information about albums,
                                407â€“11
                                Unit of Work with object registration,
                                190â€“94
                                using compound key, 224â€“35
                                using direct SQL, 253â€“56
                                using Java session bean as Remote
                                Facade, 392â€“95
                                using JSP as handler, 337â€“40
                                using JSP as view with separate controller, 355â€“57
                                using key table, 222â€“24
                                using metadata and reflection,
                                309â€“15
                                using single query for multiple employees, 256â€“61
                                using value holder, 205â€“6
                                Java session bean, using as Remote Facade
                                (Java), 392â€“95
                                JSP
                                using as handler, 337â€“40
                                using as view, 355â€“57
                                JSP and custom tags (Java), 374â€“78
                                JSP view, simple display with, 335â€“37
                                K
                                Key Mapping, Foreign, 236â€“47
                                Key table, 222â€“24
                                Keys
                                compound, 224â€“35
                                integral, 221â€“22
                                Kin, players and their, 287â€“92
                                L
                                Late transactions, 72
                                Layer Supertype, 475
                                example
                                domain objects (Java), 475
                                how it works, 475
                                when to use it, 475
                                Layering, 17â€“24
                                choosing to run your layers, 22â€“24
                                evolution of layers in enterprise applications, 18â€“19
                                schemes, 103â€“6
                                three principal layers, 19â€“22
                                Layers
                                Brown, 104
                                choosing to run your, 22â€“24
                                524 Index
                                core J2EE, 104
                                down to data source, 97â€“100
                                data source for Domain Models,
                                98â€“99
                                data source for Transaction Scripts,
                                97â€“98
                                data source Table Modules, 98
                                presentation layers, 99â€“100
                                Marinescu, 105
                                Microsoft DNA, 105
                                Nilsson, 106
                                presentation, 99â€“100
                                Service, 30â€“32
                                starting with domain, 96â€“97
                                three principal, 19â€“22
                                Layers, evolution of, 18â€“19
                                Layers, Service, 133â€“41
                                example
                                revenue recognition (Java), 138â€“41
                                further reading, 137
                                how it works, 134â€“37
                                when to use it, 137
                                Lazy initialization (Java), 203
                                Lazy Load, 200â€“214
                                examples
                                lazy initialization (Java), 203
                                using ghosts (C#), 206â€“14
                                using value holder (Java), 205â€“6
                                virtual proxy (Java), 203â€“5
                                how it works, 200â€“203
                                when to use it, 203
                                Liveness, 65
                                reducing transactions isolation for,
                                73â€“74
                                Load, Lazy, 200â€“214
                                examples
                                lazy initialization (Java), 203
                                using ghosts (C#), 206â€“14
                                using value holder (Java), 205â€“6
                                virtual proxy (Java), 203â€“5
                                how it works, 200â€“203
                                when to use it, 203
                                Loading, ripple, 202
                                LOBs (large objects), serialized, 272â€“77
                                example
                                serializing department hierarchy in
                                XML (Java), 274â€“77
                                how it works, 272â€“73
                                when to use it, 274
                                Local interfaces, remote and, 88â€“90
                                Lock manager, simple, 431â€“37
                                Locking
                                optimistic, 67
                                pessimistic, 67
                                Locks
                                root Optimistic Offline, 447â€“48
                                shared Optimistic Offline, 441â€“46
                                shared Pessimistic Offline, 446â€“47
                                Locks, Coarse-Grained, 438â€“48
                                examples
                                root Optimistic Offline Lock (Java),
                                447â€“48
                                shared Optimistic Offline Lock
                                (Java), 441â€“46
                                shared Pessimistic Offline Lock
                                (Java), 446â€“47
                                how it works, 438â€“41
                                when to use it, 441
                                Locks, Implicit, 449â€“53
                                example
                                implicit Pessimistic Offline Lock
                                (Java), 451â€“53
                                how it works, 450â€“51
                                when to use it, 451
                                Locks, implicit Pessimistic Offline, 451â€“53
                                Locks, Optimistic Offline, 416â€“25
                                example
                                domain layer with Data Mappers
                                (Java), 421â€“25
                                how it works, 417â€“20
                                when to use it, 420â€“21
                                Locks, Pessimistic Offline, 426â€“37
                                example
                                simple lock manager (Java),
                                431â€“37
                                how it works, 427â€“31
                                when to use it, 431
                                Logic
                                business, 20
                                data source, 20
                                domain, 20
                                organizing domain, 25â€“32
                                making choices, 29â€“30
                                Service Layers, 30â€“32
                                Index 525
                                presentation, 19â€“20
                                Logic patterns, domain, 109â€“41
                                Domain Model, 116â€“24
                                Service Layer, 133â€“41
                                Table Module, 125â€“32
                                Transaction Script, 110â€“15
                                Long transactions, 72
                                Lost updates, 64
                                M
                                Manager, simple lock, 431â€“37
                                Map, Identity, 195â€“99
                                example
                                methods for Identity Map (Java),
                                198â€“99
                                how it works, 195â€“97
                                when to use it, 198
                                Mapper, 473â€“74
                                how it works, 473
                                when to use it, 474
                                Mapper, Data, 165â€“81
                                examples
                                creating empty objects (Java), 179â€“81
                                separating finders (Java), 176â€“79
                                simple database mapper (Java),
                                171â€“76
                                how it works, 165â€“70
                                when to use it, 170â€“71
                                Mapper, simple database, 171â€“76
                                Mappers, domain layer with Data,
                                421â€“25
                                Mappers, Inheritance, 302â€“4
                                how it works, 303â€“4
                                when to use it, 304
                                Mapping, Association Table, 248â€“61
                                examples
                                employees and skills (C#), 250â€“53
                                using direct SQL (Java), 253â€“56
                                using single query for multiple
                                employees (Java), 256â€“61
                                how it works, 248â€“49
                                when to use it, 249
                                Mapping, building, 47â€“49
                                Mapping, Dependent, 262â€“67
                                example
                                albums and tracks (Java), 264â€“67
                                how it works, 262â€“63
                                when to use it, 263â€“64
                                Mapping, Foreign Key, 236â€“47
                                examples
                                collection of references (C#),
                                244â€“47
                                multitable find (Java}, 243â€“44
                                single-valued reference (Java),
                                240â€“43
                                how it works, 236â€“39
                                when to use it, 239â€“40
                                Mapping, Metadata
                                example
                                using metadata and reflection(Java),
                                309â€“15
                                how it works, 306â€“8
                                when to use it, 308â€“9
                                Mapping patterns
                                object-relational metadata, 305â€“27
                                Metadata Mapping, 306â€“15
                                Query Object, 316â€“21
                                Repository, 322â€“27
                                structural, 41â€“47
                                inheritance, 45â€“47
                                mapping relationships, 41â€“45
                                Mapping relationships, 41â€“45
                                Mapping to relational databases, 33â€“53
                                architectural patterns, 33â€“38
                                behavioral problem, 38â€“39
                                building mapping, 47â€“49
                                database connections, 50â€“52
                                reading in data, 40â€“41
                                some miscellaneous points, 52â€“53
                                structural mapping patterns, 41â€“47
                                using metadata, 49â€“50
                                Marinescu layers, 105
                                Messaging service, gateway to, 468â€“72
                                Metadata and reflection, using, 309â€“15
                                Metadata Mapping, 306â€“15
                                example
                                using metadata and reflection (Java),
                                309â€“15
                                Metadata Mapping, continued
                                how it works, 306â€“8
                                when to use it, 308â€“9
                                Metadata mapping patterns, objectrelational, 305â€“27
                                Metadata Mapping, 306â€“15
                                Query Object, 316â€“21
                                526 Index
                                Repository, 322â€“27
                                Metadata, using, 49â€“50
                                Microsoft DNA layers, 105
                                Migration, session, 85
                                Model, Domain, 116â€“24
                                example
                                revenue recognition (Java), 120â€“24
                                further reading, 119â€“20
                                how it works, 116â€“19
                                when to use it, 119
                                Model View Controller (MVC), 330â€“32
                                Models, data source for Domain, 98â€“99
                                Modules, data source Table, 98
                                Modules, Table, 125â€“32
                                example
                                revenue recognition with Table
                                Module (C#), 129â€“32
                                how it works, 126â€“28
                                when to use it, 128
                                Money, 488â€“95
                                example
                                money class (Java), 491â€“95
                                how it works, 488â€“90
                                when to use it, 490â€“91
                                Money class (Java), 491â€“95
                                Multiple employees, using single query for,
                                256â€“61
                                Multitable find (Java), 243â€“44
                                MVC (Model View Controller), 330â€“32
                                how it works, 330â€“32
                                when to use it, 332
                                N
                                .NET, 101â€“2
                                Nilsson layers, 106
                                Null objects, simple, 498
                                O
                                Object registration, 186
                                Object registration, Unit of Work with,
                                190â€“94
                                Object-relational behavioral patterns,
                                183â€“214
                                Identity Map, 195â€“99
                                Lazy Load, 200â€“214
                                Unit of Work, 184â€“94
                                Object-relational metadata mapping patterns, 305â€“27
                                Metadata Mapping, 306â€“15
                                Query Object, 316â€“21
                                Repository, 322â€“27
                                Object-relational structural patterns,
                                215â€“84
                                Association Table Mapping, 248â€“61
                                Class Table Inheritance, 285â€“92
                                Concrete Table Inheritance, 293â€“301
                                Dependent Mapping, 262â€“67
                                Embedded Value, 268â€“71
                                Foreign Key Mapping, 236â€“47
                                Identity Field, 216â€“35
                                Inheritance Mappers, 302â€“4
                                serialized LOBs (large objects), 272â€“77
                                Single Table Inheritance, 278â€“84
                                Object, simple Query, 318â€“21
                                Objects
                                allure of distributed, 87â€“88
                                creating empty, 179â€“81
                                domain, 475
                                loading from databases, 281â€“84
                                simple null, 498
                                simple value, 270â€“71
                                Objects, Data Transfer, 401â€“13
                                examples
                                serializing using XML (Java), 411â€“13
                                transferring information about
                                albums (Java), 407â€“11
                                further reading, 407
                                how it works, 401â€“6
                                when to use it, 406
                                Objects, Query, 316â€“21
                                example
                                simple Query Object (Java), 318â€“21
                                further reading, 318
                                how it works, 316â€“17
                                when to use it, 317â€“18
                                Objects, Value, 486â€“87
                                how it works, 486â€“87
                                when to use it, 487
                                Offline concurrency, 63, 75
                                Offline concurrency control, patterns for,
                                76â€“78
                                Offline concurrency patterns, 415â€“53
                                Coarse-Grained Lock, 438â€“48
                                Implicit Lock, 449â€“53
                                Optimistic Offline Lock, 416â€“25
                                Pessimistic Offline Lock, 426â€“37
                                Offline Lock, implicit Pessimistic, 451â€“53
                                Index 527
                                Offline Lock, Optimistic, 416â€“25
                                example
                                domain layer with Data Mappers
                                (Java), 421â€“25
                                how it works, 417â€“20
                                when to use it, 420â€“21
                                Offline Lock, Pessimistic, 426â€“37
                                example
                                simple lock manager (Java), 431â€“37
                                how it works, 427â€“31
                                when to use it, 431
                                Offline Lock, root Optimistic, 447â€“48
                                Offline Lock, shared Optimistic, 441â€“46
                                Offline Lock, shared Pessimistic, 446â€“47
                                Optimistic and pessimistic concurrency
                                controls, 67â€“71
                                Optimistic locking, 67
                                Optimistic Offline Lock, 416â€“25
                                example
                                domain layer with Data Mappers
                                (Java), 421â€“25
                                how it works, 417â€“20
                                root, 447â€“48
                                shared, 441â€“46
                                when to use it, 420â€“21
                                P
                                Page Controller, 333â€“43
                                examples
                                page handler with code behind (C#),
                                340â€“43
                                simple display with JSP view (Java),
                                335â€“37
                                simple display with servlet controller
                                (Java), 335â€“37
                                using JSP as handler (Java), 337â€“40
                                how it works, 333â€“34
                                when to use it, 334â€“35
                                Page handler with code behind,
                                340â€“43
                                Patterns
                                architectural, 33â€“38
                                base, 465â€“510
                                Gateway, 466â€“72
                                Layer Supertype, 475
                                Mapper, 473â€“74
                                Money, 488â€“95
                                Plugin, 499â€“503
                                Record Set, 508â€“10
                                Registry, 480â€“85
                                Separated Interface, 476â€“79
                                Service Stub, 504â€“7
                                Special Case, 496â€“98
                                Value Object, 486â€“87
                                data source architectural, 143â€“81
                                Active Record, 160â€“64
                                Data Mapper, 165â€“81
                                Row Data Gateway, 152â€“59
                                Table Data Gateway, 144â€“51
                                distribution, 387â€“413
                                Data Transfer Objects, 401â€“13
                                Remote Facade, 388â€“400
                                domain logic, 109â€“41
                                input controller, 61
                                mapping structural, 41â€“47
                                inheritance, 45â€“47
                                mapping relationships, 41â€“45
                                object-relational behavioral, 183â€“214
                                Identity Map, 195â€“99
                                Lazy Load, 200â€“214
                                Unit of Work, 184â€“94
                                object-relational metadata mapping,
                                305â€“27
                                Metadata Mapping, 306â€“15
                                Query Object, 316â€“21
                                Repository, 322â€“27
                                object-relational structural, 215â€“84
                                Association Table Mapping, 248â€“61
                                Class Table Inheritance, 285â€“92
                                Concrete Table Inheritance, 293â€“301
                                Dependent Mapping, 262â€“67
                                Embedded Value, 268â€“71
                                Foreign Key Mapping, 236â€“47
                                Identity Field, 216â€“35
                                Inheritance Mappers, 302â€“4
                                Serialized LOBs (large objects),
                                272â€“77
                                Single Table Inheritance, 278â€“84
                                Patterns, continued
                                offline concurrency, 415â€“53
                                Coarse-Grained Lock, 438â€“48
                                Implicit Lock, 449â€“53
                                Optimistic Offline Lock, 416â€“25
                                Pessimistic Offline Lock, 426â€“37
                                session state, 455â€“64
                                Client Session State, 456â€“57
                                Database Session State, 462â€“64
                                528 Index
                                Server Session State, 458â€“61
                                view, 58â€“60
                                Web presentation, 329â€“86
                                Application Controller, 379â€“86
                                Front Controller, 344â€“49
                                MVC (Model View Controller),
                                330â€“32
                                Page Controller, 333â€“43
                                Template View, 350â€“60
                                Transform View, 361â€“64
                                Two Step View, 365â€“78
                                Person Gateway (C#), 146â€“48
                                Person record (Java), 155â€“58
                                Person, simple, 162â€“64
                                Personâ€™s dependents, finding, 325â€“26
                                Pessimistic concurrency controls, optimistic and, 67â€“71
                                Pessimistic locking, 67
                                Pessimistic Offline Lock, 426â€“37
                                example
                                simple lock manager (Java),
                                431â€“37
                                how it works, 427â€“31
                                implicit, 451â€“53
                                shared, 446â€“47
                                when to use it, 431
                                Phantoms, 73
                                Plain old Java objects (POJOs), 392
                                Players
                                concrete, 296â€“301
                                single table for, 280â€“81
                                Players and their kin (C#), 287â€“92
                                Plugin, 499â€“503
                                example
                                Id Generator (Java), 501â€“3
                                how it works, 499â€“500
                                when to use it, 500
                                POJOs (plain old Java objects), 392
                                Presentation
                                layers, 99â€“100
                                logic, 19â€“20
                                Web, 55â€“61
                                Presentation patterns, Web, 329â€“86
                                Application Controller, 379â€“86
                                Front Controller, 344â€“49
                                MVC (Model View Controller), 330â€“32
                                Page Controller, 333â€“43
                                Template View, 350â€“60
                                Transform View, 361â€“64
                                Two Step View, 365â€“78
                                Problems
                                behavioral, 38â€“39
                                concurrency, 64â€“65
                                Procedures, stored, 102â€“3
                                Process-per-request, 78
                                Process-per-session, 78
                                Processes defined, 66
                                Proxy, virtual, 203â€“5
                                Putting it all together, 95â€“106
                                down to data source layers, 97â€“100
                                miscellaneous layering schemes, 103â€“6
                                some technology-specific advice,
                                100â€“103
                                starting with domain layers, 96â€“97
                                Q
                                Query Object, 316â€“21
                                example
                                simple Query Object (Java), 318â€“21
                                further reading, 318
                                how it works, 316â€“17
                                when to use it, 317â€“18
                                Query Object, simple, 318â€“21
                                Query, using single, 256â€“61
                                R
                                Read
                                inconsistent, 64
                                repeatable, 73
                                Read committed, 73
                                Read uncommitted, 74
                                Reads
                                dirty, 74
                                preventing inconsistent, 68â€“69
                                Temporal, 69
                                unrepeatable, 73
                                Record data, 83
                                Record Set, 508â€“10
                                how it works, 508â€“10
                                when to use it, 510
                                Records, Active, 160â€“64
                                example
                                simple person (Java), 162â€“64
                                how it works, 160â€“61
                                when to use it, 161â€“62
                                Index 529
                                References
                                collection of, 244â€“47
                                single-valued, 240â€“43
                                Reflection, using metadata and,
                                309â€“15
                                Registration
                                object, 186
                                Unit of Work with object, 190â€“94
                                Registry, 480â€“85
                                examples
                                singleton registry (Java), 483â€“84
                                thread-safe registry (Java), 484â€“85
                                how it works, 480â€“82
                                singleton, 483â€“84
                                thread-safe, 484â€“85
                                when to use it, 482â€“83
                                Relational databases, mapping to,
                                33â€“53
                                architectural patterns, 33â€“38
                                behavioral problem, 38â€“39
                                building mapping, 47â€“49
                                database connections, 50â€“52
                                reading in data, 40â€“41
                                some miscellaneous points, 52â€“53
                                structural mapping patterns, 41â€“47
                                using metadata, 49â€“50
                                Relationships, mapping, 41â€“45
                                Remote and local interfaces, 88â€“90
                                Remote Facade, 388â€“400
                                examples
                                using Java session been as Remote
                                Facade (Java), 392â€“95
                                Web service (C#), 395â€“400
                                how it works, 389â€“92
                                when to use it, 392
                                Remote Facade, using Java session bean
                                as, 392â€“95
                                Repeatable read, 73
                                Repository, 322â€“27
                                examples
                                finding personâ€™s dependents (Java),
                                325â€“26
                                swapping Repository strategies
                                (Java), 326â€“27
                                further reading, 325
                                how it works, 323â€“24
                                when to use it, 324â€“25
                                Repository strategies, swapping, 326â€“27
                                Request transactions, 72
                                Requests, 65
                                Resources, transactional, 72â€“73
                                Revenue recognition (Java), 113â€“15,
                                120â€“24
                                Revenue recognition problem, 112â€“13
                                Revenue recognition with Table Module
                                (C#), 129â€“32
                                Ripple loading, 202
                                Root Optimistic Offline Lock (Java),
                                447â€“48
                                Row Data Gateway, 152â€“59
                                examples
                                data holder for domain object (Java),
                                158â€“59
                                person record (Java), 155â€“58
                                how it works, 152â€“53
                                when to use it, 153â€“55
                                S
                                Safety, 65
                                Sales tax service (Java), 505â€“7
                                Schemes, miscellaneous layering, 103â€“6
                                SCM (source code management), 420
                                Scripts, data source for Transaction,
                                97â€“98
                                Scripts, Transaction, 110â€“15
                                example
                                revenue recognition (Java), 113â€“15
                                how it works, 110â€“11
                                revenue recognition problem, 112â€“13
                                when to use it, 111â€“12
                                Separate controller, using JSP as view
                                with, 355â€“57
                                Separated Interface, 476â€“79
                                how it works, 477â€“78
                                when to use it, 478â€“79
                                Serializable, transactions are, 73
                                Serialized LOBs (large objects), 272â€“77
                                example
                                serializing department hierarchy in
                                XML (Java), 274â€“77
                                how it works, 272â€“73
                                when to use it, 274
                                Serializing using XML (Java), 411â€“13
                                Server affinity, 85
                                Server concurrency, application, 78â€“80
                                530 Index
                                Server page, ASP.NET, 357â€“60
                                Server Session State, 458â€“61
                                how it works, 458â€“60
                                when to use it, 460â€“61
                                Servers, stateless, 81
                                Service Layer, 30â€“32, 133â€“41
                                example
                                revenue recognition (Java), 138â€“41
                                further reading, 137
                                how it works, 134â€“37
                                when to use it, 137
                                Service Stub, 504â€“7
                                example
                                sales tax service (Java), 505â€“7
                                how it works, 504â€“5
                                when to use it, 505
                                Services, gateway to proprietary messaging, 468â€“72
                                Services, Web, 103, 395â€“400
                                Servlet controller, simple display with,
                                335â€“37
                                Session migration, 85
                                Session state, 81, 83â€“86
                                Session State
                                Client, 456â€“57
                                how it works, 456â€“57
                                when to use it, 457
                                Database, 462â€“64
                                how it works, 462â€“63
                                when to use it, 464
                                Server, 458â€“61
                                how it works, 458â€“60
                                when to use it, 460â€“61
                                Session state
                                value of statelessness, 81â€“83
                                ways to store, 84â€“86
                                ways to store session state, 84â€“86
                                Session state patterns, 455â€“64
                                Client Session State, 456â€“57
                                Database Session State, 462â€“64
                                Server Session State, 458â€“61
                                Sessions defined, 66
                                Shared Optimistic Offline Lock (Java),
                                441â€“46
                                Shared Pessimistic Offline Lock (Java),
                                446â€“47
                                Simple display (Java), 347â€“49
                                Simple person (Java), 162â€“64
                                Simple transform (Java), 363â€“64
                                Single Table Inheritance
                                example
                                single table for players (C#),
                                280â€“81
                                how it works, 278â€“79
                                loading objects from databases,
                                281â€“84
                                when to use it, 279â€“80
                                Singleton registry (Java), 483â€“84
                                Skills, employees and, 250â€“53
                                Source code management (SCM), 420
                                Source layers, down to data, 97â€“100
                                Special Case, 496â€“98
                                example
                                simple null objects (C#), 498
                                further reading, 497
                                how it works, 497
                                when to use it, 497
                                SQL, using direct, 253â€“56
                                State
                                session, 81, 83â€“86
                                ways to store session, 84â€“86
                                State model Application Controller (Java),
                                382â€“86
                                Stateless servers, 81
                                Stored procedures, 102â€“3
                                Strategies
                                distribution, 87â€“93
                                allure of distributed objects, 87â€“88
                                interfaces for distribution, 92â€“93
                                remote and local interfaces, 88â€“90
                                where you have to distribute, 90â€“91
                                working with distribution boundaries, 91â€“92
                                swapping Repository, 326â€“27
                                Structural mapping patterns., 41â€“47
                                inheritance, 45â€“47
                                mapping relationships, 41â€“45
                                Structural patterns, object-relational,
                                215â€“84
                                Association Table Mapping, 248â€“61
                                Class Table Inheritance, 285â€“92
                                Concrete Table Inheritance, 293â€“301
                                Dependent Mapping, 262â€“67
                                Embedded Value, 268â€“71
                                Index 531
                                Foreign Key Mapping, 236â€“47
                                Identity Field, 216â€“35
                                Inheritance Mappers, 302â€“4
                                serialized LOBs (large objects),
                                272â€“77
                                Single Table Inheritance, 278â€“84
                                Stub, Service, 504â€“7
                                example
                                sales tax service (Java), 505â€“7
                                how it works, 504â€“5
                                when to use it, 505
                                System transactions, business and,
                                74â€“76
                                T
                                Table Data Gateway, 144â€“51
                                examples
                                Person Gateway (C#), 146â€“48
                                using ADO.NET data sets (C#),
                                148â€“51
                                further reading, 146
                                how it works, 144â€“45
                                when to use it, 145â€“46
                                Table Inheritance, Class, 285â€“92
                                Table Inheritance, Concrete, 293â€“301
                                example
                                concrete players (C#), 296â€“301
                                how it works, 293â€“95
                                when to use it, 295â€“96
                                Table Inheritance, Single
                                example
                                single table for players (C#),
                                280â€“81
                                how it works, 278â€“79
                                loading objects from databases,
                                281â€“84
                                when to use it, 279â€“80
                                Table Mapping, Association, 248â€“61
                                examples
                                employees and skills (C#), 250â€“53
                                using direct SQL (Java), 253â€“56
                                using single query for multiple
                                employees (Java), 256â€“61
                                how it works, 248â€“49
                                when to use it, 249
                                Table Modules, 125â€“32
                                data source, 98
                                example
                                revenue recognition with Table
                                Module (C#), 129â€“32
                                how it works, 126â€“28
                                when to use it, 128
                                Tables, key, 222â€“24
                                Tags, JSP and custom, 374â€“78
                                Tax service, sales, 505â€“7
                                Technology-specific advice, some,
                                100â€“103
                                Java and J2EE, 100â€“101
                                .NET, 101â€“2
                                stored procedures, 102â€“3
                                Web services, 103
                                Template View, 350â€“60
                                examples
                                ASP.NET server page (C#),
                                357â€“60
                                using JSP as view with separate controller (Java), 355â€“57
                                how it works, 351â€“54
                                when to use it, 354â€“55
                                Temporal Reads, 69
                                Thread-safe registry (Java), 484â€“85
                                Threads
                                defined, 66
                                isolated, 66
                                Together, putting it all, 95â€“106
                                down to data source layers, 97â€“100
                                miscellaneous layering schemes,
                                103â€“6
                                some technology-specific advice,
                                100â€“103
                                starting with domain layers, 96â€“97
                                Tracks, albums and, 264â€“67
                                Transaction isolation, reducing for liveness, 73â€“74
                                Transaction Script, 110â€“15
                                example
                                revenue recognition (Java), 113â€“15
                                how it works, 110â€“11
                                revenue recognition problem, 112â€“13
                                when to use it, 111â€“12
                                Transaction Scripts, data source for,
                                97â€“98
                                Transactional resources, 72â€“73
                                Transactions, 66, 71
                                business and system, 74â€“76
                                532 Index
                                late, 72
                                long, 72
                                request, 72
                                system, 74â€“76
                                Transform, simple, 363â€“64
                                Transform View, 361â€“64
                                example
                                simple transform (Java), 363â€“64
                                when to use it, 362â€“63
                                Two-stage XSLT (XSLT), 371â€“74
                                Two Step View, 365â€“78
                                examples
                                JSP and custom tags (Java), 374â€“78
                                two-stage XSLT (XSLT), 371â€“74
                                how it works, 365â€“67
                                when to use it, 367â€“71
                                U
                                Uncommitted, read, 74
                                Unit of Work, 184â€“94
                                example
                                Unit of Work with object registration
                                (Java), 190â€“94
                                how it works, 184â€“89
                                when to use it, 189â€“90
                                Unit of Work with object registration
                                (Java), 190â€“94
                                Unrepeatable reads, 73
                                Updates, lost, 64
                                V
                                Value holder, using, 205â€“6
                                Value Object, 486â€“87
                                how it works, 486â€“87
                                when to use it, 487
                                Value objects, simple, 270â€“71
                                Values, Embedded, 268â€“71
                                example
                                simple value objects (Java), 270â€“71
                                further reading, 270
                                how it works, 268
                                when to use it, 268â€“69
                                View patterns, 58â€“60
                                View, simple display with JSP, 335â€“37
                                Views, Template, 350â€“60
                                examples
                                ASP.NET server page (C#),
                                357â€“60
                                using JSP as view with separate controller (Java), 355â€“57
                                how it works, 351â€“54
                                when to use it, 354â€“55
                                Views, Transform, 361â€“64
                                example
                                simple transform (Java), 363â€“64
                                how it works, 361â€“62
                                when to use it, 362â€“63
                                Views, Two Step, 365â€“78
                                examples
                                JSP and custom tags (Java),
                                374â€“78
                                two-stage XSLT (XSLT), 371â€“74
                                how it works, 365â€“67
                                when to use it, 367â€“71
                                Virtual proxy (Java), 203â€“5
                                W
                                Web presentation, 55â€“61
                                input controller patterns, 61
                                view patterns, 58â€“60
                                Web presentation patterns, 329â€“86
                                Application Controller, 379â€“86
                                Front Controller, 344â€“49
                                MVC (Model View Controller),
                                330â€“32
                                Page Controller, 333â€“43
                                Template View, 350â€“60
                                Transform View, 361â€“64
                                Two Step View, 365â€“78
                                Web service (C#), 395â€“400
                                Web services, 103
                                Work, Unit of, 184â€“94
                                example
                                Unit of Work with object registration
                                (Java), 190â€“94
                                how it works, 184â€“89
                                when to use it, 189â€“90
                                X
                                XML
                                serializing department hierarchy in,
                                274â€“77
                                serializing using, 411â€“13
                                Index 533
                                XSLT, two stage, 371â€“74</pre></p>
                </div>
        </div> -->
    </body>
</html>
